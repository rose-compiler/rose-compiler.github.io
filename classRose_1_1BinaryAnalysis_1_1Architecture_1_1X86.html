<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Architecture::X86 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html">Architecture</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html">X86</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Architecture::X86 Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Common base class for all x86 architectures. </p>

<p class="definition">Definition at line <a class="el" href="Architecture_2X86_8h_source.html#l00012">12</a> of file <a class="el" href="Architecture_2X86_8h_source.html">Architecture/X86.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Architecture_2X86_8h_source.html">Rose/BinaryAnalysis/Architecture/X86.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Architecture::X86:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_inherit__map">
<area shape="rect" title="Common base class for all x86 architectures." alt="" coords="201,293,349,333"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html" title="Architecture&#45;specific information for x86&#45;64, x86_64, x64, amd64, Intel 64." alt="" coords="418,5,567,45"/>
<area shape="poly" title=" " alt="" coords="280,279,294,230,317,170,350,109,371,80,396,55,416,42,419,46,399,59,375,84,355,112,322,172,299,232,285,281"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel80286.html" title="Architecture specific information for Intel 80286." alt="" coords="409,69,577,109"/>
<area shape="poly" title=" " alt="" coords="285,280,303,243,327,200,358,156,396,119,415,107,418,112,399,123,362,160,331,202,307,245,290,282"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8086.html" title="Architecture&#45;specific information for Intel 8086." alt="" coords="412,133,573,173"/>
<area shape="poly" title=" " alt="" coords="296,281,339,231,366,205,396,183,419,171,421,176,399,188,369,209,343,235,300,284"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8088.html" title="Architecture&#45;specific information for Intel 8088." alt="" coords="412,197,573,237"/>
<area shape="poly" title=" " alt="" coords="321,284,396,247,427,235,429,240,398,252,323,289"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI386.html" title="Architecture&#45;specific information for Intel i386." alt="" coords="413,261,572,301"/>
<area shape="poly" title=" " alt="" coords="362,298,413,290,414,296,363,303"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI486.html" title="Architecture&#45;specific information for Intel i486." alt="" coords="413,325,572,365"/>
<area shape="poly" title=" " alt="" coords="363,324,414,331,413,336,362,329"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium.html" title="Architecture&#45;specific information for Intel Pentium." alt="" coords="402,389,583,429"/>
<area shape="poly" title=" " alt="" coords="323,338,398,375,429,387,427,392,396,380,321,343"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium4.html" title="Architecture&#45;specific information for Intel Pentium4." alt="" coords="399,453,587,493"/>
<area shape="poly" title=" " alt="" coords="300,343,343,392,369,417,399,439,421,451,419,456,396,444,366,421,339,396,296,346"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumii.html" title="Architecture&#45;specific information for Intel Pentium II." alt="" coords="399,517,586,557"/>
<area shape="poly" title=" " alt="" coords="290,345,307,382,331,424,362,467,399,503,418,515,415,519,396,507,358,470,327,427,303,384,285,347"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumiii.html" title="Architecture&#45;specific information for Intel Pentium III." alt="" coords="397,581,588,621"/>
<area shape="poly" title=" " alt="" coords="285,346,299,395,322,455,355,515,375,543,399,567,416,579,413,584,396,571,371,546,350,518,317,457,294,397,280,347"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html" title="Base class for architecture definitions." alt="" coords="5,293,153,333"/>
<area shape="poly" title=" " alt="" coords="167,311,201,311,201,316,167,316"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Architecture::X86:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_coll__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1X86_coll__map">
<area shape="rect" title="Common base class for all x86 architectures." alt="" coords="5,93,153,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html" title="Base class for architecture definitions." alt="" coords="5,5,153,45"/>
<area shape="poly" title=" " alt="" coords="82,59,82,93,77,93,77,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c5dd4afaaf01f7b19dd08adbf6d4884" id="r_a1c5dd4afaaf01f7b19dd08adbf6d4884"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a1c5dd4afaaf01f7b19dd08adbf6d4884">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a55a62db0083a83573b870f1cb943d272">X86Ptr</a></td></tr>
<tr class="separator:a1c5dd4afaaf01f7b19dd08adbf6d4884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ac32fb431b1823b94185281598a6c2c03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a025b1c1e4df943f851e04a421f9efe27">BasePtr</a></td></tr>
<tr class="memdesc:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a5bc2ec9662e6ae405e8db81bf555f79f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">BaseConstPtr</a></td></tr>
<tr class="memdesc:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer to const object.  <br /></td></tr>
<tr class="separator:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf95673d445b1198707bd7f3c2102aaf" id="r_acf95673d445b1198707bd7f3c2102aaf"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#acf95673d445b1198707bd7f3c2102aaf">callingConventions</a> () const override</td></tr>
<tr class="memdesc:acf95673d445b1198707bd7f3c2102aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Calling convention definitions.  <br /></td></tr>
<tr class="separator:acf95673d445b1198707bd7f3c2102aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6221d5beff9b0a3f10cdb8ef010d832a" id="r_a6221d5beff9b0a3f10cdb8ef010d832a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a6221d5beff9b0a3f10cdb8ef010d832a">bytesPerInstruction</a> () const override</td></tr>
<tr class="memdesc:a6221d5beff9b0a3f10cdb8ef010d832a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid sizes for encoded machine instructions.  <br /></td></tr>
<tr class="separator:a6221d5beff9b0a3f10cdb8ef010d832a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e0bdc3bf25aa2b58492956253fbef" id="r_a100e0bdc3bf25aa2b58492956253fbef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a100e0bdc3bf25aa2b58492956253fbef">instructionAlignment</a> () const override</td></tr>
<tr class="memdesc:a100e0bdc3bf25aa2b58492956253fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions.  <br /></td></tr>
<tr class="separator:a100e0bdc3bf25aa2b58492956253fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7fb29a2999d0e27e88d36e1299638b" id="r_a0b7fb29a2999d0e27e88d36e1299638b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a0b7fb29a2999d0e27e88d36e1299638b">instructionMnemonic</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a0b7fb29a2999d0e27e88d36e1299638b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mnemonic for an instruction.  <br /></td></tr>
<tr class="separator:a0b7fb29a2999d0e27e88d36e1299638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac43aee05706dec13d3b7098d3212755" id="r_aac43aee05706dec13d3b7098d3212755"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#aac43aee05706dec13d3b7098d3212755">terminatesBasicBlock</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:aac43aee05706dec13d3b7098d3212755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instruction normally terminates a basic block.  <br /></td></tr>
<tr class="separator:aac43aee05706dec13d3b7098d3212755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c83c06b6b4ad50a04fb5743809824d1" id="r_a0c83c06b6b4ad50a04fb5743809824d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a0c83c06b6b4ad50a04fb5743809824d1">isUnknown</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a0c83c06b6b4ad50a04fb5743809824d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instruction is the special "unknown" instruction.  <br /></td></tr>
<tr class="separator:a0c83c06b6b4ad50a04fb5743809824d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb232255e5406935614d075e733e8392" id="r_acb232255e5406935614d075e733e8392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#acb232255e5406935614d075e733e8392">isFunctionCallFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const override</td></tr>
<tr class="memdesc:acb232255e5406935614d075e733e8392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:acb232255e5406935614d075e733e8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b9f736400fb3c64972b8356c1d0bc3" id="r_af2b9f736400fb3c64972b8356c1d0bc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#af2b9f736400fb3c64972b8356c1d0bc3">isFunctionCallSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const override</td></tr>
<tr class="memdesc:af2b9f736400fb3c64972b8356c1d0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:af2b9f736400fb3c64972b8356c1d0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7643208cae42c0a6ccfc462c93fd11f0" id="r_a7643208cae42c0a6ccfc462c93fd11f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a7643208cae42c0a6ccfc462c93fd11f0">isFunctionReturnFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const override</td></tr>
<tr class="memdesc:a7643208cae42c0a6ccfc462c93fd11f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a7643208cae42c0a6ccfc462c93fd11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a512792e547d40728a385a8e1c4eb8" id="r_a23a512792e547d40728a385a8e1c4eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a23a512792e547d40728a385a8e1c4eb8">branchTarget</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a23a512792e547d40728a385a8e1c4eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the virtual address for a branching instruction.  <br /></td></tr>
<tr class="separator:a23a512792e547d40728a385a8e1c4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d9ff9cb1b4ee8dd904b724651d6c81" id="r_a19d9ff9cb1b4ee8dd904b724651d6c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a19d9ff9cb1b4ee8dd904b724651d6c81">getSuccessors</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, bool &amp;complete) const override</td></tr>
<tr class="memdesc:a19d9ff9cb1b4ee8dd904b724651d6c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a single instruction.  <br /></td></tr>
<tr class="separator:a19d9ff9cb1b4ee8dd904b724651d6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac9ee6888ea775a49981f4b9874ea01" id="r_a3ac9ee6888ea775a49981f4b9874ea01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a3ac9ee6888ea775a49981f4b9874ea01">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;initial_memory=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>()) const override</td></tr>
<tr class="memdesc:a3ac9ee6888ea775a49981f4b9874ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a3ac9ee6888ea775a49981f4b9874ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df74476cfefab0e46ad4701c58c450" id="r_a54df74476cfefab0e46ad4701c58c450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a54df74476cfefab0e46ad4701c58c450">newInstructionDecoder</a> () const override</td></tr>
<tr class="memdesc:a54df74476cfefab0e46ad4701c58c450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction decoder.  <br /></td></tr>
<tr class="separator:a54df74476cfefab0e46ad4701c58c450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100802f579bb1cea8b898796bccf322" id="r_ab100802f579bb1cea8b898796bccf322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#ab100802f579bb1cea8b898796bccf322">newUnparser</a> () const override</td></tr>
<tr class="memdesc:ab100802f579bb1cea8b898796bccf322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction unparser.  <br /></td></tr>
<tr class="separator:ab100802f579bb1cea8b898796bccf322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba9a3638c6ea9962789e7b9e51218f" id="r_a4fba9a3638c6ea9962789e7b9e51218f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a4fba9a3638c6ea9962789e7b9e51218f">newInstructionDispatcher</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;) const override</td></tr>
<tr class="memdesc:a4fba9a3638c6ea9962789e7b9e51218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction dispatcher.  <br /></td></tr>
<tr class="separator:a4fba9a3638c6ea9962789e7b9e51218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297f4b29348217e0aa7c4779e886547e" id="r_a297f4b29348217e0aa7c4779e886547e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Partitioner2::FunctionPrologueMatcherPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a297f4b29348217e0aa7c4779e886547e">functionPrologueMatchers</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const override</td></tr>
<tr class="memdesc:a297f4b29348217e0aa7c4779e886547e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction patterns matching function prologues.  <br /></td></tr>
<tr class="separator:a297f4b29348217e0aa7c4779e886547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cbe34ca708d8afbf0f6a313eaf5e61" id="r_a63cbe34ca708d8afbf0f6a313eaf5e61"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Partitioner2::BasicBlockCallbackPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a63cbe34ca708d8afbf0f6a313eaf5e61">basicBlockCreationHooks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const override</td></tr>
<tr class="memdesc:a63cbe34ca708d8afbf0f6a313eaf5e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific basic block callbacks for partitioning.  <br /></td></tr>
<tr class="separator:a63cbe34ca708d8afbf0f6a313eaf5e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a7758dd9b3ef45fe3bbacde31f25e0510"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a> () const</td></tr>
<tr class="memdesc:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> definition name.  <br /></td></tr>
<tr class="separator:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a02fb30e615b5afd19f867e66768b7688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a> () const</td></tr>
<tr class="memdesc:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order for memory.  <br /></td></tr>
<tr class="separator:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a80559e394e92b20bbaf76951d5900 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a06a80559e394e92b20bbaf76951d5900"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a06a80559e394e92b20bbaf76951d5900">registerDictionary</a> () const =0</td></tr>
<tr class="memdesc:a06a80559e394e92b20bbaf76951d5900 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register dictionary.  <br /></td></tr>
<tr class="separator:a06a80559e394e92b20bbaf76951d5900 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ab47215e1c00810f5afb82f4bc04af5e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab47215e1c00810f5afb82f4bc04af5e4">interruptDictionary</a> () const</td></tr>
<tr class="memdesc:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Interrupt dictionary.  <br /></td></tr>
<tr class="separator:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a08f7c3793592de8dfe7108c76245850c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08f7c3793592de8dfe7108c76245850c">matchesName</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a name.  <br /></td></tr>
<tr class="separator:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3611147dd3024b6d0de51ce006740f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_adc3611147dd3024b6d0de51ce006740f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#adc3611147dd3024b6d0de51ce006740f">matchesHeader</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *) const</td></tr>
<tr class="memdesc:adc3611147dd3024b6d0de51ce006740f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a file header.  <br /></td></tr>
<tr class="separator:adc3611147dd3024b6d0de51ce006740f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ad73177355070eeb5741e5bcbc9fc56f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ad73177355070eeb5741e5bcbc9fc56f1">instructionsCanOverlap</a> () const</td></tr>
<tr class="memdesc:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether instructions can overlap in memory.  <br /></td></tr>
<tr class="separator:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2b8bd1499cc492f7e844f188ae970 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a08e2b8bd1499cc492f7e844f188ae970"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08e2b8bd1499cc492f7e844f188ae970">instructionDescription</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a08e2b8bd1499cc492f7e844f188ae970 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description for an instruction.  <br /></td></tr>
<tr class="separator:a08e2b8bd1499cc492f7e844f188ae970 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a5f3e45432a5fb2e8a109c0d6118a0d62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5f3e45432a5fb2e8a109c0d6118a0d62">registrationId</a> () const</td></tr>
<tr class="memdesc:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_abc31f520eac844e49767d0afe1ccf1fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abc31f520eac844e49767d0afe1ccf1fe">registrationId</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;)</td></tr>
<tr class="memdesc:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a73b51aa09fc1b1a71c7f66346359d28b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a> () const</td></tr>
<tr class="memdesc:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a1ee891ea7b9a61214b14496e263bb948"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a> () const</td></tr>
<tr class="memdesc:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a9a80fb8df16e13c9333b0227620c90a2"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9a80fb8df16e13c9333b0227620c90a2">toString</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_aab7b2dad38bc3c6ca9fbb23096479292"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aab7b2dad38bc3c6ca9fbb23096479292">toStringNoAddr</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a8abf86e9095b6f586e06c65b99a14d44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8abf86e9095b6f586e06c65b99a14d44">isFunctionReturnSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const</td></tr>
<tr class="memdesc:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a0e39bd2d1ac89476495a77ba0ea1dbca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a0e39bd2d1ac89476495a77ba0ea1dbca">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete) const</td></tr>
<tr class="memdesc:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad310121e0fe931416c97c5a6d524c5a6" id="r_ad310121e0fe931416c97c5a6d524c5a6"><td class="memItemLeft" align="right" valign="top"><a id="ad310121e0fe931416c97c5a6d524c5a6" name="ad310121e0fe931416c97c5a6d524c5a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>X86</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a>, size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a>)</td></tr>
<tr class="separator:ad310121e0fe931416c97c5a6d524c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f4782158613b6ff61a645b54553e06" id="r_a35f4782158613b6ff61a645b54553e06"><td class="memItemLeft" align="right" valign="top"><a id="a35f4782158613b6ff61a645b54553e06" name="a35f4782158613b6ff61a645b54553e06"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cc_cdecl</b> (size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a>) const</td></tr>
<tr class="separator:a35f4782158613b6ff61a645b54553e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60160beb1736764271b68a181d9c06a1" id="r_a60160beb1736764271b68a181d9c06a1"><td class="memItemLeft" align="right" valign="top"><a id="a60160beb1736764271b68a181d9c06a1" name="a60160beb1736764271b68a181d9c06a1"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cc_stdcall</b> (size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a>) const</td></tr>
<tr class="separator:a60160beb1736764271b68a181d9c06a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09027b9532933690b1095d29df3fa5fe" id="r_a09027b9532933690b1095d29df3fa5fe"><td class="memItemLeft" align="right" valign="top"><a id="a09027b9532933690b1095d29df3fa5fe" name="a09027b9532933690b1095d29df3fa5fe"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cc_fastcall</b> (size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a>) const</td></tr>
<tr class="separator:a09027b9532933690b1095d29df3fa5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a62d3f5f251ba258b83d8c63e84d72059 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a62d3f5f251ba258b83d8c63e84d72059"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a>, size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a>)</td></tr>
<tr class="separator:a62d3f5f251ba258b83d8c63e84d72059 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98621d1e395d5fca985c902287ec4f inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a4a98621d1e395d5fca985c902287ec4f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> ()</td></tr>
<tr class="separator:a4a98621d1e395d5fca985c902287ec4f inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584136739b4573a9388e3903faafc562 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a584136739b4573a9388e3903faafc562"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constPtr</b> () const</td></tr>
<tr class="separator:a584136739b4573a9388e3903faafc562 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a23bc5455bc3df509e90af8f2337557ee inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a23bc5455bc3df509e90af8f2337557ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a23bc5455bc3df509e90af8f2337557ee">registerDictionary_</a></td></tr>
<tr class="separator:a23bc5455bc3df509e90af8f2337557ee inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d3a8eb56136dfe58220836faa3f21 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a058d3a8eb56136dfe58220836faa3f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a058d3a8eb56136dfe58220836faa3f21">interruptDictionary_</a></td></tr>
<tr class="separator:a058d3a8eb56136dfe58220836faa3f21 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9579050251c6bf0c3c836b0b999e7e0 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ac9579050251c6bf0c3c836b0b999e7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9579050251c6bf0c3c836b0b999e7e0">callingConventions_</a></td></tr>
<tr class="separator:ac9579050251c6bf0c3c836b0b999e7e0 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8432d213970666c785032171830d01 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_afe8432d213970666c785032171830d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#afe8432d213970666c785032171830d01">insnToString_</a></td></tr>
<tr class="separator:afe8432d213970666c785032171830d01 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dab3a55bc698d073cd54e190c4b459 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a36dab3a55bc698d073cd54e190c4b459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a36dab3a55bc698d073cd54e190c4b459">insnToStringNoAddr_</a></td></tr>
<tr class="separator:a36dab3a55bc698d073cd54e190c4b459 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1c5dd4afaaf01f7b19dd08adbf6d4884" name="a1c5dd4afaaf01f7b19dd08adbf6d4884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5dd4afaaf01f7b19dd08adbf6d4884">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Rose::BinaryAnalysis::Architecture::X86::Ptr =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a55a62db0083a83573b870f1cb943d272">X86Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2X86_8h_source.html#l00014">14</a> of file <a class="el" href="Architecture_2X86_8h_source.html">Architecture/X86.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf95673d445b1198707bd7f3c2102aaf" name="acf95673d445b1198707bd7f3c2102aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf95673d445b1198707bd7f3c2102aaf">&#9670;&#160;</a></span>callingConventions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &amp; Rose::BinaryAnalysis::Architecture::X86::callingConventions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Calling convention definitions. </p>
<p>Returns a list of calling convention definitions used by this architecture. Since definitions are generally not modified, it is permissible for this function to return the same definitions every time it's called. The list can be constructed on the first call.</p>
<p>The default implementation returns an empty list.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a000e445cbf23f56532f1bc5c7609dbac">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#a3d2c82364ccf8a650ebc386ad8a5b078">Rose::BinaryAnalysis::Architecture::Amd64</a>.</p>

</div>
</div>
<a id="a6221d5beff9b0a3f10cdb8ef010d832a" name="a6221d5beff9b0a3f10cdb8ef010d832a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6221d5beff9b0a3f10cdb8ef010d832a">&#9670;&#160;</a></span>bytesPerInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt; Rose::BinaryAnalysis::Architecture::X86::bytesPerInstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valid sizes for encoded machine instructions. </p>
<p>Returns the range of valid sizes for encoded machine instructions. For instance, an x86 instruction can be from one to 15 bytes in length, but a PowerPC PPC32 instruction is always exactly 4 bytes. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7166b2e3ad595362e876ccda9ce2dd57">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a100e0bdc3bf25aa2b58492956253fbef" name="a100e0bdc3bf25aa2b58492956253fbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100e0bdc3bf25aa2b58492956253fbef">&#9670;&#160;</a></span>instructionAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> Rose::BinaryAnalysis::Architecture::X86::instructionAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8ac610db2e1ce4866facad301b677e48">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a0b7fb29a2999d0e27e88d36e1299638b" name="a0b7fb29a2999d0e27e88d36e1299638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7fb29a2999d0e27e88d36e1299638b">&#9670;&#160;</a></span>instructionMnemonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Architecture::X86::instructionMnemonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mnemonic for an instruction. </p>
<p>Returns the mnemonic for a particular instruction.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3a56b4c385168bcf6804478700cc54ae">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="aac43aee05706dec13d3b7098d3212755" name="aac43aee05706dec13d3b7098d3212755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac43aee05706dec13d3b7098d3212755">&#9670;&#160;</a></span>terminatesBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::X86::terminatesBasicBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified instruction normally terminates a basic block. </p>
<p>The analysis generally only looks at the individual instruction and therefore is not very sophisticated. For instance, a conditional branch will always terminate a basic block by this method even if its condition is opaque. The instruction argument must not be a null pointer and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1fcbce03aea244dc9e5d9ac60554f000">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a0c83c06b6b4ad50a04fb5743809824d1" name="a0c83c06b6b4ad50a04fb5743809824d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c83c06b6b4ad50a04fb5743809824d1">&#9670;&#160;</a></span>isUnknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::X86::isUnknown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instruction is the special "unknown" instruction. </p>
<p>Each instruction architecture in ROSE defines an "unknown" instruction to be used when the disassembler is unable to create a real instruction. This can happen, for instance, if the bit pattern does not represent a valid instruction for the architecture. The instruction must not be a null pointer, and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a76e44136d49e87a71ca1ffaa468439fb">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="acb232255e5406935614d075e733e8392" name="acb232255e5406935614d075e733e8392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb232255e5406935614d075e733e8392">&#9670;&#160;</a></span>isFunctionCallFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::X86::isFunctionCallFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function call. </p>
<p>If the basic block looks like a function call then this method returns true. If (and only if) the target address is known (i.e., the address of the called function) then <code>target</code> is set to this address (otherwise <code>target</code> is unmodified). If the return address is known or can be guessed, then return_va is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise the return_va is unmodified.</p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementation of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab7752a2ed38493ccb13a369c78d23988">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="af2b9f736400fb3c64972b8356c1d0bc3" name="af2b9f736400fb3c64972b8356c1d0bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b9f736400fb3c64972b8356c1d0bc3">&#9670;&#160;</a></span>isFunctionCallSlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::X86::isFunctionCallSlow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function call. </p>
<p>If the basic block looks like a function call then this method returns true. If (and only if) the target address is known (i.e., the address of the called function) then <code>target</code> is set to this address (otherwise <code>target</code> is unmodified). If the return address is known or can be guessed, then return_va is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise the return_va is unmodified.</p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementation of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e8d8c8b916e00cefa0f1b7634c1d839">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a7643208cae42c0a6ccfc462c93fd11f0" name="a7643208cae42c0a6ccfc462c93fd11f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7643208cae42c0a6ccfc462c93fd11f0">&#9670;&#160;</a></span>isFunctionReturnFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::X86::isFunctionReturnFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function return. </p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementaiton of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abea57c49d0420f037021ff7b7afecd16">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a23a512792e547d40728a385a8e1c4eb8" name="a23a512792e547d40728a385a8e1c4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a512792e547d40728a385a8e1c4eb8">&#9670;&#160;</a></span>branchTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Architecture::X86::branchTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the virtual address for a branching instruction. </p>
<p>Returns the branch target address if the specified instruction is a branching instruction and the target is known; otherwise returns nothing.</p>
<p>The default implementation returns nothing.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a743b63088a626a602c6e9bcc3a054797">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a19d9ff9cb1b4ee8dd904b724651d6c81" name="a19d9ff9cb1b4ee8dd904b724651d6c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d9ff9cb1b4ee8dd904b724651d6c81">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::X86::getSuccessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors for a single instruction. </p>
<p>The return value does not consider neighboring instructions, and therefore is quite naive. It returns only the information it can glean from this single instruction. If the returned set of virtual instructions is fully known then the <code>complete</code> argument will be set to true, otherwise false. The instruction must not be null, and must be valid for this architecture.</p>
<p>The default implementation always returns an empty set and clears <code>complete</code>.</p>
<p>Thread safety: Thread saafe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aa57d491fecd502be6b814fcbf0be6d58">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a3ac9ee6888ea775a49981f4b9874ea01" name="a3ac9ee6888ea775a49981f4b9874ea01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac9ee6888ea775a49981f4b9874ea01">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::X86::getSuccessors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>basicBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_memory</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors for a basic block. </p>
<p>The <code>basicBlock</code> argument is a vector of instructions that is assumed to be a basic block that is entered only at the first instruction and exits only at the last instruction. A memory map can supply initial values for the analysis' memory state. The return value is a set of control flow successor virtual addresses, and the <code>complete</code> argument return value indicates whether the returned set is known to be complete (aside from interrupts, faults, etc).</p>
<p>The default implementation calls the single-instruction version, so architecture-specific subclasses might want to override this to do something more sophisticated. However, if the basic block is empty then this function instead returns an empty set and sets <code>complete</code> to true.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a584a12a9280fadaea065516e3c0cb88b">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a54df74476cfefab0e46ad4701c58c450" name="a54df74476cfefab0e46ad4701c58c450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54df74476cfefab0e46ad4701c58c450">&#9670;&#160;</a></span>newInstructionDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a> Rose::BinaryAnalysis::Architecture::X86::newInstructionDecoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction decoder. </p>
<p>Returns a new decoder for this architecture if possible, otherwise a null pointer.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e848a4594e882ab63f9a68cdb68c170">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="ab100802f579bb1cea8b898796bccf322" name="ab100802f579bb1cea8b898796bccf322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab100802f579bb1cea8b898796bccf322">&#9670;&#160;</a></span>newUnparser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> Rose::BinaryAnalysis::Architecture::X86::newUnparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction unparser. </p>
<p>An unparser is responsible for generating pseudo assembly listings.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a59df18db2baae88452946dc47fa28a66">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a4fba9a3638c6ea9962789e7b9e51218f" name="a4fba9a3638c6ea9962789e7b9e51218f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fba9a3638c6ea9962789e7b9e51218f">&#9670;&#160;</a></span>newInstructionDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> Rose::BinaryAnalysis::Architecture::X86::newInstructionDispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction dispatcher. </p>
<p>The dispatcher knows the semantics for instructions, but not the low-level operators (arithmetic, memory I/O, etc), nor the domain (concrete, symbolic, etc) on which those operators operate. These other things are supplied by the argument, which also points to the states that are modified by executing the instructions.</p>
<p>The default implementation returns a null pointer, signifying that instruction semantics are not known.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9f7bc3595c3d4258ba834ae991008d2">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a297f4b29348217e0aa7c4779e886547e" name="a297f4b29348217e0aa7c4779e886547e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297f4b29348217e0aa7c4779e886547e">&#9670;&#160;</a></span>functionPrologueMatchers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Partitioner2::FunctionPrologueMatcherPtr</a> &gt; Rose::BinaryAnalysis::Architecture::X86::functionPrologueMatchers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruction patterns matching function prologues. </p>
<p>Returns a list of matchers that match sequences of instructions that are often generated by compilers as part of instruction prologues.</p>
<p>The default implementation returns an empty list. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9c963c4b3bb04cd747f9c84de49a48d2">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a63cbe34ca708d8afbf0f6a313eaf5e61" name="a63cbe34ca708d8afbf0f6a313eaf5e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cbe34ca708d8afbf0f6a313eaf5e61">&#9670;&#160;</a></span>basicBlockCreationHooks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Partitioner2::BasicBlockCallbackPtr</a> &gt; Rose::BinaryAnalysis::Architecture::X86::basicBlockCreationHooks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Architecture-specific basic block callbacks for partitioning. </p>
<p>Returns a list of basic block callbacks used by the partitioner during disassembly.</p>
<p>The default implementation returns an empty list. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a30db9046dabe9c47b53219f28941a082">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Architecture_2X86_8h_source.html">Architecture/X86.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
