<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::InstructionSemantics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::InstructionSemantics Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Binary instruction semantics. </p>
<p>Entities in this namespace deal with the semantics of machine instructions, and with the process of "executing" a machine instruction in a particular semantic domain. Instruction "execution" is a very broad term and can refer to execution in the tranditional sense where each instruction modifies the machine state (registers and memory) in a particular domain (concrete, interval, sign, symbolic, user-defined). But it can also refer to any kind of analysis that depends on semantics of individual machine instructions (def-use, tainted-flow, etc). It can even refer to the transformation of machine instructions in ROSE internal representation to some other representation (e.g., to ROSE RISC or LLVM assembly) where the other representation is built by "executing" the instruction.</p>
<h1><a class="anchor" id="instruction_semantics_components"></a>
Components of instruction semantics</h1>
<p>ROSE's binary semantics framework has four major components: the dispatchers, RISC operators, states, and values. Each component has a base class to define the interface and common functionality, and subclasses to provide implementation details. A semantics framework is constructed at runtime by instantiating objects from these subclasses and connecting the objects together to form a lattice.</p>
<p>At the top of the lattice is a <em>dispatcher</em> (base class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Dispatcher</a>) that "executes" machine instructions by translating (or <em>lowering</em>) them to sequences of RISC-like operations. The subclasses of <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Dispatcher</a> implement various instruction set architectures (ISAs).</p>
<p>The dispatcher points to an object that defines the RISC-like operators. This object is instantiated from a subclass of <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a>, and defines the few dozen RISC-like operators in terms of modifications to a state, or collection of values. Therefore, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> needs to point to the <em>current state</em>. Depending on the subclass, it might also point to a lazily-initialized <em>initial state</em>. It is common for an analysis to swap new states in and out of the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> while the analysis runs.</p>
<p>The aforementioned states are objects instantiated from subclasses of <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html">State</a>, which points to at least two substate objects: a <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html">MemoryState</a> that describes the values stored at memory addresses, and a <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RegisterState.html">RegisterState</a> that describes the values stored in registers. Depending on the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html">State</a> subclass, a state may also contain additional data. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html">MemoryState</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RegisterState.html">RegisterState</a> are base classes, and their subclasses provide various mechanisms for storing the memory and registers. For instance, memory might be stored as a chronological list or a map, and registers might be stored as an array or map.</p>
<p>Up to this point, we haven't nailed down the definition of "value". A semantic value is also an abstract concept whose interface is declared in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html">SValue</a> base class, the subclasses of which define the details. A value could be a vector of bits (concrete); an interval defined by two concrete endpoints; a sign consisting of one of the values positive, negative, zero, top, or bottom; a symbolic expression composed of constants, variables, and operations; or pretty much anything you want as long as it implements the API defined in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html">SValue</a> base class. Many of the objects mentioned above need to be able to create new values, and therefore they point to a proto-typical value instance which forms the bottom of the lattice.</p>
<p>Not all combinations of dispatcher, operators, states, and values are possible, although they are intended to be mostly interchangeable. For instance, you could combine an x86 dispatcher with symbolic operators using chronological memory and generic register states and a symbolic value type, but it probably doesn't make sense to have all the same components but replacing the symbolic value type with a concrete value type. To help keep things organized, collections of compatible types are placed in namespaces such as <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a>. These collections of compatible semantic types are called <em>semantic domains</em>. Mixing types between semantic domains sometimes works, depending on the domain.</p>
<h1><a class="anchor" id="instruction_semantics_domains"></a>
Major domains</h1>
<p>As mentioned, a "semantic domain" is a collection of compatible semantic types contained in a namespace. ROSE provides a number of general-purpose domains but users are also expected to specialize these for specific purposes. Even within ROSE, many of the analyses specialize these general-purpose domains in order to do something more specific without needing to re-implement large portions of the infrastructure.</p>
<p>You can find the full list of general-purpose domains by looking for sub namespaces of this namespace whose names end with the word "Semantics". Some important examples:</p>
<ul>
<li><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics.html">ConcreteSemantics</a> has values that are bit vectors. This domain would be a good base class if you were writing an emulator since emulators work only with specific known values (i.e., concrete values rather than intervals, symbolic expressions, etc.). An example of a concrete value is a 16-bit vector 1010101111001110.</li>
</ul>
<ul>
<li><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics.html">IntervalSemantics</a> is a domain whose values are sets of non-contiguous ranges of values where each range is indicated by its first and last concrete value. An example of a value in this domain is the set {[0000,0010], [1000,1011]} that represents the four-bit concrete values 0000, 0001, 0010, 1000, 1001, 1010, and 1011.</li>
</ul>
<ul>
<li><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a> is a domain whose values are constants, variables, and operations that form an expression tree. Each vertex of the tree has a specific width measured in bits. Variable are named with the letter "v" followed by a decimal serial number as in "v1", "v2", etc. The symbolic <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1SValue.html">SValue</a> points to the symbolic expression. Symbolic expression trees (which are immutable) are instances of <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html">Rose::BinaryAnalysis::SymbolicExpression</a>.</li>
</ul>
<h1><a class="anchor" id="instruction_semantics_pointers"></a>
Memory Management</h1>
<p>Most of the instruction semantics objects are allocated on the heap and are reference counted. This is beneficial to the user because an analysis might create millions of objects and it would otherwise be a burden if the analysis author had to know when it was safe to delete objects. It also allows an analysis to return results to a higher level and not worry about who now owns those objects.</p>
<p>There are two ways to allocate such objects: (1) you must know the name of the derived class from which to instantiate an object, or (2) you must have an instance of an object of the class you wish to instantiate. The former method is used when you're constructing a semantics framework since that's the moment you know the names of the classes, and the latter method is used when the framework is running and the class names might not be known but an object is already available. The former method uses static member functions, and the latter method uses virtual member functions (C++ implementation of the OO term <em>virtual constructor</em>).</p>
<p>Additional information can be found under <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#instruction_semantics_specialization">Specialization</a>.</p>
<h1><a class="anchor" id="instruction_semantics_create"></a>
Instantiating a Semantics Framework</h1>
<p>Let's say you have an analysis that needs to process x86 instructions symbolically. The first thing you need to do is instantiate a semantics framework &ndash; the lattice of objects that are instantiated from the particular semantics component subclasses. You'll need a <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html">InstructionSemantics::DispatcherX86</a> object to handle the instructions, which invokes the RISC-like operations defined by an instance of <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">SymbolicSemantics::RiscOperators</a>, which can use a chronological memory state and a generic register state, and whose values are symbolic (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1SValue.html">SymbolicSemantics::SValue</a>). You'll need to tie all these objects together into a lattice with the disptatcher at the top. The constructors for the various components generally take arguments which are the lower layers of the lattice, therefore you'll need to build the lattice from the bottom up; that is, start by constructing a proto-typical value (i.e., a value from which new values can be created), then the register and memory states, which are then joined together into a single state object. Then create the RISC-like operations object and give it an initial state, and finally create the dispatcher that points to the RISC-like operations.</p>
<p>Most semantic domains (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a> included) have a simplified <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> constructor that uses default types for some of the lower components, but we'll show the full monty here:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Base = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics</a>;</div>
<div class="line"><span class="keyword">namespace </span>Symbolic = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics</a>;</div>
<div class="line"><span class="keyword">namespace </span>P2 = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a>;</div>
<div class="line"> </div>
<div class="line">P2::Partitioner::Ptr partitioner = ....; <span class="comment">// disassembly results</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> solver = ....; <span class="comment">// optional SMT solver</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">RegisterDictionary::Ptr</a> regdict = partitioner-&gt;instructionProvider().registerDictionary();</div>
<div class="line">Base::SValuePtr prototval = Symbolic::SValue::instance();</div>
<div class="line">Base::RegisterStatePtr regs = Symbolic::RegisterState::instance(protoval, regdict);</div>
<div class="line">Base::MemoryStatePtr mem = Symbolic::MemoryListState::instance(protoval, protoval);</div>
<div class="line">Base::StatePtr state = Symbolic::State::instance(regs, mem);</div>
<div class="line">Base::RiscOperatorsPtr ops = Symbolic::RiscOperators::instance(state, solver);</div>
<div class="line">Base::DispatcherPtr cpu = Base::DispatcherX86::instance(ops, 32, regdict);</div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; RegisterDictionary &gt;</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics</a></div><div class="ttdoc">Base classes for instruction semantics.</div><div class="ttdef"><b>Definition</b> <a href="Rose_2BinaryAnalysis_2InstructionSemantics_2BaseSemantics_2BasicTypes_8h_source.html#l00022">Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h:22</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics</a></div><div class="ttdoc">A fully symbolic semantic domain.</div><div class="ttdef"><b>Definition</b> <a href="SymbolicSemantics_8h_source.html#l00051">SymbolicSemantics.h:51</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1Partitioner2_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a></div><div class="ttdoc">Binary function detection.</div><div class="ttdef"><b>Definition</b> <a href="Partitioner2_8h_source.html#l00050">Partitioner2.h:50</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_html_ac6a5a4bfe0af39c76b621715abea1925"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">Rose::BinaryAnalysis::SmtSolverPtr</a></div><div class="ttdeci">std::shared_ptr&lt; SmtSolver &gt; SmtSolverPtr</div><div class="ttdoc">Reference counting pointer.</div><div class="ttdef"><b>Definition</b> <a href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html#l00057">Rose/BinaryAnalysis/BasicTypes.h:57</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="instruction_semantics_specialization"></a>
Specialization</h1>
<p>The instruction semantics architecture is designed to allow users to specialize nearly every part of it, which is useful when creating an analysis that needs to override some small parts of the entire semantics framework. Lets say you need to write an analysis that uses a concrete domain (like a simulator) and you want it to report every memory address to which a value is written. Such a domain would be identical in every respect to the ROSE-provided <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics.html">ConcreteSemantics</a> domain except the RISC-like operation for writing a value to memory needs to additionally print the address and value.</p>
<p>Since you're essentially creating a new domain derived from ROSE's concrete domain, you should create a namespace for your domain. Let's call it <code>MySemantics</code>. Since the value type, memory state, register state, combined state are all the same, create typedefs within <code>MySemantics</code> that just alias the types in ROSE's concrete domain. Notice there's no alias for a dispatcher; this is because dispatchers are domain-agnostic&ndash;any dispatcher will work with any semantic domain.</p>
<p>The only class you need to change is the RiscOperators class in ROSE's concrete domain. Therefore, within your namespace, define a new class named <code>MySemantics::RiscOperators</code> that inherits from ROSE's <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1RiscOperators.html">ConcreteSemantics::RiscOperators</a>, and override the <code>writeMemory</code> method so it prints the address and value before delegating to the base class. You'll also need to define three classes of constructors detailed in <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#instruction_semantics_constructors">Writing Constructors for Reference-counted Classes</a>.</p>
<p>Finally, your analysis can instantiate a semantics framework using the components from the new <code>MySemantics</code>. The code to do this looks almost identical to the example instantiation we already saw, except the word <code>Symbolic</code> would be changed to <code>MySemantics</code> wherever it appears.</p>
<h1><a class="anchor" id="instruction_semantics_constructors"></a>
Writing Constructors for Reference-counted Classes</h1>
<p>Here are some additional details to help you implement subclasses of reference-counted classes: You should implement three versions of each constructor: the real C++ constructor, the static allocating constructor, and the virtual constructor. Fortunately, the amount of extra code needed is not substantial since the virtual constructor can call the static allocating constructor, which can call the real C++ constructor. You'll need to override each overload of the three versions of constructors from the base class. The three versions in more detail are:</p>
<ul>
<li><em>Real Constructors</em>: These are the normal C++ constructors. They should have protected access and are used only by authors of subclasses. The other two versions of constructors described next are <em>constructors</em> in the sense of object-oriented languages in general, although in the C++ world they're not called "constructors".</li>
</ul>
<ul>
<li><em>Static Allocating Constructors</em>: These are class methods (C++ static member functions) that allocate a specific kind of object on the heap and return a smart pointer to the object. They are named "instance" to emphasize that they instantiate a new instance of a particular class and they return the pointer type that is specific to the class (i.e., not one of the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html" title="Base classes for instruction semantics.">BaseSemantics</a> pointer types). When an end user constructs a dispatcher, RISC operators, etc., they have particular classes in mind and use those classes' "instance" methods to create objects. Static allocating constructors are seldom called by authors of subclasses; instead the author usually has an object whose provenance can be traced back to a user-created object (such as a prototypical object), and he invokes one of that object's virtual constructors.</li>
</ul>
<ul>
<li><em>Virtual Constructors</em>: A virtual constructor creates a new object having the same run-time type as the object on which the method is invoked. Virtual constructors are often named "create" with the virtual copy constructor named "copy" or "clone", however the SValue class hierarchy follows a different naming scheme for historic reason&ndash;its virtual constructors end with an underscore. Virtual constructors return pointer types that defined in <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html" title="Base classes for instruction semantics.">BaseSemantics</a>. Subclass authors usually use this kind of constructor because it frees them from having to know a specific type and allows their classes to be easily subclassed. Virtual constructors are implemented in C++ as virtual member functions.</li>
</ul>
<p>When writing a subclass the author should implement the three versions for each constructor inherited from the super class. The author may also add any additional constructors that are deemed necessary, realizing that all subclasses of his class will also need to implement those constructors.</p>
<p>The subclass may define a public virtual destructor that will be called by the smart pointer implementation when the final pointer to the object is destroyed.</p>
<p>Here is an example of specializing a class that is itself derived from something in ROSE semantics framework.</p>
<div class="fragment"><div class="line"> <span class="comment">// Smart pointer for the subclass</span></div>
<div class="line"> <span class="keyword">typedef</span> boost::shared_ptr&lt;class MyThing&gt; MyThingPtr;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Class derived from OtherThing, which eventually derives from a class</span></div>
<div class="line"> <span class="comment">// defined in BinarySemantics::InstructionSemantics::BaseSemantics--lets</span></div>
<div class="line"> <span class="comment">// say BaseSemantics::Thing -- a non-existent class that follows the rules</span></div>
<div class="line"> <span class="comment">// outlined above.</span></div>
<div class="line"> <span class="keyword">class </span>MyThing: <span class="keyword">public</span> OtherThing {</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">     <span class="keywordtype">char</span> *data; <span class="comment">// some data allocated on the heap w/out a smart pointer</span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Real constructors.  Normally this will be all the same constructors as</span></div>
<div class="line">     <span class="comment">// in the super class, and possibly a few new ones.  Thus anything you add</span></div>
<div class="line">     <span class="comment">// here will need to also be implemented in all subclasses hereof. Lets</span></div>
<div class="line">     <span class="comment">// pretend that the super class has two constructors: a copy constructor</span></div>
<div class="line">     <span class="comment">// and one that takes a pointer to a register state.</span></div>
<div class="line"> <span class="keyword">protected</span>:</div>
<div class="line">     <span class="keyword">explicit</span> MyThing(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">BaseSemantics::RegisterStatePtr</a> &amp;rstate)</div>
<div class="line">         : OtherThing(rstate), data(NULL) {}</div>
<div class="line"> </div>
<div class="line">     MyThing(<span class="keyword">const</span> MyThing &amp;other)</div>
<div class="line">         : OtherThing(other), data(copy_string(other.data)) {}</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Define the virtual destructor if necessary.  This won&#39;t be called until</span></div>
<div class="line">     <span class="comment">// the last smart pointer reference to this object is destroyed.</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">     <span class="keyword">virtual</span> ~MyThing() {</div>
<div class="line">         <span class="keyword">delete</span> data;</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Static allocating constructors. One static allocating constructor</span></div>
<div class="line">     <span class="comment">// for each real constructor, including the copy constructor.</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">     <span class="keyword">static</span> MyThingPtr instance(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">BaseSemantics::RegisterStatePtr</a> &amp;rstate) {</div>
<div class="line">         <span class="keywordflow">return</span> MyThingPtr(<span class="keyword">new</span> MyThing(rstate));</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">static</span> MyThingPtr instance(<span class="keyword">const</span> MyThingPtr &amp;other) {</div>
<div class="line">         <span class="keywordflow">return</span> MyThingPtr(<span class="keyword">new</span> MyThing(*other));</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Virtual constructors. One virtual constructor for each static allocating</span></div>
<div class="line">     <span class="comment">// constructor.  It is of utmost importance that we cover all the virtual</span></div>
<div class="line">     <span class="comment">// constructors from the super class. These return the most super type</span></div>
<div class="line">     <span class="comment">// possible, usually something from BaseSemantics.</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">     <span class="keyword">virtual</span> BaseSemantics::ThingPtr create(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">BaseSemantics::RegisterStatePtr</a> &amp;rstate) {</div>
<div class="line">         <span class="keywordflow">return</span> instance(rstate);</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Name the virtual copy constructor &quot;clone&quot; rather than &quot;create&quot;.</span></div>
<div class="line">     <span class="keyword">virtual</span> BaseSemantics::ThingPtr clone(<span class="keyword">const</span> BaseSemantics::ThingPtr &amp;other_) {</div>
<div class="line">         MyThingPtr other = MyThing::promote(other_);</div>
<div class="line">         <span class="keywordflow">return</span> instance(other);</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Define the checking dynamic pointer cast.</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">     <span class="keyword">static</span> MyThingPtr promomte(<span class="keyword">const</span> BaseSemantics::ThingPtr &amp;obj) {</div>
<div class="line">         MyThingPtr retval = boost::dynamic_pointer_cast&lt;MyThingPtr&gt;(obj);</div>
<div class="line">         assert(retval!=NULL);</div>
<div class="line">         <span class="keywordflow">return</span> NULL;</div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Define the methods you need for this class.</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">char</span> *get_data()<span class="keyword"> const </span>{</div>
<div class="line">         <span class="keywordflow">return</span> data; <span class="comment">// or maybe return a copy in case this gets deleted?</span></div>
<div class="line">     }</div>
<div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_data(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {</div>
<div class="line">         data = copy_string(s);</div>
<div class="line">     }</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">     <span class="keywordtype">void</span> <span class="keywordtype">char</span> *copy_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {</div>
<div class="line">         <span class="keywordflow">if</span> (s==NULL)</div>
<div class="line">             <span class="keywordflow">return</span> NULL;</div>
<div class="line">         <span class="keywordtype">char</span> *retval = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(s)+1];</div>
<div class="line">         strcpy(retval, s);</div>
<div class="line">         <span class="keywordflow">return</span> retval;</div>
<div class="line">     }</div>
<div class="line">};</div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_html_af9979602b39d09fa0afc9b6727142cf9"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RegisterStatePtr</a></div><div class="ttdeci">boost::shared_ptr&lt; RegisterState &gt; RegisterStatePtr</div><div class="ttdoc">Shared-ownership pointer to a register state.</div><div class="ttdef"><b>Definition</b> <a href="Rose_2BinaryAnalysis_2InstructionSemantics_2BaseSemantics_2BasicTypes_8h_source.html#l00051">Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h:51</a></div></div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html">BaseSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base classes for instruction semantics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics.html">ConcreteSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete semantic domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics.html">IntervalSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interval analysis semantic domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html">LlvmSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semantic domain to generate LLVM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic domain composed of subdomains. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics.html">NullSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic domain that does nothing, but is well documented. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast, partially symbolic semantic domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SourceAstSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SourceAstSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SourceAstSemantics.html">SourceAstSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SourceAstSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate C source <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from binary <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1StaticSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1StaticSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1StaticSemantics.html">StaticSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1StaticSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate static semantics and attach to the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully symbolic semantic domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TaintSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TaintSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TaintSemantics.html">TaintSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TaintSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds taint information to all symbolic values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TraceSemantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TraceSemantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TraceSemantics.html">TraceSemantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TraceSemantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semantics domain wrapper that prints and checks all RISC operators as they occur. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherCil.html">DispatcherCil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherM68k.html">DispatcherM68k</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches Motorola 68k instructions through the semantics layer.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherM68k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherMips.html">DispatcherMips</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches MIPS instructions through the semantics layer.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherMips.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherPowerpc.html">DispatcherPowerpc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html">DispatcherX86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantically evaluates Intel x86 instructions.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TestSemantics.html">TestSemantics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for testing binary instruction semantics.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1TestSemantics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa619352fd8f4bee4f2ba242fad51f327" id="r_aa619352fd8f4bee4f2ba242fad51f327"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherCil.html">DispatcherCil</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#aa619352fd8f4bee4f2ba242fad51f327">DispatcherCilPtr</a></td></tr>
<tr class="memdesc:aa619352fd8f4bee4f2ba242fad51f327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to an CIL instruction dispatcher.  <br /></td></tr>
<tr class="separator:aa619352fd8f4bee4f2ba242fad51f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419eb9091df671582ad3986820bbcfae" id="r_a419eb9091df671582ad3986820bbcfae"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherM68k.html">DispatcherM68k</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a419eb9091df671582ad3986820bbcfae">DispatcherM68kPtr</a></td></tr>
<tr class="memdesc:a419eb9091df671582ad3986820bbcfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to an M68k instruction dispatcher.  <br /></td></tr>
<tr class="separator:a419eb9091df671582ad3986820bbcfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad29f7f55fe9821a1760d85b7b8e92b" id="r_adad29f7f55fe9821a1760d85b7b8e92b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#adad29f7f55fe9821a1760d85b7b8e92b">DispatcherMipsPtr</a> = boost::shared_ptr&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherMips.html">DispatcherMips</a> &gt;</td></tr>
<tr class="memdesc:adad29f7f55fe9821a1760d85b7b8e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to a MIPS instruction dispatcher.  <br /></td></tr>
<tr class="separator:adad29f7f55fe9821a1760d85b7b8e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7121b7034c2ccb7bed2c82e2a406dc6f" id="r_a7121b7034c2ccb7bed2c82e2a406dc6f"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherPowerpc.html">DispatcherPowerpc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a7121b7034c2ccb7bed2c82e2a406dc6f">DispatcherPowerpcPtr</a></td></tr>
<tr class="memdesc:a7121b7034c2ccb7bed2c82e2a406dc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to a PowerPC instruction dispatcher.  <br /></td></tr>
<tr class="separator:a7121b7034c2ccb7bed2c82e2a406dc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90db6f28357786d9537040c99bd7ba23" id="r_a90db6f28357786d9537040c99bd7ba23"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html">DispatcherX86</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a></td></tr>
<tr class="memdesc:a90db6f28357786d9537040c99bd7ba23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to an x86 instruction dispatcher.  <br /></td></tr>
<tr class="separator:a90db6f28357786d9537040c99bd7ba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8079d85a0048d51cd62e8c1ced71e4f1" id="r_a8079d85a0048d51cd62e8c1ced71e4f1"><td class="memItemLeft" align="right" valign="top"><a id="a8079d85a0048d51cd62e8c1ced71e4f1" name="a8079d85a0048d51cd62e8c1ced71e4f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initDiagnostics</b> ()</td></tr>
<tr class="memdesc:a8079d85a0048d51cd62e8c1ced71e4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostics for instruction semantics. <br /></td></tr>
<tr class="separator:a8079d85a0048d51cd62e8c1ced71e4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a99a35560a04dfe7b35ef209a392edfa8" id="r_a99a35560a04dfe7b35ef209a392edfa8"><td class="memItemLeft" align="right" valign="top"><a id="a99a35560a04dfe7b35ef209a392edfa8" name="a99a35560a04dfe7b35ef209a392edfa8"></a>
<a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mlog</b></td></tr>
<tr class="memdesc:a99a35560a04dfe7b35ef209a392edfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRose_1_1Diagnostics.html" title="Controls diagnostic messages from ROSE.">Diagnostics</a> logging facility for instruction semantics. <br /></td></tr>
<tr class="separator:a99a35560a04dfe7b35ef209a392edfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa619352fd8f4bee4f2ba242fad51f327" name="aa619352fd8f4bee4f2ba242fad51f327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa619352fd8f4bee4f2ba242fad51f327">&#9670;&#160;</a></span>DispatcherCilPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherCil.html">DispatcherCil</a>&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#aa619352fd8f4bee4f2ba242fad51f327">Rose::BinaryAnalysis::InstructionSemantics::DispatcherCilPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to an CIL instruction dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherCil_8h_source.html#l00020">20</a> of file <a class="el" href="DispatcherCil_8h_source.html">DispatcherCil.h</a>.</p>

</div>
</div>
<a id="a419eb9091df671582ad3986820bbcfae" name="a419eb9091df671582ad3986820bbcfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419eb9091df671582ad3986820bbcfae">&#9670;&#160;</a></span>DispatcherM68kPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherM68k.html">DispatcherM68k</a>&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a419eb9091df671582ad3986820bbcfae">Rose::BinaryAnalysis::InstructionSemantics::DispatcherM68kPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to an M68k instruction dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherM68k_8h_source.html#l00023">23</a> of file <a class="el" href="DispatcherM68k_8h_source.html">DispatcherM68k.h</a>.</p>

</div>
</div>
<a id="adad29f7f55fe9821a1760d85b7b8e92b" name="adad29f7f55fe9821a1760d85b7b8e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad29f7f55fe9821a1760d85b7b8e92b">&#9670;&#160;</a></span>DispatcherMipsPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#adad29f7f55fe9821a1760d85b7b8e92b">Rose::BinaryAnalysis::InstructionSemantics::DispatcherMipsPtr</a> = typedef boost::shared_ptr&lt;class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherMips.html">DispatcherMips</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to a MIPS instruction dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherMips_8h_source.html#l00026">26</a> of file <a class="el" href="DispatcherMips_8h_source.html">DispatcherMips.h</a>.</p>

</div>
</div>
<a id="a7121b7034c2ccb7bed2c82e2a406dc6f" name="a7121b7034c2ccb7bed2c82e2a406dc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7121b7034c2ccb7bed2c82e2a406dc6f">&#9670;&#160;</a></span>DispatcherPowerpcPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherPowerpc.html">DispatcherPowerpc</a>&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a7121b7034c2ccb7bed2c82e2a406dc6f">Rose::BinaryAnalysis::InstructionSemantics::DispatcherPowerpcPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to a PowerPC instruction dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherPowerpc_8h_source.html#l00026">26</a> of file <a class="el" href="DispatcherPowerpc_8h_source.html">DispatcherPowerpc.h</a>.</p>

</div>
</div>
<a id="a90db6f28357786d9537040c99bd7ba23" name="a90db6f28357786d9537040c99bd7ba23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90db6f28357786d9537040c99bd7ba23">&#9670;&#160;</a></span>DispatcherX86Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;class <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html">DispatcherX86</a>&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to an x86 instruction dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00028">28</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
