<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::MemoryMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html">MemoryMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1MemoryMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::MemoryMap Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>An efficient mapping from an address space to stored data. </p>
<p>This class, a specialization of <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>, maps 64-bit addresses to bytes. The address space is organized into non-overlapping, contiguous "segments" (<a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">Sawyer::Container::AddressSegment</a>) that impart properties such as names and access permissions. Each segment points into a buffer (subclass of <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>) where the data bytes are stored.</p>
<p>The buffers pointed to by the segments are reference counted with smart pointers. Normally, each segment points to the beginning of its own buffer, but this is not always true. Sometimes segments share buffers, and sometimes segments point into the middle of buffers. This flexibility allows parts of an address space to be erased or replaced even from the middle of existing segments. It also allows the same data to be mapped and shared at multiple addresses.</p>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> objects are also reference counted and created by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a788dc3ca323dee1fc811bc55645ecdf8">instance</a> method. Copying a <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> object is shallow: the new object will have its own mapping and segments, but will share the underying buffers with the source map.</p>
<p>Most of the low level functionality for a <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> comes from the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a> base class, such as the ability to add, erase, or replace parts of the address space and the ability to read data from the address space. The base class documentation has lots of example code. On the other hand, most of the more complex behaviors are defined in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> class, such as initializing a <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> from a Linux process or reading a NUL-terminated string.</p>
<p>Here's an example of mapping a file into an address space at virtual address 0x08040000 and then temporarily replacing the second 1kB page of the file with our own data. We demonstrate using a <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">Sawyer::Container::MappedBuffer</a> because these are very fast for large files, especially if only small parts of the file are ever accessed.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceSawyer_1_1Container.html">Sawyer::Container</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and initialize the overlay data</span></div>
<div class="line">uint8_t myData[8192];</div>
<div class="line"><a class="code hl_function" href="namespaceRose.html#af33aa6af24a48a55a0664622f9ff27a9">initialize</a>(myData, myDataSize);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the two buffers: one for the file, one for the overlay data</span></div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Buffer::Ptr</a> fileBuf = <a class="code hl_function" href="classSawyer_1_1Container_1_1MappedBuffer.html#a5a02eed7e8f44728b321fe8bcf08802e">MappedBuffer::instance</a>(<span class="stringliteral">&quot;the_file&quot;</span>, boost::iostreams::mapped_file::readonly);</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Buffer::Ptr</a> dataBuf = <a class="code hl_function" href="classSawyer_1_1Container_1_1StaticBuffer.html#a9b8f220a9332d70d7c357d3601ef9049">StaticBuffer::instance</a>(myData, 8192);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the memory map.</span></div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">MemoryMap::Ptr</a> map = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a788dc3ca323dee1fc811bc55645ecdf8">MemoryMap::instance</a>();</div>
<div class="line">map-&gt;insert(<a class="code hl_function" href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f">AddressInterval::baseSize</a>(0x08040000, fileBuf-&gt;size()),</div>
<div class="line">            <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>(fileBuf, 0, MemoryMap::MM_PROT_READ, <span class="stringliteral">&quot;the file contents&quot;</span>));</div>
<div class="line">map-&gt;insert(<a class="code hl_function" href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f">AddressInterval::baseSize</a>(0x08040000+1024, dataBuf-&gt;size()),</div>
<div class="line">           <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>(dataBuf, 0, MemoryMap::MM_PROT_RW, <span class="stringliteral">&quot;data overlay&quot;</span>));</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1MemoryMap_html_a788dc3ca323dee1fc811bc55645ecdf8"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a788dc3ca323dee1fc811bc55645ecdf8">Rose::BinaryAnalysis::MemoryMap::instance</a></div><div class="ttdeci">static Ptr instance()</div><div class="ttdoc">Construct an empty memory map.</div><div class="ttdef"><b>Definition</b> <a href="MemoryMap_8h_source.html#l00267">MemoryMap.h:267</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressSegment_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressSegment.html">Sawyer::Container::AddressSegment</a></div><div class="ttdoc">A homogeneous interval of an address space.</div><div class="ttdef"><b>Definition</b> <a href="AddressSegment_8h_source.html#l00042">AddressSegment.h:42</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Interval_html_a136b9afce8c48871c21c58dc9ecdc48f"><div class="ttname"><a href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f">Sawyer::Container::Interval&lt; Address &gt;::baseSize</a></div><div class="ttdeci">static Interval baseSize(Address lo, Address size)</div><div class="ttdoc">Construct an interval from one endpoint and a size.</div><div class="ttdef"><b>Definition</b> <a href="Interval_8h_source.html#l00173">Interval.h:173</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1MappedBuffer_html_a5a02eed7e8f44728b321fe8bcf08802e"><div class="ttname"><a href="classSawyer_1_1Container_1_1MappedBuffer.html#a5a02eed7e8f44728b321fe8bcf08802e">Sawyer::Container::MappedBuffer::instance</a></div><div class="ttdeci">static Buffer&lt; A, T &gt;::Ptr instance(const boost::iostreams::mapped_file_params &amp;params)</div><div class="ttdoc">Map a file according to boost parameters.</div><div class="ttdef"><b>Definition</b> <a href="MappedBuffer_8h_source.html#l00149">MappedBuffer.h:149</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1StaticBuffer_html_a9b8f220a9332d70d7c357d3601ef9049"><div class="ttname"><a href="classSawyer_1_1Container_1_1StaticBuffer.html#a9b8f220a9332d70d7c357d3601ef9049">Sawyer::Container::StaticBuffer::instance</a></div><div class="ttdeci">static Buffer&lt; A, T &gt;::Ptr instance(Value *values, Address size)</div><div class="ttdoc">Construct from caller-supplied data.</div><div class="ttdef"><b>Definition</b> <a href="StaticBuffer_8h_source.html#l00111">StaticBuffer.h:111</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a></div><div class="ttdoc">Reference-counting intrusive smart pointer.</div><div class="ttdef"><b>Definition</b> <a href="SharedPointer_8h_source.html#l00065">SharedPointer.h:65</a></div></div>
<div class="ttc" id="anamespaceRose_html_af33aa6af24a48a55a0664622f9ff27a9"><div class="ttname"><a href="namespaceRose.html#af33aa6af24a48a55a0664622f9ff27a9">Rose::initialize</a></div><div class="ttdeci">ROSE_DLL_API void initialize(const char *configToken)</div><div class="ttdoc">Initialize the library.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_html"><div class="ttname"><a href="namespaceSawyer_1_1Container.html">Sawyer::Container</a></div><div class="ttdoc">Container classes that store user-defined values.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l00031">AddressMap.h:31</a></div></div>
</div><!-- fragment --><p>A <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> provides methods to easily read from and write to the underlying data storage, addressing it in terms of the virtual address space. These functions return the addresses that were accessed, and are prefixed by calls that describe what data is to be accessed.</p>
<div class="fragment"><div class="line"><span class="comment">// read part of the data, right across the file/overlay boundary</span></div>
<div class="line">uint8_t data[4096];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map-&gt;at(0x08040100).limit(<span class="keyword">sizeof</span> data).read(data).size();</div>
<div class="line">assert(nread == <span class="keyword">sizeof</span> data);</div>
</div><!-- fragment --><p>The <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> documentation contains many more examples. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00115">115</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="MemoryMap_8h_source.html">Rose/BinaryAnalysis/MemoryMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::MemoryMap:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1MemoryMap__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1MemoryMap_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1MemoryMap_inherit__map" id="aRose_1_1BinaryAnalysis_1_1MemoryMap_inherit__map">
<area shape="rect" title="An efficient mapping from an address space to stored data." alt="" coords="104,108,252,148"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html" title=" " alt="" coords="5,5,169,60"/>
<area shape="poly" title=" " alt="" coords="125,68,161,106,157,110,121,72"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="193,20,347,45"/>
<area shape="poly" title=" " alt="" coords="250,57,200,110,196,106,246,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::MemoryMap:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1MemoryMap__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1MemoryMap_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1MemoryMap_coll__map" id="aRose_1_1BinaryAnalysis_1_1MemoryMap_coll__map">
<area shape="rect" title="An efficient mapping from an address space to stored data." alt="" coords="104,108,252,148"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html" title=" " alt="" coords="5,5,169,60"/>
<area shape="poly" title=" " alt="" coords="125,68,161,106,157,110,121,72"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="193,20,347,45"/>
<area shape="poly" title=" " alt="" coords="250,57,200,110,196,106,246,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Attach.html">Attach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Attach.html" title="Attach with ptrace first when reading a process?">Attach</a> with ptrace first when reading a process?  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Attach.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html" title="Exception for MemoryMap operations.">Exception</a> for <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> operations.  <a href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Inconsistent.html">Inconsistent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html" title="Exception for MemoryMap operations.">Exception</a> for an inconsistent mapping.  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Inconsistent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NoFreeSpace.html">NoFreeSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html" title="Exception for MemoryMap operations.">Exception</a> thrown by <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html#a716ae314dade2783d07d384ba34e480a" title="Map that caused the exception if available, null otherwise.">find_free()</a> when there's not enough free space left.  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NoFreeSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NotMapped.html">NotMapped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html" title="Exception for MemoryMap operations.">Exception</a> for when we try to access a virtual address that isn't mapped.  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NotMapped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1ProcessMapRecord.html">ProcessMapRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a process map.  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1ProcessMapRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1SyntaxError.html">SyntaxError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Exception.html" title="Exception for MemoryMap operations.">Exception</a> thrown by load() when there's a syntax error in the index file.  <a href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1SyntaxError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9bc4cf22ea8728c97c452f3c0ae4151" id="r_af9bc4cf22ea8728c97c452f3c0ae4151"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Clobber</a> { <br />
&#160;&#160;<b>NO</b>
, <br />
&#160;&#160;<b>YES</b>
<br />
 }</td></tr>
<tr class="memdesc:af9bc4cf22ea8728c97c452f3c0ae4151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite (parts of) existing segments?  <a href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">More...</a><br /></td></tr>
<tr class="separator:af9bc4cf22ea8728c97c452f3c0ae4151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d621d26efc9f3fd4a506633fb300f8" id="r_a87d621d26efc9f3fd4a506633fb300f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8">InsertFileMapMode</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8a30c3ab6e206e47fbd0c1b545a0828d4a">MAP_PRIVATE</a> = 0
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8a7d1630e6c92a57579111fcfb164e0090">MAP_READWRITE</a> = 1
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8a99249a98054c92d479e3251701b1bf64">MAP_RDONLY</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:a87d621d26efc9f3fd4a506633fb300f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping mode for insertFile.  <a href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8">More...</a><br /></td></tr>
<tr class="separator:a87d621d26efc9f3fd4a506633fb300f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbb47f6fe164ce6ef8816f28dc93a1f" id="r_a0dbb47f6fe164ce6ef8816f28dc93a1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a></td></tr>
<tr class="memdesc:a0dbb47f6fe164ce6ef8816f28dc93a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:a0dbb47f6fe164ce6ef8816f28dc93a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f665704a05e1328ab2b67b4bb5612d1" id="r_a7f665704a05e1328ab2b67b4bb5612d1"><td class="memItemLeft" align="right" valign="top">typedef rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a7f665704a05e1328ab2b67b4bb5612d1">Address</a></td></tr>
<tr class="separator:a7f665704a05e1328ab2b67b4bb5612d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05384f3d6f268eb1407b5b3d01f9ddfe" id="r_a05384f3d6f268eb1407b5b3d01f9ddfe"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a05384f3d6f268eb1407b5b3d01f9ddfe">Value</a></td></tr>
<tr class="separator:a05384f3d6f268eb1407b5b3d01f9ddfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538f22af92cd81f32268a159f0ad7e34" id="r_a538f22af92cd81f32268a159f0ad7e34"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a538f22af92cd81f32268a159f0ad7e34">Super</a></td></tr>
<tr class="separator:a538f22af92cd81f32268a159f0ad7e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d23c83a629a9ecdc3eec2489673b1" id="r_a759d23c83a629a9ecdc3eec2489673b1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a759d23c83a629a9ecdc3eec2489673b1">Buffer</a></td></tr>
<tr class="separator:a759d23c83a629a9ecdc3eec2489673b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f64d5c4d18d7372d9fd350bdb5f95" id="r_a6b1f64d5c4d18d7372d9fd350bdb5f95"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AllocatingBuffer.html">Sawyer::Container::AllocatingBuffer</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a6b1f64d5c4d18d7372d9fd350bdb5f95">AllocatingBuffer</a></td></tr>
<tr class="separator:a6b1f64d5c4d18d7372d9fd350bdb5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b087a99a3ce49d8f326c1683d279b7" id="r_aa3b087a99a3ce49d8f326c1683d279b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">Sawyer::Container::MappedBuffer</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aa3b087a99a3ce49d8f326c1683d279b7">MappedBuffer</a></td></tr>
<tr class="separator:aa3b087a99a3ce49d8f326c1683d279b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cbd7c4a04f0aa30d0925c2415353c3" id="r_ab1cbd7c4a04f0aa30d0925c2415353c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1NullBuffer.html">Sawyer::Container::NullBuffer</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ab1cbd7c4a04f0aa30d0925c2415353c3">NullBuffer</a></td></tr>
<tr class="separator:ab1cbd7c4a04f0aa30d0925c2415353c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a74b38bbe8d2144b76dee36961486c9" id="r_a5a74b38bbe8d2144b76dee36961486c9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1StaticBuffer.html">Sawyer::Container::StaticBuffer</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a5a74b38bbe8d2144b76dee36961486c9">StaticBuffer</a></td></tr>
<tr class="separator:a5a74b38bbe8d2144b76dee36961486c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dd604ea5d50d05d4bf968fb021d9d" id="r_af35dd604ea5d50d05d4bf968fb021d9d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">Sawyer::Container::SegmentPredicate</a>&lt; Address, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af35dd604ea5d50d05d4bf968fb021d9d">SegmentPredicate</a></td></tr>
<tr class="separator:af35dd604ea5d50d05d4bf968fb021d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1900db9b5623173c4fae7410f2af9e40" id="r_a1900db9b5623173c4fae7410f2af9e40"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Sawyer::Container::AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; rose_addr_t, uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a1900db9b5623173c4fae7410f2af9e40">Constraints</a></td></tr>
<tr class="separator:a1900db9b5623173c4fae7410f2af9e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa3903f1e3e1bc921f7e080862dfe52" id="r_a9aa3903f1e3e1bc921f7e080862dfe52"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Sawyer::Container::AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; rose_addr_t, uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9aa3903f1e3e1bc921f7e080862dfe52">ConstConstraints</a></td></tr>
<tr class="separator:a9aa3903f1e3e1bc921f7e080862dfe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Container_1_1AddressMap"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Container_1_1AddressMap')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;</a></td></tr>
<tr class="memitem:a1134be6cf10571edef9ffe6ab06fd7a9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_a1134be6cf10571edef9ffe6ab06fd7a9"><td class="memItemLeft" align="right" valign="top">typedef rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a></td></tr>
<tr class="memdesc:a1134be6cf10571edef9ffe6ab06fd7a9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for addresses.  <br /></td></tr>
<tr class="separator:a1134be6cf10571edef9ffe6ab06fd7a9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a7317b6be4502317ab4357b5989660 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_aa7a7317b6be4502317ab4357b5989660"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a></td></tr>
<tr class="memdesc:aa7a7317b6be4502317ab4357b5989660 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of data stored in the address space.  <br /></td></tr>
<tr class="separator:aa7a7317b6be4502317ab4357b5989660 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30140763fdfb3c3c12e8fd6a1dc22ea9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>&lt; rose_addr_t, uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a></td></tr>
<tr class="memdesc:a30140763fdfb3c3c12e8fd6a1dc22ea9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of segments stored by this map.  <br /></td></tr>
<tr class="separator:a30140763fdfb3c3c12e8fd6a1dc22ea9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b56b98075440d935890ac4f0c0053 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_a853b56b98075440d935890ac4f0c0053"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a853b56b98075440d935890ac4f0c0053">Buffer</a></td></tr>
<tr class="separator:a853b56b98075440d935890ac4f0c0053 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9cf858603ecda80b73929ad8fcbc9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_af2c9cf858603ecda80b73929ad8fcbc9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Super::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a></td></tr>
<tr class="memdesc:af2c9cf858603ecda80b73929ad8fcbc9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node containing interval/segment pair.  <br /></td></tr>
<tr class="separator:af2c9cf858603ecda80b73929ad8fcbc9 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7204596756341c0ea7eeadc5d38262 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_a9f7204596756341c0ea7eeadc5d38262"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">Super::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a></td></tr>
<tr class="memdesc:a9f7204596756341c0ea7eeadc5d38262 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over segments in the map.  <br /></td></tr>
<tr class="separator:a9f7204596756341c0ea7eeadc5d38262 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852a793027a1c74c097147546910f47 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_aa852a793027a1c74c097147546910f47"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">Super::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a></td></tr>
<tr class="memdesc:aa852a793027a1c74c097147546910f47 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators over segments in the map.  <br /></td></tr>
<tr class="separator:aa852a793027a1c74c097147546910f47 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0994c89a6b4a525a52f8f341ae3d28ed inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_a0994c89a6b4a525a52f8f341ae3d28ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">Super::ConstIntervalIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0994c89a6b4a525a52f8f341ae3d28ed">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:a0994c89a6b4a525a52f8f341ae3d28ed inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address intervals in the map.  <br /></td></tr>
<tr class="separator:a0994c89a6b4a525a52f8f341ae3d28ed inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6954614b9b130d841261ad4d2644316 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_ac6954614b9b130d841261ad4d2644316"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">Super::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a></td></tr>
<tr class="memdesc:ac6954614b9b130d841261ad4d2644316 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval, segment pairs in the map.  <br /></td></tr>
<tr class="separator:ac6954614b9b130d841261ad4d2644316 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a3b18db58eae98d782531b3f155b5 inherit pub_types_classSawyer_1_1Container_1_1AddressMap" id="r_abf7a3b18db58eae98d782531b3f155b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">Super::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a></td></tr>
<tr class="memdesc:abf7a3b18db58eae98d782531b3f155b5 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval/segment pairs in the map.  <br /></td></tr>
<tr class="separator:abf7a3b18db58eae98d782531b3f155b5 inherit pub_types_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a664961032974fd71f132d8931edd68de"><td class="memItemLeft" align="right" valign="top">typedef I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a></td></tr>
<tr class="memdesc:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type.  <br /></td></tr>
<tr class="separator:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a7c7ef387287aa01aa632dfeafc121e95"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a></td></tr>
<tr class="memdesc:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <br /></td></tr>
<tr class="separator:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae27b32aea90cdef93228cd5c978c00ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Container::Map</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>, IntervalCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a></td></tr>
<tr class="memdesc:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of the underlying map.  <br /></td></tr>
<tr class="separator:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad3da8180167b02f750f8138e21fea1b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td></tr>
<tr class="memdesc:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node.  <br /></td></tr>
<tr class="separator:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> iterator.  <br /></td></tr>
<tr class="separator:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae50e191b16e240244fb48af0232e88ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td></tr>
<tr class="memdesc:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a></td></tr>
<tr class="memdesc:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a643bf7e3b1413a950b3e66bd7244dacb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td></tr>
<tr class="memdesc:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad28df1a69755b5534a2ddb68bd447e61"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a></td></tr>
<tr class="memdesc:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa0c0e42f15d273c92e12dffa49256a48" id="r_aa0c0e42f15d273c92e12dffa49256a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aa0c0e42f15d273c92e12dffa49256a48">shallowCopy</a> ()</td></tr>
<tr class="memdesc:aa0c0e42f15d273c92e12dffa49256a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new copy of the memory map.  <br /></td></tr>
<tr class="separator:aa0c0e42f15d273c92e12dffa49256a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0df1ec6d8b31a7b82d24aedbe8be4" id="r_a4fa0df1ec6d8b31a7b82d24aedbe8be4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a4fa0df1ec6d8b31a7b82d24aedbe8be4">insertFile</a> (const std::string &amp;fileName, rose_addr_t va, <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8">InsertFileMapMode</a> mode=<a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8a30c3ab6e206e47fbd0c1b545a0828d4a">MAP_PRIVATE</a>, std::string segmentName=&quot;&quot;)</td></tr>
<tr class="memdesc:a4fa0df1ec6d8b31a7b82d24aedbe8be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert file contents into memory map.  <br /></td></tr>
<tr class="separator:a4fa0df1ec6d8b31a7b82d24aedbe8be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae810726284ca11827e317530f5ac4722" id="r_ae810726284ca11827e317530f5ac4722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ae810726284ca11827e317530f5ac4722">insertFile</a> (const std::string &amp;locatorString)</td></tr>
<tr class="memdesc:ae810726284ca11827e317530f5ac4722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert file contents into memory map.  <br /></td></tr>
<tr class="separator:ae810726284ca11827e317530f5ac4722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f88ba78df49ac09e2734db004e2df3" id="r_a02f88ba78df49ac09e2734db004e2df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a02f88ba78df49ac09e2734db004e2df3">insertData</a> (const std::string &amp;locatorString)</td></tr>
<tr class="memdesc:a02f88ba78df49ac09e2734db004e2df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into a memory map.  <br /></td></tr>
<tr class="separator:a02f88ba78df49ac09e2734db004e2df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35043ddbd26847f4271d0bd38af6e18" id="r_af35043ddbd26847f4271d0bd38af6e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af35043ddbd26847f4271d0bd38af6e18">adjustMap</a> (const std::string &amp;locatorString)</td></tr>
<tr class="memdesc:af35043ddbd26847f4271d0bd38af6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts a memory map according to the locator string.  <br /></td></tr>
<tr class="separator:af35043ddbd26847f4271d0bd38af6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad677c86ba0e10b313e3a5b36f8a5217" id="r_aad677c86ba0e10b313e3a5b36f8a5217"><td class="memItemLeft" align="right" valign="top"><a id="aad677c86ba0e10b313e3a5b36f8a5217" name="aad677c86ba0e10b313e3a5b36f8a5217"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertProcess</b> (pid_t pid, <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1Attach.html#a75e897f3ada117f110312bd7d5254fc5">Attach::Boolean</a> attach)</td></tr>
<tr class="memdesc:aad677c86ba0e10b313e3a5b36f8a5217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the memory of some other process into this memory map. <br /></td></tr>
<tr class="separator:aad677c86ba0e10b313e3a5b36f8a5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf90935bc209a9c36e9473be70c9d38" id="r_aaaf90935bc209a9c36e9473be70c9d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aaaf90935bc209a9c36e9473be70c9d38">insertProcess</a> (const std::string &amp;locatorString)</td></tr>
<tr class="memdesc:aaaf90935bc209a9c36e9473be70c9d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the memory of some other process into this memory map.  <br /></td></tr>
<tr class="separator:aaaf90935bc209a9c36e9473be70c9d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd28068846fb7cb9cc9c1695b82e6293" id="r_afd28068846fb7cb9cc9c1695b82e6293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#afd28068846fb7cb9cc9c1695b82e6293">align</a> (rose_addr_t lowAlignment, rose_addr_t highAlignment) const</td></tr>
<tr class="memdesc:afd28068846fb7cb9cc9c1695b82e6293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new map by padding and aligning segments.  <br /></td></tr>
<tr class="separator:afd28068846fb7cb9cc9c1695b82e6293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08d1e0ba388008d15e64c6e4b422a80" id="r_aa08d1e0ba388008d15e64c6e4b422a80"><td class="memItemLeft" align="right" valign="top"><a id="aa08d1e0ba388008d15e64c6e4b422a80" name="aa08d1e0ba388008d15e64c6e4b422a80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eraseZeros</b> (size_t minsize)</td></tr>
<tr class="memdesc:aa08d1e0ba388008d15e64c6e4b422a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases regions of zero bytes that are executable and readable and at least <code>minsize</code> in size. <br /></td></tr>
<tr class="separator:aa08d1e0ba388008d15e64c6e4b422a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bac3678aca70245a9e87f6b353f21bf" id="r_a4bac3678aca70245a9e87f6b353f21bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a4bac3678aca70245a9e87f6b353f21bf">shrinkUnshare</a> ()</td></tr>
<tr class="memdesc:a4bac3678aca70245a9e87f6b353f21bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink buffers and remove sharing.  <br /></td></tr>
<tr class="separator:a4bac3678aca70245a9e87f6b353f21bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eed131c77e6ae95d379bee546f2d9e" id="r_ad0eed131c77e6ae95d379bee546f2d9e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ad0eed131c77e6ae95d379bee546f2d9e">readQuick</a> (void *buf, rose_addr_t startVa, size_t desired) const</td></tr>
<tr class="memdesc:ad0eed131c77e6ae95d379bee546f2d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into buffer.  <br /></td></tr>
<tr class="separator:ad0eed131c77e6ae95d379bee546f2d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d20c9c61b8545d4994513cc5c18066a" id="r_a9d20c9c61b8545d4994513cc5c18066a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9d20c9c61b8545d4994513cc5c18066a">readString</a> (rose_addr_t startVa, size_t desired, int(*validChar)(int)=NULL, int(*invalidChar)(int)=NULL, unsigned requiredPerms=READABLE, unsigned prohibitedPerms=0, char terminator='\0') const</td></tr>
<tr class="memdesc:a9d20c9c61b8545d4994513cc5c18066a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a NUL-terminated string from the memory map.  <br /></td></tr>
<tr class="separator:a9d20c9c61b8545d4994513cc5c18066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c63a2f916fcee57a1268bc2cbe5b8f" id="r_a62c63a2f916fcee57a1268bc2cbe5b8f"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a62c63a2f916fcee57a1268bc2cbe5b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a62c63a2f916fcee57a1268bc2cbe5b8f">readUnsigned</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a62c63a2f916fcee57a1268bc2cbe5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned value.  <br /></td></tr>
<tr class="separator:a62c63a2f916fcee57a1268bc2cbe5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de66f3b03192e4d82279a67292b7f32" id="r_a0de66f3b03192e4d82279a67292b7f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0de66f3b03192e4d82279a67292b7f32">readLongUnsinged</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a0de66f3b03192e4d82279a67292b7f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a long unsigned value.  <br /></td></tr>
<tr class="separator:a0de66f3b03192e4d82279a67292b7f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7851003d7eda2cf19853c46e74a4acec" id="r_a7851003d7eda2cf19853c46e74a4acec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a7851003d7eda2cf19853c46e74a4acec">writeUnsigned</a> (uint32_t value, rose_addr_t startVa)</td></tr>
<tr class="memdesc:a7851003d7eda2cf19853c46e74a4acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned value.  <br /></td></tr>
<tr class="separator:a7851003d7eda2cf19853c46e74a4acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe58985a57d91bbe19882b616f4f88e" id="r_acbe58985a57d91bbe19882b616f4f88e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#acbe58985a57d91bbe19882b616f4f88e">writeUnsigned</a> (uint64_t value, rose_addr_t startVa)</td></tr>
<tr class="memdesc:acbe58985a57d91bbe19882b616f4f88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a long unsigned value.  <br /></td></tr>
<tr class="separator:acbe58985a57d91bbe19882b616f4f88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01e9fab5cc3179dae674f2a67e55459" id="r_af01e9fab5cc3179dae674f2a67e55459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af01e9fab5cc3179dae674f2a67e55459">readByte</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:af01e9fab5cc3179dae674f2a67e55459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from memory.  <br /></td></tr>
<tr class="separator:af01e9fab5cc3179dae674f2a67e55459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90df3c68940eb6520a0bc10668848f" id="r_a3b90df3c68940eb6520a0bc10668848f"><td class="memItemLeft" align="right" valign="top"><a id="a3b90df3c68940eb6520a0bc10668848f" name="a3b90df3c68940eb6520a0bc10668848f"></a>
SgUnsignedCharList&#160;</td><td class="memItemRight" valign="bottom"><b>readVector</b> (rose_addr_t startVa, size_t desired, unsigned requiredPerms=READABLE) const</td></tr>
<tr class="memdesc:a3b90df3c68940eb6520a0bc10668848f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read quickly into a vector. <br /></td></tr>
<tr class="separator:a3b90df3c68940eb6520a0bc10668848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d39ab5e0ca182aae31fe1666e60c95" id="r_ab2d39ab5e0ca182aae31fe1666e60c95"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ab2d39ab5e0ca182aae31fe1666e60c95">writeQuick</a> (const void *buf, rose_addr_t startVa, size_t desired)</td></tr>
<tr class="memdesc:ab2d39ab5e0ca182aae31fe1666e60c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data from buffer.  <br /></td></tr>
<tr class="separator:ab2d39ab5e0ca182aae31fe1666e60c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b264dbe50c160e3654f946f88c372c" id="r_ad5b264dbe50c160e3654f946f88c372c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ad5b264dbe50c160e3654f946f88c372c">findSequence</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;interval, const std::vector&lt; uint8_t &gt; &amp;sequence) const</td></tr>
<tr class="memdesc:ad5b264dbe50c160e3654f946f88c372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a byte sequence.  <br /></td></tr>
<tr class="separator:ad5b264dbe50c160e3654f946f88c372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f3b09b22c8fe61102781612ad45459" id="r_a95f3b09b22c8fe61102781612ad45459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a95f3b09b22c8fe61102781612ad45459">hash</a> (<a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;) const</td></tr>
<tr class="memdesc:a95f3b09b22c8fe61102781612ad45459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash of the entire memory contents.  <br /></td></tr>
<tr class="separator:a95f3b09b22c8fe61102781612ad45459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0f5814ca1011d24c50831db25b6a1faf" id="r_a0f5814ca1011d24c50831db25b6a1faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0f5814ca1011d24c50831db25b6a1faf">byteOrder</a> () const</td></tr>
<tr class="memdesc:a0f5814ca1011d24c50831db25b6a1faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order.  <br /></td></tr>
<tr class="separator:a0f5814ca1011d24c50831db25b6a1faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cca00a43c93a6e47e1cf758c6a40a4" id="r_ad6cca00a43c93a6e47e1cf758c6a40a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ad6cca00a43c93a6e47e1cf758c6a40a4">byteOrder</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> order)</td></tr>
<tr class="memdesc:ad6cca00a43c93a6e47e1cf758c6a40a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order.  <br /></td></tr>
<tr class="separator:ad6cca00a43c93a6e47e1cf758c6a40a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ea59ab4c870a51afdf55a34a20b1f0a" id="r_a9ea59ab4c870a51afdf55a34a20b1f0a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9ea59ab4c870a51afdf55a34a20b1f0a">name</a> () const</td></tr>
<tr class="memdesc:a9ea59ab4c870a51afdf55a34a20b1f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:a9ea59ab4c870a51afdf55a34a20b1f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e60affc757e34e56e93672ee5795eb" id="r_a80e60affc757e34e56e93672ee5795eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a80e60affc757e34e56e93672ee5795eb">name</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a80e60affc757e34e56e93672ee5795eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:a80e60affc757e34e56e93672ee5795eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a941933796af7fcf7825296057634219b" id="r_a941933796af7fcf7825296057634219b"><td class="memItemLeft" align="right" valign="top"><a id="a941933796af7fcf7825296057634219b" name="a941933796af7fcf7825296057634219b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insertProcessPid</b> (pid_t, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;where, unsigned accessibility, const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9ea59ab4c870a51afdf55a34a20b1f0a">name</a>)</td></tr>
<tr class="memdesc:a941933796af7fcf7825296057634219b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of another process's memory into this memory map. <br /></td></tr>
<tr class="separator:a941933796af7fcf7825296057634219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bb35e7223665248e2919b7c90a6466" id="r_af0bb35e7223665248e2919b7c90a6466"><td class="memItemLeft" align="right" valign="top"><a id="af0bb35e7223665248e2919b7c90a6466" name="af0bb35e7223665248e2919b7c90a6466"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertProcessPid</b> (pid_t, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1ProcessMapRecord.html">ProcessMapRecord</a> &gt; &amp;)</td></tr>
<tr class="memdesc:af0bb35e7223665248e2919b7c90a6466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of another process's memory into this memory map. <br /></td></tr>
<tr class="separator:af0bb35e7223665248e2919b7c90a6466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23eeab1c90b61170f300f2467d655fe6" id="r_a23eeab1c90b61170f300f2467d655fe6"><td class="memItemLeft" align="right" valign="top"><a id="a23eeab1c90b61170f300f2467d655fe6" name="a23eeab1c90b61170f300f2467d655fe6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insertProcessMemory</b> (int memFile, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;where, unsigned accessibility, std::string <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9ea59ab4c870a51afdf55a34a20b1f0a">name</a>)</td></tr>
<tr class="memdesc:a23eeab1c90b61170f300f2467d655fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of another process's memory into this memory map. <br /></td></tr>
<tr class="separator:a23eeab1c90b61170f300f2467d655fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaba3ba3e4f0897bf5912fd36b20fecd9" id="r_aaba3ba3e4f0897bf5912fd36b20fecd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aaba3ba3e4f0897bf5912fd36b20fecd9">linkTo</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;source, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;where, <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Clobber</a>=Clobber::YES)</td></tr>
<tr class="memdesc:aaba3ba3e4f0897bf5912fd36b20fecd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of another map by reference.  <br /></td></tr>
<tr class="separator:aaba3ba3e4f0897bf5912fd36b20fecd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ddb64d1de9c10f925b4d61c4da5787" id="r_ab2ddb64d1de9c10f925b4d61c4da5787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ab2ddb64d1de9c10f925b4d61c4da5787">linkTo</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;source, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;where, <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Clobber</a>=Clobber::YES)</td></tr>
<tr class="memdesc:ab2ddb64d1de9c10f925b4d61c4da5787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert part of another map by reference.  <br /></td></tr>
<tr class="separator:ab2ddb64d1de9c10f925b4d61c4da5787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aecf3bd4f98820b1fc1fa303c8f809849" id="r_aecf3bd4f98820b1fc1fa303c8f809849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aecf3bd4f98820b1fc1fa303c8f809849">findAny</a> (const <a class="el" href="classRange.html">Extent</a> &amp;limits, const std::vector&lt; uint8_t &gt; &amp;bytesToFind, unsigned requiredPerms=READABLE, unsigned prohibitedPerms=0) const</td></tr>
<tr class="memdesc:aecf3bd4f98820b1fc1fa303c8f809849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for any byte.  <br /></td></tr>
<tr class="separator:aecf3bd4f98820b1fc1fa303c8f809849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d16515b3c11cb868e3aa04618876846" id="r_a7d16515b3c11cb868e3aa04618876846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a7d16515b3c11cb868e3aa04618876846">findAny</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;limits, const std::vector&lt; uint8_t &gt; &amp;bytesToFind, unsigned requiredPerms=READABLE, unsigned prohibitedPerms=0) const</td></tr>
<tr class="memdesc:a7d16515b3c11cb868e3aa04618876846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for any byte.  <br /></td></tr>
<tr class="separator:a7d16515b3c11cb868e3aa04618876846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae22e797e2b3e14aef3200b03765917ea" id="r_ae22e797e2b3e14aef3200b03765917ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ae22e797e2b3e14aef3200b03765917ea">dump</a> (FILE *, const char *prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:ae22e797e2b3e14aef3200b03765917ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the map for debugging.  <br /></td></tr>
<tr class="separator:ae22e797e2b3e14aef3200b03765917ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232b7a13b0b01463ddd3ec8dd77a81d3" id="r_a232b7a13b0b01463ddd3ec8dd77a81d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a232b7a13b0b01463ddd3ec8dd77a81d3">dump</a> (std::ostream &amp;, std::string prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:a232b7a13b0b01463ddd3ec8dd77a81d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the map for debugging.  <br /></td></tr>
<tr class="separator:a232b7a13b0b01463ddd3ec8dd77a81d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc02cd21b36577ba15d2094ad4c8b5" id="r_a99dc02cd21b36577ba15d2094ad4c8b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a99dc02cd21b36577ba15d2094ad4c8b5">print</a> (std::ostream &amp;o, std::string prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:a99dc02cd21b36577ba15d2094ad4c8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the map for debugging.  <br /></td></tr>
<tr class="separator:a99dc02cd21b36577ba15d2094ad4c8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27c9d481c390de37fc090aa67d6334d" id="r_ab27c9d481c390de37fc090aa67d6334d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ab27c9d481c390de37fc090aa67d6334d">dump</a> () const</td></tr>
<tr class="memdesc:ab27c9d481c390de37fc090aa67d6334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of the map for debugging.  <br /></td></tr>
<tr class="separator:ab27c9d481c390de37fc090aa67d6334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Container_1_1AddressMap"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Container_1_1AddressMap')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;</a></td></tr>
<tr class="memitem:a3e8cd51e41cea7489ea3f78b0d30365c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a3e8cd51e41cea7489ea3f78b0d30365c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3e8cd51e41cea7489ea3f78b0d30365c">AddressMap</a> ()</td></tr>
<tr class="memdesc:a3e8cd51e41cea7489ea3f78b0d30365c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty address map.  <br /></td></tr>
<tr class="separator:a3e8cd51e41cea7489ea3f78b0d30365c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac1bbe4c8188403070b62fbd6e85fa9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a2ac1bbe4c8188403070b62fbd6e85fa9">AddressMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &amp;other, bool copyOnWrite=false)</td></tr>
<tr class="memdesc:a2ac1bbe4c8188403070b62fbd6e85fa9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a2ac1bbe4c8188403070b62fbd6e85fa9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a26b869a20b7c773f75f7c3d75e04 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a300a26b869a20b7c773f75f7c3d75e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04">checkConsistency</a> () const</td></tr>
<tr class="memdesc:a300a26b869a20b7c773f75f7c3d75e04 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check map consistency.  <br /></td></tr>
<tr class="separator:a300a26b869a20b7c773f75f7c3d75e04 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1ef82354f141b3961d957e8728158 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a78c1ef82354f141b3961d957e8728158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a78c1ef82354f141b3961d957e8728158">nSegments</a> () const</td></tr>
<tr class="memdesc:a78c1ef82354f141b3961d957e8728158 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of segments contained in the map.  <br /></td></tr>
<tr class="separator:a78c1ef82354f141b3961d957e8728158 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f8d5e6092f38ec348503421148dd77 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_af1f8d5e6092f38ec348503421148dd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">next</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:af1f8d5e6092f38ec348503421148dd77 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum or maximum address that satisfies constraints.  <br /></td></tr>
<tr class="separator:af1f8d5e6092f38ec348503421148dd77 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022219388a2d8859eae98f31e675db8d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a022219388a2d8859eae98f31e675db8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a022219388a2d8859eae98f31e675db8d">available</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a022219388a2d8859eae98f31e675db8d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adress interval that satisfies constraints.  <br /></td></tr>
<tr class="separator:a022219388a2d8859eae98f31e675db8d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9a20f07deebeaacfeb58846102b2df inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_adb9a20f07deebeaacfeb58846102b2df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#adb9a20f07deebeaacfeb58846102b2df">exists</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:adb9a20f07deebeaacfeb58846102b2df inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an address exists with the specified constraints.  <br /></td></tr>
<tr class="separator:adb9a20f07deebeaacfeb58846102b2df inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a44452570a955f6e4d347cdcc9608f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ac6a44452570a955f6e4d347cdcc9608f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6a44452570a955f6e4d347cdcc9608f">unmapped</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> boundary, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ac6a44452570a955f6e4d347cdcc9608f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find unmapped interval.  <br /></td></tr>
<tr class="separator:ac6a44452570a955f6e4d347cdcc9608f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c4969b86b4737401da8629fb54092 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a064c4969b86b4737401da8629fb54092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a064c4969b86b4737401da8629fb54092">findFreeSpace</a> (size_t nValues, size_t alignment=1, <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; restriction=<a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;::whole(), <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a064c4969b86b4737401da8629fb54092 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find free space.  <br /></td></tr>
<tr class="separator:a064c4969b86b4737401da8629fb54092 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79044a63583ed0fa8cd49c945372d696 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a79044a63583ed0fa8cd49c945372d696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">prune</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a79044a63583ed0fa8cd49c945372d696 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune away addresses that match constraints.  <br /></td></tr>
<tr class="separator:a79044a63583ed0fa8cd49c945372d696 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d024a2128d70727cfce72518a32bfd inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ab1d024a2128d70727cfce72518a32bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">keep</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ab1d024a2128d70727cfce72518a32bfd inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep only addresses that match constraints.  <br /></td></tr>
<tr class="separator:ab1d024a2128d70727cfce72518a32bfd inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406ad656e7e800fd01f9d17ccc297a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a1406ad656e7e800fd01f9d17ccc297a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1406ad656e7e800fd01f9d17ccc297a8">changeAccess</a> (unsigned requiredAccess, unsigned prohibitedAccess, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a1406ad656e7e800fd01f9d17ccc297a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change access bits for addresses that match constraints.  <br /></td></tr>
<tr class="separator:a1406ad656e7e800fd01f9d17ccc297a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d01f0d9ff8007d7b88039153c2d52d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a82d01f0d9ff8007d7b88039153c2d52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a> (unsigned x) const</td></tr>
<tr class="memdesc:a82d01f0d9ff8007d7b88039153c2d52d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <br /></td></tr>
<tr class="separator:a82d01f0d9ff8007d7b88039153c2d52d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84107f87cfb3f3b3cd32a6b3a981f1fb inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a84107f87cfb3f3b3cd32a6b3a981f1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a84107f87cfb3f3b3cd32a6b3a981f1fb">require</a> (unsigned x)</td></tr>
<tr class="memdesc:a84107f87cfb3f3b3cd32a6b3a981f1fb inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <br /></td></tr>
<tr class="separator:a84107f87cfb3f3b3cd32a6b3a981f1fb inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d2f15072209b954e3c055bcacc2e4f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a45d2f15072209b954e3c055bcacc2e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">prohibit</a> (unsigned x) const</td></tr>
<tr class="memdesc:a45d2f15072209b954e3c055bcacc2e4f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <br /></td></tr>
<tr class="separator:a45d2f15072209b954e3c055bcacc2e4f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab141fc4506bb97d6574b58eeaf782378 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ab141fc4506bb97d6574b58eeaf782378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab141fc4506bb97d6574b58eeaf782378">prohibit</a> (unsigned x)</td></tr>
<tr class="memdesc:ab141fc4506bb97d6574b58eeaf782378 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <br /></td></tr>
<tr class="separator:ab141fc4506bb97d6574b58eeaf782378 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1142607bf87813a913b03189b922b00 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ae1142607bf87813a913b03189b922b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae1142607bf87813a913b03189b922b00">access</a> (unsigned x) const</td></tr>
<tr class="memdesc:ae1142607bf87813a913b03189b922b00 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <br /></td></tr>
<tr class="separator:ae1142607bf87813a913b03189b922b00 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bc359d2b544bf85a518f65f8f8a5be inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ab7bc359d2b544bf85a518f65f8f8a5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab7bc359d2b544bf85a518f65f8f8a5be">access</a> (unsigned x)</td></tr>
<tr class="memdesc:ab7bc359d2b544bf85a518f65f8f8a5be inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <br /></td></tr>
<tr class="separator:ab7bc359d2b544bf85a518f65f8f8a5be inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c36dc3dc76f1b7ae01af3e7bd73b85a inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a7c36dc3dc76f1b7ae01af3e7bd73b85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">substr</a> (const std::string &amp;x) const</td></tr>
<tr class="memdesc:a7c36dc3dc76f1b7ae01af3e7bd73b85a inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <br /></td></tr>
<tr class="separator:a7c36dc3dc76f1b7ae01af3e7bd73b85a inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee094304b7195f71401da1deb75a61c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a5ee094304b7195f71401da1deb75a61c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a5ee094304b7195f71401da1deb75a61c">substr</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:a5ee094304b7195f71401da1deb75a61c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <br /></td></tr>
<tr class="separator:a5ee094304b7195f71401da1deb75a61c inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70820e2d652356ea0b0c4224d2a4a235 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a70820e2d652356ea0b0c4224d2a4a235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a70820e2d652356ea0b0c4224d2a4a235">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a70820e2d652356ea0b0c4224d2a4a235 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <br /></td></tr>
<tr class="separator:a70820e2d652356ea0b0c4224d2a4a235 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbcda4aa2b527f0752ded21f7849ca inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aafcbcda4aa2b527f0752ded21f7849ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aafcbcda4aa2b527f0752ded21f7849ca">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:aafcbcda4aa2b527f0752ded21f7849ca inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <br /></td></tr>
<tr class="separator:aafcbcda4aa2b527f0752ded21f7849ca inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68049818a794cf43306236fdcc9a0499 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a68049818a794cf43306236fdcc9a0499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a68049818a794cf43306236fdcc9a0499">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:a68049818a794cf43306236fdcc9a0499 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <br /></td></tr>
<tr class="separator:a68049818a794cf43306236fdcc9a0499 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91afd9bf6d949f6cba433b36b2c21d21 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a91afd9bf6d949f6cba433b36b2c21d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a91afd9bf6d949f6cba433b36b2c21d21">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a91afd9bf6d949f6cba433b36b2c21d21 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <br /></td></tr>
<tr class="separator:a91afd9bf6d949f6cba433b36b2c21d21 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38bfd2f3963653a29b2c7488225f34b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ac38bfd2f3963653a29b2c7488225f34b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac38bfd2f3963653a29b2c7488225f34b">limit</a> (size_t x) const</td></tr>
<tr class="memdesc:ac38bfd2f3963653a29b2c7488225f34b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <br /></td></tr>
<tr class="separator:ac38bfd2f3963653a29b2c7488225f34b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71086ccca75dd0b7cfc677e276a8a2f3 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a71086ccca75dd0b7cfc677e276a8a2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a71086ccca75dd0b7cfc677e276a8a2f3">limit</a> (size_t x)</td></tr>
<tr class="memdesc:a71086ccca75dd0b7cfc677e276a8a2f3 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <br /></td></tr>
<tr class="separator:a71086ccca75dd0b7cfc677e276a8a2f3 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8c9ef37f66c1fd8b466eb9c31460d7 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a4b8c9ef37f66c1fd8b466eb9c31460d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a4b8c9ef37f66c1fd8b466eb9c31460d7">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a4b8c9ef37f66c1fd8b466eb9c31460d7 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:a4b8c9ef37f66c1fd8b466eb9c31460d7 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af638e01c5db346116fc31448c9d01671 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_af638e01c5db346116fc31448c9d01671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af638e01c5db346116fc31448c9d01671">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:af638e01c5db346116fc31448c9d01671 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:af638e01c5db346116fc31448c9d01671 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5a281e1542b9ce6fb5941f451bf129 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ade5a281e1542b9ce6fb5941f451bf129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ade5a281e1542b9ce6fb5941f451bf129">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:ade5a281e1542b9ce6fb5941f451bf129 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:ade5a281e1542b9ce6fb5941f451bf129 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5852715c72575f5e3d8e50006cc1930 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aa5852715c72575f5e3d8e50006cc1930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa5852715c72575f5e3d8e50006cc1930">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:aa5852715c72575f5e3d8e50006cc1930 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:aa5852715c72575f5e3d8e50006cc1930 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038b598dc4b28efc36d616e651021e3d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a038b598dc4b28efc36d616e651021e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a038b598dc4b28efc36d616e651021e3d">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:a038b598dc4b28efc36d616e651021e3d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a038b598dc4b28efc36d616e651021e3d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae15758d951ac9470757fbd4a854f26 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a6ae15758d951ac9470757fbd4a854f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a6ae15758d951ac9470757fbd4a854f26">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a6ae15758d951ac9470757fbd4a854f26 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a6ae15758d951ac9470757fbd4a854f26 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed07d5c39f1a69b76f0d9375e2f26bc9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aed07d5c39f1a69b76f0d9375e2f26bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aed07d5c39f1a69b76f0d9375e2f26bc9">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y) const</td></tr>
<tr class="memdesc:aed07d5c39f1a69b76f0d9375e2f26bc9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aed07d5c39f1a69b76f0d9375e2f26bc9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d09802303534be37bb2ab2b662c33f8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a6d09802303534be37bb2ab2b662c33f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a6d09802303534be37bb2ab2b662c33f8">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y)</td></tr>
<tr class="memdesc:a6d09802303534be37bb2ab2b662c33f8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a6d09802303534be37bb2ab2b662c33f8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec124932e7320a78baf6e2cc8c654aa2 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aec124932e7320a78baf6e2cc8c654aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aec124932e7320a78baf6e2cc8c654aa2">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> size) const</td></tr>
<tr class="memdesc:aec124932e7320a78baf6e2cc8c654aa2 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aec124932e7320a78baf6e2cc8c654aa2 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd476001bdac0f00e71a8363a2ae0c8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aefd476001bdac0f00e71a8363a2ae0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aefd476001bdac0f00e71a8363a2ae0c8">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> size)</td></tr>
<tr class="memdesc:aefd476001bdac0f00e71a8363a2ae0c8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aefd476001bdac0f00e71a8363a2ae0c8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0106cea41e48f180c5916e939384d49 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aa0106cea41e48f180c5916e939384d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa0106cea41e48f180c5916e939384d49">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:aa0106cea41e48f180c5916e939384d49 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:aa0106cea41e48f180c5916e939384d49 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8be355c7931c9b00c621247d0f8327 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_acc8be355c7931c9b00c621247d0f8327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#acc8be355c7931c9b00c621247d0f8327">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:acc8be355c7931c9b00c621247d0f8327 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:acc8be355c7931c9b00c621247d0f8327 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c10facd22691c9068519f5b06166aae inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a1c10facd22691c9068519f5b06166aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1c10facd22691c9068519f5b06166aae">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a1c10facd22691c9068519f5b06166aae inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:a1c10facd22691c9068519f5b06166aae inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbc8290efe3e296e0a4ef6dd0ade7d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_abedbc8290efe3e296e0a4ef6dd0ade7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abedbc8290efe3e296e0a4ef6dd0ade7d">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:abedbc8290efe3e296e0a4ef6dd0ade7d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:abedbc8290efe3e296e0a4ef6dd0ade7d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54070def208a6ef2bc441176a25e1d96 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a54070def208a6ef2bc441176a25e1d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a54070def208a6ef2bc441176a25e1d96">singleSegment</a> () const</td></tr>
<tr class="memdesc:a54070def208a6ef2bc441176a25e1d96 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <br /></td></tr>
<tr class="separator:a54070def208a6ef2bc441176a25e1d96 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410ae4d161493bfb1906b392c45bd601 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a410ae4d161493bfb1906b392c45bd601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a410ae4d161493bfb1906b392c45bd601">singleSegment</a> ()</td></tr>
<tr class="memdesc:a410ae4d161493bfb1906b392c45bd601 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <br /></td></tr>
<tr class="separator:a410ae4d161493bfb1906b392c45bd601 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af896378e5b63e968d0c44cfacfa0954b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_af896378e5b63e968d0c44cfacfa0954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af896378e5b63e968d0c44cfacfa0954b">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p) const</td></tr>
<tr class="memdesc:af896378e5b63e968d0c44cfacfa0954b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <br /></td></tr>
<tr class="separator:af896378e5b63e968d0c44cfacfa0954b inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb0089fa00ad1ea3c11a18051f01484 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_acfb0089fa00ad1ea3c11a18051f01484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#acfb0089fa00ad1ea3c11a18051f01484">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p)</td></tr>
<tr class="memdesc:acfb0089fa00ad1ea3c11a18051f01484 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <br /></td></tr>
<tr class="separator:acfb0089fa00ad1ea3c11a18051f01484 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a935200e06fbc09262a9f8452465a9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a13a935200e06fbc09262a9f8452465a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a13a935200e06fbc09262a9f8452465a9">any</a> () const</td></tr>
<tr class="memdesc:a13a935200e06fbc09262a9f8452465a9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <br /></td></tr>
<tr class="separator:a13a935200e06fbc09262a9f8452465a9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03d3746419b8e479b502965c60a7e9e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ac03d3746419b8e479b502965c60a7e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac03d3746419b8e479b502965c60a7e9e">any</a> ()</td></tr>
<tr class="memdesc:ac03d3746419b8e479b502965c60a7e9e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <br /></td></tr>
<tr class="separator:ac03d3746419b8e479b502965c60a7e9e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7630d1cfb2d77700010c13c25ea20120 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a7630d1cfb2d77700010c13c25ea20120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7630d1cfb2d77700010c13c25ea20120">none</a> () const</td></tr>
<tr class="memdesc:a7630d1cfb2d77700010c13c25ea20120 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <br /></td></tr>
<tr class="separator:a7630d1cfb2d77700010c13c25ea20120 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ae41df44c705df60531d0e2f869caa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a39ae41df44c705df60531d0e2f869caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a39ae41df44c705df60531d0e2f869caa">none</a> ()</td></tr>
<tr class="memdesc:a39ae41df44c705df60531d0e2f869caa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <br /></td></tr>
<tr class="separator:a39ae41df44c705df60531d0e2f869caa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800770e4dbdb91ad94db36031da25b33 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a800770e4dbdb91ad94db36031da25b33"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a800770e4dbdb91ad94db36031da25b33">segments</a> ()</td></tr>
<tr class="memdesc:a800770e4dbdb91ad94db36031da25b33 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:a800770e4dbdb91ad94db36031da25b33 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598081918a53e58769abf182468da05 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_af598081918a53e58769abf182468da05"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af598081918a53e58769abf182468da05">segments</a> () const</td></tr>
<tr class="memdesc:af598081918a53e58769abf182468da05 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:af598081918a53e58769abf182468da05 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ebcc9606d5be9a29130e491435345 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ad53ebcc9606d5be9a29130e491435345"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad53ebcc9606d5be9a29130e491435345">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ad53ebcc9606d5be9a29130e491435345 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments that overlap with constraints.  <br /></td></tr>
<tr class="separator:ad53ebcc9606d5be9a29130e491435345 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9832d3eeccc2daf7b01b3f84233ed inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a06e9832d3eeccc2daf7b01b3f84233ed"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a06e9832d3eeccc2daf7b01b3f84233ed">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a06e9832d3eeccc2daf7b01b3f84233ed inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:a06e9832d3eeccc2daf7b01b3f84233ed inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac607416127deca39cea3ba026eaa893e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ac607416127deca39cea3ba026eaa893e"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac607416127deca39cea3ba026eaa893e">nodes</a> ()</td></tr>
<tr class="memdesc:ac607416127deca39cea3ba026eaa893e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <br /></td></tr>
<tr class="separator:ac607416127deca39cea3ba026eaa893e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed0ae63ebdd27bb6894fe85e6fe66c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a7ed0ae63ebdd27bb6894fe85e6fe66c5"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7ed0ae63ebdd27bb6894fe85e6fe66c5">nodes</a> () const</td></tr>
<tr class="memdesc:a7ed0ae63ebdd27bb6894fe85e6fe66c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <br /></td></tr>
<tr class="separator:a7ed0ae63ebdd27bb6894fe85e6fe66c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad070947b7a9bb1d13b1040b0877ae9c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ad070947b7a9bb1d13b1040b0877ae9c5"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad070947b7a9bb1d13b1040b0877ae9c5">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ad070947b7a9bb1d13b1040b0877ae9c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <br /></td></tr>
<tr class="separator:ad070947b7a9bb1d13b1040b0877ae9c5 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c76e29df249359dbf6383ce592cb64d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a9c76e29df249359dbf6383ce592cb64d"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9c76e29df249359dbf6383ce592cb64d">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a9c76e29df249359dbf6383ce592cb64d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <br /></td></tr>
<tr class="separator:a9c76e29df249359dbf6383ce592cb64d inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11968c68b0efd523b24e371bff818613 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a11968c68b0efd523b24e371bff818613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a11968c68b0efd523b24e371bff818613">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a11968c68b0efd523b24e371bff818613 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <br /></td></tr>
<tr class="separator:a11968c68b0efd523b24e371bff818613 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164562fd38d476e8c0daf810075b399f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a164562fd38d476e8c0daf810075b399f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a164562fd38d476e8c0daf810075b399f">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a164562fd38d476e8c0daf810075b399f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <br /></td></tr>
<tr class="separator:a164562fd38d476e8c0daf810075b399f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895d3400de898b3dd49a7bb7074dcf0e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a895d3400de898b3dd49a7bb7074dcf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a895d3400de898b3dd49a7bb7074dcf0e">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a895d3400de898b3dd49a7bb7074dcf0e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a895d3400de898b3dd49a7bb7074dcf0e inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8b6e632d09737c2ca035640af3d565 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a0a8b6e632d09737c2ca035640af3d565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0a8b6e632d09737c2ca035640af3d565">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a0a8b6e632d09737c2ca035640af3d565 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a0a8b6e632d09737c2ca035640af3d565 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd627686043b35501fabb3b89e867a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a9bd627686043b35501fabb3b89e867a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9bd627686043b35501fabb3b89e867a8">traverse</a> (Visitor &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a9bd627686043b35501fabb3b89e867a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a9bd627686043b35501fabb3b89e867a8 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c7d3e990027e75a9dbe45e10841ac inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a7b9c7d3e990027e75a9dbe45e10841ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7b9c7d3e990027e75a9dbe45e10841ac">traverse</a> (Visitor &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a7b9c7d3e990027e75a9dbe45e10841ac inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a7b9c7d3e990027e75a9dbe45e10841ac inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533c4cf1642ffb3a2e0e256c11508fa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a3533c4cf1642ffb3a2e0e256c11508fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3533c4cf1642ffb3a2e0e256c11508fa">read</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a3533c4cf1642ffb3a2e0e256c11508fa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <br /></td></tr>
<tr class="separator:a3533c4cf1642ffb3a2e0e256c11508fa inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b80d240df8d1ba24f7b4712c5f30f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_aed5b80d240df8d1ba24f7b4712c5f30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aed5b80d240df8d1ba24f7b4712c5f30f">read</a> (std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:aed5b80d240df8d1ba24f7b4712c5f30f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <br /></td></tr>
<tr class="separator:aed5b80d240df8d1ba24f7b4712c5f30f inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e7147002d95c6ae762062e8e0552b9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_ac9e7147002d95c6ae762062e8e0552b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac9e7147002d95c6ae762062e8e0552b9">write</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ac9e7147002d95c6ae762062e8e0552b9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <br /></td></tr>
<tr class="separator:ac9e7147002d95c6ae762062e8e0552b9 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9b85c7265696674312150e69d57999 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap" id="r_a1a9b85c7265696674312150e69d57999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1a9b85c7265696674312150e69d57999">write</a> (const std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a1a9b85c7265696674312150e69d57999 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <br /></td></tr>
<tr class="separator:a1a9b85c7265696674312150e69d57999 inherit pub_methods_classSawyer_1_1Container_1_1AddressMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0c5f60fb7032334c08cf77fa731aeb26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">IntervalMap</a> ()</td></tr>
<tr class="memdesc:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a5eec51514347acfef76b9b4a65654bcc"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">IntervalMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af681700b55257f5ccb0078c6bca9dbfa"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af681700b55257f5ccb0078c6bca9dbfa">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa43368dbaee5e1dc47efab1b5b6ce9c1"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa43368dbaee5e1dc47efab1b5b6ce9c1">intervals</a> () const</td></tr>
<tr class="memdesc:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing keys.  <br /></td></tr>
<tr class="separator:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a25feb127b25f2d5f7616003a010abdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">firstUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> minAddr) const</td></tr>
<tr class="memdesc:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first unmapped region.  <br /></td></tr>
<tr class="separator:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">lastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> maxAddr) const</td></tr>
<tr class="memdesc:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last unmapped region.  <br /></td></tr>
<tr class="separator:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a8da2cba60c620a2c9d4e60f57fe7a530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">exists</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if element exists.  <br /></td></tr>
<tr class="separator:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad069dd4df1f86cb36ca5abd79d670f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad069dd4df1f86cb36ca5abd79d670f6e">getOptional</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <br /></td></tr>
<tr class="separator:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad85884652be5225f99a9492e83252b75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad85884652be5225f99a9492e83252b75">getOrDefault</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <br /></td></tr>
<tr class="separator:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acb61e91bac6aa82b6a5193726799bdf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">isEmpty</a> () const</td></tr>
<tr class="memdesc:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is empty.  <br /></td></tr>
<tr class="separator:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a017216edaa9c3064857c75fc63c07217"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">nIntervals</a> () const</td></tr>
<tr class="memdesc:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the container.  <br /></td></tr>
<tr class="separator:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adbf9f66a08580ead37de8f0dd96d575e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a> () const</td></tr>
<tr class="memdesc:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this container.  <br /></td></tr>
<tr class="separator:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6e7d3909845b1efa5c5849f60faa3192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192">least</a> () const</td></tr>
<tr class="memdesc:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum scalar key.  <br /></td></tr>
<tr class="separator:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a385bbee53b2f1ba14ad34af9211f067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d">greatest</a> () const</td></tr>
<tr class="memdesc:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum scalar key.  <br /></td></tr>
<tr class="separator:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a455ed64c13c1284608dfab1f6fa09ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a455ed64c13c1284608dfab1f6fa09ace">least</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum scalar key.  <br /></td></tr>
<tr class="separator:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a63bc9c438221e753ed9a1539b5b14002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a63bc9c438221e753ed9a1539b5b14002">greatest</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum scalar key.  <br /></td></tr>
<tr class="separator:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af87b09a062b8dd2e7fe64051184fba96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af87b09a062b8dd2e7fe64051184fba96">leastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum unmapped scalar key.  <br /></td></tr>
<tr class="separator:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac1dafe332cf7e4e2bc8da2b9993e8f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac1dafe332cf7e4e2bc8da2b9993e8f9c">greatestUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum unmapped scalar key.  <br /></td></tr>
<tr class="separator:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4734abf74cda51aa6252ecfc38342e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> () const</td></tr>
<tr class="memdesc:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map.  <br /></td></tr>
<tr class="separator:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2fd736a589e045f795c917a9d16c33d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2fd736a589e045f795c917a9d16c33d2">clear</a> ()</td></tr>
<tr class="memdesc:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the container.  <br /></td></tr>
<tr class="separator:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;erasure)</td></tr>
<tr class="memdesc:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified interval.  <br /></td></tr>
<tr class="separator:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3e96516680b59244ef196a9e885ac0ca"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">eraseMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase intervals specified in another <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non-overlapping intervals.">IntervalMap</a>.  <br /></td></tr>
<tr class="separator:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1effdf10ccfb80ed11cc999e850ab2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">insert</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> value, bool makeHole=true)</td></tr>
<tr class="memdesc:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair.  <br /></td></tr>
<tr class="separator:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af596a5898489cd4c86320bd5a1aa4307"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">insertMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, bool makeHole=true)</td></tr>
<tr class="memdesc:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert values from another container.  <br /></td></tr>
<tr class="separator:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a775489990d1f4afaba7b7ee94e2e7f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a775489990d1f4afaba7b7ee94e2e7f1d">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a11a77bbaa8abcabd5f21e3fafd19dafd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a11a77bbaa8abcabd5f21e3fafd19dafd">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2e50f959ecc418c31ccf2fa8a465df80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2e50f959ecc418c31ccf2fa8a465df80">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aedc79f844559a4d50a71073d40f3c495"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aedc79f844559a4d50a71073d40f3c495">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a28ed971cc7c018a24e1bad32b6a3cd3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a28ed971cc7c018a24e1bad32b6a3cd3d">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac040de688b66d2fd0f96e9e8da36ccb3">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a968496e5f3ddf732369084e3b9405fb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a968496e5f3ddf732369084e3b9405fb6">contains</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key) const</td></tr>
<tr class="separator:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a12776c478c6a1448865aa083fac5a2a4"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a12776c478c6a1448865aa083fac5a2a4">contains</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6819a75d74d259b0862b7b48705fcf5a"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6819a75d74d259b0862b7b48705fcf5a">nodes</a> ()</td></tr>
<tr class="memdesc:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3f1a21b012e0404f2d12167b5444e1ed"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3f1a21b012e0404f2d12167b5444e1ed">nodes</a> () const</td></tr>
<tr class="memdesc:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a70b9c01a8212eba072916db1d746cc9f"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> ()</td></tr>
<tr class="memdesc:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf80f4f896443d489431178d0121b754"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf80f4f896443d489431178d0121b754">values</a> () const</td></tr>
<tr class="memdesc:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a87170e7d06eb8710211a65fb9bc052c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4cdf5d3be3c2b27013876e65f69acd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a56a00171503e761f08e789d07692187e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1f52b31510a0edd7a3a6b99848d66df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad47a0cae47f4423000356e8a46b5ae33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad47a0cae47f4423000356e8a46b5ae33">operator[]</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a128f75d742f421056d4497519b1cbc5a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a128f75d742f421056d4497519b1cbc5a">get</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afd397b582b605adcab6cce46894b7bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afd397b582b605adcab6cce46894b7bc9">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0612b2970067bf6e0c858dfcb9c937a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0612b2970067bf6e0c858dfcb9c937a2">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aad53242671f18d795f3b040bdd0d7e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab59f19099179c53ab74984bf74855aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6675861f9feb70004fe397d1600d466f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa4e9edf0de829a794a10703c21228de0"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa4e9edf0de829a794a10703c21228de0">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adfc6016e9440f8dee3e7f37f4dd65aa7"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adfc6016e9440f8dee3e7f37f4dd65aa7">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab5a821909b63dedab54193fbd4a747c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a48ef3aaccd8a7cb97c33359be83ca883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a7395c06804302359b2243a6016644e25"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7395c06804302359b2243a6016644e25">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">IntervalMap::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac217c94739290a0c52debdac53020634"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac217c94739290a0c52debdac53020634">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">IntervalMap::ConstNodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter) const</td></tr>
<tr class="memdesc:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3710d6445b86359fc16236d2bb54a8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afa299225e9e0576bc9944dde4b29d569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a747ae7350949b0c59e9d40db1c62286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a788dc3ca323dee1fc811bc55645ecdf8" id="r_a788dc3ca323dee1fc811bc55645ecdf8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a788dc3ca323dee1fc811bc55645ecdf8">instance</a> ()</td></tr>
<tr class="memdesc:a788dc3ca323dee1fc811bc55645ecdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty memory map.  <br /></td></tr>
<tr class="separator:a788dc3ca323dee1fc811bc55645ecdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea6be0b0e2219c63994982b111ea995" id="r_adea6be0b0e2219c63994982b111ea995"><td class="memItemLeft" align="right" valign="top"><a id="adea6be0b0e2219c63994982b111ea995" name="adea6be0b0e2219c63994982b111ea995"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>insertFileDocumentation</b> ()</td></tr>
<tr class="memdesc:adea6be0b0e2219c63994982b111ea995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation string for <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a4fa0df1ec6d8b31a7b82d24aedbe8be4">insertFile</a>. <br /></td></tr>
<tr class="separator:adea6be0b0e2219c63994982b111ea995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad8173f1cb1e668cac5dadcdac2ed7" id="r_a32ad8173f1cb1e668cac5dadcdac2ed7"><td class="memItemLeft" align="right" valign="top"><a id="a32ad8173f1cb1e668cac5dadcdac2ed7" name="a32ad8173f1cb1e668cac5dadcdac2ed7"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>insertDataDocumentation</b> ()</td></tr>
<tr class="memdesc:a32ad8173f1cb1e668cac5dadcdac2ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation string for <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a02f88ba78df49ac09e2734db004e2df3">insertData</a>. <br /></td></tr>
<tr class="separator:a32ad8173f1cb1e668cac5dadcdac2ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee64eefc350cee665d4f8d5f1dbabeb" id="r_a3ee64eefc350cee665d4f8d5f1dbabeb"><td class="memItemLeft" align="right" valign="top"><a id="a3ee64eefc350cee665d4f8d5f1dbabeb" name="a3ee64eefc350cee665d4f8d5f1dbabeb"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>adjustMapDocumentation</b> ()</td></tr>
<tr class="memdesc:a3ee64eefc350cee665d4f8d5f1dbabeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation string for <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af35043ddbd26847f4271d0bd38af6e18">adjustMap</a>. <br /></td></tr>
<tr class="separator:a3ee64eefc350cee665d4f8d5f1dbabeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f37b9ddd0dcf81a6d0216793c89102" id="r_a25f37b9ddd0dcf81a6d0216793c89102"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1ProcessMapRecord.html">ProcessMapRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a25f37b9ddd0dcf81a6d0216793c89102">readProcessMap</a> (pid_t)</td></tr>
<tr class="memdesc:a25f37b9ddd0dcf81a6d0216793c89102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the memory map information for a process.  <br /></td></tr>
<tr class="separator:a25f37b9ddd0dcf81a6d0216793c89102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae450753de325b1d2809ff8fab4a8e14c" id="r_ae450753de325b1d2809ff8fab4a8e14c"><td class="memItemLeft" align="right" valign="top"><a id="ae450753de325b1d2809ff8fab4a8e14c" name="ae450753de325b1d2809ff8fab4a8e14c"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>insertProcessDocumentation</b> ()</td></tr>
<tr class="memdesc:ae450753de325b1d2809ff8fab4a8e14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation string for <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aad677c86ba0e10b313e3a5b36f8a5217">insertProcess</a>. <br /></td></tr>
<tr class="separator:ae450753de325b1d2809ff8fab4a8e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2f4f05bc65fa7cffe8c10b6e0f1a2d" id="r_aae2f4f05bc65fa7cffe8c10b6e0f1a2d"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1Buffer.html#a51d7578c5e6fb3d634ad1299c8754857">Buffer::Ptr</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#aae2f4f05bc65fa7cffe8c10b6e0f1a2d">copyFromFile</a> (int fd, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:aae2f4f05bc65fa7cffe8c10b6e0f1a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy part of a file into a buffer.  <br /></td></tr>
<tr class="separator:aae2f4f05bc65fa7cffe8c10b6e0f1a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8ecadbcaec5869951b39e0bd2f070b" id="r_a1d8ecadbcaec5869951b39e0bd2f070b"><td class="memItemLeft" align="right" valign="top"><a id="a1d8ecadbcaec5869951b39e0bd2f070b" name="a1d8ecadbcaec5869951b39e0bd2f070b"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>segmentTitle</b> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a> &amp;)</td></tr>
<tr class="memdesc:a1d8ecadbcaec5869951b39e0bd2f070b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Title of a segment when printing the map. <br /></td></tr>
<tr class="separator:a1d8ecadbcaec5869951b39e0bd2f070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2ae4f73131a2d77738a17708a7c1d262"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2ae4f73131a2d77738a17708a7c1d262">findPriorImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf352fa4dd63a2476519d74738f026d8"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf352fa4dd63a2476519d74738f026d8">findImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a916678d0f4bd8caf5cc70a3f2de287d6"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static boost::iterator_range&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a916678d0f4bd8caf5cc70a3f2de287d6">findAllImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a55c31fa3f4ef0c963492c305154aafa3"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a55c31fa3f4ef0c963492c305154aafa3">findFirstOverlapImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a83fd6db343d27ec8461ea48b9440c2a5"><td class="memTemplParams" colspan="2">template&lt;class IMap , typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a83fd6db343d27ec8461ea48b9440c2a5">findFirstOverlapImpl</a> (IMap &amp;imap, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ae69e9931f89e2b57d7eccff30bddc3a1"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae69e9931f89e2b57d7eccff30bddc3a1">firstFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> start)</td></tr>
<tr class="memdesc:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a33a10236237378a3f6e62f501c96fd2d"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a33a10236237378a3f6e62f501c96fd2d">bestFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> start)</td></tr>
<tr class="memdesc:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7ae107e935935b9301a7160a84365136" id="r_a7ae107e935935b9301a7160a84365136"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a7ae107e935935b9301a7160a84365136">NO_ACCESS</a> = 0</td></tr>
<tr class="separator:a7ae107e935935b9301a7160a84365136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570a7e2d272757f35810c79dbf9bb3" id="r_a61570a7e2d272757f35810c79dbf9bb3"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a61570a7e2d272757f35810c79dbf9bb3">READABLE</a> = Sawyer::Access::READABLE</td></tr>
<tr class="separator:a61570a7e2d272757f35810c79dbf9bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993703ff3cb175924154b63ff760fe93" id="r_a993703ff3cb175924154b63ff760fe93"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a993703ff3cb175924154b63ff760fe93">WRITABLE</a> = Sawyer::Access::WRITABLE</td></tr>
<tr class="separator:a993703ff3cb175924154b63ff760fe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd5565fdc27aee9acabc448dc523071" id="r_a7dd5565fdc27aee9acabc448dc523071"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a7dd5565fdc27aee9acabc448dc523071">EXECUTABLE</a> = Sawyer::Access::EXECUTABLE</td></tr>
<tr class="separator:a7dd5565fdc27aee9acabc448dc523071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aac2de2d6fef665d98440070cdf1c9" id="r_a96aac2de2d6fef665d98440070cdf1c9"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a96aac2de2d6fef665d98440070cdf1c9">IMMUTABLE</a> = Sawyer::Access::IMMUTABLE</td></tr>
<tr class="separator:a96aac2de2d6fef665d98440070cdf1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e48e113d0149deda4499ba2c3ec811" id="r_ac8e48e113d0149deda4499ba2c3ec811"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ac8e48e113d0149deda4499ba2c3ec811">PRIVATE</a> = Sawyer::Access::PRIVATE</td></tr>
<tr class="separator:ac8e48e113d0149deda4499ba2c3ec811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc82dfbf249d14e70f5bb7d5c352922a" id="r_afc82dfbf249d14e70f5bb7d5c352922a"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#afc82dfbf249d14e70f5bb7d5c352922a">INITIALIZED</a> = 0x00000200</td></tr>
<tr class="separator:afc82dfbf249d14e70f5bb7d5c352922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c0b10dc413c3295da85d4a92b1acc9" id="r_ac4c0b10dc413c3295da85d4a92b1acc9"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ac4c0b10dc413c3295da85d4a92b1acc9">READ_WRITE</a> = READABLE | WRITABLE</td></tr>
<tr class="separator:ac4c0b10dc413c3295da85d4a92b1acc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9088f93cf173ce7a67f24520620da8c8" id="r_a9088f93cf173ce7a67f24520620da8c8"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a9088f93cf173ce7a67f24520620da8c8">READ_EXECUTE</a> = READABLE | EXECUTABLE</td></tr>
<tr class="separator:a9088f93cf173ce7a67f24520620da8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f187a060a187da2ff369373259a6e2" id="r_ac5f187a060a187da2ff369373259a6e2"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ac5f187a060a187da2ff369373259a6e2">READ_WRITE_EXECUTE</a> = READABLE | WRITABLE | EXECUTABLE</td></tr>
<tr class="separator:ac5f187a060a187da2ff369373259a6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e58ab297bbc5e3ac9d3d357ba91aa0" id="r_a34e58ab297bbc5e3ac9d3d357ba91aa0"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a34e58ab297bbc5e3ac9d3d357ba91aa0">RESERVED_ACCESS_BITS</a> = 0x0000ffff</td></tr>
<tr class="separator:a34e58ab297bbc5e3ac9d3d357ba91aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abed234f45d45c76b39e1d2953ee7193e" id="r_abed234f45d45c76b39e1d2953ee7193e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#abed234f45d45c76b39e1d2953ee7193e">MemoryMap</a> ()</td></tr>
<tr class="memdesc:abed234f45d45c76b39e1d2953ee7193e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty memory map.  <br /></td></tr>
<tr class="separator:abed234f45d45c76b39e1d2953ee7193e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0dbb47f6fe164ce6ef8816f28dc93a1f" name="a0dbb47f6fe164ce6ef8816f28dc93a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbb47f6fe164ce6ef8816f28dc93a1f">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00118">118</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a7f665704a05e1328ab2b67b4bb5612d1" name="a7f665704a05e1328ab2b67b4bb5612d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f665704a05e1328ab2b67b4bb5612d1">&#9670;&#160;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef rose_addr_t Rose::BinaryAnalysis::MemoryMap::Address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00120">120</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a05384f3d6f268eb1407b5b3d01f9ddfe" name="a05384f3d6f268eb1407b5b3d01f9ddfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05384f3d6f268eb1407b5b3d01f9ddfe">&#9670;&#160;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t Rose::BinaryAnalysis::MemoryMap::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00121">121</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a538f22af92cd81f32268a159f0ad7e34" name="a538f22af92cd81f32268a159f0ad7e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538f22af92cd81f32268a159f0ad7e34">&#9670;&#160;</a></span>Super</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Rose::BinaryAnalysis::MemoryMap::Super</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00122">122</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a759d23c83a629a9ecdc3eec2489673b1" name="a759d23c83a629a9ecdc3eec2489673b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d23c83a629a9ecdc3eec2489673b1">&#9670;&#160;</a></span>Buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Rose::BinaryAnalysis::MemoryMap::Buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00123">123</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a6b1f64d5c4d18d7372d9fd350bdb5f95" name="a6b1f64d5c4d18d7372d9fd350bdb5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1f64d5c4d18d7372d9fd350bdb5f95">&#9670;&#160;</a></span>AllocatingBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1AllocatingBuffer.html">Sawyer::Container::AllocatingBuffer</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1AllocatingBuffer.html">Rose::BinaryAnalysis::MemoryMap::AllocatingBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00124">124</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="aa3b087a99a3ce49d8f326c1683d279b7" name="aa3b087a99a3ce49d8f326c1683d279b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b087a99a3ce49d8f326c1683d279b7">&#9670;&#160;</a></span>MappedBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">Sawyer::Container::MappedBuffer</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">Rose::BinaryAnalysis::MemoryMap::MappedBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00125">125</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="ab1cbd7c4a04f0aa30d0925c2415353c3" name="ab1cbd7c4a04f0aa30d0925c2415353c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cbd7c4a04f0aa30d0925c2415353c3">&#9670;&#160;</a></span>NullBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1NullBuffer.html">Sawyer::Container::NullBuffer</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1NullBuffer.html">Rose::BinaryAnalysis::MemoryMap::NullBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00126">126</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a5a74b38bbe8d2144b76dee36961486c9" name="a5a74b38bbe8d2144b76dee36961486c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a74b38bbe8d2144b76dee36961486c9">&#9670;&#160;</a></span>StaticBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1StaticBuffer.html">Sawyer::Container::StaticBuffer</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1StaticBuffer.html">Rose::BinaryAnalysis::MemoryMap::StaticBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00127">127</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="af35dd604ea5d50d05d4bf968fb021d9d" name="af35dd604ea5d50d05d4bf968fb021d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35dd604ea5d50d05d4bf968fb021d9d">&#9670;&#160;</a></span>SegmentPredicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">Sawyer::Container::SegmentPredicate</a>&lt;Address, Value&gt; <a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">Rose::BinaryAnalysis::MemoryMap::SegmentPredicate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00128">128</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a1900db9b5623173c4fae7410f2af9e40" name="a1900db9b5623173c4fae7410f2af9e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1900db9b5623173c4fae7410f2af9e40">&#9670;&#160;</a></span>Constraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Sawyer::Container::AddressMapConstraints</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt;rose_addr_t, uint8_t&gt; &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Rose::BinaryAnalysis::MemoryMap::Constraints</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00129">129</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a9aa3903f1e3e1bc921f7e080862dfe52" name="a9aa3903f1e3e1bc921f7e080862dfe52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa3903f1e3e1bc921f7e080862dfe52">&#9670;&#160;</a></span>ConstConstraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Sawyer::Container::AddressMapConstraints</a>&lt;const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt;rose_addr_t, uint8_t&gt; &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">Rose::BinaryAnalysis::MemoryMap::ConstConstraints</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00130">130</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af9bc4cf22ea8728c97c452f3c0ae4151" name="af9bc4cf22ea8728c97c452f3c0ae4151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bc4cf22ea8728c97c452f3c0ae4151">&#9670;&#160;</a></span>Clobber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Rose::BinaryAnalysis::MemoryMap::Clobber</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite (parts of) existing segments? </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00141">141</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a87d621d26efc9f3fd4a506633fb300f8" name="a87d621d26efc9f3fd4a506633fb300f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d621d26efc9f3fd4a506633fb300f8">&#9670;&#160;</a></span>InsertFileMapMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8">Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping mode for insertFile. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a87d621d26efc9f3fd4a506633fb300f8a30c3ab6e206e47fbd0c1b545a0828d4a" name="a87d621d26efc9f3fd4a506633fb300f8a30c3ab6e206e47fbd0c1b545a0828d4a"></a>MAP_PRIVATE&#160;</td><td class="fielddoc"><p>File is mapped privately. </p>
<p>Writing to the memory map is allowed, but the changes will not show up in the file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87d621d26efc9f3fd4a506633fb300f8a7d1630e6c92a57579111fcfb164e0090" name="a87d621d26efc9f3fd4a506633fb300f8a7d1630e6c92a57579111fcfb164e0090"></a>MAP_READWRITE&#160;</td><td class="fielddoc"><p>File is mapped with read and write permission. </p>
<p>Changes to the memory map will also cause the file to change. </p>
</td></tr>
<tr><td class="fieldname"><a id="a87d621d26efc9f3fd4a506633fb300f8a99249a98054c92d479e3251701b1bf64" name="a87d621d26efc9f3fd4a506633fb300f8a99249a98054c92d479e3251701b1bf64"></a>MAP_RDONLY&#160;</td><td class="fielddoc"><p>File is mapped with read-only permission. </p>
<p>Any attempt to modify the file will likely result in a segmentation fault. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00303">303</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abed234f45d45c76b39e1d2953ee7193e" name="abed234f45d45c76b39e1d2953ee7193e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed234f45d45c76b39e1d2953ee7193e">&#9670;&#160;</a></span>MemoryMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::MemoryMap::MemoryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty memory map. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00263">263</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryMap_8h_source.html#l00274">shallowCopy()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a788dc3ca323dee1fc811bc55645ecdf8" name="a788dc3ca323dee1fc811bc55645ecdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788dc3ca323dee1fc811bc55645ecdf8">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Ptr</a> Rose::BinaryAnalysis::MemoryMap::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty memory map. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00267">267</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="aa0c0e42f15d273c92e12dffa49256a48" name="aa0c0e42f15d273c92e12dffa49256a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c0e42f15d273c92e12dffa49256a48">&#9670;&#160;</a></span>shallowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Ptr</a> Rose::BinaryAnalysis::MemoryMap::shallowCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new copy of the memory map. </p>
<p>The copy maintains its own independent list of segments, but points to the same data buffers as the source map. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00274">274</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="MemoryMap_8h_source.html#l00263">MemoryMap()</a>.</p>

</div>
</div>
<a id="a0f5814ca1011d24c50831db25b6a1faf" name="a0f5814ca1011d24c50831db25b6a1faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5814ca1011d24c50831db25b6a1faf">&#9670;&#160;</a></span>byteOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> Rose::BinaryAnalysis::MemoryMap::byteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Byte order. </p>
<p>Every map has a default byte order property which can be used by functions that read and write multi-byte values when the user does not provide a byte order to those functions. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> constructors initialize this property to <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58a8459548c6f70379963bc23ac28ae09af" title="Endianness is unspecified and unknown.">ByteOrder::ORDER_UNSPECIFIED</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00285">285</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="ad6cca00a43c93a6e47e1cf758c6a40a4" name="ad6cca00a43c93a6e47e1cf758c6a40a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cca00a43c93a6e47e1cf758c6a40a4">&#9670;&#160;</a></span>byteOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::byteOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Byte order. </p>
<p>Every map has a default byte order property which can be used by functions that read and write multi-byte values when the user does not provide a byte order to those functions. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> constructors initialize this property to <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58a8459548c6f70379963bc23ac28ae09af" title="Endianness is unspecified and unknown.">ByteOrder::ORDER_UNSPECIFIED</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00286">286</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a9ea59ab4c870a51afdf55a34a20b1f0a" name="a9ea59ab4c870a51afdf55a34a20b1f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea59ab4c870a51afdf55a34a20b1f0a">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::MemoryMap::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name. </p>
<p>Optional name of the map, mostly used for debugging. </p>

</div>
</div>
<a id="a80e60affc757e34e56e93672ee5795eb" name="a80e60affc757e34e56e93672ee5795eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e60affc757e34e56e93672ee5795eb">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name. </p>
<p>Optional name of the map, mostly used for debugging. </p>

</div>
</div>
<a id="a4fa0df1ec6d8b31a7b82d24aedbe8be4" name="a4fa0df1ec6d8b31a7b82d24aedbe8be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa0df1ec6d8b31a7b82d24aedbe8be4">&#9670;&#160;</a></span>insertFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::MemoryMap::insertFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8">InsertFileMapMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a87d621d26efc9f3fd4a506633fb300f8a30c3ab6e206e47fbd0c1b545a0828d4a">MAP_PRIVATE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>segmentName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert file contents into memory map. </p>
<p>Insert the contents of a file into the memory map at the specified address. This is just a convenience wrapper that creates a new MappedBuffer and inserts it into the mapping. Returns the size of the file mapping. </p>

</div>
</div>
<a id="ae810726284ca11827e317530f5ac4722" name="ae810726284ca11827e317530f5ac4722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae810726284ca11827e317530f5ac4722">&#9670;&#160;</a></span>insertFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::MemoryMap::insertFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locatorString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert file contents into memory map. </p>
<p>Uses a locator string to load a file into a memory map.</p>
<p>Returns the address interval that was inserted into this memory map, or throws an <code>std::runtime_error</code> for syntax errors and problems reading the file.</p>
<h1><a class="anchor" id="syntax"></a>
Locator Syntax</h1>
<p>The locator string is a file name preceded by various other parameters to control where the file is loaded in memory. It takes the form:</p>
<pre class="fragment">*  :[ADDR][+VMSIZE][=PERM]:[OFFSET[+FSIZE]]:FILENAME
* </pre><p>The fields between the first and second colon are parameters for virtual memory; the fields between the second and third colon are parameters for the file. Their meanings are:</p>
<ul>
<li><code>ADDR:</code> The virtual address where the first byte of the file is mapped. This can be specified in decimal, octal, or hexadecimal using the usual C syntax. If no address is specified then the file is mapped at the lowest unmapped region which is large enough to hold the file.</li>
</ul>
<ul>
<li><code>VMSIZE:</code> Size of virtual memory to map. If VMSIZE is not specified then it is either the FSIZE (if specified) or the file size. On POSIX systems the file size is that which is reported by <code>stat</code>, and on other systems it is the number of bytes that can be read from the file. The size can be specified as decimal, octal, or hexadecimal with the usual C syntax. If VMSIZE is greater than the specified or calculated FSIZE then the data from the file is padded with zero bytes.</li>
</ul>
<ul>
<li><code>PERM:</code> Accessibility for the mapped segment. If present, it should be any of the letters "r", "w", and/or "x" in that order to indicate readable, writable, and/or executable. If not present, the accessibility of the segment is the same as the user's accessibility of the file (on POSIX systems; "rwx" on Windows systems).</li>
</ul>
<ul>
<li><code>OFFSET:</code> Byte offset within file for first byte to map. If no offset is specified then zero is assumed. The size can be decimal, octal, or hexadecimal in the usual C sytax.</li>
</ul>
<ul>
<li><code>FSIZE:</code> Number of file bytes to map. If not specified the entire readable content of the file is mapped beginning at the specified OFFSET but not exceeding a specified VMSIZE. If this number of bytes cannot be read from the file then an error is thrown.</li>
</ul>
<ul>
<li><code>FILENAME:</code> Name of file to read. The file must be readable by the user and its contents are copied into the memory map. Once inside the memory map, the segment can be given any accessibility according to PERM. The name of the segment will be the non-directory part of the FILENAME (e.g., on POSIX systems, the part after the final slash).</li>
</ul>
<h1><a class="anchor" id="exampes"></a>
Examples</h1>
<p>To load a couple raw files at the lowest available addresses:</p>
<div class="fragment"><div class="line">:::myfile1.bin :::myfile2.bin</div>
</div><!-- fragment --><p>To load a 4k page of zeros with read and execute permission at address 0x7ffff000 (won't work on Microsoft systems):</p>
<div class="fragment"><div class="line"> :0x7ffff000+0x1000=rx::/dev/zero</div>
<div class="line">@code</div>
<div class="line"> </div>
<div class="line"> On Microsoft Windows one could create a large file containing zeros:</div>
<div class="line"> </div>
<div class="line">@code</div>
<div class="line"> :0x7ffff000+0x1000=rx::myzeros.dat</div>
</div><!-- fragment --><p>To load the .text and .data segments from a PE file when we know where they occur in the PE file but the PE file is damaged to the point where it cannot be loaded by ROSE's <code>frontend</code>. Both sections are zero-padded since the memory segment size is larger than the file size. But if one wants to more closely emulate the Windows loader, leave off the file sizes:</p>
<div class="fragment"><div class="line">:0x01000400+0xa00=rx:0x1000+0x9a8:proxycfg.exe</div>
<div class="line">:0x01000e00+0x200=rw:0x3000+8:proxycfg.exe</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#adea6be0b0e2219c63994982b111ea995" title="Documentation string for insertFile.">insertFileDocumentation</a> </dd></dl>

</div>
</div>
<a id="a02f88ba78df49ac09e2734db004e2df3" name="a02f88ba78df49ac09e2734db004e2df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f88ba78df49ac09e2734db004e2df3">&#9670;&#160;</a></span>insertData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::MemoryMap::insertData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locatorString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into a memory map. </p>
<p>This is intended for insert small pieces of data parsed from the locator string. The locator string has the form:</p>
<pre class="fragment">*  :[ADDR][+VMSIZE][=PERM]::DATA
* </pre><p>The fields between the first and second colon are parameters for virtual memory; the fields between the second and third colon are parameters for the data (none currently defined). Their meanings are:</p>
<ul>
<li><code>ADDR:</code> The virtual address where the first byte of data is mapped. This can be specified in decimal, octal, or hexadecimal using the usual C syntax. If no address is specified then the data is mapped at the lowest unmapped region which is large enough to hold it.</li>
</ul>
<ul>
<li><code>VMSIZE:</code> Size in bytes of the virtual memory to map. If VMSIZE is not specified then it is the same as the number of bytes of DATA. If VMSIZE is smaller than DATA then the DATA will be truncated; if VMSIZE is larger than DATA then DATA is zero-padded. If the resulting memory are size is zero then no change is made to the memory map.</li>
</ul>
<ul>
<li><code>PERM:</code> Accessibility for the mapped segment. If present, it should be any of the letters "r", "w", and/or "x" in that order to indicate readable, writable, and/or executable. If not present, then the new memory is readable, writable, and executable.</li>
</ul>
<ul>
<li><code>DATA:</code> The byte values in ascending address order. The values should be separated from one another by white space and all values must be in the range 0 through 255, inclusive. Values can be specified in hexadecimal (leading "0x"), binary (leading "0b"), octal (leading "0"), or decimal. </li>
</ul>

</div>
</div>
<a id="af35043ddbd26847f4271d0bd38af6e18" name="af35043ddbd26847f4271d0bd38af6e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35043ddbd26847f4271d0bd38af6e18">&#9670;&#160;</a></span>adjustMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::adjustMap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locatorString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts a memory map according to the locator string. </p>
<p>See &ndash;help output from tools that support this feature, or look at the implementation of <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a3ee64eefc350cee665d4f8d5f1dbabeb">adjustMapDocumentation</a> for details about the syntax of the <code>locatorString</code>. </p>

</div>
</div>
<a id="a25f37b9ddd0dcf81a6d0216793c89102" name="a25f37b9ddd0dcf81a6d0216793c89102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f37b9ddd0dcf81a6d0216793c89102">&#9670;&#160;</a></span>readProcessMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1ProcessMapRecord.html">ProcessMapRecord</a> &gt; Rose::BinaryAnalysis::MemoryMap::readProcessMap </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the memory map information for a process. </p>
<p>Returns an empty vector if there was an error parsing the process information. </p>

</div>
</div>
<a id="aaaf90935bc209a9c36e9473be70c9d38" name="aaaf90935bc209a9c36e9473be70c9d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf90935bc209a9c36e9473be70c9d38">&#9670;&#160;</a></span>insertProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::insertProcess </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locatorString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the memory of some other process into this memory map. </p>
<p>The locator string follows the syntax described in <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ae450753de325b1d2809ff8fab4a8e14c">insertProcessDocumentation</a>. </p>

</div>
</div>
<a id="aaba3ba3e4f0897bf5912fd36b20fecd9" name="aaba3ba3e4f0897bf5912fd36b20fecd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba3ba3e4f0897bf5912fd36b20fecd9">&#9670;&#160;</a></span>linkTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::MemoryMap::linkTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Clobber</a>&#160;</td>
          <td class="paramname"> = <code>Clobber::YES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert part of another map by reference. </p>
<p>The segments of the <code>source</code> map that overlap with the addresses specified by <code>where</code> are copied and inserted into <code>this</code> map. The new copied segments point to the same data buffers as <code>source</code>, therefore the segments in the new map will share the same data as the old map and changing the data in either map will change the data in the other map as well.</p>
<p>If the <code>Clobber</code> flag is set, then any segment that previously existed in the <code>this</code> map will be overwritten by segments copied from the <code>source</code> map. Otherwise, when <code>Clobber</code> is clear, only those parts of the <code>source</code> map that are not already mapped in <code>this</code> map are copied.</p>
<p>The return value is the set of addresses that were actually copied from the <code>source</code> to <code>this</code> map. </p>

</div>
</div>
<a id="ab2ddb64d1de9c10f925b4d61c4da5787" name="ab2ddb64d1de9c10f925b4d61c4da5787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ddb64d1de9c10f925b4d61c4da5787">&#9670;&#160;</a></span>linkTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::MemoryMap::linkTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#af9bc4cf22ea8728c97c452f3c0ae4151">Clobber</a>&#160;</td>
          <td class="paramname"> = <code>Clobber::YES</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert part of another map by reference. </p>
<p>The segments of the <code>source</code> map that overlap with the addresses specified by <code>where</code> are copied and inserted into <code>this</code> map. The new copied segments point to the same data buffers as <code>source</code>, therefore the segments in the new map will share the same data as the old map and changing the data in either map will change the data in the other map as well.</p>
<p>If the <code>Clobber</code> flag is set, then any segment that previously existed in the <code>this</code> map will be overwritten by segments copied from the <code>source</code> map. Otherwise, when <code>Clobber</code> is clear, only those parts of the <code>source</code> map that are not already mapped in <code>this</code> map are copied.</p>
<p>The return value is the set of addresses that were actually copied from the <code>source</code> to <code>this</code> map. </p>

</div>
</div>
<a id="afd28068846fb7cb9cc9c1695b82e6293" name="afd28068846fb7cb9cc9c1695b82e6293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd28068846fb7cb9cc9c1695b82e6293">&#9670;&#160;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> Rose::BinaryAnalysis::MemoryMap::align </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>lowAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>highAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new map by padding and aligning segments. </p>
<p>A new map is created by padding the segments of this map so they're aligned in the returned map. Data is copied (not linked) from this map to the new map. After alignment and padding, it's possible that more than one segment from the source maps to a single segment in the destination. When this happens, the destination segment's name comes from the first corresponding source segment, and the destination access permissions are the union of all the corresponding source segment access permissions.</p>
<p>A low or high aligment of zero is treated as an alignment of one; that is, the endpoint is not aligned. Higher values will cause segment beginning address to be aligned downward, and segment one-past-end addresses to be aligned upward. </p>

</div>
</div>
<a id="aae2f4f05bc65fa7cffe8c10b6e0f1a2d" name="aae2f4f05bc65fa7cffe8c10b6e0f1a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2f4f05bc65fa7cffe8c10b6e0f1a2d">&#9670;&#160;</a></span>copyFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1Buffer.html#a51d7578c5e6fb3d634ad1299c8754857">Buffer::Ptr</a>, std::string &gt; Rose::BinaryAnalysis::MemoryMap::copyFromFile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy part of a file into a buffer. </p>
<p>This copies (rather than directly references) part of a file and returns a pointer to a new buffer containing the data. If an error occurs when reading the file, then a buffer is still returned but its length will only be what was actually read, and a string is also returned containing the error message. </p>

</div>
</div>
<a id="a4bac3678aca70245a9e87f6b353f21bf" name="a4bac3678aca70245a9e87f6b353f21bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bac3678aca70245a9e87f6b353f21bf">&#9670;&#160;</a></span>shrinkUnshare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::MemoryMap::shrinkUnshare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink buffers and remove sharing. </p>
<p>Creates a new buffer per segment and copies the data for that segment into the new buffer. The new buffers are allocated to be just large enough to hold the data for the segment's interval. Segments that shared the same underlying data no longer share data.</p>
<p>Returns true if new buffers could be allocated for all segments, and false otherwise. A false return value could occur if a buffer does not support the <a class="el" href="classSawyer_1_1Container_1_1Buffer.html#a83701b3ecaeaf7ec1dd43f3de4c1c764">Sawyer::Container::Buffer::data</a>. As of this writing (Nov 2016) the only buffer type that doesn't support <code>data</code> is <a class="el" href="classSawyer_1_1Container_1_1NullBuffer.html">NullBuffer</a>, which doesn't appear in memory maps created by ROSE's binary specimen mappers. </p>

</div>
</div>
<a id="ad0eed131c77e6ae95d379bee546f2d9e" name="ad0eed131c77e6ae95d379bee546f2d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eed131c77e6ae95d379bee546f2d9e">&#9670;&#160;</a></span>readQuick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::MemoryMap::readQuick </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into buffer. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00533">533</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>.</p>

</div>
</div>
<a id="a9d20c9c61b8545d4994513cc5c18066a" name="a9d20c9c61b8545d4994513cc5c18066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d20c9c61b8545d4994513cc5c18066a">&#9670;&#160;</a></span>readString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::MemoryMap::readString </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int)&#160;</td>
          <td class="paramname"><em>validChar</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int)&#160;</td>
          <td class="paramname"><em>invalidChar</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>requiredPerms</em> = <code>READABLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prohibitedPerms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a NUL-terminated string from the memory map. </p>
<p>Reads data beginning at <code>startVa</code> in the memory map and continuing until one of the following conditions is met:</p>
<ul>
<li>The desired number of characters has been read (returns empty string) </li>
<li>The next character is the termination character (defaults to NUL) </li>
<li>An <code>invalidChar</code> function is specified and the next character causes it to return true (returns empty string) </li>
<li>A validChar function is specified and the next character causes it to return false (returns empty string)</li>
</ul>
<p>The empty string is returned unless the terminator character is encountered.</p>
<p>The <code>validChar</code> and <code>invalidChar</code> take an integer argument and return an integer value so that the C character classification functions from &lt;ctype.h&gt; can be used directly. </p>

</div>
</div>
<a id="a62c63a2f916fcee57a1268bc2cbe5b8f" name="a62c63a2f916fcee57a1268bc2cbe5b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c63a2f916fcee57a1268bc2cbe5b8f">&#9670;&#160;</a></span>readUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; U &gt; Rose::BinaryAnalysis::MemoryMap::readUnsigned </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an unsigned value. </p>
<p>Reads an unsigned value from memory and converts it from the memory byte order to the host byte order. If the entire value is not mapped in memory then return nothing (not even any part of the multi-byte value that might have been present. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00558">558</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a9d57d0cb52b7534503ece57a239fb803">Rose::BinaryAnalysis::ByteOrder::convert()</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#ad4b9bf5b149ac6dfd0e0bd07c9a49d5b">Rose::BinaryAnalysis::ByteOrder::hostOrder()</a>, <a class="el" href="AddressMap_8h_source.html#l01164">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::limit()</a>, <a class="el" href="AddressMap_8h_source.html#l01700">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::read()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00704">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::size()</a>.</p>

</div>
</div>
<a id="a0de66f3b03192e4d82279a67292b7f32" name="a0de66f3b03192e4d82279a67292b7f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de66f3b03192e4d82279a67292b7f32">&#9670;&#160;</a></span>readLongUnsinged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; Rose::BinaryAnalysis::MemoryMap::readLongUnsinged </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a long unsigned value. </p>
<p>Reads a long unsigned value from memory and converts it from the memory byte order to the host byte order. If the entire value is not mapped in memory then return nothing (not even any part of the multi-byte value that might have been present. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00571">571</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a9d57d0cb52b7534503ece57a239fb803">Rose::BinaryAnalysis::ByteOrder::convert()</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#ad4b9bf5b149ac6dfd0e0bd07c9a49d5b">Rose::BinaryAnalysis::ByteOrder::hostOrder()</a>, <a class="el" href="AddressMap_8h_source.html#l01164">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::limit()</a>, <a class="el" href="AddressMap_8h_source.html#l01700">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::read()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00704">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::size()</a>.</p>

</div>
</div>
<a id="a7851003d7eda2cf19853c46e74a4acec" name="a7851003d7eda2cf19853c46e74a4acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7851003d7eda2cf19853c46e74a4acec">&#9670;&#160;</a></span>writeUnsigned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::MemoryMap::writeUnsigned </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an unsigned value. </p>
<p>Takes a unsigned value converts it from the memory byte order to the host byte order then writes to memory. This does not verify the memory is writable. Returns the number of bytes written. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00583">583</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>.</p>

</div>
</div>
<a id="acbe58985a57d91bbe19882b616f4f88e" name="acbe58985a57d91bbe19882b616f4f88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe58985a57d91bbe19882b616f4f88e">&#9670;&#160;</a></span>writeUnsigned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::MemoryMap::writeUnsigned </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a long unsigned value. </p>
<p>Takes a long unsigned value converts it from the memory byte order to the host byte order then writes to memory. This does not verify the memory is writable. Returns the number of bytes written. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00591">591</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>.</p>

</div>
</div>
<a id="af01e9fab5cc3179dae674f2a67e55459" name="af01e9fab5cc3179dae674f2a67e55459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01e9fab5cc3179dae674f2a67e55459">&#9670;&#160;</a></span>readByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint8_t &gt; Rose::BinaryAnalysis::MemoryMap::readByte </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a byte from memory. </p>
<p>Reads a byte at the specified address and returns it. Returns nothing if the address is not mapped. </p>

</div>
</div>
<a id="ab2d39ab5e0ca182aae31fe1666e60c95" name="ab2d39ab5e0ca182aae31fe1666e60c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d39ab5e0ca182aae31fe1666e60c95">&#9670;&#160;</a></span>writeQuick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::MemoryMap::writeQuick </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data from buffer. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00604">604</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01123">Sawyer::Container::AddressMap&lt; rose_addr_t, uint8_t &gt;::at()</a>.</p>

</div>
</div>
<a id="aecf3bd4f98820b1fc1fa303c8f809849" name="aecf3bd4f98820b1fc1fa303c8f809849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf3bd4f98820b1fc1fa303c8f809849">&#9670;&#160;</a></span>findAny() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::MemoryMap::findAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Extent</a> &amp;&#160;</td>
          <td class="paramname"><em>limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytesToFind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>requiredPerms</em> = <code>READABLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prohibitedPerms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for any byte. </p>
<p>Searches for all of the specified bytes simultaneously and returns the lowest address (subject to <code>limits</code>) where one of the specified values appears. If none of the specified bytes appear within the given address extent, then this method returns none. </p>

</div>
</div>
<a id="a7d16515b3c11cb868e3aa04618876846" name="a7d16515b3c11cb868e3aa04618876846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d16515b3c11cb868e3aa04618876846">&#9670;&#160;</a></span>findAny() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::MemoryMap::findAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytesToFind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>requiredPerms</em> = <code>READABLE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prohibitedPerms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for any byte. </p>
<p>Searches for all of the specified bytes simultaneously and returns the lowest address (subject to <code>limits</code>) where one of the specified values appears. If none of the specified bytes appear within the given address extent, then this method returns none. </p>

</div>
</div>
<a id="ad5b264dbe50c160e3654f946f88c372c" name="ad5b264dbe50c160e3654f946f88c372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b264dbe50c160e3654f946f88c372c">&#9670;&#160;</a></span>findSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::MemoryMap::findSequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a byte sequence. </p>
<p>Searches for the bytes specified by <code>sequence</code> occuring within the specified <code>interval</code>. If the <code>interval</code> is empty or the sequence cannot be found then nothing is returned. Otherwise, the virtual address for the start of the sequence is returned. An empty sequence matches at the beginning of the <code>interval</code>. </p>

</div>
</div>
<a id="ae22e797e2b3e14aef3200b03765917ea" name="ae22e797e2b3e14aef3200b03765917ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22e797e2b3e14aef3200b03765917ea">&#9670;&#160;</a></span>dump() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of the map for debugging. </p>
<p>The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. </p>

</div>
</div>
<a id="a232b7a13b0b01463ddd3ec8dd77a81d3" name="a232b7a13b0b01463ddd3ec8dd77a81d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232b7a13b0b01463ddd3ec8dd77a81d3">&#9670;&#160;</a></span>dump() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of the map for debugging. </p>
<p>The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. </p>

</div>
</div>
<a id="a99dc02cd21b36577ba15d2094ad4c8b5" name="a99dc02cd21b36577ba15d2094ad4c8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc02cd21b36577ba15d2094ad4c8b5">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the contents of the map for debugging. </p>
<p>The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. </p>

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00633">633</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ab27c9d481c390de37fc090aa67d6334d">dump()</a>.</p>

</div>
</div>
<a id="ab27c9d481c390de37fc090aa67d6334d" name="ab27c9d481c390de37fc090aa67d6334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27c9d481c390de37fc090aa67d6334d">&#9670;&#160;</a></span>dump() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::MemoryMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of the map for debugging. </p>
<p>The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. </p>

<p class="reference">Referenced by <a class="el" href="MemoryMap_8h_source.html#l00633">print()</a>.</p>

</div>
</div>
<a id="a95f3b09b22c8fe61102781612ad45459" name="a95f3b09b22c8fe61102781612ad45459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f3b09b22c8fe61102781612ad45459">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp; Rose::BinaryAnalysis::MemoryMap::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash of the entire memory contents. </p>
<p>This hashes the memory contents. Segment information (names, addresses, permissions, etc) are not included in the hash; only the bytes stored in the map. The user should supply a hasher whose <code>append</code> method will be called to add memory map contents to the hash. For instance, here's one way to hash the contents of a file without having to read the entire file into memory first:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">MemoryMap::Ptr</a> file = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a788dc3ca323dee1fc811bc55645ecdf8">MemoryMap::instance</a>();</div>
<div class="line">file-&gt;insertFile(<span class="stringliteral">&quot;/name/of/the/file&quot;</span>, 0);</div>
<div class="line">HasherSha1 hasher;</div>
<div class="line">file-&gt;hash(hasher);</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;file SHA1 hash is &quot;</span> &lt;&lt;<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a95f3b09b22c8fe61102781612ad45459">hash</a> &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1MemoryMap_html_a95f3b09b22c8fe61102781612ad45459"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a95f3b09b22c8fe61102781612ad45459">Rose::BinaryAnalysis::MemoryMap::hash</a></div><div class="ttdeci">Combinatorics::Hasher &amp; hash(Combinatorics::Hasher &amp;) const</div><div class="ttdoc">Compute a hash of the entire memory contents.</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7ae107e935935b9301a7160a84365136" name="a7ae107e935935b9301a7160a84365136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae107e935935b9301a7160a84365136">&#9670;&#160;</a></span>NO_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::NO_ACCESS = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00179">179</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a61570a7e2d272757f35810c79dbf9bb3" name="a61570a7e2d272757f35810c79dbf9bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61570a7e2d272757f35810c79dbf9bb3">&#9670;&#160;</a></span>READABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::READABLE = Sawyer::Access::READABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00180">180</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a993703ff3cb175924154b63ff760fe93" name="a993703ff3cb175924154b63ff760fe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993703ff3cb175924154b63ff760fe93">&#9670;&#160;</a></span>WRITABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::WRITABLE = Sawyer::Access::WRITABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00181">181</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a7dd5565fdc27aee9acabc448dc523071" name="a7dd5565fdc27aee9acabc448dc523071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd5565fdc27aee9acabc448dc523071">&#9670;&#160;</a></span>EXECUTABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::EXECUTABLE = Sawyer::Access::EXECUTABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00182">182</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a96aac2de2d6fef665d98440070cdf1c9" name="a96aac2de2d6fef665d98440070cdf1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aac2de2d6fef665d98440070cdf1c9">&#9670;&#160;</a></span>IMMUTABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::IMMUTABLE = Sawyer::Access::IMMUTABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00183">183</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="ac8e48e113d0149deda4499ba2c3ec811" name="ac8e48e113d0149deda4499ba2c3ec811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e48e113d0149deda4499ba2c3ec811">&#9670;&#160;</a></span>PRIVATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::PRIVATE = Sawyer::Access::PRIVATE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00184">184</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="afc82dfbf249d14e70f5bb7d5c352922a" name="afc82dfbf249d14e70f5bb7d5c352922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc82dfbf249d14e70f5bb7d5c352922a">&#9670;&#160;</a></span>INITIALIZED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::INITIALIZED = 0x00000200</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00185">185</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="ac4c0b10dc413c3295da85d4a92b1acc9" name="ac4c0b10dc413c3295da85d4a92b1acc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c0b10dc413c3295da85d4a92b1acc9">&#9670;&#160;</a></span>READ_WRITE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::READ_WRITE = READABLE | WRITABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00188">188</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a9088f93cf173ce7a67f24520620da8c8" name="a9088f93cf173ce7a67f24520620da8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9088f93cf173ce7a67f24520620da8c8">&#9670;&#160;</a></span>READ_EXECUTE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::READ_EXECUTE = READABLE | EXECUTABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00189">189</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="ac5f187a060a187da2ff369373259a6e2" name="ac5f187a060a187da2ff369373259a6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f187a060a187da2ff369373259a6e2">&#9670;&#160;</a></span>READ_WRITE_EXECUTE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::READ_WRITE_EXECUTE = READABLE | WRITABLE | EXECUTABLE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00190">190</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<a id="a34e58ab297bbc5e3ac9d3d357ba91aa0" name="a34e58ab297bbc5e3ac9d3d357ba91aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e58ab297bbc5e3ac9d3d357ba91aa0">&#9670;&#160;</a></span>RESERVED_ACCESS_BITS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::MemoryMap::RESERVED_ACCESS_BITS = 0x0000ffff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryMap_8h_source.html#l00193">193</a> of file <a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MemoryMap_8h_source.html">MemoryMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
