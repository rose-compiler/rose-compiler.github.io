<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::IntervalSetMap&lt; I, S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">IntervalSetMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1IntervalSetMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::IntervalSetMap&lt; I, S &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename I, typename S&gt;<br />
class Sawyer::Container::IntervalSetMap&lt; I, S &gt;</div><p>Mapping from integers to sets. </p>
<p>This container maps integer keys to sets of values and is optimized to store the same set across adjacent keys by using intervals of the key. For instance, an <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html" title="Mapping from integers to sets.">IntervalSetMap</a> that maps integer keys to sets of characters is declared like this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval&lt;int&gt;</a> IntRange;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set&lt;char&gt;</a> CharSet;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1IntervalSetMap.html">IntervalSetMap&lt;IntRange, CharSet&gt;</a> IntCharMap;</div>
<div class="line">IntCharMap icmap;</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalSetMap_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a></div><div class="ttdoc">Mapping from integers to sets.</div><div class="ttdef"><b>Definition</b> <a href="IntervalSetMap_8h_source.html#l00079">IntervalSetMap.h:79</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalSetMap_html_a8b20647cc36075ee851903065edc5435"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Sawyer::Container::IntervalSetMap::Set</a></div><div class="ttdeci">S Set</div><div class="ttdoc">Set type for values.</div><div class="ttdef"><b>Definition</b> <a href="IntervalSetMap_8h_source.html#l00083">IntervalSetMap.h:83</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalSetMap_html_a9978b9bd5d21d30d8373cf202357802b"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Sawyer::Container::IntervalSetMap::Interval</a></div><div class="ttdeci">I Interval</div><div class="ttdoc">Interval type for keys.</div><div class="ttdef"><b>Definition</b> <a href="IntervalSetMap_8h_source.html#l00082">IntervalSetMap.h:82</a></div></div>
</div><!-- fragment --><p>Such a map stores a set of characters for each integer key, but does so efficiently when the same set is stored across many consecutive keys. For instance, one can store the set {'a', 'b'} across a few million keys and use very little storage:</p>
<div class="fragment"><div class="line">icmap.insert(IntRange::baseSize(0,5000000), <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">icmap.insert(IntRange::baseSize(0,5000000), <span class="charliteral">&#39;b&#39;</span>);</div>
</div><!-- fragment --><p>At this point <code>icmap</code> is storing 'a' and 'b' at every key from 0 through 4999999, inclusive. This could also have been done by constructing the set first and then inserting the set. The real power of this container comes from the fact that one can insert values without regard for what intervals currently exist. For instance, we now insert a few more characters:</p>
<div class="fragment"><div class="line">icmap.insert(5, <span class="charliteral">&#39;c&#39;</span>); <span class="comment">// 5 is a singleton range</span></div>
<div class="line">icmap.insert(IntRange::hull(10,19), <span class="charliteral">&#39;d&#39;</span>);</div>
</div><!-- fragment --><p>Now <code>icmap</code> stores {'a', 'b'} at keys 0 through 4, {'a', 'b', 'c'} at key 5, {'a', 'b'} at keys 6 through 9, {'a', 'b', 'd'} at keys 10 through 19, and {'a', 'b'} at keys 20 through 4999999.</p>
<p>Erasing values works similarly: one can erase a character from an interval or single key without regard for what intervals already exist. Attempting to erase a character from a set that doesn't contain the character is a no-op. Here we erase 'b' and 'e' from large parts of the map key space:</p>
<div class="fragment"><div class="line">icmap.erase(icmap.hull(), <span class="charliteral">&#39;b&#39;</span>); <span class="comment">// erase &#39;b&#39; from everywhere</span></div>
<div class="line">icmap.erase(IntRange::hull(-1000000,1000000), <span class="charliteral">&#39;e&#39;</span>);</div>
</div><!-- fragment --><p>Querying is also quite efficient. Here we obtain the set of all values stored in the map's sets:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> allValues = icmap.getUnion(icmap.hull());</div>
</div><!-- fragment --><p>There are also predicates to determine whether a key or value is present in the map.</p>
<div class="fragment"><div class="line">icmap.contains(IntRange::hull(10,19)); <span class="comment">// Do keys 10 through 19 all have non-empty sets?</span></div>
<div class="line">icmap.containsAnywhere(icmap.hull(), <span class="charliteral">&#39;b&#39;</span>); <span class="comment">// Is value &#39;b&#39; present anywhere in the map?</span></div>
<div class="line">icmap.containsEverywhere(IntRange::hull(10,19), <span class="charliteral">&#39;a&#39;</span>); <span class="comment">// Is value &#39;a&#39; present for all keys 10 through 19?</span></div>
</div><!-- fragment --><p>The <code>S</code> template parameter is the set type and must implement the API defined by <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>.</p>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<p>See <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> for a similar container whose values don't act like sets. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00079">79</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="IntervalSetMap_8h_source.html">Sawyer/IntervalSetMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::IntervalSetMap&lt; I, S &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalSetMap__inherit__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_inherit__map" id="aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_inherit__map">
<area shape="rect" title="Mapping from integers to sets." alt="" coords="5,93,160,133"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="13,5,152,45"/>
<area shape="poly" title=" " alt="" coords="85,59,85,93,80,93,80,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Container::IntervalSetMap&lt; I, S &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1IntervalSetMap__coll__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_coll__map" id="aSawyer_1_1Container_1_1IntervalSetMap_3_01I_00_01S_01_4_coll__map">
<area shape="rect" title="Mapping from integers to sets." alt="" coords="5,93,160,133"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title=" " alt="" coords="13,5,152,45"/>
<area shape="poly" title=" " alt="" coords="85,59,85,93,80,93,80,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9978b9bd5d21d30d8373cf202357802b" id="r_a9978b9bd5d21d30d8373cf202357802b"><td class="memItemLeft" align="right" valign="top">typedef I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a></td></tr>
<tr class="memdesc:a9978b9bd5d21d30d8373cf202357802b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type for keys.  <br /></td></tr>
<tr class="separator:a9978b9bd5d21d30d8373cf202357802b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b20647cc36075ee851903065edc5435" id="r_a8b20647cc36075ee851903065edc5435"><td class="memItemLeft" align="right" valign="top">typedef S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a></td></tr>
<tr class="memdesc:a8b20647cc36075ee851903065edc5435"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> type for values.  <br /></td></tr>
<tr class="separator:a8b20647cc36075ee851903065edc5435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, S &gt;</a></td></tr>
<tr class="memitem:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a664961032974fd71f132d8931edd68de"><td class="memItemLeft" align="right" valign="top">typedef I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a></td></tr>
<tr class="memdesc:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type.  <br /></td></tr>
<tr class="separator:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a7c7ef387287aa01aa632dfeafc121e95"><td class="memItemLeft" align="right" valign="top">typedef S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a></td></tr>
<tr class="memdesc:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <br /></td></tr>
<tr class="separator:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae27b32aea90cdef93228cd5c978c00ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Container::Map</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>, IntervalCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a></td></tr>
<tr class="memdesc:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of the underlying map.  <br /></td></tr>
<tr class="separator:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad3da8180167b02f750f8138e21fea1b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td></tr>
<tr class="memdesc:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node.  <br /></td></tr>
<tr class="separator:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> iterator.  <br /></td></tr>
<tr class="separator:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae50e191b16e240244fb48af0232e88ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td></tr>
<tr class="memdesc:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a></td></tr>
<tr class="memdesc:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a643bf7e3b1413a950b3e66bd7244dacb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td></tr>
<tr class="memdesc:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad28df1a69755b5534a2ddb68bd447e61"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a></td></tr>
<tr class="memdesc:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0194a982385b2557f5bd47dfd4200db4" id="r_a0194a982385b2557f5bd47dfd4200db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a0194a982385b2557f5bd47dfd4200db4">getUnion</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a0194a982385b2557f5bd47dfd4200db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of values over an interval of keys.  <br /></td></tr>
<tr class="separator:a0194a982385b2557f5bd47dfd4200db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6cd602dd6935d011d1671d92b58d40" id="r_a2c6cd602dd6935d011d1671d92b58d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a2c6cd602dd6935d011d1671d92b58d40">getIntersection</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a2c6cd602dd6935d011d1671d92b58d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of values over an interval of keys.  <br /></td></tr>
<tr class="separator:a2c6cd602dd6935d011d1671d92b58d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7f8f2b525c6431055d836c4bdbc42a" id="r_aeb7f8f2b525c6431055d836c4bdbc42a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#aeb7f8f2b525c6431055d836c4bdbc42a">exists</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:aeb7f8f2b525c6431055d836c4bdbc42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if values are stored for an interval.  <br /></td></tr>
<tr class="separator:aeb7f8f2b525c6431055d836c4bdbc42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ec92211e46b08ef15b1d1f39a50781" id="r_af9ec92211e46b08ef15b1d1f39a50781"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#af9ec92211e46b08ef15b1d1f39a50781">existsAnywhere</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;value) const</td></tr>
<tr class="memdesc:af9ec92211e46b08ef15b1d1f39a50781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a particular value is stored in an interval.  <br /></td></tr>
<tr class="separator:af9ec92211e46b08ef15b1d1f39a50781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefda21bb701df227241ffa403c61685e" id="r_aefda21bb701df227241ffa403c61685e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#aefda21bb701df227241ffa403c61685e">existsEverywhere</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;value) const</td></tr>
<tr class="memdesc:aefda21bb701df227241ffa403c61685e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a particular value is stored everywhere in the interval.  <br /></td></tr>
<tr class="separator:aefda21bb701df227241ffa403c61685e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb485ef2f4a763a43111f77450ad0835" id="r_adb485ef2f4a763a43111f77450ad0835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#adb485ef2f4a763a43111f77450ad0835">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:adb485ef2f4a763a43111f77450ad0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase sets for an interval.  <br /></td></tr>
<tr class="separator:adb485ef2f4a763a43111f77450ad0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9023dbe83c1f8990286366ca952c084" id="r_ac9023dbe83c1f8990286366ca952c084"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#ac9023dbe83c1f8990286366ca952c084">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;value)</td></tr>
<tr class="memdesc:ac9023dbe83c1f8990286366ca952c084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases one value from a set over an interval.  <br /></td></tr>
<tr class="separator:ac9023dbe83c1f8990286366ca952c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9a3681c193288a64c71ae726369f8" id="r_ac2d9a3681c193288a64c71ae726369f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#ac2d9a3681c193288a64c71ae726369f8">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a>)</td></tr>
<tr class="memdesc:ac2d9a3681c193288a64c71ae726369f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase specified values from the sets of an interval.  <br /></td></tr>
<tr class="separator:ac2d9a3681c193288a64c71ae726369f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5277668c1316a1ee17f509181622b9e" id="r_ac5277668c1316a1ee17f509181622b9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#ac5277668c1316a1ee17f509181622b9e">insert</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;value)</td></tr>
<tr class="memdesc:ac5277668c1316a1ee17f509181622b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one value to the sets of an interval.  <br /></td></tr>
<tr class="separator:ac5277668c1316a1ee17f509181622b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e6c042ccebcb997d74cbc31f9eba50" id="r_a60e6c042ccebcb997d74cbc31f9eba50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a60e6c042ccebcb997d74cbc31f9eba50">insert</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a>)</td></tr>
<tr class="memdesc:a60e6c042ccebcb997d74cbc31f9eba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a set of values into the sets of an interval.  <br /></td></tr>
<tr class="separator:a60e6c042ccebcb997d74cbc31f9eba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7787385cf7f148de59bd705a29c8c4" id="r_ace7787385cf7f148de59bd705a29c8c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#ace7787385cf7f148de59bd705a29c8c4">replace</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;interval, const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;set)</td></tr>
<tr class="memdesc:ace7787385cf7f148de59bd705a29c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace sets with a new set.  <br /></td></tr>
<tr class="separator:ace7787385cf7f148de59bd705a29c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, S &gt;</a></td></tr>
<tr class="memitem:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0c5f60fb7032334c08cf77fa731aeb26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">IntervalMap</a> ()</td></tr>
<tr class="memdesc:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a5eec51514347acfef76b9b4a65654bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">IntervalMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af681700b55257f5ccb0078c6bca9dbfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af681700b55257f5ccb0078c6bca9dbfa">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa43368dbaee5e1dc47efab1b5b6ce9c1"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa43368dbaee5e1dc47efab1b5b6ce9c1">intervals</a> () const</td></tr>
<tr class="memdesc:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing keys.  <br /></td></tr>
<tr class="separator:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a25feb127b25f2d5f7616003a010abdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">firstUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> minAddr) const</td></tr>
<tr class="memdesc:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first unmapped region.  <br /></td></tr>
<tr class="separator:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">lastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> maxAddr) const</td></tr>
<tr class="memdesc:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last unmapped region.  <br /></td></tr>
<tr class="separator:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a8da2cba60c620a2c9d4e60f57fe7a530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">exists</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size) const</td></tr>
<tr class="memdesc:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if element exists.  <br /></td></tr>
<tr class="separator:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad069dd4df1f86cb36ca5abd79d670f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad069dd4df1f86cb36ca5abd79d670f6e">getOptional</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <br /></td></tr>
<tr class="separator:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad85884652be5225f99a9492e83252b75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad85884652be5225f99a9492e83252b75">getOrDefault</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <br /></td></tr>
<tr class="separator:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acb61e91bac6aa82b6a5193726799bdf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">isEmpty</a> () const</td></tr>
<tr class="memdesc:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is empty.  <br /></td></tr>
<tr class="separator:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a017216edaa9c3064857c75fc63c07217"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">nIntervals</a> () const</td></tr>
<tr class="memdesc:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the container.  <br /></td></tr>
<tr class="separator:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adbf9f66a08580ead37de8f0dd96d575e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a> () const</td></tr>
<tr class="memdesc:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this container.  <br /></td></tr>
<tr class="separator:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6e7d3909845b1efa5c5849f60faa3192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192">least</a> () const</td></tr>
<tr class="memdesc:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum scalar key.  <br /></td></tr>
<tr class="separator:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a455ed64c13c1284608dfab1f6fa09ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a455ed64c13c1284608dfab1f6fa09ace">least</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum scalar key.  <br /></td></tr>
<tr class="separator:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a385bbee53b2f1ba14ad34af9211f067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d">greatest</a> () const</td></tr>
<tr class="memdesc:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum scalar key.  <br /></td></tr>
<tr class="separator:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a63bc9c438221e753ed9a1539b5b14002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a63bc9c438221e753ed9a1539b5b14002">greatest</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum scalar key.  <br /></td></tr>
<tr class="separator:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af87b09a062b8dd2e7fe64051184fba96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af87b09a062b8dd2e7fe64051184fba96">leastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum unmapped scalar key.  <br /></td></tr>
<tr class="separator:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac1dafe332cf7e4e2bc8da2b9993e8f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac1dafe332cf7e4e2bc8da2b9993e8f9c">greatestUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum unmapped scalar key.  <br /></td></tr>
<tr class="separator:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4734abf74cda51aa6252ecfc38342e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> () const</td></tr>
<tr class="memdesc:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map.  <br /></td></tr>
<tr class="separator:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2fd736a589e045f795c917a9d16c33d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2fd736a589e045f795c917a9d16c33d2">clear</a> ()</td></tr>
<tr class="memdesc:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the container.  <br /></td></tr>
<tr class="separator:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;erasure)</td></tr>
<tr class="memdesc:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified interval.  <br /></td></tr>
<tr class="separator:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3e96516680b59244ef196a9e885ac0ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">eraseMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase intervals specified in another <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non-overlapping intervals.">IntervalMap</a>.  <br /></td></tr>
<tr class="separator:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1effdf10ccfb80ed11cc999e850ab2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">insert</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> value, bool makeHole=true)</td></tr>
<tr class="memdesc:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair.  <br /></td></tr>
<tr class="separator:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af596a5898489cd4c86320bd5a1aa4307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">insertMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, bool makeHole=true)</td></tr>
<tr class="memdesc:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert values from another container.  <br /></td></tr>
<tr class="separator:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a775489990d1f4afaba7b7ee94e2e7f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a775489990d1f4afaba7b7ee94e2e7f1d">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2e50f959ecc418c31ccf2fa8a465df80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2e50f959ecc418c31ccf2fa8a465df80">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a11a77bbaa8abcabd5f21e3fafd19dafd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a11a77bbaa8abcabd5f21e3fafd19dafd">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aedc79f844559a4d50a71073d40f3c495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aedc79f844559a4d50a71073d40f3c495">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a28ed971cc7c018a24e1bad32b6a3cd3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a28ed971cc7c018a24e1bad32b6a3cd3d">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac040de688b66d2fd0f96e9e8da36ccb3">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a968496e5f3ddf732369084e3b9405fb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a968496e5f3ddf732369084e3b9405fb6">contains</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key) const</td></tr>
<tr class="separator:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a12776c478c6a1448865aa083fac5a2a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a12776c478c6a1448865aa083fac5a2a4">contains</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6819a75d74d259b0862b7b48705fcf5a"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6819a75d74d259b0862b7b48705fcf5a">nodes</a> ()</td></tr>
<tr class="memdesc:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3f1a21b012e0404f2d12167b5444e1ed"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3f1a21b012e0404f2d12167b5444e1ed">nodes</a> () const</td></tr>
<tr class="memdesc:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a70b9c01a8212eba072916db1d746cc9f"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> ()</td></tr>
<tr class="memdesc:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf80f4f896443d489431178d0121b754"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf80f4f896443d489431178d0121b754">values</a> () const</td></tr>
<tr class="memdesc:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a87170e7d06eb8710211a65fb9bc052c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4cdf5d3be3c2b27013876e65f69acd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a56a00171503e761f08e789d07692187e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1f52b31510a0edd7a3a6b99848d66df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad47a0cae47f4423000356e8a46b5ae33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad47a0cae47f4423000356e8a46b5ae33">operator[]</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a128f75d742f421056d4497519b1cbc5a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a128f75d742f421056d4497519b1cbc5a">get</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afd397b582b605adcab6cce46894b7bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afd397b582b605adcab6cce46894b7bc9">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0612b2970067bf6e0c858dfcb9c937a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0612b2970067bf6e0c858dfcb9c937a2">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aad53242671f18d795f3b040bdd0d7e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab59f19099179c53ab74984bf74855aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6675861f9feb70004fe397d1600d466f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa4e9edf0de829a794a10703c21228de0"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa4e9edf0de829a794a10703c21228de0">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adfc6016e9440f8dee3e7f37f4dd65aa7"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adfc6016e9440f8dee3e7f37f4dd65aa7">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab5a821909b63dedab54193fbd4a747c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a48ef3aaccd8a7cb97c33359be83ca883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a7395c06804302359b2243a6016644e25"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7395c06804302359b2243a6016644e25">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">IntervalMap::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator otherIter)</td></tr>
<tr class="memdesc:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac217c94739290a0c52debdac53020634"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac217c94739290a0c52debdac53020634">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">IntervalMap::ConstNodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator otherIter) const</td></tr>
<tr class="memdesc:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3710d6445b86359fc16236d2bb54a8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afa299225e9e0576bc9944dde4b29d569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a747ae7350949b0c59e9d40db1c62286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, S &gt;</a></td></tr>
<tr class="memitem:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2ae4f73131a2d77738a17708a7c1d262"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2ae4f73131a2d77738a17708a7c1d262">findPriorImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf352fa4dd63a2476519d74738f026d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf352fa4dd63a2476519d74738f026d8">findImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a916678d0f4bd8caf5cc70a3f2de287d6"><td class="memItemLeft" align="right" valign="top">static boost::iterator_range&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a916678d0f4bd8caf5cc70a3f2de287d6">findAllImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a55c31fa3f4ef0c963492c305154aafa3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a55c31fa3f4ef0c963492c305154aafa3">findFirstOverlapImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a83fd6db343d27ec8461ea48b9440c2a5"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a83fd6db343d27ec8461ea48b9440c2a5">findFirstOverlapImpl</a> (IMap &amp;imap, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;::ConstNodeIterator otherIter)</td></tr>
<tr class="memdesc:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ae69e9931f89e2b57d7eccff30bddc3a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae69e9931f89e2b57d7eccff30bddc3a1">firstFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator start)</td></tr>
<tr class="memdesc:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a33a10236237378a3f6e62f501c96fd2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a33a10236237378a3f6e62f501c96fd2d">bestFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;size, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;::NodeIterator start)</td></tr>
<tr class="memdesc:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9978b9bd5d21d30d8373cf202357802b" name="a9978b9bd5d21d30d8373cf202357802b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9978b9bd5d21d30d8373cf202357802b">&#9670;&#160;</a></span>Interval</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef I <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::Interval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type for keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00082">82</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

</div>
</div>
<a id="a8b20647cc36075ee851903065edc5435" name="a8b20647cc36075ee851903065edc5435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b20647cc36075ee851903065edc5435">&#9670;&#160;</a></span>Set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef S <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::Set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> type for values. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00083">83</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0194a982385b2557f5bd47dfd4200db4" name="a0194a982385b2557f5bd47dfd4200db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0194a982385b2557f5bd47dfd4200db4">&#9670;&#160;</a></span>getUnion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::getUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union of values over an interval of keys. </p>
<p>Returns the union of the sets stored across an interval of keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00092">92</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, S &gt;::findAll()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00123">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

</div>
</div>
<a id="a2c6cd602dd6935d011d1671d92b58d40" name="a2c6cd602dd6935d011d1671d92b58d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6cd602dd6935d011d1671d92b58d40">&#9670;&#160;</a></span>getIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::getIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection of values over an interval of keys. </p>
<p>Returns the set of values that are present for all keys in the interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00105">105</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, S &gt;::findAll()</a>, <a class="el" href="IntervalMap_8h_source.html#l00627">Sawyer::Container::IntervalMap&lt; I, S &gt;::get()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00116">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>.</p>

</div>
</div>
<a id="aeb7f8f2b525c6431055d836c4bdbc42a" name="aeb7f8f2b525c6431055d836c4bdbc42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7f8f2b525c6431055d836c4bdbc42a">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if values are stored for an interval. </p>
<p>Returns true if <code>get(interval)</code> would return a non-empty set. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00126">126</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

</div>
</div>
<a id="af9ec92211e46b08ef15b1d1f39a50781" name="af9ec92211e46b08ef15b1d1f39a50781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ec92211e46b08ef15b1d1f39a50781">&#9670;&#160;</a></span>existsAnywhere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::existsAnywhere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a particular value is stored in an interval. </p>
<p>Returns true if <code>getUnion(interval)</code> would return a set containing <code>value</code> as a member. In particular, this returns false if the <code>interval</code> is empty. This is more efficient than calling <code>getUnion(interval)</code> and checking whether it contains <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00135">135</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, S &gt;::findAll()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00123">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

</div>
</div>
<a id="aefda21bb701df227241ffa403c61685e" name="aefda21bb701df227241ffa403c61685e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefda21bb701df227241ffa403c61685e">&#9670;&#160;</a></span>existsEverywhere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::existsEverywhere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a particular value is stored everywhere in the interval. </p>
<p>Returns true if <code>getIntersection(interval)</code> would return a set containing <code>value</code> as a member. In particular, this returns false if the <code>interval</code> is empty. This is more efficient than calling <code>getIntersection(interval)</code> and checking whether it contains <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00148">148</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, S &gt;::findAll()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00123">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::value()</a>.</p>

</div>
</div>
<a id="adb485ef2f4a763a43111f77450ad0835" name="adb485ef2f4a763a43111f77450ad0835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb485ef2f4a763a43111f77450ad0835">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase sets for an interval. </p>
<p>Erases the sets associated with the given interval of keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00166">166</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00793">Sawyer::Container::IntervalMap&lt; I, S &gt;::erase()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSetMap_8h_source.html#l00174">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::erase()</a>.</p>

</div>
</div>
<a id="ac9023dbe83c1f8990286366ca952c084" name="ac9023dbe83c1f8990286366ca952c084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9023dbe83c1f8990286366ca952c084">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases one value from a set over an interval. </p>
<p>Erases the specified <code>value</code> from all sets over the specified <code>interval</code> of keys. Any sets that become empty are removed from the map as if <code>erase</code> had been called on that sub-interval. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00174">174</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalSetMap_8h_source.html#l00166">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::erase()</a>.</p>

</div>
</div>
<a id="ac2d9a3681c193288a64c71ae726369f8" name="ac2d9a3681c193288a64c71ae726369f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d9a3681c193288a64c71ae726369f8">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase specified values from the sets of an interval. </p>
<p>Erases the specified values from all sets over the specified <code>interval</code> of keys. Any sets that become empty are removed from the map as if single-argument <code>erase</code> hd been called on that sub-interval. Returns true if any values were erased, false if none of the values were members of the affected sets. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00185">185</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00438">Sawyer::Container::IntervalMap&lt; I, S &gt;::findFirstOverlap()</a>, <a class="el" href="IntervalMap_8h_source.html#l00627">Sawyer::Container::IntervalMap&lt; I, S &gt;::get()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; T &gt;::hull()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00116">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="IntervalMap_8h_source.html#l00306">Sawyer::Container::IntervalMap&lt; I, S &gt;::nodes()</a>, <a class="el" href="IntervalSetMap_8h_source.html#l00252">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::replace()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00322">Sawyer::Container::IntervalMap&lt; I, S &gt;::values()</a>.</p>

</div>
</div>
<a id="ac5277668c1316a1ee17f509181622b9e" name="ac5277668c1316a1ee17f509181622b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5277668c1316a1ee17f509181622b9e">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classSawyer_1_1Container_1_1Set.html#ada5c8b0de39d9b55cb305aebe0dbbd5f">Set::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert one value to the sets of an interval. </p>
<p>Inserts the specified <code>value</code> to all sets in the <code>interval</code> of keys. Returns true if the value was inserted anywhere, false if the value already existed everywhere. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00213">213</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalSetMap_8h_source.html#l00213">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSetMap_8h_source.html#l00213">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::insert()</a>.</p>

</div>
</div>
<a id="a60e6c042ccebcb997d74cbc31f9eba50" name="a60e6c042ccebcb997d74cbc31f9eba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e6c042ccebcb997d74cbc31f9eba50">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a set of values into the sets of an interval. </p>
<p>Inserts the specified values into all sets in the <code>interval</code> of keys. Returns true if any value was inserted anywhere, false if all values already existed in the sets of all specified keys. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00223">223</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00438">Sawyer::Container::IntervalMap&lt; I, S &gt;::findFirstOverlap()</a>, <a class="el" href="IntervalMap_8h_source.html#l00627">Sawyer::Container::IntervalMap&lt; I, S &gt;::get()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; T &gt;::hull()</a>, <a class="el" href="IntervalMap_8h_source.html#l00861">Sawyer::Container::IntervalMap&lt; I, S &gt;::insert()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00116">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::Node::key()</a>, <a class="el" href="IntervalMap_8h_source.html#l00306">Sawyer::Container::IntervalMap&lt; I, S &gt;::nodes()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00322">Sawyer::Container::IntervalMap&lt; I, S &gt;::values()</a>.</p>

</div>
</div>
<a id="ace7787385cf7f148de59bd705a29c8c4" name="ace7787385cf7f148de59bd705a29c8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7787385cf7f148de59bd705a29c8c4">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html">Sawyer::Container::IntervalSetMap</a>&lt; I, S &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a9978b9bd5d21d30d8373cf202357802b">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1IntervalSetMap.html#a8b20647cc36075ee851903065edc5435">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace sets with a new set. </p>
<p>Replaces sets for keys in the specified <code>interval</code> with the specified <code>set</code>. </p>

<p class="definition">Definition at line <a class="el" href="IntervalSetMap_8h_source.html#l00252">252</a> of file <a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00793">Sawyer::Container::IntervalMap&lt; I, S &gt;::erase()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00861">Sawyer::Container::IntervalMap&lt; I, S &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntervalSetMap_8h_source.html#l00185">Sawyer::Container::IntervalSetMap&lt; I, S &gt;::erase()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="IntervalSetMap_8h_source.html">IntervalSetMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
