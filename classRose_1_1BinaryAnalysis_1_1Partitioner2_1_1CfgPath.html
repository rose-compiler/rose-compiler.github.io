<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::CfgPath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html">CfgPath</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::CfgPath Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>A path through a control flow graph. </p>
<p>A CFG path consists of a starting CFG vertex plus zero or more CFG edges. The first edge is an outgoing edge of the starting vertex and subsequent edges must be connected through inter-edge vertices. An empty path is a path with no edges and no starting vertex. A path acts like a stack in that edges can be pushed and popped from the end of the path. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00017">17</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="CfgPath_8h_source.html">Rose/BinaryAnalysis/Partitioner2/CfgPath.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9389f52d102a82b445548027a5e6508b" id="r_a9389f52d102a82b445548027a5e6508b"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9389f52d102a82b445548027a5e6508b">Edges</a></td></tr>
<tr class="memdesc:a9389f52d102a82b445548027a5e6508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of inter-connected edges.  <br /></td></tr>
<tr class="separator:a9389f52d102a82b445548027a5e6508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9639c5ead707afd46cd5c34b4c86cce7" id="r_a9639c5ead707afd46cd5c34b4c86cce7"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; ControlFlowGraph::ConstVertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9639c5ead707afd46cd5c34b4c86cce7">Vertices</a></td></tr>
<tr class="memdesc:a9639c5ead707afd46cd5c34b4c86cce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of vertices.  <br /></td></tr>
<tr class="separator:a9639c5ead707afd46cd5c34b4c86cce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa700c506515f8695ff22d5b46bf598e0" id="r_aa700c506515f8695ff22d5b46bf598e0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a>&lt; <a class="el" href="structSawyer_1_1SingleThreadedTag.html">Sawyer::SingleThreadedTag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a></td></tr>
<tr class="memdesc:aa700c506515f8695ff22d5b46bf598e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores user-defined attributes.  <br /></td></tr>
<tr class="separator:aa700c506515f8695ff22d5b46bf598e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b472f31ba7b713c0d20e6cefc5ef646" id="r_a0b472f31ba7b713c0d20e6cefc5ef646"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a0b472f31ba7b713c0d20e6cefc5ef646">CfgPath</a> ()</td></tr>
<tr class="memdesc:a0b472f31ba7b713c0d20e6cefc5ef646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty path.  <br /></td></tr>
<tr class="separator:a0b472f31ba7b713c0d20e6cefc5ef646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5aa51d115c7b67f5643d7b08bf3fe" id="r_a80f5aa51d115c7b67f5643d7b08bf3fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a80f5aa51d115c7b67f5643d7b08bf3fe">CfgPath</a> (const ControlFlowGraph::ConstVertexIterator &amp;vertex)</td></tr>
<tr class="memdesc:a80f5aa51d115c7b67f5643d7b08bf3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a path having only a starting vertex.  <br /></td></tr>
<tr class="separator:a80f5aa51d115c7b67f5643d7b08bf3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28afbcc67c17bfffe3596df33876762" id="r_af28afbcc67c17bfffe3596df33876762"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#af28afbcc67c17bfffe3596df33876762">CfgPath</a> (const ControlFlowGraph::ConstEdgeIterator &amp;edge)</td></tr>
<tr class="memdesc:af28afbcc67c17bfffe3596df33876762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a path given an initial edge.  <br /></td></tr>
<tr class="separator:af28afbcc67c17bfffe3596df33876762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5a45732b940856fa074e26cc097ed6" id="r_a5d5a45732b940856fa074e26cc097ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a5d5a45732b940856fa074e26cc097ed6">clear</a> ()</td></tr>
<tr class="memdesc:a5d5a45732b940856fa074e26cc097ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this path empty.  <br /></td></tr>
<tr class="separator:a5d5a45732b940856fa074e26cc097ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf24ec2ae7287da3b014bfbc86eb2d36" id="r_acf24ec2ae7287da3b014bfbc86eb2d36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#acf24ec2ae7287da3b014bfbc86eb2d36">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf24ec2ae7287da3b014bfbc86eb2d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path is empty.  <br /></td></tr>
<tr class="separator:acf24ec2ae7287da3b014bfbc86eb2d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86f6bbf890c40a48dcfb96405bf1fd7" id="r_ab86f6bbf890c40a48dcfb96405bf1fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#ab86f6bbf890c40a48dcfb96405bf1fd7">isConnected</a> () const</td></tr>
<tr class="memdesc:ab86f6bbf890c40a48dcfb96405bf1fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that path edges are connected.  <br /></td></tr>
<tr class="separator:ab86f6bbf890c40a48dcfb96405bf1fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775165a3d71a870c09268999b46fa93" id="r_ac775165a3d71a870c09268999b46fa93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#ac775165a3d71a870c09268999b46fa93">nEdges</a> () const</td></tr>
<tr class="memdesc:ac775165a3d71a870c09268999b46fa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of edges in a path.  <br /></td></tr>
<tr class="separator:ac775165a3d71a870c09268999b46fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2959fd393ec0c8852b2cb5ab5395e7f" id="r_af2959fd393ec0c8852b2cb5ab5395e7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#af2959fd393ec0c8852b2cb5ab5395e7f">nVertices</a> () const</td></tr>
<tr class="memdesc:af2959fd393ec0c8852b2cb5ab5395e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices in a path.  <br /></td></tr>
<tr class="separator:af2959fd393ec0c8852b2cb5ab5395e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e33ba37c1be26ea08ec8c2faedc32" id="r_a690e33ba37c1be26ea08ec8c2faedc32"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a690e33ba37c1be26ea08ec8c2faedc32">frontVertex</a> () const</td></tr>
<tr class="memdesc:a690e33ba37c1be26ea08ec8c2faedc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex where the path starts.  <br /></td></tr>
<tr class="separator:a690e33ba37c1be26ea08ec8c2faedc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65912035a94848263705ca1f5977d55a" id="r_a65912035a94848263705ca1f5977d55a"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a65912035a94848263705ca1f5977d55a">backVertex</a> () const</td></tr>
<tr class="memdesc:a65912035a94848263705ca1f5977d55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex where the path ends.  <br /></td></tr>
<tr class="separator:a65912035a94848263705ca1f5977d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f157044e7b943d174c747248cb1d8a" id="r_a52f157044e7b943d174c747248cb1d8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9389f52d102a82b445548027a5e6508b">Edges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a52f157044e7b943d174c747248cb1d8a">edges</a> () const</td></tr>
<tr class="memdesc:a52f157044e7b943d174c747248cb1d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the edges in a path.  <br /></td></tr>
<tr class="separator:a52f157044e7b943d174c747248cb1d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537cb91ee56210a59722bd23ab882b9f" id="r_a537cb91ee56210a59722bd23ab882b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9639c5ead707afd46cd5c34b4c86cce7">Vertices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a537cb91ee56210a59722bd23ab882b9f">vertices</a> () const</td></tr>
<tr class="memdesc:a537cb91ee56210a59722bd23ab882b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the vertices in a path.  <br /></td></tr>
<tr class="separator:a537cb91ee56210a59722bd23ab882b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b3131d2a02849201464dc581115320" id="r_a69b3131d2a02849201464dc581115320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a69b3131d2a02849201464dc581115320">pushBack</a> (ControlFlowGraph::ConstEdgeIterator edge)</td></tr>
<tr class="memdesc:a69b3131d2a02849201464dc581115320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new edge to the end of the path.  <br /></td></tr>
<tr class="separator:a69b3131d2a02849201464dc581115320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada924373c6db0fe959b8073256479b0" id="r_aada924373c6db0fe959b8073256479b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aada924373c6db0fe959b8073256479b0">pushBack</a> (const std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a52f157044e7b943d174c747248cb1d8a">edges</a>)</td></tr>
<tr class="memdesc:aada924373c6db0fe959b8073256479b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new edge to the end of the path.  <br /></td></tr>
<tr class="separator:aada924373c6db0fe959b8073256479b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4544f6e6ad1dbdabafb89fc78fe7ab0" id="r_ac4544f6e6ad1dbdabafb89fc78fe7ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#ac4544f6e6ad1dbdabafb89fc78fe7ab0">pushFront</a> (ControlFlowGraph::ConstEdgeIterator edge)</td></tr>
<tr class="memdesc:ac4544f6e6ad1dbdabafb89fc78fe7ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge to the front of the path.  <br /></td></tr>
<tr class="separator:ac4544f6e6ad1dbdabafb89fc78fe7ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0130a1c3235c6c9956f6cfc226443b3" id="r_af0130a1c3235c6c9956f6cfc226443b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#af0130a1c3235c6c9956f6cfc226443b3">pushFront</a> (const std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a52f157044e7b943d174c747248cb1d8a">edges</a>)</td></tr>
<tr class="memdesc:af0130a1c3235c6c9956f6cfc226443b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge to the front of the path.  <br /></td></tr>
<tr class="separator:af0130a1c3235c6c9956f6cfc226443b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10891b3b6d237253b3cf3bd65165ed71" id="r_a10891b3b6d237253b3cf3bd65165ed71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a10891b3b6d237253b3cf3bd65165ed71">popBack</a> ()</td></tr>
<tr class="memdesc:a10891b3b6d237253b3cf3bd65165ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the final edge from a path.  <br /></td></tr>
<tr class="separator:a10891b3b6d237253b3cf3bd65165ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddac102937ff4110d59d4f4ffe08e2d" id="r_a9ddac102937ff4110d59d4f4ffe08e2d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9ddac102937ff4110d59d4f4ffe08e2d">backtrack</a> ()</td></tr>
<tr class="memdesc:a9ddac102937ff4110d59d4f4ffe08e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtrack to next path.  <br /></td></tr>
<tr class="separator:a9ddac102937ff4110d59d4f4ffe08e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b78ec7e9efcc15615534fe4d69a408f" id="r_a1b78ec7e9efcc15615534fe4d69a408f"><td class="memItemLeft" align="right" valign="top"><a id="a1b78ec7e9efcc15615534fe4d69a408f" name="a1b78ec7e9efcc15615534fe4d69a408f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nVisits</b> (const ControlFlowGraph::ConstVertexIterator &amp;vertex) const</td></tr>
<tr class="memdesc:a1b78ec7e9efcc15615534fe4d69a408f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times vertex appears in path. <br /></td></tr>
<tr class="separator:a1b78ec7e9efcc15615534fe4d69a408f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9b19ef04a98e303c5aa5d1564acce6" id="r_abc9b19ef04a98e303c5aa5d1564acce6"><td class="memItemLeft" align="right" valign="top"><a id="abc9b19ef04a98e303c5aa5d1564acce6" name="abc9b19ef04a98e303c5aa5d1564acce6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nVisits</b> (const ControlFlowGraph::ConstEdgeIterator &amp;edge) const</td></tr>
<tr class="memdesc:abc9b19ef04a98e303c5aa5d1564acce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times edge appears in path. <br /></td></tr>
<tr class="separator:abc9b19ef04a98e303c5aa5d1564acce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e87b3f5143b859b52a5a50bf451152" id="r_a03e87b3f5143b859b52a5a50bf451152"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a03e87b3f5143b859b52a5a50bf451152">lastInsnIndex</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a03e87b3f5143b859b52a5a50bf451152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find indices of last vertex and instruction.  <br /></td></tr>
<tr class="separator:a03e87b3f5143b859b52a5a50bf451152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828c8806a18258c8799ee0f4da5c113" id="r_a4828c8806a18258c8799ee0f4da5c113"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a4828c8806a18258c8799ee0f4da5c113">hash</a> () const</td></tr>
<tr class="memdesc:a4828c8806a18258c8799ee0f4da5c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the path.  <br /></td></tr>
<tr class="separator:a4828c8806a18258c8799ee0f4da5c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1818645c73fd9265c9d163e6ab96d56e" id="r_a1818645c73fd9265c9d163e6ab96d56e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a1818645c73fd9265c9d163e6ab96d56e">hash</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a1818645c73fd9265c9d163e6ab96d56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash part of a path,.  <br /></td></tr>
<tr class="separator:a1818645c73fd9265c9d163e6ab96d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd761d8abab8c0ec22bbe6e0a986de14" id="r_afd761d8abab8c0ec22bbe6e0a986de14"><td class="memItemLeft" align="right" valign="top"><a id="afd761d8abab8c0ec22bbe6e0a986de14" name="afd761d8abab8c0ec22bbe6e0a986de14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afd761d8abab8c0ec22bbe6e0a986de14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the path. <br /></td></tr>
<tr class="separator:afd761d8abab8c0ec22bbe6e0a986de14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a887ec72d0e5acc90aa6578a3b5fecd19" id="r_a887ec72d0e5acc90aa6578a3b5fecd19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a887ec72d0e5acc90aa6578a3b5fecd19">vertexAttributes</a> (size_t)</td></tr>
<tr class="memdesc:a887ec72d0e5acc90aa6578a3b5fecd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined attributes for the nth vertex.  <br /></td></tr>
<tr class="separator:a887ec72d0e5acc90aa6578a3b5fecd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a870078b8e1a096afbe262dee246784" id="r_a6a870078b8e1a096afbe262dee246784"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a6a870078b8e1a096afbe262dee246784">vertexAttributes</a> (size_t) const</td></tr>
<tr class="memdesc:a6a870078b8e1a096afbe262dee246784"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined attributes for the nth vertex.  <br /></td></tr>
<tr class="separator:a6a870078b8e1a096afbe262dee246784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a621b1a00172cc3ad29604a8dfbbd727e" id="r_a621b1a00172cc3ad29604a8dfbbd727e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a621b1a00172cc3ad29604a8dfbbd727e">edgeAttributes</a> (size_t)</td></tr>
<tr class="memdesc:a621b1a00172cc3ad29604a8dfbbd727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined attributes for the nth edge.  <br /></td></tr>
<tr class="separator:a621b1a00172cc3ad29604a8dfbbd727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8e1fe7d643697ad43ee203b55e917" id="r_a5fb8e1fe7d643697ad43ee203b55e917"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a5fb8e1fe7d643697ad43ee203b55e917">edgeAttributes</a> (size_t) const</td></tr>
<tr class="memdesc:a5fb8e1fe7d643697ad43ee203b55e917"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined attributes for the nth edge.  <br /></td></tr>
<tr class="separator:a5fb8e1fe7d643697ad43ee203b55e917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abdcbd99a4342100e0c11fa60b9b3e0c5" id="r_abdcbd99a4342100e0c11fa60b9b3e0c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#abdcbd99a4342100e0c11fa60b9b3e0c5">nCalls</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:abdcbd99a4342100e0c11fa60b9b3e0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of function calls.  <br /></td></tr>
<tr class="separator:abdcbd99a4342100e0c11fa60b9b3e0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce43ec74bf11d541a9fe47bb17a8835" id="r_a5ce43ec74bf11d541a9fe47bb17a8835"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a5ce43ec74bf11d541a9fe47bb17a8835">nCalls</a> () const</td></tr>
<tr class="memdesc:a5ce43ec74bf11d541a9fe47bb17a8835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of function calls.  <br /></td></tr>
<tr class="separator:a5ce43ec74bf11d541a9fe47bb17a8835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab9c4a7774b7ba9e9d6c3846b73680b1f" id="r_ab9c4a7774b7ba9e9d6c3846b73680b1f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#ab9c4a7774b7ba9e9d6c3846b73680b1f">nReturns</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ab9c4a7774b7ba9e9d6c3846b73680b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of function returns.  <br /></td></tr>
<tr class="separator:ab9c4a7774b7ba9e9d6c3846b73680b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689316d6c965d801525f16e6c78b3cb3" id="r_a689316d6c965d801525f16e6c78b3cb3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a689316d6c965d801525f16e6c78b3cb3">nReturns</a> () const</td></tr>
<tr class="memdesc:a689316d6c965d801525f16e6c78b3cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of function returns.  <br /></td></tr>
<tr class="separator:a689316d6c965d801525f16e6c78b3cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aed1c72cb5b76778fe21823191fe2fe44" id="r_aed1c72cb5b76778fe21823191fe2fe44"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aed1c72cb5b76778fe21823191fe2fe44">callDepth</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:aed1c72cb5b76778fe21823191fe2fe44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call depth.  <br /></td></tr>
<tr class="separator:aed1c72cb5b76778fe21823191fe2fe44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa591d447ba477305f320aee3864c5be0" id="r_aa591d447ba477305f320aee3864c5be0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa591d447ba477305f320aee3864c5be0">callDepth</a> () const</td></tr>
<tr class="memdesc:aa591d447ba477305f320aee3864c5be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call depth.  <br /></td></tr>
<tr class="separator:aa591d447ba477305f320aee3864c5be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a118efeac392f9efba7561191fea5b4a0" id="r_a118efeac392f9efba7561191fea5b4a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a118efeac392f9efba7561191fea5b4a0">maxCallDepth</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a118efeac392f9efba7561191fea5b4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum call depth.  <br /></td></tr>
<tr class="separator:a118efeac392f9efba7561191fea5b4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445d0a8246bd4b6d8f9470b911ba970f" id="r_a445d0a8246bd4b6d8f9470b911ba970f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a445d0a8246bd4b6d8f9470b911ba970f">maxCallDepth</a> () const</td></tr>
<tr class="memdesc:a445d0a8246bd4b6d8f9470b911ba970f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum call depth.  <br /></td></tr>
<tr class="separator:a445d0a8246bd4b6d8f9470b911ba970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a62b10dab3f945cd5df4c8150e74deeba" id="r_a62b10dab3f945cd5df4c8150e74deeba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a62b10dab3f945cd5df4c8150e74deeba">truncate</a> (const ControlFlowGraph::ConstEdgeIterator &amp;)</td></tr>
<tr class="memdesc:a62b10dab3f945cd5df4c8150e74deeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the path.  <br /></td></tr>
<tr class="separator:a62b10dab3f945cd5df4c8150e74deeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336abd979e97fea0dad8c0e766918f35" id="r_a336abd979e97fea0dad8c0e766918f35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a336abd979e97fea0dad8c0e766918f35">truncate</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;)</td></tr>
<tr class="memdesc:a336abd979e97fea0dad8c0e766918f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the path.  <br /></td></tr>
<tr class="separator:a336abd979e97fea0dad8c0e766918f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9389f52d102a82b445548027a5e6508b" name="a9389f52d102a82b445548027a5e6508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9389f52d102a82b445548027a5e6508b">&#9670;&#160;</a></span>Edges</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;ControlFlowGraph::ConstEdgeIterator&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9389f52d102a82b445548027a5e6508b">Rose::BinaryAnalysis::Partitioner2::CfgPath::Edges</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack of inter-connected edges. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00020">20</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="a9639c5ead707afd46cd5c34b4c86cce7" name="a9639c5ead707afd46cd5c34b4c86cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9639c5ead707afd46cd5c34b4c86cce7">&#9670;&#160;</a></span>Vertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;ControlFlowGraph::ConstVertexIterator&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9639c5ead707afd46cd5c34b4c86cce7">Rose::BinaryAnalysis::Partitioner2::CfgPath::Vertices</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack of vertices. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00023">23</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="aa700c506515f8695ff22d5b46bf598e0" name="aa700c506515f8695ff22d5b46bf598e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa700c506515f8695ff22d5b46bf598e0">&#9670;&#160;</a></span>Attributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a>&lt;<a class="el" href="structSawyer_1_1SingleThreadedTag.html">Sawyer::SingleThreadedTag</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Rose::BinaryAnalysis::Partitioner2::CfgPath::Attributes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores user-defined attributes. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00026">26</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b472f31ba7b713c0d20e6cefc5ef646" name="a0b472f31ba7b713c0d20e6cefc5ef646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b472f31ba7b713c0d20e6cefc5ef646">&#9670;&#160;</a></span>CfgPath() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::Partitioner2::CfgPath::CfgPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty path. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00044">44</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="a80f5aa51d115c7b67f5643d7b08bf3fe" name="a80f5aa51d115c7b67f5643d7b08bf3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f5aa51d115c7b67f5643d7b08bf3fe">&#9670;&#160;</a></span>CfgPath() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::Partitioner2::CfgPath::CfgPath </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a path having only a starting vertex. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00047">47</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="af28afbcc67c17bfffe3596df33876762" name="af28afbcc67c17bfffe3596df33876762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28afbcc67c17bfffe3596df33876762">&#9670;&#160;</a></span>CfgPath() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::Partitioner2::CfgPath::CfgPath </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a path given an initial edge. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00051">51</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d5a45732b940856fa074e26cc097ed6" name="a5d5a45732b940856fa074e26cc097ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5a45732b940856fa074e26cc097ed6">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this path empty. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00055">55</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="acf24ec2ae7287da3b014bfbc86eb2d36" name="acf24ec2ae7287da3b014bfbc86eb2d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24ec2ae7287da3b014bfbc86eb2d36">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::CfgPath::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path is empty. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00064">64</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CfgPath_8h_source.html#l00099">backVertex()</a>, <a class="el" href="CfgPath_8h_source.html#l00091">frontVertex()</a>, and <a class="el" href="CfgPath_8h_source.html#l00084">nVertices()</a>.</p>

</div>
</div>
<a id="ab86f6bbf890c40a48dcfb96405bf1fd7" name="ab86f6bbf890c40a48dcfb96405bf1fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f6bbf890c40a48dcfb96405bf1fd7">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::CfgPath::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that path edges are connected. </p>
<p>Checks whether adjacent edges in the path go through a common vertex. Returns true if they do, false otherwise. Returns true for a path with no edges. </p>

</div>
</div>
<a id="ac775165a3d71a870c09268999b46fa93" name="ac775165a3d71a870c09268999b46fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac775165a3d71a870c09268999b46fa93">&#9670;&#160;</a></span>nEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of edges in a path. </p>
<p>A path with zero edges is not necessarily empty; it may have an initial vertex. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00077">77</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CfgPath_8h_source.html#l00084">nVertices()</a>.</p>

</div>
</div>
<a id="af2959fd393ec0c8852b2cb5ab5395e7f" name="af2959fd393ec0c8852b2cb5ab5395e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2959fd393ec0c8852b2cb5ab5395e7f">&#9670;&#160;</a></span>nVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of vertices in a path. </p>
<p>The number of vertices in a non-empty path is one more than the number of edges. An empty path has zero vertices. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00084">84</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

<p class="reference">References <a class="el" href="CfgPath_8h_source.html#l00064">isEmpty()</a>, and <a class="el" href="CfgPath_8h_source.html#l00077">nEdges()</a>.</p>

</div>
</div>
<a id="a690e33ba37c1be26ea08ec8c2faedc32" name="a690e33ba37c1be26ea08ec8c2faedc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690e33ba37c1be26ea08ec8c2faedc32">&#9670;&#160;</a></span>frontVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::CfgPath::frontVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vertex where the path starts. </p>
<p>The path must not be empty. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00091">91</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

<p class="reference">References <a class="el" href="CfgPath_8h_source.html#l00064">isEmpty()</a>.</p>

</div>
</div>
<a id="a65912035a94848263705ca1f5977d55a" name="a65912035a94848263705ca1f5977d55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65912035a94848263705ca1f5977d55a">&#9670;&#160;</a></span>backVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::CfgPath::backVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vertex where the path ends. </p>
<p>The path must not be empty. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00099">99</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

<p class="reference">References <a class="el" href="CfgPath_8h_source.html#l00064">isEmpty()</a>.</p>

</div>
</div>
<a id="a52f157044e7b943d174c747248cb1d8a" name="a52f157044e7b943d174c747248cb1d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f157044e7b943d174c747248cb1d8a">&#9670;&#160;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9389f52d102a82b445548027a5e6508b">Edges</a> &amp; Rose::BinaryAnalysis::Partitioner2::CfgPath::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all the edges in a path. </p>
<p>A path with no edges is not necessarly an empty path; it may have an initial vertex. </p>

<p class="definition">Definition at line <a class="el" href="CfgPath_8h_source.html#l00107">107</a> of file <a class="el" href="CfgPath_8h_source.html">CfgPath.h</a>.</p>

</div>
</div>
<a id="a537cb91ee56210a59722bd23ab882b9f" name="a537cb91ee56210a59722bd23ab882b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537cb91ee56210a59722bd23ab882b9f">&#9670;&#160;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9639c5ead707afd46cd5c34b4c86cce7">Vertices</a> Rose::BinaryAnalysis::Partitioner2::CfgPath::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all the vertices in a path. </p>
<p>The list of vertices is not stored explicitly by this path object and must be recomputed for each call. Vertices are not necessarily unique within a path since they can be reached sometimes by multiple edges. </p>

</div>
</div>
<a id="a69b3131d2a02849201464dc581115320" name="a69b3131d2a02849201464dc581115320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b3131d2a02849201464dc581115320">&#9670;&#160;</a></span>pushBack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::pushBack </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new edge to the end of the path. </p>
<p>If the path is not empty then the source vertex for the new edge must be equal to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a65912035a94848263705ca1f5977d55a">backVertex</a>. The specified edge is pushed onto the path and the path is configured to visit the sibling edges during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9ddac102937ff4110d59d4f4ffe08e2d">backtrack</a> operation in order by incrementing the given iterator. </p>

</div>
</div>
<a id="aada924373c6db0fe959b8073256479b0" name="aada924373c6db0fe959b8073256479b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada924373c6db0fe959b8073256479b0">&#9670;&#160;</a></span>pushBack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::pushBack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new edge to the end of the path. </p>
<p>The argument is a list of edges all originating from the same vertex. If the path is non-empty, then the originating vertex must be equal to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a65912035a94848263705ca1f5977d55a">backVertex</a>. The argument specifies the order in which the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9ddac102937ff4110d59d4f4ffe08e2d">backtrack</a> operation will visit the edges, and only the first edge of this list is actually appended to the path. </p>

</div>
</div>
<a id="ac4544f6e6ad1dbdabafb89fc78fe7ab0" name="ac4544f6e6ad1dbdabafb89fc78fe7ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4544f6e6ad1dbdabafb89fc78fe7ab0">&#9670;&#160;</a></span>pushFront() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::pushFront </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new edge to the front of the path. </p>
<p>If the path is not empty, then the target vertex for the new edge must be equal to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a690e33ba37c1be26ea08ec8c2faedc32">frontVertex</a>. The specified edge is inserted at the front of the path and the path is configured to visit the sibling edges during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9ddac102937ff4110d59d4f4ffe08e2d">backtrack</a> operation in order by incrementing the given iterator.</p>
<p>Pushing edges onto the front of a path is not efficient; it requires moving all previous edges, taking time linearly proportional to the length of the path. </p>

</div>
</div>
<a id="af0130a1c3235c6c9956f6cfc226443b3" name="af0130a1c3235c6c9956f6cfc226443b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0130a1c3235c6c9956f6cfc226443b3">&#9670;&#160;</a></span>pushFront() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::pushFront </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new edge to the front of the path. </p>
<p>The argument is a list of edges all pointing to the same vertex. If the path is non-empty, then the pointed to vertex must be equal to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a690e33ba37c1be26ea08ec8c2faedc32">frontVertex</a>. The argument specifies the order in which the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#a9ddac102937ff4110d59d4f4ffe08e2d">backtrack</a> operation will visit the edges, and only the first edge of this list is actually inserted at the front of the path. </p>

</div>
</div>
<a id="a10891b3b6d237253b3cf3bd65165ed71" name="a10891b3b6d237253b3cf3bd65165ed71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10891b3b6d237253b3cf3bd65165ed71">&#9670;&#160;</a></span>popBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::CfgPath::popBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the final edge from a path. </p>
<p>Erasing the only remaining edge will leave the path in a state where it has only a starting vertex and no edges. Calling this method on such a path will remove the starting vertex. This method should not be called if the path is empty (has no edges and no starting vertex). </p>

</div>
</div>
<a id="a9ddac102937ff4110d59d4f4ffe08e2d" name="a9ddac102937ff4110d59d4f4ffe08e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddac102937ff4110d59d4f4ffe08e2d">&#9670;&#160;</a></span>backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; Rose::BinaryAnalysis::Partitioner2::CfgPath::backtrack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backtrack to next path. </p>
<p>Pops edges from the path until a vertex is reached where some other (later) edge can be followed, then push that edge onto the path. If no subsequent path through the CFG is available, then modify this path to be empty. This happens when this path's edges are all final outgoing edges for each vertex in the path.</p>
<p>Returns the edges that were removed in the order that they were removed. I.e., the first edge popped from the end of the path is at the front of the returned vector. </p>

</div>
</div>
<a id="a887ec72d0e5acc90aa6578a3b5fecd19" name="a887ec72d0e5acc90aa6578a3b5fecd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887ec72d0e5acc90aa6578a3b5fecd19">&#9670;&#160;</a></span>vertexAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp; Rose::BinaryAnalysis::Partitioner2::CfgPath::vertexAttributes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined attributes for the nth vertex. </p>
<p>Each vertex in the path has a corresponding attribute storage system. The attribute storage lifetime is the same as that of the vertex to which it corresponds; when the path through the vertex index changes, the storage is reset. Note that there is always one more vertex than edge (except when the path is completely empty). <a class="el" href="structEdge.html">Edge</a> number <em>i</em> has two endpoints that are vertices <em>i</em> and <em>i+1</em>. </p>

</div>
</div>
<a id="a6a870078b8e1a096afbe262dee246784" name="a6a870078b8e1a096afbe262dee246784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a870078b8e1a096afbe262dee246784">&#9670;&#160;</a></span>vertexAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp; Rose::BinaryAnalysis::Partitioner2::CfgPath::vertexAttributes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined attributes for the nth vertex. </p>
<p>Each vertex in the path has a corresponding attribute storage system. The attribute storage lifetime is the same as that of the vertex to which it corresponds; when the path through the vertex index changes, the storage is reset. Note that there is always one more vertex than edge (except when the path is completely empty). <a class="el" href="structEdge.html">Edge</a> number <em>i</em> has two endpoints that are vertices <em>i</em> and <em>i+1</em>. </p>

</div>
</div>
<a id="a621b1a00172cc3ad29604a8dfbbd727e" name="a621b1a00172cc3ad29604a8dfbbd727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621b1a00172cc3ad29604a8dfbbd727e">&#9670;&#160;</a></span>edgeAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp; Rose::BinaryAnalysis::Partitioner2::CfgPath::edgeAttributes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined attributes for the nth edge. </p>
<p>Each edge in the path has a corresponding attribute storage system. The attribute storage lifetime is the same as that of the edge to which it corresponds; when the path through the edge index changes, the storage is reset. Note that there is always one more vertex than edge (except when the path is completely empty). <a class="el" href="structEdge.html">Edge</a> number <em>i</em> has two endpoints that are vertices <em>i</em> and <em>i+1</em>. </p>

</div>
</div>
<a id="a5fb8e1fe7d643697ad43ee203b55e917" name="a5fb8e1fe7d643697ad43ee203b55e917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb8e1fe7d643697ad43ee203b55e917">&#9670;&#160;</a></span>edgeAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#aa700c506515f8695ff22d5b46bf598e0">Attributes</a> &amp; Rose::BinaryAnalysis::Partitioner2::CfgPath::edgeAttributes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined attributes for the nth edge. </p>
<p>Each edge in the path has a corresponding attribute storage system. The attribute storage lifetime is the same as that of the edge to which it corresponds; when the path through the edge index changes, the storage is reset. Note that there is always one more vertex than edge (except when the path is completely empty). <a class="el" href="structEdge.html">Edge</a> number <em>i</em> has two endpoints that are vertices <em>i</em> and <em>i+1</em>. </p>

</div>
</div>
<a id="abdcbd99a4342100e0c11fa60b9b3e0c5" name="abdcbd99a4342100e0c11fa60b9b3e0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcbd99a4342100e0c11fa60b9b3e0c5">&#9670;&#160;</a></span>nCalls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nCalls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of function calls. </p>
<p>Counts the number of E_FUNCTION_CALL edges in a path. If a non-null function is supplied then only count those edges that enter the specified function. </p>

</div>
</div>
<a id="a5ce43ec74bf11d541a9fe47bb17a8835" name="a5ce43ec74bf11d541a9fe47bb17a8835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce43ec74bf11d541a9fe47bb17a8835">&#9670;&#160;</a></span>nCalls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nCalls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of function calls. </p>
<p>Counts the number of E_FUNCTION_CALL edges in a path. If a non-null function is supplied then only count those edges that enter the specified function. </p>

</div>
</div>
<a id="ab9c4a7774b7ba9e9d6c3846b73680b1f" name="ab9c4a7774b7ba9e9d6c3846b73680b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4a7774b7ba9e9d6c3846b73680b1f">&#9670;&#160;</a></span>nReturns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nReturns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of function returns. </p>
<p>Counts the number of E_FUNCTION_RETURN edges in a path. If a non-null function is supplied then only count those edges that return from the specified function. </p>

</div>
</div>
<a id="a689316d6c965d801525f16e6c78b3cb3" name="a689316d6c965d801525f16e6c78b3cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689316d6c965d801525f16e6c78b3cb3">&#9670;&#160;</a></span>nReturns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::nReturns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of function returns. </p>
<p>Counts the number of E_FUNCTION_RETURN edges in a path. If a non-null function is supplied then only count those edges that return from the specified function. </p>

</div>
</div>
<a id="aed1c72cb5b76778fe21823191fe2fe44" name="aed1c72cb5b76778fe21823191fe2fe44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1c72cb5b76778fe21823191fe2fe44">&#9670;&#160;</a></span>callDepth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Rose::BinaryAnalysis::Partitioner2::CfgPath::callDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call depth. </p>
<p>Returns the function call depth at the end of the path. The call depth is incremented for each E_FUNCTION_CALL edge and decremented for each E_FUNCTION_RETURN edge, and the value at the end of the path is returned. If a non-null function is specified, then count only calls to that function and returns from that function. The return value may be negative if more return edges than call edges are encountered. </p>

</div>
</div>
<a id="aa591d447ba477305f320aee3864c5be0" name="aa591d447ba477305f320aee3864c5be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa591d447ba477305f320aee3864c5be0">&#9670;&#160;</a></span>callDepth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Rose::BinaryAnalysis::Partitioner2::CfgPath::callDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call depth. </p>
<p>Returns the function call depth at the end of the path. The call depth is incremented for each E_FUNCTION_CALL edge and decremented for each E_FUNCTION_RETURN edge, and the value at the end of the path is returned. If a non-null function is specified, then count only calls to that function and returns from that function. The return value may be negative if more return edges than call edges are encountered. </p>

</div>
</div>
<a id="a118efeac392f9efba7561191fea5b4a0" name="a118efeac392f9efba7561191fea5b4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118efeac392f9efba7561191fea5b4a0">&#9670;&#160;</a></span>maxCallDepth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::maxCallDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum call depth. </p>
<p>Returns the maximum function call depth in the path. The call depth is incremented for each E_FUNCTION_CALL edge and decremented for each E_FUNCTION_RETURN edge, and its maximum value is returned. If a non-null function is specified, then count only calls to that function and returns from that function. </p>

</div>
</div>
<a id="a445d0a8246bd4b6d8f9470b911ba970f" name="a445d0a8246bd4b6d8f9470b911ba970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445d0a8246bd4b6d8f9470b911ba970f">&#9670;&#160;</a></span>maxCallDepth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::CfgPath::maxCallDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum call depth. </p>
<p>Returns the maximum function call depth in the path. The call depth is incremented for each E_FUNCTION_CALL edge and decremented for each E_FUNCTION_RETURN edge, and its maximum value is returned. If a non-null function is specified, then count only calls to that function and returns from that function. </p>

</div>
</div>
<a id="a62b10dab3f945cd5df4c8150e74deeba" name="a62b10dab3f945cd5df4c8150e74deeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b10dab3f945cd5df4c8150e74deeba">&#9670;&#160;</a></span>truncate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; Rose::BinaryAnalysis::Partitioner2::CfgPath::truncate </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate the path. </p>
<p>Erase edges from the end of this path until this path contains none of the specified edges.</p>
<p>Returns the edges that were removed in the order that they were removed. I.e., the first edge popped from the end of the path is at the front of the returned vector. </p>

</div>
</div>
<a id="a336abd979e97fea0dad8c0e766918f35" name="a336abd979e97fea0dad8c0e766918f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336abd979e97fea0dad8c0e766918f35">&#9670;&#160;</a></span>truncate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ControlFlowGraph::ConstEdgeIterator &gt; Rose::BinaryAnalysis::Partitioner2::CfgPath::truncate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate the path. </p>
<p>Erase edges from the end of this path until this path contains none of the specified edges.</p>
<p>Returns the edges that were removed in the order that they were removed. I.e., the first edge popped from the end of the path is at the front of the returned vector. </p>

</div>
</div>
<a id="a03e87b3f5143b859b52a5a50bf451152" name="a03e87b3f5143b859b52a5a50bf451152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e87b3f5143b859b52a5a50bf451152">&#9670;&#160;</a></span>lastInsnIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; Rose::BinaryAnalysis::Partitioner2::CfgPath::lastInsnIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find indices of last vertex and instruction. </p>
<p>Given an instruction, return the index of the last occurrence of the instruction in this path. The return value is the index of the vertex containing the last occurrence of the instruction, and the index of the instruction across all instructions and summarized functions in this path. The path must contain at least one occurrence of the specified instruction. </p>

</div>
</div>
<a id="a4828c8806a18258c8799ee0f4da5c113" name="a4828c8806a18258c8799ee0f4da5c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4828c8806a18258c8799ee0f4da5c113">&#9670;&#160;</a></span>hash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Rose::BinaryAnalysis::Partitioner2::CfgPath::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash the path. </p>
<p>The path vertex addresses are hashed in the order they appear in order to create a unique identifier for the path. Any user-defined data attached to the path is not hashed. </p>

</div>
</div>
<a id="a1818645c73fd9265c9d163e6ab96d56e" name="a1818645c73fd9265c9d163e6ab96d56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1818645c73fd9265c9d163e6ab96d56e">&#9670;&#160;</a></span>hash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Rose::BinaryAnalysis::Partitioner2::CfgPath::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash part of a path,. </p>
<p>Hash this path up to and including the last occurrence of the specified instruction. This hash is calculated differently than <code>hash</code> with no arguments, thus even if the specified instruction is the very last instruction of the path the hashes returned by the two functions will differ. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CfgPath_8h_source.html">CfgPath.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
