<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Working with attributes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">Working with attributes<div class="ingroups"><a class="el" href="group__library__general__principles.html">Library general principles</a> &raquo; <a class="el" href="group__rose__midend.html">Midend</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>Attaching user-defined attributes to objects. </p>
<p>Many ROSE classes allow users to define and store their own data in the form of <em>attributes</em>. An attribute is a name/value pair where the name uniquely identifies the attribute within the container object and the value has a user-defined type.</p>
<p>ROSE supports three interfaces for attributes:</p>
<ul>
<li>The Sage IR nodes derived from <a class="el" href="classSgNode.html">SgNode</a> have a built-in interface for storing heap-allocated attributes. The applicable methods all have "attribute" as part of their names. This interface is built upon <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a>. This interface provides a way for the user to make multiple passes over the AST and save state information into the AST for subsequent traversals. The mechanism is different from creation of inherited and synthesized attributes within the AST processing mechanism (ASTProcessing) since those attributes are allocated and deallocated automatically on the stack. </li>
<li>The <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> provides a mechanism by which heap-allocated attributes derived from <a class="el" href="classAstAttribute.html">AstAttribute</a> can be stored in an object. Such attributes are copied (by reallocating) whenever their container is copied so that they are never shared between two containers. The <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a> container owns these attributes and deletes them when the container is destroyed. </li>
<li>The <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> support library has a <a class="el" href="namespaceSawyer_1_1Attribute.html">Sawyer::Attribute</a> namespace that provides a mechanism for storing values that are instances of POD types and 3rd-party types that the user cannot edit. It stores attributes by value, and uses the value's normal C++ constructors and destructor.</li>
</ul>
<p>Although there are three interfaces, they really all share the same basic mechanism. <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> attributes are implemented in terms of the <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a>, which is implemented in terms of <a class="el" href="namespaceSawyer_1_1Attribute.html" title="Attributes attached to other objects.">Sawyer::Attribute</a>.</p>
<h1><a class="anchor" id="attribute_comparison"></a>
Comparison of attribute interfaces</h1>
<table class="doxtable">
<tr>
<td><b>IR node attributes</b> </td><td><b><a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a></b> </td><td><b><a class="el" href="namespaceSawyer_1_1Attribute.html" title="Attributes attached to other objects.">Sawyer::Attribute</a></b>  </td></tr>
<tr>
<td>Applies only to IR nodes. </td><td>Class authors can add attribute-storing capability to any class by containing an <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a> object. </td><td>Class authors can add attribute-storing capability to any class by inheriting this interface.  </td></tr>
<tr>
<td>Can store multiple attributes with many different value types as long as those types all derive from <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>. </td><td>Can store multiple attributes with many different value types as long as those types all derive from <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>. </td><td>Can store multiple attributes with many different value types.  </td></tr>
<tr>
<td>Requires non-class values to be wrapped in a class derived from <a class="el" href="classAstAttribute.html">AstAttribute</a> </td><td>Requires non-class values to be wrapped in a class derived from <a class="el" href="classAstAttribute.html">AstAttribute</a> </td><td>Can directly store non-class values.  </td></tr>
<tr>
<td>User must be able modify the value type so it inherits from <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>, or he must wrap the type in his own subclass of <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>, adding an extra level of indirection to access the value. </td><td>User must be able modify the value type so it inherits from <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>, or he must wrap the type in his own subclass of <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>, adding an extra level of indirection to access the value. </td><td>Can store values whose type is not user-modifiable, such as STL containers.  </td></tr>
<tr>
<td>No assurance that the same name is not used for two different purposes. </td><td>No assurance that the same name is not used for two different purposes. </td><td>Ensures that two users don't declare the same attribute name.  </td></tr>
<tr>
<td>Requires implementation of virtual <code>copy</code> method (non-pure) if copying is intended. </td><td>Requires implementation of virtual <code>copy</code> method (non-pure) if copying is intended. </td><td>Uses normal C++ copy constructors and assignment operators for attribute values.  </td></tr>
<tr>
<td>Errors are not reported. </td><td>Errors are reported by return values. </td><td>Errors are reported by dedicated exception types.  </td></tr>
<tr>
<td>Attempting to retrieve a non-existing attribute without providing a default value returns a null attribute pointer </td><td>Attempting to retrieve a non-existing attribute without providing a default value returns a null attribute pointer </td><td>Attempting to retrieve a non-existing attribute without providing a default value throws a <a class="el" href="classSawyer_1_1Attribute_1_1DoesNotExist.html">Sawyer::Attribute::DoesNotExist</a> exception.  </td></tr>
<tr>
<td>Attribute values types are runtime checked. A mismatch is discovered by the user when they perform a <code>dynamic_cast</code> from the <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a> base type to their subclass. </td><td>Attribute values types are runtime checked. A mismatch is discovered by the user when they perform a <code>dynamic_cast</code> from the <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a> base type to their subclass. </td><td>Attribute value types are runtime checked. A mismatch between writing and reading is reported by a <a class="el" href="namespaceSawyer_1_1Attribute.html#a9baa2cf18cfb7f6c63f16e343b47dbba">Sawyer::Attribute::WrongQueryType</a> exception.  </td></tr>
<tr>
<td>Requires user to use C++ <code>dynamic_cast</code> from the <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a> pointer to the user's subclass pointer. </td><td>Requires user to use C++ <code>dynamic_cast</code> from the <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a> pointer to the user's subclass pointer. </td><td>All casting is hidden behind the API.  </td></tr>
</table>
<p>Some examples may help illuminate the differences. The examples show three methods of using attributes:</p>
<ul>
<li><b>Method 1</b> uses the <a class="el" href="namespaceSawyer_1_1Attribute.html" title="Attributes attached to other objects.">Sawyer::Attribute</a> interface directly. </li>
<li><b>Method 2</b> uses the <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> interface. </li>
<li><b>Method 3</b> uses the <a class="el" href="classSgNode.html">SgNode</a> attribute interface.</li>
</ul>
<p>Let us assume that two types exist in some library header file somewhere and the user wants to store these as attribute values in some object. The two value types are:</p>
<div class="fragment"><div class="line"><span class="comment">// Declared in a 3rd-party library</span></div>
<div class="line"><span class="keyword">enum</span> Approximation { UNDER_APPROXIMATED, OVER_APPROXIMATED, UNKNOWN_APPROXIMATION };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declared in a 3rd-party library</span></div>
<div class="line"><span class="keyword">struct </span>AnalysisTime {</div>
<div class="line">    <span class="keywordtype">double</span> cpuTime;</div>
<div class="line">    <span class="keywordtype">double</span> elapsedTime;</div>
<div class="line"> </div>
<div class="line">    AnalysisTime()</div>
<div class="line">        : cpuTime(0.0), elapsedTime(0.0) {}</div>
<div class="line"> </div>
<div class="line">    AnalysisTime(<span class="keywordtype">double</span> cpuTime, <span class="keywordtype">double</span> elapsedTime)</div>
<div class="line">        : cpuTime(cpuTime), elapsedTime(elapsedTime) {}</div>
<div class="line">};</div>
</div><!-- fragment --><p>Let us also assume that a ROSE developer has a class and wants the user to be able to store attributes in objects of that class. The first step is for the ROSE developer to prepare his class for storing attributes:</p>
<div class="fragment"><div class="line"><span class="comment">// Method 1: Sawyer::Attribute</span></div>
<div class="line"><span class="keyword">class </span>ObjectWithAttributes_1: <span class="keyword">public</span> <a class="code hl_class" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a>&lt;&gt; {</div>
<div class="line">    <span class="comment">// other members here...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 2: AstAttributeMechanism</span></div>
<div class="line"><span class="keyword">class </span>ObjectWithAttributes_2 {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_class" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> attributeMechanism;</div>
<div class="line">    <span class="comment">// other members here...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 3: Attributes in IR nodes (class derivation is not demoed here)</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSgAsmInstruction.html">SgAsmInstruction</a> ObjectWithAttributes_3;</div>
<div class="ttc" id="aclassAstAttributeMechanism_html"><div class="ttname"><a href="classAstAttributeMechanism.html">AstAttributeMechanism</a></div><div class="ttdoc">Stores named attributes in Sage IR nodes.</div><div class="ttdef"><b>Definition</b> <a href="AstAttributeMechanism_8h_source.html#l00249">AstAttributeMechanism.h:249</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Attribute_1_1Storage_html"><div class="ttname"><a href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a></div><div class="ttdoc">API and storage for attributes.</div><div class="ttdef"><b>Definition</b> <a href="Attribute_8h_source.html#l00215">Attribute.h:215</a></div></div>
<div class="ttc" id="aclassSgAsmInstruction_html"><div class="ttname"><a href="classSgAsmInstruction.html">SgAsmInstruction</a></div><div class="ttdoc">Base class for machine instructions.</div><div class="ttdef"><b>Definition</b> <a href="binaryInstruction_8C_source.html#l43208">binaryInstruction.C:43208</a></div></div>
</div><!-- fragment --><p>Method 1 is designed to use inheritance: all of its methods have the word "attribute" in their names. Method 2 could be used by inheritance, but is more commonly used with containment due to its short, common method names like <code>size</code>. Method 3 applies only to Sage IR nodes, but creating a new subclass of <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> is outside the scope of this document; instead, we'll just use an existing IR node type.</p>
<p>Now we jump into the user code. The user wants to be able to store two attributes, one of each value type. As mentioned above, the attribute value types are defined in some library header, and the class of objects in which to store them is defined in a ROSE header file. Method 1 an store values of any type, but the user has more work to do before he can use methods 2 or 3:</p>
<div class="fragment"><div class="line"><span class="comment">// Method 2: AstAttributeMechanism needs wrappers with &quot;copy&quot; methods.</span></div>
<div class="line"><span class="keyword">class </span>ApproximationAttribute_2: <span class="keyword">public</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>, </div>
<div class="line">    <span class="keyword">public</span> AllocationCounter&lt;ApproximationAttribute_2&gt; <span class="comment">// ignore this, it&#39;s only for testing the implementation</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Approximation approximation;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> ApproximationAttribute_2(Approximation a)</div>
<div class="line">        : approximation(a) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>* <a class="code hl_function" href="classAstAttribute.html#af88df78f415af920800bbf4023281f2f">copy</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> ApproximationAttribute_2(*<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code hl_function" href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">attribute_class_name</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;ApproximationAttribute_2&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AnalysisTimeAttribute_2: <span class="keyword">public</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>,</div>
<div class="line">    <span class="keyword">public</span> AllocationCounter&lt;AnalysisTimeAttribute_2&gt; <span class="comment">// ignore this, it&#39;s only for testing the implementation</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AnalysisTime analysisTime;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> AnalysisTimeAttribute_2(<span class="keyword">const</span> AnalysisTime &amp;t)</div>
<div class="line">        : analysisTime(t) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>* <a class="code hl_function" href="classAstAttribute.html#af88df78f415af920800bbf4023281f2f">copy</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AnalysisTimeAttribute_2(*<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code hl_function" href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">attribute_class_name</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;AnalysisTimeAttribute_2&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 3: IR node attributes need to be wrapped</span></div>
<div class="line"><span class="keyword">class </span>ApproximationAttribute_3: <span class="keyword">public</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>,</div>
<div class="line">    <span class="keyword">public</span> AllocationCounter&lt;ApproximationAttribute_3&gt; <span class="comment">// ignore this, it&#39;s only for testing the implementation</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_function" href="namespacestringify_1_1Rose_1_1BinaryAnalysis_1_1TaintedFlow.html#aed2c84e2a7a9bb10426ffd7baf49b019">Approximation</a> approximation;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> ApproximationAttribute_3(Approximation a)</div>
<div class="line">        : approximation(a) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>* <a class="code hl_function" href="classAstAttribute.html#af88df78f415af920800bbf4023281f2f">copy</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> ApproximationAttribute_3(*<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code hl_function" href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">attribute_class_name</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;ApproximationAttribute_3&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AnalysisTimeAttribute_3: <span class="keyword">public</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>,</div>
<div class="line">    <span class="keyword">public</span> AllocationCounter&lt;AnalysisTimeAttribute_3&gt; <span class="comment">// ignore this, it&#39;s only for testing the implementation</span></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AnalysisTime analysisTime;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> AnalysisTimeAttribute_3(<span class="keyword">const</span> AnalysisTime &amp;t)</div>
<div class="line">        : analysisTime(t) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_class" href="classAstAttribute.html">AstAttribute</a>* <a class="code hl_function" href="classAstAttribute.html#af88df78f415af920800bbf4023281f2f">copy</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> AnalysisTimeAttribute_3(*<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code hl_function" href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">attribute_class_name</a>()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;AllocationTimeAttribute_3&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassAstAttribute_html"><div class="ttname"><a href="classAstAttribute.html">AstAttribute</a></div><div class="ttdoc">Base class for all IR node attribute values.</div><div class="ttdef"><b>Definition</b> <a href="AstAttributeMechanism_8h_source.html#l00036">AstAttributeMechanism.h:36</a></div></div>
<div class="ttc" id="aclassAstAttribute_html_aa7b2177c686e996dd455c1f7ab9ecab6"><div class="ttname"><a href="classAstAttribute.html#aa7b2177c686e996dd455c1f7ab9ecab6">AstAttribute::attribute_class_name</a></div><div class="ttdeci">virtual std::string attribute_class_name() const</div><div class="ttdoc">Attribute class name.</div><div class="ttdef"><b>Definition</b> <a href="AstAttributeMechanism_8h_source.html#l00182">AstAttributeMechanism.h:182</a></div></div>
<div class="ttc" id="aclassAstAttribute_html_af88df78f415af920800bbf4023281f2f"><div class="ttname"><a href="classAstAttribute.html#af88df78f415af920800bbf4023281f2f">AstAttribute::copy</a></div><div class="ttdeci">virtual AstAttribute * copy() const</div><div class="ttdoc">Virtual copy constructor.</div><div class="ttdef"><b>Definition</b> <a href="AstAttributeMechanism_8h_source.html#l00162">AstAttributeMechanism.h:162</a></div></div>
<div class="ttc" id="anamespacestringify_1_1Rose_1_1BinaryAnalysis_1_1TaintedFlow_html_aed2c84e2a7a9bb10426ffd7baf49b019"><div class="ttname"><a href="namespacestringify_1_1Rose_1_1BinaryAnalysis_1_1TaintedFlow.html#aed2c84e2a7a9bb10426ffd7baf49b019">stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation</a></div><div class="ttdeci">const char * Approximation(int64_t)</div><div class="ttdoc">Convert Rose::BinaryAnalysis::TaintedFlow::Approximation enum constant to a string.</div></div>
</div><!-- fragment --><p>Method 1 requires no additional wrapper code since it can store any value directly. Methods 2 and 3 both require a substantial amount of boilerplate to store even a simple enum value. The <code>copy</code> method's purpose is to allocate a new copy of an attribute when the object holding the attribute is copied or assigned. The copy method should be implemented in every <a class="el" href="classAstAttribute.html">AstAttribute</a> subclass, although few do. If it's not implemented then one of two things happen: either the attribute is not copied, or only a superclass of the attribute is copied. Subclasses must also implement <code>attribute_class_name</code>, although few do. Neither <code>copy</code> nor <code>attribute_class_name</code> are pure virtual because of limitations with ROSETTA code generation.</p>
<p>Next, the user will want to use descriptive strings for the attribute so error messages are informative, but shorter names in C++ code, so we declare the attribute names:</p>
<div class="fragment"><div class="line">    <span class="comment">// Method 1: Sawyer::Attribute</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Sawyer::Attribute::Id</a> APPROXIMATION_ATTR = <a class="code hl_function" href="namespaceSawyer_1_1Attribute.html#aeece48cf6f8b5028066b0f8d2374e2e5">Sawyer::Attribute::declare</a>(<span class="stringliteral">&quot;type of approximation performed&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Sawyer::Attribute::Id</a> ANALYSIS_TIME_ATTR = <a class="code hl_function" href="namespaceSawyer_1_1Attribute.html#aeece48cf6f8b5028066b0f8d2374e2e5">Sawyer::Attribute::declare</a>(<span class="stringliteral">&quot;time taken for the analysis&quot;</span>);</div>
<div class="ttc" id="anamespaceSawyer_1_1Attribute_html_ac2390b0d8b09f1b75e5d452e2dc90e68"><div class="ttname"><a href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Sawyer::Attribute::Id</a></div><div class="ttdeci">size_t Id</div><div class="ttdoc">Attribute identification.</div><div class="ttdef"><b>Definition</b> <a href="Attribute_8h_source.html#l00140">Attribute.h:140</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Attribute_html_aeece48cf6f8b5028066b0f8d2374e2e5"><div class="ttname"><a href="namespaceSawyer_1_1Attribute.html#aeece48cf6f8b5028066b0f8d2374e2e5">Sawyer::Attribute::declare</a></div><div class="ttdeci">Id declare(const std::string &amp;name)</div><div class="ttdoc">Register a new attribute key.</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 2: AstAttributeMechanism</span></div>
<div class="line">    <span class="keyword">const</span> std::string APPROXIMATION_ATTR = <span class="stringliteral">&quot;type of approximation performed&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> std::string ANALYSIS_TIME_ATTR = <span class="stringliteral">&quot;time taken for the analysis&quot;</span>;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 3: Attributes in IR nodes</span></div>
<div class="line">    <span class="keyword">const</span> std::string APPROXIMATION_ATTR = <span class="stringliteral">&quot;type of approximation performed&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> std::string ANALYSIS_TIME_ATTR = <span class="stringliteral">&quot;time taken for the analysis&quot;</span>;</div>
</div><!-- fragment --><p>The declarations in methods 2 and 3 are identical. Method 1 differs by using an integral type for attribute IDs, which has two benefits: (1) it prevents two users from using the same attribute name for different purposes, and (2) it reduces the size and increases the speed of the underlying storage maps by storing integer keys rather than strings. Method 1 has functions that convert between identification numbers and strings if necessary (e.g., error messages).</p>
<p>Now, let us see how to insert two attributes into an object assuming that the object came from somewhere far away and we don't know whether it already contains these attributes. If it does, we want to overwrite their old values with new values. Overwriting values is likely to be a more common operation than insert-if-nonexistent. After all, languages generally don't have a dedicated assign-value-if-none-assigned operator (Perl and Bash being exceptions).</p>
<div class="fragment"><div class="line">    <span class="comment">// Method 1: Sawyer::Attribute</span></div>
<div class="line">    obj_1.setAttribute(APPROXIMATION_ATTR, UNDER_APPROXIMATED);</div>
<div class="line">    obj_1.setAttribute(ANALYSIS_TIME_ATTR, AnalysisTime(1.0, 2.0));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 2: AstAttributeMechanism</span></div>
<div class="line">    obj_1.attributeMechanism.set(APPROXIMATION_ATTR, <span class="keyword">new</span> ApproximationAttribute_2(UNDER_APPROXIMATED));</div>
<div class="line">    obj_1.attributeMechanism.set(ANALYSIS_TIME_ATTR, <span class="keyword">new</span> AnalysisTimeAttribute_2(AnalysisTime(1.0, 2.0)));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 3: Attributes in IR nodes</span></div>
<div class="line">    obj_1-&gt;setAttribute(APPROXIMATION_ATTR, <span class="keyword">new</span> ApproximationAttribute_3(UNDER_APPROXIMATED));</div>
<div class="line">    obj_1-&gt;setAttribute(ANALYSIS_TIME_ATTR, <span class="keyword">new</span> AnalysisTimeAttribute_3(AnalysisTime(1.0, 2.0)));</div>
</div><!-- fragment --><p>Method 1 stores the attribute directly while Methods 2 and 3 require the attribute value to be wrapped in a heap-allocated object first.</p>
<p>Eventually the user will want to retrieve an attribute's value. Users commonly need to obtain the attribute or a default value.</p>
<div class="fragment"><div class="line">    <span class="comment">// Method 1: Sawyer::Attribute</span></div>
<div class="line">    Approximation approx_1 = obj_1.attributeOrElse(APPROXIMATION_ATTR, UNKNOWN_APPROXIMATION);</div>
<div class="line">    <span class="keywordtype">double</span> cpuTime_1 = obj_1.attributeOrDefault&lt;AnalysisTime&gt;(ANALYSIS_TIME_ATTR).cpuTime;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 2: AstAttributeMechanism</span></div>
<div class="line">    Approximation approx_1 = UNKNOWN_APPROXIMATION;</div>
<div class="line">    <span class="keywordflow">if</span> (ApproximationAttribute_2 *tmp = <span class="keyword">dynamic_cast&lt;</span>ApproximationAttribute_2*<span class="keyword">&gt;</span>(obj_1.attributeMechanism[APPROXIMATION_ATTR]))</div>
<div class="line">        approx_1 = tmp-&gt;approximation;</div>
<div class="line">    <span class="keywordtype">double</span> cpuTime_1 = AnalysisTime().cpuTime;          <span class="comment">// the default, assuming we don&#39;t want to hard-code it.</span></div>
<div class="line">    <span class="keywordflow">if</span> (AnalysisTimeAttribute_2 *tmp = <span class="keyword">dynamic_cast&lt;</span>AnalysisTimeAttribute_2*<span class="keyword">&gt;</span>(obj_1.attributeMechanism[ANALYSIS_TIME_ATTR]))</div>
<div class="line">        cpuTime_1 = tmp-&gt;analysisTime.cpuTime;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 3: Attributes in IR nodes</span></div>
<div class="line">    Approximation approx_1 = UNKNOWN_APPROXIMATION;</div>
<div class="line">    <span class="keywordflow">if</span> (ApproximationAttribute_3 *tmp = <span class="keyword">dynamic_cast&lt;</span>ApproximationAttribute_3*<span class="keyword">&gt;</span>(obj_1-&gt;getAttribute(APPROXIMATION_ATTR)))</div>
<div class="line">        approx_1 = tmp-&gt;approximation;</div>
<div class="line">    <span class="keywordtype">double</span> cpuTime_1 = AnalysisTime().cpuTime;          <span class="comment">// the default, assuming we don&#39;t want to hard-code it.</span></div>
<div class="line">    <span class="keywordflow">if</span> (AnalysisTimeAttribute_3 *tmp = <span class="keyword">dynamic_cast&lt;</span>AnalysisTimeAttribute_3*<span class="keyword">&gt;</span>(obj_1-&gt;getAttribute(ANALYSIS_TIME_ATTR)))</div>
<div class="line">        cpuTime_1 = tmp-&gt;analysisTime.cpuTime;</div>
</div><!-- fragment --><p>Method 1 has a couple functions dedicated to this common scenario. Methods 2 and 3 return a null pointer if the attribute doesn't exist, but require a dynamic cast to the appropriate type otherwise.</p>
<p>Sooner or later a user will want to erase an attribute. Perhaps the attribute holds the result of some optional analysis which is no longer valid. The user wants to ensure that the attribute doesn't exist, but isn't sure whether it currently exists:</p>
<div class="fragment"><div class="line">    <span class="comment">// Method 1: Sawyer::Attribute</span></div>
<div class="line">    obj_1.eraseAttribute(APPROXIMATION_ATTR);</div>
<div class="line">    obj_2.eraseAttribute(ANALYSIS_TIME_ATTR);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 2: AstAttributeMechanism</span></div>
<div class="line">    obj_1.attributeMechanism.remove(APPROXIMATION_ATTR);</div>
<div class="line">    obj_2.attributeMechanism.remove(ANALYSIS_TIME_ATTR);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// Method 3: Attributes in IR nodes</span></div>
<div class="line">    obj_1-&gt;removeAttribute(APPROXIMATION_ATTR);</div>
<div class="line">    obj_2-&gt;removeAttribute(ANALYSIS_TIME_ATTR);</div>
</div><!-- fragment --><p>If the attribute didn't exist then none of these methods do anything. If it did exist... With Method 1, the value's destructor is called. Methods 2 and 3 delete the heap-allocated value, which is allowed since the attribute container owns the object.</p>
<p>Finally, when the object containing the attributes is destroyed the user needs to be able to clean up by destroying the attributes that are attached:</p>
<div class="fragment"><div class="line">        <span class="comment">// Method 1: Sawyer::Attribute: value destructors called automatically</span></div>
<div class="line">        <span class="comment">// if containing object is destroyed by exception unwinding.</span></div>
<div class="line">        <span class="keywordtype">int</span> x = something_that_might_throw();</div>
</div><!-- fragment --> <div class="fragment"><div class="line">        <span class="comment">// Method 2: AstAttributeMechanism: attributes automatically deleted</span></div>
<div class="line">        <span class="comment">// if the containing object would be destroyed by exception unwinding.</span></div>
<div class="line">        <span class="keywordtype">int</span> x = something_that_might_throw();</div>
</div><!-- fragment --> <div class="fragment"><div class="line">        <span class="comment">// Method 3: Attributes in IR nodes: attributes automatically destroyed if</span></div>
<div class="line">        <span class="comment">// an IR node is deleted. IR nodes are seldome destroyed during exception unwinding.</span></div>
<div class="line">        <span class="keywordtype">int</span> x = something_that_might_throw();</div>
</div><!-- fragment --><p>All three interfaces now properly clean up their attributes, although this wasn't always the case with methods 2 and 3. </p>
<div class="dynheader">
Collaboration diagram for Working with attributes:</div>
<div class="dyncontent">
<div class="center"><img src="group__attributes.png" border="0" usemap="#agroup____attributes" alt=""/></div>
<map name="agroup____attributes" id="agroup____attributes">
<area shape="rect" title="Attaching user&#45;defined attributes to objects." alt="" coords="117,5,273,31"/>
<area shape="rect" href="group__rose__midend.html" title="Analyzing and transforming the AST." alt="" coords="5,5,69,31"/>
</map>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:08:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
