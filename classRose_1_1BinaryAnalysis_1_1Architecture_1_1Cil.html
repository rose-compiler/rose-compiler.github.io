<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Architecture::Cil Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html">Architecture</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html">Cil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Architecture::Cil Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Architecture-specific information for the Common Intermediate Language. </p>
<p>Common Intermediate Language (CIL), formerly called Microsoft Intermediate Language (MSIL) or Intermediate Language (IL), is the intermediate language binary instruction set defined within the Common Language Infrastructure (CLI) specification. CIL instructions are executed by a CLI-compatible runtime environment such as the Common Language Runtime. Languages which target the CLI compile to CIL. CIL is object-oriented, stack-based bytecode. Runtimes typically just-in-time compile CIL instructions into native code.</p>
<p>CIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of C# and the CLI, the bytecode is now officially known as CIL. Windows Defender virus definitions continue to refer to binaries compiled with it as MSIL. </p>

<p class="definition">Definition at line <a class="el" href="Architecture_2Cil_8h_source.html#l00022">22</a> of file <a class="el" href="Architecture_2Cil_8h_source.html">Architecture/Cil.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Architecture_2Cil_8h_source.html">Rose/BinaryAnalysis/Architecture/Cil.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Architecture::Cil:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_inherit__map">
<area shape="rect" title="Architecture&#45;specific information for the Common Intermediate Language." alt="" coords="5,93,153,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html" title="Base class for architecture definitions." alt="" coords="5,5,153,45"/>
<area shape="poly" title=" " alt="" coords="82,59,82,93,77,93,77,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Architecture::Cil:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_coll__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil_coll__map">
<area shape="rect" title="Architecture&#45;specific information for the Common Intermediate Language." alt="" coords="5,93,153,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html" title="Base class for architecture definitions." alt="" coords="5,5,153,45"/>
<area shape="poly" title=" " alt="" coords="82,59,82,93,77,93,77,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a04b9230db0badccab12703d84c06846c" id="r_a04b9230db0badccab12703d84c06846c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a04b9230db0badccab12703d84c06846c">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aab6ca938b286ac9af68ace46b0a9e89a">CilPtr</a></td></tr>
<tr class="separator:a04b9230db0badccab12703d84c06846c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ac32fb431b1823b94185281598a6c2c03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a025b1c1e4df943f851e04a421f9efe27">BasePtr</a></td></tr>
<tr class="memdesc:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:ac32fb431b1823b94185281598a6c2c03 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a5bc2ec9662e6ae405e8db81bf555f79f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">BaseConstPtr</a></td></tr>
<tr class="memdesc:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer to const object.  <br /></td></tr>
<tr class="separator:a5bc2ec9662e6ae405e8db81bf555f79f inherit pub_types_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c584d80e1b7145ba1fc8466f9a98ef6" id="r_a1c584d80e1b7145ba1fc8466f9a98ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">RegisterDictionary::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a1c584d80e1b7145ba1fc8466f9a98ef6">registerDictionary</a> () const override</td></tr>
<tr class="memdesc:a1c584d80e1b7145ba1fc8466f9a98ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register dictionary.  <br /></td></tr>
<tr class="separator:a1c584d80e1b7145ba1fc8466f9a98ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef4d037af74674a8eed9a4b77fa24ec" id="r_a0ef4d037af74674a8eed9a4b77fa24ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a0ef4d037af74674a8eed9a4b77fa24ec">matchesHeader</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *) const override</td></tr>
<tr class="memdesc:a0ef4d037af74674a8eed9a4b77fa24ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a file header.  <br /></td></tr>
<tr class="separator:a0ef4d037af74674a8eed9a4b77fa24ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f1702f6fa366a222fe1d72cd23dbb3" id="r_a81f1702f6fa366a222fe1d72cd23dbb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a81f1702f6fa366a222fe1d72cd23dbb3">bytesPerInstruction</a> () const override</td></tr>
<tr class="memdesc:a81f1702f6fa366a222fe1d72cd23dbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid sizes for encoded machine instructions.  <br /></td></tr>
<tr class="separator:a81f1702f6fa366a222fe1d72cd23dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aaa5dfd05a3b3e3084a853a058a656" id="r_ab5aaa5dfd05a3b3e3084a853a058a656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#ab5aaa5dfd05a3b3e3084a853a058a656">instructionAlignment</a> () const override</td></tr>
<tr class="memdesc:ab5aaa5dfd05a3b3e3084a853a058a656"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions.  <br /></td></tr>
<tr class="separator:ab5aaa5dfd05a3b3e3084a853a058a656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f3cd80da6430bb398eda48c55292e9" id="r_a80f3cd80da6430bb398eda48c55292e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a80f3cd80da6430bb398eda48c55292e9">instructionMnemonic</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a80f3cd80da6430bb398eda48c55292e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mnemonic for an instruction.  <br /></td></tr>
<tr class="separator:a80f3cd80da6430bb398eda48c55292e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc093994f54836601472229867b18a4" id="r_aacc093994f54836601472229867b18a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aacc093994f54836601472229867b18a4">instructionDescription</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:aacc093994f54836601472229867b18a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description for an instruction.  <br /></td></tr>
<tr class="separator:aacc093994f54836601472229867b18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4edcee3d81d3f3337b21af0206779c" id="r_a5a4edcee3d81d3f3337b21af0206779c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a5a4edcee3d81d3f3337b21af0206779c">isUnknown</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a5a4edcee3d81d3f3337b21af0206779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instruction is the special "unknown" instruction.  <br /></td></tr>
<tr class="separator:a5a4edcee3d81d3f3337b21af0206779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8004e38713e51a8ac6531bc72d22a161" id="r_a8004e38713e51a8ac6531bc72d22a161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a8004e38713e51a8ac6531bc72d22a161">terminatesBasicBlock</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a8004e38713e51a8ac6531bc72d22a161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instruction normally terminates a basic block.  <br /></td></tr>
<tr class="separator:a8004e38713e51a8ac6531bc72d22a161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7711c049bdb1223255603031f776de4d" id="r_a7711c049bdb1223255603031f776de4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a7711c049bdb1223255603031f776de4d">isFunctionCallFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const override</td></tr>
<tr class="memdesc:a7711c049bdb1223255603031f776de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:a7711c049bdb1223255603031f776de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218fdc5287d307d5dd2c7fac7a915fbf" id="r_a218fdc5287d307d5dd2c7fac7a915fbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a218fdc5287d307d5dd2c7fac7a915fbf">isFunctionReturnFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const override</td></tr>
<tr class="memdesc:a218fdc5287d307d5dd2c7fac7a915fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a218fdc5287d307d5dd2c7fac7a915fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637fbb6ad3e6ddb32dc06ad9921ca9f7" id="r_a637fbb6ad3e6ddb32dc06ad9921ca9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a637fbb6ad3e6ddb32dc06ad9921ca9f7">branchTarget</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const override</td></tr>
<tr class="memdesc:a637fbb6ad3e6ddb32dc06ad9921ca9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the virtual address for a branching instruction.  <br /></td></tr>
<tr class="separator:a637fbb6ad3e6ddb32dc06ad9921ca9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb83bc0dc36289f0d6843f8d6d0c538a" id="r_aeb83bc0dc36289f0d6843f8d6d0c538a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aeb83bc0dc36289f0d6843f8d6d0c538a">getSuccessors</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, bool &amp;complete) const override</td></tr>
<tr class="memdesc:aeb83bc0dc36289f0d6843f8d6d0c538a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a single instruction.  <br /></td></tr>
<tr class="separator:aeb83bc0dc36289f0d6843f8d6d0c538a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1dfa16531bfcd0309aedbb03192a09" id="r_aac1dfa16531bfcd0309aedbb03192a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aac1dfa16531bfcd0309aedbb03192a09">newInstructionDecoder</a> () const override</td></tr>
<tr class="memdesc:aac1dfa16531bfcd0309aedbb03192a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction decoder.  <br /></td></tr>
<tr class="separator:aac1dfa16531bfcd0309aedbb03192a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f03c7eb098a0dfc12ef27d88db4095d" id="r_a9f03c7eb098a0dfc12ef27d88db4095d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a9f03c7eb098a0dfc12ef27d88db4095d">newUnparser</a> () const override</td></tr>
<tr class="memdesc:a9f03c7eb098a0dfc12ef27d88db4095d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction unparser.  <br /></td></tr>
<tr class="separator:a9f03c7eb098a0dfc12ef27d88db4095d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a7758dd9b3ef45fe3bbacde31f25e0510"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a> () const</td></tr>
<tr class="memdesc:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> definition name.  <br /></td></tr>
<tr class="separator:a7758dd9b3ef45fe3bbacde31f25e0510 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a02fb30e615b5afd19f867e66768b7688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a> () const</td></tr>
<tr class="memdesc:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order for memory.  <br /></td></tr>
<tr class="separator:a02fb30e615b5afd19f867e66768b7688 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ab47215e1c00810f5afb82f4bc04af5e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab47215e1c00810f5afb82f4bc04af5e4">interruptDictionary</a> () const</td></tr>
<tr class="memdesc:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Interrupt dictionary.  <br /></td></tr>
<tr class="separator:ab47215e1c00810f5afb82f4bc04af5e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000e445cbf23f56532f1bc5c7609dbac inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a000e445cbf23f56532f1bc5c7609dbac"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a000e445cbf23f56532f1bc5c7609dbac">callingConventions</a> () const</td></tr>
<tr class="memdesc:a000e445cbf23f56532f1bc5c7609dbac inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Calling convention definitions.  <br /></td></tr>
<tr class="separator:a000e445cbf23f56532f1bc5c7609dbac inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a08f7c3793592de8dfe7108c76245850c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08f7c3793592de8dfe7108c76245850c">matchesName</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a name.  <br /></td></tr>
<tr class="separator:a08f7c3793592de8dfe7108c76245850c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f7bc3595c3d4258ba834ae991008d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ac9f7bc3595c3d4258ba834ae991008d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9f7bc3595c3d4258ba834ae991008d2">newInstructionDispatcher</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ac9f7bc3595c3d4258ba834ae991008d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction dispatcher.  <br /></td></tr>
<tr class="separator:ac9f7bc3595c3d4258ba834ae991008d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ad73177355070eeb5741e5bcbc9fc56f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ad73177355070eeb5741e5bcbc9fc56f1">instructionsCanOverlap</a> () const</td></tr>
<tr class="memdesc:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether instructions can overlap in memory.  <br /></td></tr>
<tr class="separator:ad73177355070eeb5741e5bcbc9fc56f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c963c4b3bb04cd747f9c84de49a48d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a9c963c4b3bb04cd747f9c84de49a48d2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Partitioner2::FunctionPrologueMatcherPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9c963c4b3bb04cd747f9c84de49a48d2">functionPrologueMatchers</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a9c963c4b3bb04cd747f9c84de49a48d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction patterns matching function prologues.  <br /></td></tr>
<tr class="separator:a9c963c4b3bb04cd747f9c84de49a48d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db9046dabe9c47b53219f28941a082 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a30db9046dabe9c47b53219f28941a082"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Partitioner2::BasicBlockCallbackPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a30db9046dabe9c47b53219f28941a082">basicBlockCreationHooks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a30db9046dabe9c47b53219f28941a082 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific basic block callbacks for partitioning.  <br /></td></tr>
<tr class="separator:a30db9046dabe9c47b53219f28941a082 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a5f3e45432a5fb2e8a109c0d6118a0d62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5f3e45432a5fb2e8a109c0d6118a0d62">registrationId</a> () const</td></tr>
<tr class="memdesc:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:a5f3e45432a5fb2e8a109c0d6118a0d62 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_abc31f520eac844e49767d0afe1ccf1fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abc31f520eac844e49767d0afe1ccf1fe">registrationId</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;)</td></tr>
<tr class="memdesc:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:abc31f520eac844e49767d0afe1ccf1fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a73b51aa09fc1b1a71c7f66346359d28b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a> () const</td></tr>
<tr class="memdesc:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a73b51aa09fc1b1a71c7f66346359d28b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a1ee891ea7b9a61214b14496e263bb948"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a> () const</td></tr>
<tr class="memdesc:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a1ee891ea7b9a61214b14496e263bb948 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a9a80fb8df16e13c9333b0227620c90a2"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9a80fb8df16e13c9333b0227620c90a2">toString</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:a9a80fb8df16e13c9333b0227620c90a2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_aab7b2dad38bc3c6ca9fbb23096479292"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aab7b2dad38bc3c6ca9fbb23096479292">toStringNoAddr</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:aab7b2dad38bc3c6ca9fbb23096479292 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8d8c8b916e00cefa0f1b7634c1d839 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a3e8d8c8b916e00cefa0f1b7634c1d839"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e8d8c8b916e00cefa0f1b7634c1d839">isFunctionCallSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const</td></tr>
<tr class="memdesc:a3e8d8c8b916e00cefa0f1b7634c1d839 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:a3e8d8c8b916e00cefa0f1b7634c1d839 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a8abf86e9095b6f586e06c65b99a14d44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8abf86e9095b6f586e06c65b99a14d44">isFunctionReturnSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const</td></tr>
<tr class="memdesc:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a8abf86e9095b6f586e06c65b99a14d44 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a0e39bd2d1ac89476495a77ba0ea1dbca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a0e39bd2d1ac89476495a77ba0ea1dbca">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete) const</td></tr>
<tr class="memdesc:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a0e39bd2d1ac89476495a77ba0ea1dbca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a12a9280fadaea065516e3c0cb88b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a584a12a9280fadaea065516e3c0cb88b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a584a12a9280fadaea065516e3c0cb88b">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;initial_memory) const</td></tr>
<tr class="memdesc:a584a12a9280fadaea065516e3c0cb88b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a584a12a9280fadaea065516e3c0cb88b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f4ec86bbb9476978ee24c9870b79e73" id="r_a8f4ec86bbb9476978ee24c9870b79e73"><td class="memItemLeft" align="right" valign="top"><a id="a8f4ec86bbb9476978ee24c9870b79e73" name="a8f4ec86bbb9476978ee24c9870b79e73"></a>
static Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> ()</td></tr>
<tr class="memdesc:a8f4ec86bbb9476978ee24c9870b79e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor. <br /></td></tr>
<tr class="separator:a8f4ec86bbb9476978ee24c9870b79e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a62d3f5f251ba258b83d8c63e84d72059 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a62d3f5f251ba258b83d8c63e84d72059"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a>, size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a>)</td></tr>
<tr class="separator:a62d3f5f251ba258b83d8c63e84d72059 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98621d1e395d5fca985c902287ec4f inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a4a98621d1e395d5fca985c902287ec4f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> ()</td></tr>
<tr class="separator:a4a98621d1e395d5fca985c902287ec4f inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584136739b4573a9388e3903faafc562 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a584136739b4573a9388e3903faafc562"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constPtr</b> () const</td></tr>
<tr class="separator:a584136739b4573a9388e3903faafc562 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Rose::BinaryAnalysis::Architecture::Base</a></td></tr>
<tr class="memitem:a23bc5455bc3df509e90af8f2337557ee inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a23bc5455bc3df509e90af8f2337557ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a23bc5455bc3df509e90af8f2337557ee">registerDictionary_</a></td></tr>
<tr class="separator:a23bc5455bc3df509e90af8f2337557ee inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d3a8eb56136dfe58220836faa3f21 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a058d3a8eb56136dfe58220836faa3f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a058d3a8eb56136dfe58220836faa3f21">interruptDictionary_</a></td></tr>
<tr class="separator:a058d3a8eb56136dfe58220836faa3f21 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9579050251c6bf0c3c836b0b999e7e0 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_ac9579050251c6bf0c3c836b0b999e7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9579050251c6bf0c3c836b0b999e7e0">callingConventions_</a></td></tr>
<tr class="separator:ac9579050251c6bf0c3c836b0b999e7e0 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8432d213970666c785032171830d01 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_afe8432d213970666c785032171830d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#afe8432d213970666c785032171830d01">insnToString_</a></td></tr>
<tr class="separator:afe8432d213970666c785032171830d01 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dab3a55bc698d073cd54e190c4b459 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base" id="r_a36dab3a55bc698d073cd54e190c4b459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a36dab3a55bc698d073cd54e190c4b459">insnToStringNoAddr_</a></td></tr>
<tr class="separator:a36dab3a55bc698d073cd54e190c4b459 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a04b9230db0badccab12703d84c06846c" name="a04b9230db0badccab12703d84c06846c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b9230db0badccab12703d84c06846c">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Rose::BinaryAnalysis::Architecture::Cil::Ptr =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aab6ca938b286ac9af68ace46b0a9e89a">CilPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Cil_8h_source.html#l00024">24</a> of file <a class="el" href="Architecture_2Cil_8h_source.html">Architecture/Cil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c584d80e1b7145ba1fc8466f9a98ef6" name="a1c584d80e1b7145ba1fc8466f9a98ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c584d80e1b7145ba1fc8466f9a98ef6">&#9670;&#160;</a></span>registerDictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">RegisterDictionary::Ptr</a> Rose::BinaryAnalysis::Architecture::Cil::registerDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Register dictionary. </p>
<p>The register dictionary defines a mapping between register names and register descriptors (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>), and thus how the registers map into hardware.</p>
<p>Since dictionaries are generally not modified, it is permissible for this function to return the same dictionary every time it's called. The dictionary can be constructed on the first call.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a06a80559e394e92b20bbaf76951d5900">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a0ef4d037af74674a8eed9a4b77fa24ec" name="a0ef4d037af74674a8eed9a4b77fa24ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef4d037af74674a8eed9a4b77fa24ec">&#9670;&#160;</a></span>matchesHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Cil::matchesHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this architecture matches a file header. </p>
<p>Returns true if this architecture matches the specified file header, and false otherwise.</p>
<p>The default implementation always returns false. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#adc3611147dd3024b6d0de51ce006740f">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a81f1702f6fa366a222fe1d72cd23dbb3" name="a81f1702f6fa366a222fe1d72cd23dbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f1702f6fa366a222fe1d72cd23dbb3">&#9670;&#160;</a></span>bytesPerInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt; Rose::BinaryAnalysis::Architecture::Cil::bytesPerInstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valid sizes for encoded machine instructions. </p>
<p>Returns the range of valid sizes for encoded machine instructions. For instance, an x86 instruction can be from one to 15 bytes in length, but a PowerPC PPC32 instruction is always exactly 4 bytes. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7166b2e3ad595362e876ccda9ce2dd57">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="ab5aaa5dfd05a3b3e3084a853a058a656" name="ab5aaa5dfd05a3b3e3084a853a058a656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aaa5dfd05a3b3e3084a853a058a656">&#9670;&#160;</a></span>instructionAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> Rose::BinaryAnalysis::Architecture::Cil::instructionAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8ac610db2e1ce4866facad301b677e48">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a80f3cd80da6430bb398eda48c55292e9" name="a80f3cd80da6430bb398eda48c55292e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f3cd80da6430bb398eda48c55292e9">&#9670;&#160;</a></span>instructionMnemonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Architecture::Cil::instructionMnemonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mnemonic for an instruction. </p>
<p>Returns the mnemonic for a particular instruction.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3a56b4c385168bcf6804478700cc54ae">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="aacc093994f54836601472229867b18a4" name="aacc093994f54836601472229867b18a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc093994f54836601472229867b18a4">&#9670;&#160;</a></span>instructionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Architecture::Cil::instructionDescription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Description for an instruction. </p>
<p>Returns the description for a particular instruction. The description must be a single line with no leading or trailing white space, no line termination characters, and no non-printable characters. Most subclasses will just return a string based on the instruction mnemonic, such as "push a value onto the stack" for a <code>PUSH</code> instruction. The instruction argument must not be a null pointer and must be valid for this architecture.</p>
<p>The default implementation returns an empty string.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08e2b8bd1499cc492f7e844f188ae970">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a5a4edcee3d81d3f3337b21af0206779c" name="a5a4edcee3d81d3f3337b21af0206779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4edcee3d81d3f3337b21af0206779c">&#9670;&#160;</a></span>isUnknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Cil::isUnknown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instruction is the special "unknown" instruction. </p>
<p>Each instruction architecture in ROSE defines an "unknown" instruction to be used when the disassembler is unable to create a real instruction. This can happen, for instance, if the bit pattern does not represent a valid instruction for the architecture. The instruction must not be a null pointer, and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a76e44136d49e87a71ca1ffaa468439fb">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a8004e38713e51a8ac6531bc72d22a161" name="a8004e38713e51a8ac6531bc72d22a161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8004e38713e51a8ac6531bc72d22a161">&#9670;&#160;</a></span>terminatesBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Cil::terminatesBasicBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified instruction normally terminates a basic block. </p>
<p>The analysis generally only looks at the individual instruction and therefore is not very sophisticated. For instance, a conditional branch will always terminate a basic block by this method even if its condition is opaque. The instruction argument must not be a null pointer and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1fcbce03aea244dc9e5d9ac60554f000">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a7711c049bdb1223255603031f776de4d" name="a7711c049bdb1223255603031f776de4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7711c049bdb1223255603031f776de4d">&#9670;&#160;</a></span>isFunctionCallFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Cil::isFunctionCallFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function call. </p>
<p>If the basic block looks like a function call then this method returns true. If (and only if) the target address is known (i.e., the address of the called function) then <code>target</code> is set to this address (otherwise <code>target</code> is unmodified). If the return address is known or can be guessed, then return_va is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise the return_va is unmodified.</p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementation of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab7752a2ed38493ccb13a369c78d23988">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a218fdc5287d307d5dd2c7fac7a915fbf" name="a218fdc5287d307d5dd2c7fac7a915fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218fdc5287d307d5dd2c7fac7a915fbf">&#9670;&#160;</a></span>isFunctionReturnFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Cil::isFunctionReturnFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function return. </p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementaiton of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abea57c49d0420f037021ff7b7afecd16">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a637fbb6ad3e6ddb32dc06ad9921ca9f7" name="a637fbb6ad3e6ddb32dc06ad9921ca9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637fbb6ad3e6ddb32dc06ad9921ca9f7">&#9670;&#160;</a></span>branchTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Architecture::Cil::branchTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the virtual address for a branching instruction. </p>
<p>Returns the branch target address if the specified instruction is a branching instruction and the target is known; otherwise returns nothing.</p>
<p>The default implementation returns nothing.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a743b63088a626a602c6e9bcc3a054797">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="aeb83bc0dc36289f0d6843f8d6d0c538a" name="aeb83bc0dc36289f0d6843f8d6d0c538a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb83bc0dc36289f0d6843f8d6d0c538a">&#9670;&#160;</a></span>getSuccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::Cil::getSuccessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors for a single instruction. </p>
<p>The return value does not consider neighboring instructions, and therefore is quite naive. It returns only the information it can glean from this single instruction. If the returned set of virtual instructions is fully known then the <code>complete</code> argument will be set to true, otherwise false. The instruction must not be null, and must be valid for this architecture.</p>
<p>The default implementation always returns an empty set and clears <code>complete</code>.</p>
<p>Thread safety: Thread saafe. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aa57d491fecd502be6b814fcbf0be6d58">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="aac1dfa16531bfcd0309aedbb03192a09" name="aac1dfa16531bfcd0309aedbb03192a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1dfa16531bfcd0309aedbb03192a09">&#9670;&#160;</a></span>newInstructionDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a> Rose::BinaryAnalysis::Architecture::Cil::newInstructionDecoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction decoder. </p>
<p>Returns a new decoder for this architecture if possible, otherwise a null pointer.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e848a4594e882ab63f9a68cdb68c170">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<a id="a9f03c7eb098a0dfc12ef27d88db4095d" name="a9f03c7eb098a0dfc12ef27d88db4095d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f03c7eb098a0dfc12ef27d88db4095d">&#9670;&#160;</a></span>newUnparser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> Rose::BinaryAnalysis::Architecture::Cil::newUnparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction unparser. </p>
<p>An unparser is responsible for generating pseudo assembly listings.</p>
<p>Thread safety: Thread safe. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a59df18db2baae88452946dc47fa28a66">Rose::BinaryAnalysis::Architecture::Base</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Architecture_2Cil_8h_source.html">Architecture/Cil.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
