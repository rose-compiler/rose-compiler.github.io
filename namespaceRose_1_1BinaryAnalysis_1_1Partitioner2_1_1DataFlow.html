<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::DataFlow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html">DataFlow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::DataFlow Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Data-flow utilities. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1DfCfgVertex.html">DfCfgVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFG vertex for data-flow analysis.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1DfCfgVertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html">InterproceduralPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate that decides when to use inter-procedural data-flow.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1NotInterprocedural.html">NotInterprocedural</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate that always returns false, preventing interprocedural analysis.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1NotInterprocedural.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1TransferFunction.html">TransferFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-Flow transfer functor.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1TransferFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a76881e1a9693982c366ef4b417f6f20e" id="r_a76881e1a9693982c366ef4b417f6f20e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> = <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1DfCfgVertex.html">DfCfgVertex</a> &gt;</td></tr>
<tr class="memdesc:a76881e1a9693982c366ef4b417f6f20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph used by data-flow analysis.  <br /></td></tr>
<tr class="separator:a76881e1a9693982c366ef4b417f6f20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708eccca15ab4e07a8af115e4809516d" id="r_a708eccca15ab4e07a8af115e4809516d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1SemanticsMerge.html">Rose::BinaryAnalysis::DataFlow::SemanticsMerge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a708eccca15ab4e07a8af115e4809516d">MergeFunction</a></td></tr>
<tr class="memdesc:a708eccca15ab4e07a8af115e4809516d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-flow merge function.  <br /></td></tr>
<tr class="separator:a708eccca15ab4e07a8af115e4809516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af101f7cb25f27b7b56f3d877d7aece7f" id="r_af101f7cb25f27b7b56f3d877d7aece7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#af101f7cb25f27b7b56f3d877d7aece7f">Engine</a> = <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html">Rose::BinaryAnalysis::DataFlow::Engine</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">InstructionSemantics::BaseSemantics::StatePtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1TransferFunction.html">TransferFunction</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a708eccca15ab4e07a8af115e4809516d">MergeFunction</a> &gt;</td></tr>
<tr class="memdesc:af101f7cb25f27b7b56f3d877d7aece7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-Flow engine.  <br /></td></tr>
<tr class="separator:af101f7cb25f27b7b56f3d877d7aece7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07fa847523fb06f380ecf2cd560506d5" id="r_a07fa847523fb06f380ecf2cd560506d5"><td class="memItemLeft" align="right" valign="top"><a id="a07fa847523fb06f380ecf2cd560506d5" name="a07fa847523fb06f380ecf2cd560506d5"></a>
std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexUnpacker</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1DfCfgVertex.html">DfCfgVertex</a> &amp;)</td></tr>
<tr class="memdesc:a07fa847523fb06f380ecf2cd560506d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a vertex into a list of instructions. <br /></td></tr>
<tr class="separator:a07fa847523fb06f380ecf2cd560506d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e44ecc99233bf07d131663d4874285" id="r_a87e44ecc99233bf07d131663d4874285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a87e44ecc99233bf07d131663d4874285">buildDfCfg</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;, const ControlFlowGraph::ConstVertexIterator &amp;startVertex, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html">InterproceduralPredicate</a> &amp;predicate=NOT_INTERPROCEDURAL)</td></tr>
<tr class="memdesc:a87e44ecc99233bf07d131663d4874285"><td class="mdescLeft">&#160;</td><td class="mdescRight">build a cfg useful for data-flow analysis.  <br /></td></tr>
<tr class="separator:a87e44ecc99233bf07d131663d4874285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e925b08e6e2a0646be27a4d5f9b31b" id="r_ae8e925b08e6e2a0646be27a4d5f9b31b"><td class="memItemLeft" align="right" valign="top"><a id="ae8e925b08e6e2a0646be27a4d5f9b31b" name="ae8e925b08e6e2a0646be27a4d5f9b31b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpDfCfg</b> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &amp;)</td></tr>
<tr class="memdesc:ae8e925b08e6e2a0646be27a4d5f9b31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a data-flow CFG as a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a> file. <br /></td></tr>
<tr class="separator:ae8e925b08e6e2a0646be27a4d5f9b31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f94f42d0be1ee15e9c41201b666779" id="r_a19f94f42d0be1ee15e9c41201b666779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a19f94f42d0be1ee15e9c41201b666779">bestSummaryFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9d20f1665ce8329b95f8fae0e33a8422">FunctionSet</a> &amp;functions)</td></tr>
<tr class="memdesc:a19f94f42d0be1ee15e9c41201b666779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose best function for data-flow summary vertex.  <br /></td></tr>
<tr class="separator:a19f94f42d0be1ee15e9c41201b666779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b3dfaa8618917c9cff5b315bc08e11" id="r_a85b3dfaa8618917c9cff5b315bc08e11"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &gt; </td></tr>
<tr class="memitem:a85b3dfaa8618917c9cff5b315bc08e11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">Sawyer::Container::GraphTraits</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &gt;::VertexIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a85b3dfaa8618917c9cff5b315bc08e11">findReturnVertex</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &amp;dfCfg)</td></tr>
<tr class="memdesc:a85b3dfaa8618917c9cff5b315bc08e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the return vertex.  <br /></td></tr>
<tr class="separator:a85b3dfaa8618917c9cff5b315bc08e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6010cb835fed6104a26b65572d2662" id="r_a5b6010cb835fed6104a26b65572d2662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a5b6010cb835fed6104a26b65572d2662">findStackVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;initialStackPointer)</td></tr>
<tr class="memdesc:a5b6010cb835fed6104a26b65572d2662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all known stack variables.  <br /></td></tr>
<tr class="separator:a5b6010cb835fed6104a26b65572d2662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fd92675e064eb0eee7b4fc9ffb263c" id="r_ad5fd92675e064eb0eee7b4fc9ffb263c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#ad5fd92675e064eb0eee7b4fc9ffb263c">findLocalVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;initialStackPointer)</td></tr>
<tr class="memdesc:ad5fd92675e064eb0eee7b4fc9ffb263c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all known local variables.  <br /></td></tr>
<tr class="separator:ad5fd92675e064eb0eee7b4fc9ffb263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867ccaae16794c0634affe02923c8d9" id="r_a2867ccaae16794c0634affe02923c8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a2867ccaae16794c0634affe02923c8d9">findFunctionArguments</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;initialStackPointer)</td></tr>
<tr class="memdesc:a2867ccaae16794c0634affe02923c8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all known function arguments.  <br /></td></tr>
<tr class="separator:a2867ccaae16794c0634affe02923c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991912d693a0f20296b615bcf892814" id="r_a7991912d693a0f20296b615bcf892814"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a7991912d693a0f20296b615bcf892814">findGlobalVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops, size_t wordNBytes)</td></tr>
<tr class="memdesc:a7991912d693a0f20296b615bcf892814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of global variables.  <br /></td></tr>
<tr class="separator:a7991912d693a0f20296b615bcf892814"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af1f411e8a3420db835a8b51e95bc21e3" id="r_af1f411e8a3420db835a8b51e95bc21e3"><td class="memItemLeft" align="right" valign="top"><a id="af1f411e8a3420db835a8b51e95bc21e3" name="af1f411e8a3420db835a8b51e95bc21e3"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1NotInterprocedural.html">NotInterprocedural</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NOT_INTERPROCEDURAL</b></td></tr>
<tr class="separator:af1f411e8a3420db835a8b51e95bc21e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a76881e1a9693982c366ef4b417f6f20e" name="a76881e1a9693982c366ef4b417f6f20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76881e1a9693982c366ef4b417f6f20e">&#9670;&#160;</a></span>DfCfg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfg</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1DfCfgVertex.html">DfCfgVertex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control flow graph used by data-flow analysis. </p>
<p>The CFG used for data-flow is slightly different than the global CFG maintained by the partitioner. The partitioner's global CFG is tuned for discovering basic blocks and deciding which basic blocks are owned by which functions, whereas a data-flow's CFG is tuned for performing data flow analysis. A data-flow CFG is usually constructed from the partitioner's global CFG, but differs in the following ways:</p>
<ul>
<li>First, data-flow analysis is usually performed on a subset of the partitioner's global CFG. This function uses the <code>startVertex</code> to select some connected subgraph, such as a subgraph corresponding to a single function definition when given the entry block.</li>
</ul>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> return blocks (e.g., RET instructions) are handled differently during data-flow. In the partitioner's global CFG each return block is marked as a function return and has single successor&ndash;the indeterminate vertex. In a data-flow CFG the return blocks are not handled specially, but rather all flow into a single special return vertex that has no instructions. This allows data to be merged from all the return points.</li>
</ul>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call sites are modified. In the partitioner global CFG a function call (e.g., CALL instruction) has an edge (or edges) going to the entry block of the called function(s) and a special call-return edge to the return site if there is one (usually the fall-through address). A data-flow analysis often needs to perform some special action for the call-return, thus a call-return edge in the global CFG gets transformed to an edge-vertex-edge sequence in the data-flow CFG where the middle vertex is a special CALLRET vertex with no instructions. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00123">123</a> of file <a class="el" href="Partitioner2_2DataFlow_8h_source.html">Partitioner2/DataFlow.h</a>.</p>

</div>
</div>
<a id="a708eccca15ab4e07a8af115e4809516d" name="a708eccca15ab4e07a8af115e4809516d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708eccca15ab4e07a8af115e4809516d">&#9670;&#160;</a></span>MergeFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1SemanticsMerge.html">Rose::BinaryAnalysis::DataFlow::SemanticsMerge</a> <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a708eccca15ab4e07a8af115e4809516d">Rose::BinaryAnalysis::Partitioner2::DataFlow::MergeFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data-flow merge function. </p>
<p>Computes the meet of two states, merging the source state into the destination state and returning true iff the destination state changed. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00254">254</a> of file <a class="el" href="Partitioner2_2DataFlow_8h_source.html">Partitioner2/DataFlow.h</a>.</p>

</div>
</div>
<a id="af101f7cb25f27b7b56f3d877d7aece7f" name="af101f7cb25f27b7b56f3d877d7aece7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af101f7cb25f27b7b56f3d877d7aece7f">&#9670;&#160;</a></span>Engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#af101f7cb25f27b7b56f3d877d7aece7f">Rose::BinaryAnalysis::Partitioner2::DataFlow::Engine</a> = typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html">Rose::BinaryAnalysis::DataFlow::Engine</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">InstructionSemantics::BaseSemantics::StatePtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1TransferFunction.html">TransferFunction</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a708eccca15ab4e07a8af115e4809516d">MergeFunction</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data-Flow engine. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00257">257</a> of file <a class="el" href="Partitioner2_2DataFlow_8h_source.html">Partitioner2/DataFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a87e44ecc99233bf07d131663d4874285" name="a87e44ecc99233bf07d131663d4874285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e44ecc99233bf07d131663d4874285">&#9670;&#160;</a></span>buildDfCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> Rose::BinaryAnalysis::Partitioner2::DataFlow::buildDfCfg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>startVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html">InterproceduralPredicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>NOT_INTERPROCEDURAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>build a cfg useful for data-flow analysis. </p>
<p>The returned CFG will be constructed from the global CFG vertices that are reachable from <code>startVertex</code> such that the reached vertex belongs to the same function as <code>startVertex</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e" title="Control flow graph used by data-flow analysis.">DfCfg</a> </dd></dl>

</div>
</div>
<a id="a19f94f42d0be1ee15e9c41201b666779" name="a19f94f42d0be1ee15e9c41201b666779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f94f42d0be1ee15e9c41201b666779">&#9670;&#160;</a></span>bestSummaryFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::DataFlow::bestSummaryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9d20f1665ce8329b95f8fae0e33a8422">FunctionSet</a> &amp;&#160;</td>
          <td class="paramname"><em>functions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose best function for data-flow summary vertex. </p>
<p>When replacing a function call edge with a function summary, we insert a data-flow vertex that points to a function. During the data-flow processing, the function's information summarizes the data-flow state changes that are necessary. If multiple functions own the target block of a function call edge then we need to choose the "best" function to use. </p>

</div>
</div>
<a id="a85b3dfaa8618917c9cff5b315bc08e11" name="a85b3dfaa8618917c9cff5b315bc08e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b3dfaa8618917c9cff5b315bc08e11">&#9670;&#160;</a></span>findReturnVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSawyer_1_1Container_1_1GraphTraits.html">Sawyer::Container::GraphTraits</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &gt;::VertexIterator Rose::BinaryAnalysis::Partitioner2::DataFlow::findReturnVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a76881e1a9693982c366ef4b417f6f20e">DfCfg</a> &amp;&#160;</td>
          <td class="paramname"><em>dfCfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the return vertex. </p>
<p>Finds the FUNCRET vertex. <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> returns all flow into this special vertex, but if there are no function return blocks then this vertex also doesn't exist (in which case the end iterator is returned). Do not call this if there's a chance that the data-flow CFG has more than one FUNCRET vertex. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00174">174</a> of file <a class="el" href="Partitioner2_2DataFlow_8h_source.html">Partitioner2/DataFlow.h</a>.</p>

<p class="reference">References <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00035">Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::FUNCRET</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

</div>
</div>
<a id="a5b6010cb835fed6104a26b65572d2662" name="a5b6010cb835fed6104a26b65572d2662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6010cb835fed6104a26b65572d2662">&#9670;&#160;</a></span>findStackVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a> Rose::BinaryAnalysis::Partitioner2::DataFlow::findStackVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>initialStackPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of all known stack variables. </p>
<p>A stack variable is any memory location whose address is a constant offset from an initial stack pointer. That is, the address has the form (add SP0 CONSTANT) where SP0 is a variable supplied as an argument to this function. When CONSTANT is zero the expression is simplified to SP0, so that also is accepted. Although memory is byte addressable and values are stored as individual bytes in memory, this function attempts to sew related addresses back together again to produce variables that are multiple bytes. There are many ways to do this, all of which are heuristic.</p>
<p>The <code>ops</code> provides the operators for comparing stack pointers, and also provides the state which is examined to find the stack variables. The underlying memory state should be of type <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html">MemoryCellList</a> or a subclass, or else no stack variables will be found. </p>

</div>
</div>
<a id="ad5fd92675e064eb0eee7b4fc9ffb263c" name="ad5fd92675e064eb0eee7b4fc9ffb263c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd92675e064eb0eee7b4fc9ffb263c">&#9670;&#160;</a></span>findLocalVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a> Rose::BinaryAnalysis::Partitioner2::DataFlow::findLocalVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>initialStackPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of all known local variables. </p>
<p>A local variable is any stack variable whose starting address is less than the specified stack pointer. For the definition of stack variable, see <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a5b6010cb835fed6104a26b65572d2662">findStackVariables</a>. </p>

</div>
</div>
<a id="a2867ccaae16794c0634affe02923c8d9" name="a2867ccaae16794c0634affe02923c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2867ccaae16794c0634affe02923c8d9">&#9670;&#160;</a></span>findFunctionArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">Variables::StackVariables</a> Rose::BinaryAnalysis::Partitioner2::DataFlow::findFunctionArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>initialStackPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of all known function arguments. </p>
<p>A function argument is any stack variable whose starting address is greater than or equal to the specified stack pointer. For the definition of stack variable, see <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a5b6010cb835fed6104a26b65572d2662">findStackVariables</a>. On architectures that pass a return address on the top of the stack, that return address is considered to be the first argument of the function. </p>

</div>
</div>
<a id="a7991912d693a0f20296b615bcf892814" name="a7991912d693a0f20296b615bcf892814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7991912d693a0f20296b615bcf892814">&#9670;&#160;</a></span>findGlobalVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &gt; Rose::BinaryAnalysis::Partitioner2::DataFlow::findGlobalVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wordNBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of global variables. </p>
<p>The returned abstract locations all point to memory. The <code>wordNBytes</code> is the maximum size for any returned variable; larger units of memory written to by the same instruction will be broken into smaller variables. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
