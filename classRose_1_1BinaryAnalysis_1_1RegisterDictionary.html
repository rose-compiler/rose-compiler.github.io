<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::RegisterDictionary Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html">RegisterDictionary</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::RegisterDictionary Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Defines registers available for a particular architecture. </p>
<p>The dictionary maps each register name to a <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a>. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> describes how a register name maps to (part of) a physical CPU register by providing a major number, minor number, bit offset, and number of bits. The major number is typically a register class number and the minor number is typically an offset within the class. For instance, for x86 the major numbers might indicate whether a register is a general purpose register, an 80-bit floating point register, a 128-bit MMX register, etc.</p>
<p>Users should not assume that the values of a <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> correspond to actual values found in the machine instructions that were disassembled. What they can assume is that two unrelated registers (such as "eax" and "ebx") do not overlap in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> address space (major, minor, offset, size). They can also assume that two related registers (such as "eax" and "rax", the 32- and 64-bit versions of a single CPU register) do, in fact, overlap in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> address space and that the overlap indicates how the registers are related.</p>
<p>Users should not assume that <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> entries from two separate dictionaries are compatible, although the dictionaries created by the ROSE library do use compatible descriptors across each family. Looking up the "eax" register in one dictionary may return a different descriptor than "eax" looked up in a different dictionary (but not in ROSE-created dictinaries). Components of the ROSE binary support that generate RegisterDescriptors provide a mechanism for obtaining (and possibly setting) the register dictionary. For instance, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Disassembler::Base</a> class has get_registers() and set_registers() methods. </p>

<p class="definition">Definition at line <a class="el" href="RegisterDictionary_8h_source.html#l00046">46</a> of file <a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="RegisterDictionary_8h_source.html">Rose/BinaryAnalysis/RegisterDictionary.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::RegisterDictionary:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1RegisterDictionary__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1RegisterDictionary_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1RegisterDictionary_inherit__map" id="aRose_1_1BinaryAnalysis_1_1RegisterDictionary_inherit__map">
<area shape="rect" title="Defines registers available for a particular architecture." alt="" coords="8,79,156,119"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,31"/>
<area shape="poly" title=" " alt="" coords="85,44,85,78,79,78,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::RegisterDictionary:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1RegisterDictionary__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1RegisterDictionary_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1RegisterDictionary_coll__map" id="aRose_1_1BinaryAnalysis_1_1RegisterDictionary_coll__map">
<area shape="rect" title="Defines registers available for a particular architecture." alt="" coords="8,79,156,119"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,31"/>
<area shape="poly" title=" " alt="" coords="85,44,85,78,79,78,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">SortBySize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares number of bits in register descriptors.  <a href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae67aef087fe8d3792ddeb021b79b927c" id="r_ae67aef087fe8d3792ddeb021b79b927c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a></td></tr>
<tr class="memdesc:ae67aef087fe8d3792ddeb021b79b927c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:ae67aef087fe8d3792ddeb021b79b927c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17998fec3505c118fa117252cdff137" id="r_aa17998fec3505c118fa117252cdff137"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa17998fec3505c118fa117252cdff137">Entries</a> = std::map&lt; std::string, <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt;</td></tr>
<tr class="memdesc:aa17998fec3505c118fa117252cdff137"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of registers in dictionary.  <br /></td></tr>
<tr class="separator:aa17998fec3505c118fa117252cdff137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500242df223c9f4975874de40e081444" id="r_a500242df223c9f4975874de40e081444"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#af7c1782aaca4c584eda00e115508b268">Rose::BinaryAnalysis::RegisterDescriptors</a></td></tr>
<tr class="memdesc:a500242df223c9f4975874de40e081444"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of register descriptors in dictionary.  <br /></td></tr>
<tr class="separator:a500242df223c9f4975874de40e081444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab315186e0229c7abde9360f88e040722" id="r_ab315186e0229c7abde9360f88e040722"><td class="memItemLeft" align="right" valign="top"><a id="ab315186e0229c7abde9360f88e040722" name="ab315186e0229c7abde9360f88e040722"></a>
const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa17998fec3505c118fa117252cdff137">Entries</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>registers</b> () const</td></tr>
<tr class="memdesc:ab315186e0229c7abde9360f88e040722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all register definitions in the dictionary. <br /></td></tr>
<tr class="separator:ab315186e0229c7abde9360f88e040722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4461ab3d2d95763a2b845520ca51e64" id="r_ac4461ab3d2d95763a2b845520ca51e64"><td class="memItemLeft" align="right" valign="top"><a id="ac4461ab3d2d95763a2b845520ca51e64" name="ac4461ab3d2d95763a2b845520ca51e64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:ac4461ab3d2d95763a2b845520ca51e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of entries in the dictionary. <br /></td></tr>
<tr class="separator:ac4461ab3d2d95763a2b845520ca51e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf71679566b2169d43246625949292c" id="r_a3bf71679566b2169d43246625949292c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a3bf71679566b2169d43246625949292c">insert</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a3bf71679566b2169d43246625949292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a definition into the dictionary.  <br /></td></tr>
<tr class="separator:a3bf71679566b2169d43246625949292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3a11fb8d740eff3cbf07872c072491" id="r_a9d3a11fb8d740eff3cbf07872c072491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a9d3a11fb8d740eff3cbf07872c072491">insert</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>, unsigned majr, unsigned minr, unsigned offset, unsigned nbits)</td></tr>
<tr class="memdesc:a9d3a11fb8d740eff3cbf07872c072491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a definition into the dictionary.  <br /></td></tr>
<tr class="separator:a9d3a11fb8d740eff3cbf07872c072491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4669ac57faeeccb83cc7486431f0f56" id="r_af4669ac57faeeccb83cc7486431f0f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#af4669ac57faeeccb83cc7486431f0f56">insert</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Ptr</a> &amp;)</td></tr>
<tr class="memdesc:af4669ac57faeeccb83cc7486431f0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts definitions from another dictionary into this dictionary.  <br /></td></tr>
<tr class="separator:af4669ac57faeeccb83cc7486431f0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad09cb14c2893a97ac2b5a64173467d9" id="r_aad09cb14c2893a97ac2b5a64173467d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aad09cb14c2893a97ac2b5a64173467d9">resize</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>, unsigned new_nbits)</td></tr>
<tr class="memdesc:aad09cb14c2893a97ac2b5a64173467d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of a register.  <br /></td></tr>
<tr class="separator:aad09cb14c2893a97ac2b5a64173467d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b25b629bb223047fd9da05babce27e" id="r_af4b25b629bb223047fd9da05babce27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#af4b25b629bb223047fd9da05babce27e">find</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>) const</td></tr>
<tr class="memdesc:af4b25b629bb223047fd9da05babce27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a register by name.  <br /></td></tr>
<tr class="separator:af4b25b629bb223047fd9da05babce27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc40c9247ca0a52108d861c80bc7c7c" id="r_a4bc40c9247ca0a52108d861c80bc7c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a4bc40c9247ca0a52108d861c80bc7c7c">findOrThrow</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>) const</td></tr>
<tr class="memdesc:a4bc40c9247ca0a52108d861c80bc7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a register by name.  <br /></td></tr>
<tr class="separator:a4bc40c9247ca0a52108d861c80bc7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967f382e67abaccca1f790d475568095" id="r_a967f382e67abaccca1f790d475568095"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a967f382e67abaccca1f790d475568095">lookup</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:a967f382e67abaccca1f790d475568095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a register name for a given descriptor.  <br /></td></tr>
<tr class="separator:a967f382e67abaccca1f790d475568095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404b35c076cf377707fff4774a176c6c" id="r_a404b35c076cf377707fff4774a176c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a404b35c076cf377707fff4774a176c6c">exists</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:a404b35c076cf377707fff4774a176c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a register descriptor exists.  <br /></td></tr>
<tr class="separator:a404b35c076cf377707fff4774a176c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadd293969065b0f4a2a1a04c87e96a2" id="r_acadd293969065b0f4a2a1a04c87e96a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#acadd293969065b0f4a2a1a04c87e96a2">findLargestRegister</a> (unsigned major, unsigned minor, size_t maxWidth=0) const</td></tr>
<tr class="memdesc:acadd293969065b0f4a2a1a04c87e96a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first largest register with specified major and minor number.  <br /></td></tr>
<tr class="separator:acadd293969065b0f4a2a1a04c87e96a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f9bf9616933d1e49afd9c39941b46" id="r_a7f1f9bf9616933d1e49afd9c39941b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a7f1f9bf9616933d1e49afd9c39941b46">name</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:a7f1f9bf9616933d1e49afd9c39941b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the register or nothing.  <br /></td></tr>
<tr class="separator:a7f1f9bf9616933d1e49afd9c39941b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3d2722c5b0eb1239b35d4b129957b1" id="r_afb3d2722c5b0eb1239b35d4b129957b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#afb3d2722c5b0eb1239b35d4b129957b1">nameOrQuad</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:afb3d2722c5b0eb1239b35d4b129957b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name or quad.  <br /></td></tr>
<tr class="separator:afb3d2722c5b0eb1239b35d4b129957b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be5b0c32894086ce16bd4afd3a8eee0" id="r_a8be5b0c32894086ce16bd4afd3a8eee0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a8be5b0c32894086ce16bd4afd3a8eee0">nameAndQuad</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:a8be5b0c32894086ce16bd4afd3a8eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name and quad.  <br /></td></tr>
<tr class="separator:a8be5b0c32894086ce16bd4afd3a8eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656256f500868e4f85e5fab9d0278ea0" id="r_a656256f500868e4f85e5fab9d0278ea0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a656256f500868e4f85e5fab9d0278ea0">quadAndName</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:a656256f500868e4f85e5fab9d0278ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quad and name.  <br /></td></tr>
<tr class="separator:a656256f500868e4f85e5fab9d0278ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8ea02917c5c9dbf3d9400cd27ea903" id="r_a1f8ea02917c5c9dbf3d9400cd27ea903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">Rose::BinaryAnalysis::RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a1f8ea02917c5c9dbf3d9400cd27ea903">getAllParts</a> () const</td></tr>
<tr class="memdesc:a1f8ea02917c5c9dbf3d9400cd27ea903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all register parts.  <br /></td></tr>
<tr class="separator:a1f8ea02917c5c9dbf3d9400cd27ea903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2dce99ab3b31d72799fb767c2c04b8" id="r_a7f2dce99ab3b31d72799fb767c2c04b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a7f2dce99ab3b31d72799fb767c2c04b8">getDescriptors</a> () const</td></tr>
<tr class="memdesc:a7f2dce99ab3b31d72799fb767c2c04b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all register descriptors.  <br /></td></tr>
<tr class="separator:a7f2dce99ab3b31d72799fb767c2c04b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bab60e6bd58c39dc4782ff0549f0d0e" id="r_a6bab60e6bd58c39dc4782ff0549f0d0e"><td class="memItemLeft" align="right" valign="top"><a id="a6bab60e6bd58c39dc4782ff0549f0d0e" name="a6bab60e6bd58c39dc4782ff0549f0d0e"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>firstUnusedMajor</b> () const</td></tr>
<tr class="memdesc:a6bab60e6bd58c39dc4782ff0549f0d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first unused major register number. <br /></td></tr>
<tr class="separator:a6bab60e6bd58c39dc4782ff0549f0d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffd45167dc48a4d5cc61fe2dc11d231" id="r_adffd45167dc48a4d5cc61fe2dc11d231"><td class="memItemLeft" align="right" valign="top"><a id="adffd45167dc48a4d5cc61fe2dc11d231" name="adffd45167dc48a4d5cc61fe2dc11d231"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>firstUnusedMinor</b> (unsigned majr) const</td></tr>
<tr class="memdesc:adffd45167dc48a4d5cc61fe2dc11d231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first unused minor register number. <br /></td></tr>
<tr class="separator:adffd45167dc48a4d5cc61fe2dc11d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4124e9972cc94b1f6035e42184fd5a4" id="r_af4124e9972cc94b1f6035e42184fd5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#af4124e9972cc94b1f6035e42184fd5a4">getLargestRegisters</a> () const</td></tr>
<tr class="memdesc:af4124e9972cc94b1f6035e42184fd5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the largest non-overlapping registers.  <br /></td></tr>
<tr class="separator:af4124e9972cc94b1f6035e42184fd5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ba50423703b2122f3f9c648a7e92ae" id="r_a06ba50423703b2122f3f9c648a7e92ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a06ba50423703b2122f3f9c648a7e92ae">getSmallestRegisters</a> () const</td></tr>
<tr class="memdesc:a06ba50423703b2122f3f9c648a7e92ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the smallest non-overlapping registers.  <br /></td></tr>
<tr class="separator:a06ba50423703b2122f3f9c648a7e92ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33bda123316d2c8405ceacb97e77b2ce" id="r_a33bda123316d2c8405ceacb97e77b2ce"><td class="memItemLeft" align="right" valign="top"><a id="a33bda123316d2c8405ceacb97e77b2ce" name="a33bda123316d2c8405ceacb97e77b2ce"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const</td></tr>
<tr class="memdesc:a33bda123316d2c8405ceacb97e77b2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> name. <br /></td></tr>
<tr class="separator:a33bda123316d2c8405ceacb97e77b2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2ab66df01ad6e9a47e56d5693fa6c" id="r_a0cd2ab66df01ad6e9a47e56d5693fa6c"><td class="memItemLeft" align="right" valign="top"><a id="a0cd2ab66df01ad6e9a47e56d5693fa6c" name="a0cd2ab66df01ad6e9a47e56d5693fa6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a0cd2ab66df01ad6e9a47e56d5693fa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> name. <br /></td></tr>
<tr class="separator:a0cd2ab66df01ad6e9a47e56d5693fa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3cee64125d12b2a76b573c1d678a839" id="r_aa3cee64125d12b2a76b573c1d678a839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa3cee64125d12b2a76b573c1d678a839">instructionPointerRegister</a> () const</td></tr>
<tr class="memdesc:aa3cee64125d12b2a76b573c1d678a839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to instructions.  <br /></td></tr>
<tr class="separator:aa3cee64125d12b2a76b573c1d678a839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4952050ee91b0f7fe29d935a0da64519" id="r_a4952050ee91b0f7fe29d935a0da64519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a4952050ee91b0f7fe29d935a0da64519">instructionPointerRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a4952050ee91b0f7fe29d935a0da64519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to instructions.  <br /></td></tr>
<tr class="separator:a4952050ee91b0f7fe29d935a0da64519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e3af03bd2ac2defb0d671f2f945df" id="r_a8f8e3af03bd2ac2defb0d671f2f945df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a8f8e3af03bd2ac2defb0d671f2f945df">instructionPointerRegister</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a8f8e3af03bd2ac2defb0d671f2f945df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to instructions.  <br /></td></tr>
<tr class="separator:a8f8e3af03bd2ac2defb0d671f2f945df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad98cd5e1f62ccaede27a04a9f0dab32d" id="r_ad98cd5e1f62ccaede27a04a9f0dab32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ad98cd5e1f62ccaede27a04a9f0dab32d">stackPointerRegister</a> () const</td></tr>
<tr class="memdesc:ad98cd5e1f62ccaede27a04a9f0dab32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to the stack.  <br /></td></tr>
<tr class="separator:ad98cd5e1f62ccaede27a04a9f0dab32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b888e12c9c3e149f0f4810aabd720ad" id="r_a1b888e12c9c3e149f0f4810aabd720ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a1b888e12c9c3e149f0f4810aabd720ad">stackPointerRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a1b888e12c9c3e149f0f4810aabd720ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to the stack.  <br /></td></tr>
<tr class="separator:a1b888e12c9c3e149f0f4810aabd720ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd59ec547af3910ac9b406f83965999" id="r_aafd59ec547af3910ac9b406f83965999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aafd59ec547af3910ac9b406f83965999">stackPointerRegister</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:aafd59ec547af3910ac9b406f83965999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that points to the stack.  <br /></td></tr>
<tr class="separator:aafd59ec547af3910ac9b406f83965999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a06033c5c11d3a256e6ce4697bbf1e58b" id="r_a06033c5c11d3a256e6ce4697bbf1e58b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a06033c5c11d3a256e6ce4697bbf1e58b">stackFrameRegister</a> () const</td></tr>
<tr class="memdesc:a06033c5c11d3a256e6ce4697bbf1e58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that ponts to the stack frame.  <br /></td></tr>
<tr class="separator:a06033c5c11d3a256e6ce4697bbf1e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ec7071313c55a55d23528a2f66bbc3" id="r_a29ec7071313c55a55d23528a2f66bbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a29ec7071313c55a55d23528a2f66bbc3">stackFrameRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a29ec7071313c55a55d23528a2f66bbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that ponts to the stack frame.  <br /></td></tr>
<tr class="separator:a29ec7071313c55a55d23528a2f66bbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87173f3bd6bc07298de1b36f277f71da" id="r_a87173f3bd6bc07298de1b36f277f71da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a87173f3bd6bc07298de1b36f277f71da">stackFrameRegister</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a87173f3bd6bc07298de1b36f277f71da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that ponts to the stack frame.  <br /></td></tr>
<tr class="separator:a87173f3bd6bc07298de1b36f277f71da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea60f34d3dab37ea7dec78c67442e704" id="r_aea60f34d3dab37ea7dec78c67442e704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aea60f34d3dab37ea7dec78c67442e704">stackSegmentRegister</a> () const</td></tr>
<tr class="memdesc:aea60f34d3dab37ea7dec78c67442e704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The segment register for accessing the stack.  <br /></td></tr>
<tr class="separator:aea60f34d3dab37ea7dec78c67442e704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3f56ad32e19bf2f529165a05965980" id="r_a2b3f56ad32e19bf2f529165a05965980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a2b3f56ad32e19bf2f529165a05965980">stackSegmentRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a2b3f56ad32e19bf2f529165a05965980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The segment register for accessing the stack.  <br /></td></tr>
<tr class="separator:a2b3f56ad32e19bf2f529165a05965980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc07ea97912c630b8bc33c07c57525f" id="r_a4cc07ea97912c630b8bc33c07c57525f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a4cc07ea97912c630b8bc33c07c57525f">stackSegmentRegister</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a4cc07ea97912c630b8bc33c07c57525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The segment register for accessing the stack.  <br /></td></tr>
<tr class="separator:a4cc07ea97912c630b8bc33c07c57525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa96fbf4125911f9f40994eedca01ebb0" id="r_aa96fbf4125911f9f40994eedca01ebb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa96fbf4125911f9f40994eedca01ebb0">callReturnRegister</a> () const</td></tr>
<tr class="memdesc:aa96fbf4125911f9f40994eedca01ebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that holds the return address for a function.  <br /></td></tr>
<tr class="separator:aa96fbf4125911f9f40994eedca01ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9341ed31ca7069962946f2c98c063b11" id="r_a9341ed31ca7069962946f2c98c063b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a9341ed31ca7069962946f2c98c063b11">callReturnRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a9341ed31ca7069962946f2c98c063b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that holds the return address for a function.  <br /></td></tr>
<tr class="separator:a9341ed31ca7069962946f2c98c063b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657043508be084d332873bf7ad201629" id="r_a657043508be084d332873bf7ad201629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a657043508be084d332873bf7ad201629">callReturnRegister</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a657043508be084d332873bf7ad201629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: The register that holds the return address for a function.  <br /></td></tr>
<tr class="separator:a657043508be084d332873bf7ad201629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a38a56560bc415276e379a113e22fdd9a" id="r_a38a56560bc415276e379a113e22fdd9a"><td class="memItemLeft" align="right" valign="top"><a id="a38a56560bc415276e379a113e22fdd9a" name="a38a56560bc415276e379a113e22fdd9a"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>)</td></tr>
<tr class="memdesc:a38a56560bc415276e379a113e22fdd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor for an empty dictionary. <br /></td></tr>
<tr class="separator:a38a56560bc415276e379a113e22fdd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6fb92478e7ec45917fef0e0718e573" id="r_a4a6fb92478e7ec45917fef0e0718e573"><td class="memItemLeft" align="right" valign="top"><a id="a4a6fb92478e7ec45917fef0e0718e573" name="a4a6fb92478e7ec45917fef0e0718e573"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instanceNull</b> ()</td></tr>
<tr class="memdesc:a4a6fb92478e7ec45917fef0e0718e573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mostly empty dictionary for the null ISA. <br /></td></tr>
<tr class="separator:a4a6fb92478e7ec45917fef0e0718e573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d96a5e48b42267d1f94fc75821782b" id="r_aa4d96a5e48b42267d1f94fc75821782b"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:aa4d96a5e48b42267d1f94fc75821782b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa4d96a5e48b42267d1f94fc75821782b">filterNonoverlapping</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> reglist, Compare order=<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">SortBySize</a>(), bool reconsiderParts=true)</td></tr>
<tr class="memdesc:aa4d96a5e48b42267d1f94fc75821782b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of non-overlapping registers or register parts.  <br /></td></tr>
<tr class="separator:aa4d96a5e48b42267d1f94fc75821782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aff9c7ed45db4e9d88554bd8fcaf3057c" id="r_aff9c7ed45db4e9d88554bd8fcaf3057c"><td class="memItemLeft" align="right" valign="top"><a id="aff9c7ed45db4e9d88554bd8fcaf3057c" name="aff9c7ed45db4e9d88554bd8fcaf3057c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterDictionary</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a33bda123316d2c8405ceacb97e77b2ce">name</a>)</td></tr>
<tr class="separator:aff9c7ed45db4e9d88554bd8fcaf3057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99184c18ab1fecde5c74f6859a43f161" id="r_a99184c18ab1fecde5c74f6859a43f161"><td class="memItemLeft" align="right" valign="top"><a id="a99184c18ab1fecde5c74f6859a43f161" name="a99184c18ab1fecde5c74f6859a43f161"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterDictionary</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html">RegisterDictionary</a> &amp;other)</td></tr>
<tr class="separator:a99184c18ab1fecde5c74f6859a43f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f47ba79a993e060377a651f2d5b570" id="r_a93f47ba79a993e060377a651f2d5b570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a93f47ba79a993e060377a651f2d5b570">print</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a93f47ba79a993e060377a651f2d5b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of this register dictionary.  <br /></td></tr>
<tr class="separator:a93f47ba79a993e060377a651f2d5b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae67aef087fe8d3792ddeb021b79b927c" name="ae67aef087fe8d3792ddeb021b79b927c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67aef087fe8d3792ddeb021b79b927c">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Rose::BinaryAnalysis::RegisterDictionary::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="RegisterDictionary_8h_source.html#l00053">53</a> of file <a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a>.</p>

</div>
</div>
<a id="aa17998fec3505c118fa117252cdff137" name="aa17998fec3505c118fa117252cdff137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17998fec3505c118fa117252cdff137">&#9670;&#160;</a></span>Entries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#aa17998fec3505c118fa117252cdff137">Rose::BinaryAnalysis::RegisterDictionary::Entries</a> =  std::map&lt;std::string, <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of registers in dictionary. </p>

<p class="definition">Definition at line <a class="el" href="RegisterDictionary_8h_source.html#l00056">56</a> of file <a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a>.</p>

</div>
</div>
<a id="a500242df223c9f4975874de40e081444" name="a500242df223c9f4975874de40e081444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500242df223c9f4975874de40e081444">&#9670;&#160;</a></span>RegisterDescriptors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">Rose::BinaryAnalysis::RegisterDictionary::RegisterDescriptors</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#af7c1782aaca4c584eda00e115508b268">Rose::BinaryAnalysis::RegisterDescriptors</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of register descriptors in dictionary. </p>

<p class="definition">Definition at line <a class="el" href="RegisterDictionary_8h_source.html#l00059">59</a> of file <a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bf71679566b2169d43246625949292c" name="a3bf71679566b2169d43246625949292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf71679566b2169d43246625949292c">&#9670;&#160;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a definition into the dictionary. </p>
<p>If the name already exists in the dictionary then the new <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> will replace the one that already exists. </p>

</div>
</div>
<a id="a9d3a11fb8d740eff3cbf07872c072491" name="a9d3a11fb8d740eff3cbf07872c072491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3a11fb8d740eff3cbf07872c072491">&#9670;&#160;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>majr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a definition into the dictionary. </p>
<p>If the name already exists in the dictionary then the new <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> will replace the one that already exists. </p>

</div>
</div>
<a id="af4669ac57faeeccb83cc7486431f0f56" name="af4669ac57faeeccb83cc7486431f0f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4669ac57faeeccb83cc7486431f0f56">&#9670;&#160;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#ae67aef087fe8d3792ddeb021b79b927c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts definitions from another dictionary into this dictionary. </p>
<p>Names in the other dictionary that are the same as names in this dictionary will replace the definitions in this dictionary. </p>

</div>
</div>
<a id="aad09cb14c2893a97ac2b5a64173467d9" name="aad09cb14c2893a97ac2b5a64173467d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad09cb14c2893a97ac2b5a64173467d9">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::resize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>new_nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the size of a register. </p>
<p>This is a common enough operation that we have a special method to do it. To change other properties of a register you would look up the register descriptor, change the property, then re-insert the register into the dictionary using the new descriptor. This method does exactly that. </p>

</div>
</div>
<a id="af4b25b629bb223047fd9da05babce27e" name="af4b25b629bb223047fd9da05babce27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b25b629bb223047fd9da05babce27e">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::find </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a register by name. </p>
<p>Looks up the descriptor for the register having the specified name. If no descriptor exists for that name then a default constructed invalid descriptor is returned. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a4bc40c9247ca0a52108d861c80bc7c7c">findOrThrow</a>. </p>

</div>
</div>
<a id="a4bc40c9247ca0a52108d861c80bc7c7c" name="a4bc40c9247ca0a52108d861c80bc7c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc40c9247ca0a52108d861c80bc7c7c">&#9670;&#160;</a></span>findOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::findOrThrow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a register by name. </p>
<p>Looks up the descriptor for the register having the specified name. If no descriptor exists for that name then a <a class="el" href="classRose_1_1Exception.html">Rose::Exception</a> is thrown. See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#af4b25b629bb223047fd9da05babce27e">find</a>. </p>

</div>
</div>
<a id="a967f382e67abaccca1f790d475568095" name="a967f382e67abaccca1f790d475568095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967f382e67abaccca1f790d475568095">&#9670;&#160;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::RegisterDictionary::lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a register name for a given descriptor. </p>
<p>If more than one register has the same descriptor then the name added latest is returned. If no register is found then return the empty string. </p>

</div>
</div>
<a id="a404b35c076cf377707fff4774a176c6c" name="a404b35c076cf377707fff4774a176c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404b35c076cf377707fff4774a176c6c">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::RegisterDictionary::exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a register descriptor exists. </p>
<p>This is similar to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a967f382e67abaccca1f790d475568095">lookup</a> method that takes a <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> argument, but instead of returning the name it returns true if found, false if not found. </p>

</div>
</div>
<a id="acadd293969065b0f4a2a1a04c87e96a2" name="acadd293969065b0f4a2a1a04c87e96a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadd293969065b0f4a2a1a04c87e96a2">&#9670;&#160;</a></span>findLargestRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::findLargestRegister </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxWidth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first largest register with specified major and minor number. </p>
<p>Returns the first register with the largest width and having the specified major and minor numbers. Registers wider than <code>maxWidth</code> (if non-zero) are ignored. If no register is found with the major/minor number then an invalid (default-constructed) register is returned.</p>
<p>This function takes O(n) time where n is the number of registers defined. </p>

</div>
</div>
<a id="a7f1f9bf9616933d1e49afd9c39941b46" name="a7f1f9bf9616933d1e49afd9c39941b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1f9bf9616933d1e49afd9c39941b46">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; std::string &gt; Rose::BinaryAnalysis::RegisterDictionary::name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the register or nothing. </p>
<p>Returns the non-empty name of the register if available, or nothing. </p>

</div>
</div>
<a id="afb3d2722c5b0eb1239b35d4b129957b1" name="afb3d2722c5b0eb1239b35d4b129957b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3d2722c5b0eb1239b35d4b129957b1">&#9670;&#160;</a></span>nameOrQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::RegisterDictionary::nameOrQuad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name or quad. </p>
<p>Returns the name of the register if available, or else the quad. The quad is generated from the <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html#a7260c4334b9a740bf26dff3a86f355a2">RegisterDescriptor::toString</a> method. </p>

</div>
</div>
<a id="a8be5b0c32894086ce16bd4afd3a8eee0" name="a8be5b0c32894086ce16bd4afd3a8eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be5b0c32894086ce16bd4afd3a8eee0">&#9670;&#160;</a></span>nameAndQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::RegisterDictionary::nameAndQuad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name and quad. </p>
<p>If the register has a name, then this function returns the name in quotes using C string literal escapes followed by the quad. Otherwise just the quad is returned. The quad is generated by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html#a7260c4334b9a740bf26dff3a86f355a2">RegisterDescriptor::toString</a>. </p>

</div>
</div>
<a id="a656256f500868e4f85e5fab9d0278ea0" name="a656256f500868e4f85e5fab9d0278ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656256f500868e4f85e5fab9d0278ea0">&#9670;&#160;</a></span>quadAndName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::RegisterDictionary::quadAndName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quad and name. </p>
<p>Returns a string containing the register quad. If the register has a name then it follows in quotes using C string literal escapes. The quad is generated by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html#a7260c4334b9a740bf26dff3a86f355a2">RegisterDescriptor::toString</a>. </p>

</div>
</div>
<a id="aa3cee64125d12b2a76b573c1d678a839" name="aa3cee64125d12b2a76b573c1d678a839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cee64125d12b2a76b573c1d678a839">&#9670;&#160;</a></span>instructionPointerRegister() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to instructions. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a4952050ee91b0f7fe29d935a0da64519" name="a4952050ee91b0f7fe29d935a0da64519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4952050ee91b0f7fe29d935a0da64519">&#9670;&#160;</a></span>instructionPointerRegister() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to instructions. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a8f8e3af03bd2ac2defb0d671f2f945df" name="a8f8e3af03bd2ac2defb0d671f2f945df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8e3af03bd2ac2defb0d671f2f945df">&#9670;&#160;</a></span>instructionPointerRegister() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to instructions. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="ad98cd5e1f62ccaede27a04a9f0dab32d" name="ad98cd5e1f62ccaede27a04a9f0dab32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98cd5e1f62ccaede27a04a9f0dab32d">&#9670;&#160;</a></span>stackPointerRegister() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::stackPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to the stack. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a1b888e12c9c3e149f0f4810aabd720ad" name="a1b888e12c9c3e149f0f4810aabd720ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b888e12c9c3e149f0f4810aabd720ad">&#9670;&#160;</a></span>stackPointerRegister() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackPointerRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to the stack. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="aafd59ec547af3910ac9b406f83965999" name="aafd59ec547af3910ac9b406f83965999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd59ec547af3910ac9b406f83965999">&#9670;&#160;</a></span>stackPointerRegister() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackPointerRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that points to the stack. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a06033c5c11d3a256e6ce4697bbf1e58b" name="a06033c5c11d3a256e6ce4697bbf1e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06033c5c11d3a256e6ce4697bbf1e58b">&#9670;&#160;</a></span>stackFrameRegister() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::stackFrameRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that ponts to the stack frame. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a29ec7071313c55a55d23528a2f66bbc3" name="a29ec7071313c55a55d23528a2f66bbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ec7071313c55a55d23528a2f66bbc3">&#9670;&#160;</a></span>stackFrameRegister() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackFrameRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that ponts to the stack frame. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a87173f3bd6bc07298de1b36f277f71da" name="a87173f3bd6bc07298de1b36f277f71da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87173f3bd6bc07298de1b36f277f71da">&#9670;&#160;</a></span>stackFrameRegister() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackFrameRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that ponts to the stack frame. </p>
<p>If this architecture has no such register (most do) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="aea60f34d3dab37ea7dec78c67442e704" name="aea60f34d3dab37ea7dec78c67442e704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea60f34d3dab37ea7dec78c67442e704">&#9670;&#160;</a></span>stackSegmentRegister() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::stackSegmentRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The segment register for accessing the stack. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a2b3f56ad32e19bf2f529165a05965980" name="a2b3f56ad32e19bf2f529165a05965980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3f56ad32e19bf2f529165a05965980">&#9670;&#160;</a></span>stackSegmentRegister() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackSegmentRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The segment register for accessing the stack. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a4cc07ea97912c630b8bc33c07c57525f" name="a4cc07ea97912c630b8bc33c07c57525f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc07ea97912c630b8bc33c07c57525f">&#9670;&#160;</a></span>stackSegmentRegister() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::stackSegmentRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The segment register for accessing the stack. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="aa96fbf4125911f9f40994eedca01ebb0" name="aa96fbf4125911f9f40994eedca01ebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96fbf4125911f9f40994eedca01ebb0">&#9670;&#160;</a></span>callReturnRegister() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::RegisterDictionary::callReturnRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that holds the return address for a function. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a9341ed31ca7069962946f2c98c063b11" name="a9341ed31ca7069962946f2c98c063b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9341ed31ca7069962946f2c98c063b11">&#9670;&#160;</a></span>callReturnRegister() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::callReturnRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that holds the return address for a function. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a657043508be084d332873bf7ad201629" name="a657043508be084d332873bf7ad201629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657043508be084d332873bf7ad201629">&#9670;&#160;</a></span>callReturnRegister() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::callReturnRegister </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: The register that holds the return address for a function. </p>
<p>If this architecture has no such register (most don't) then this property stores an empty register descriptor. </p>

</div>
</div>
<a id="a1f8ea02917c5c9dbf3d9400cd27ea903" name="a1f8ea02917c5c9dbf3d9400cd27ea903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8ea02917c5c9dbf3d9400cd27ea903">&#9670;&#160;</a></span>getAllParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">Rose::BinaryAnalysis::RegisterParts</a> Rose::BinaryAnalysis::RegisterDictionary::getAllParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all register parts. </p>
<p>Returns all parts of all registers in this dictionary without any regard for register boundaries. For instance, if a diction contains the x86 AX and AL registers where AX is 16 bits and AL is its low-order eight bits, the return value will only contain the fact that the 16 bits corresponding to AX are stored, which also happens to contain the eight bits of AL, but it won't keep track that AX and AL were inserted separately. In other words, erasing AL from the returned container would also erase the low-order 8 bits of AX. </p>

</div>
</div>
<a id="a7f2dce99ab3b31d72799fb767c2c04b8" name="a7f2dce99ab3b31d72799fb767c2c04b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2dce99ab3b31d72799fb767c2c04b8">&#9670;&#160;</a></span>getDescriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> Rose::BinaryAnalysis::RegisterDictionary::getDescriptors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of all register descriptors. </p>
<p>The returned list may have overlapping register descriptors. The return value is similar to get_registers() except only the <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> part is returned, not the names. </p>

</div>
</div>
<a id="aa4d96a5e48b42267d1f94fc75821782b" name="aa4d96a5e48b42267d1f94fc75821782b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d96a5e48b42267d1f94fc75821782b">&#9670;&#160;</a></span>filterNonoverlapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> Rose::BinaryAnalysis::RegisterDictionary::filterNonoverlapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a>&#160;</td>
          <td class="paramname"><em>reglist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">SortBySize</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reconsiderParts</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of non-overlapping registers or register parts. </p>
<p>The list of registers are processed in the reverse specified order and each register is added to the return value if its bits were not already added to the return value by a previous register. If a register under consideration is only partially represented in the return value at the time it is considered, then it is either split into smaller parts to be reconsidered later, or not reconsidered at all. Thus, when <code>reconsiderParts</code> is true, the return value might contain register descriptors that were not part of the input <code>reglist</code>, and which might not even have entries/names in the register dictionary (see get_largest_registers() for more explaination).</p>
<p>For example, to get a list of the largest non-overlapping registers one could do the following: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">RegisterDictionary::SortBySize</a> largest_to_smallest(RegisterDictionary::SortBySize::DESCENDING);</div>
<div class="line"><a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> all_registers = ditionary.get_descriptors();</div>
<div class="line"><a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> list = dictionary.filter_nonoverlapping(all_registers, largest_to_smallest, <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">Rose::BinaryAnalysis::RegisterDictionary::SortBySize</a></div><div class="ttdoc">Compares number of bits in register descriptors.</div><div class="ttdef"><b>Definition</b> <a href="RegisterDictionary_8h_source.html#l00312">RegisterDictionary.h:312</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1RegisterDictionary_html_a500242df223c9f4975874de40e081444"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">Rose::BinaryAnalysis::RegisterDictionary::RegisterDescriptors</a></div><div class="ttdeci">Rose::BinaryAnalysis::RegisterDescriptors RegisterDescriptors</div><div class="ttdoc">List of register descriptors in dictionary.</div><div class="ttdef"><b>Definition</b> <a href="RegisterDictionary_8h_source.html#l00059">RegisterDictionary.h:59</a></div></div>
</div><!-- fragment --><p>Filtering largest to smallest and reconsidering parts is the default, so the example can be shortened to: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> list = dictionary.filter_nonoverlapping(dictionary.get_descriptors());</div>
</div><!-- fragment --><p>In fact, it can be shortened even more since this common operation is encapsulated in get_largest_registers(): </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> list = dictionary.get_largest_registers();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="RegisterDictionary_8h_source.html#l00408">408</a> of file <a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a>.</p>

<p class="reference">References <a class="el" href="rangemap_8h_source.html#l00901">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h_source.html#l01253">RangeMap&lt; R, T &gt;::distinct()</a>, <a class="el" href="rangemap_8h_source.html#l00913">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h_source.html#l01177">RangeMap&lt; R, T &gt;::erase_ranges()</a>, <a class="el" href="rangemap_8h_source.html#l00103">Range&lt; T &gt;::first()</a>, <a class="el" href="rangemap_8h_source.html#l01188">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="RegisterDescriptor_8h_source.html#l00094">Rose::BinaryAnalysis::RegisterDescriptor::majorNumber()</a>, <a class="el" href="RegisterDescriptor_8h_source.html#l00106">Rose::BinaryAnalysis::RegisterDescriptor::minorNumber()</a>, <a class="el" href="RegisterDescriptor_8h_source.html#l00141">Rose::BinaryAnalysis::RegisterDescriptor::nBits()</a>, <a class="el" href="RegisterDescriptor_8h_source.html#l00122">Rose::BinaryAnalysis::RegisterDescriptor::offset()</a>, and <a class="el" href="rangemap_8h_source.html#l00147">Range&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="af4124e9972cc94b1f6035e42184fd5a4" name="af4124e9972cc94b1f6035e42184fd5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4124e9972cc94b1f6035e42184fd5a4">&#9670;&#160;</a></span>getLargestRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> Rose::BinaryAnalysis::RegisterDictionary::getLargestRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of the largest non-overlapping registers. </p>
<p>For instance, for a 32-bit x86 dictionary the return value will contain registers EAX, EBX, etc. but not AX, AH, AL, BX, BH, BL, etc. Note that some of the returned descriptors might not correspond to actual names in the dictionary; this can happen when the dictionary contains two registers that partially overlap, but are themselves not subsets of a larger register, as in:</p>
<div class="fragment"><div class="line">|XXXXXXXXXXXX....| The <span class="stringliteral">&quot;X&quot;</span> <span class="keyword">register</span> occupies the first 12 bits of a 16-bit <span class="keyword">register</span></div>
<div class="line">|....YYYYYYYYYYYY| The <span class="stringliteral">&quot;Y&quot;</span> <span class="keyword">register</span> occupies the last 12 bits of a 16-bit <span class="keyword">register</span></div>
</div><!-- fragment --><p>If the 16-bit register has no name, and the high- and low-order four-bit parts have no name, then the return value might consist of register "X" and the low four bits. Or it could be register "Y" and the high four bits. </p>

</div>
</div>
<a id="a06ba50423703b2122f3f9c648a7e92ae" name="a06ba50423703b2122f3f9c648a7e92ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ba50423703b2122f3f9c648a7e92ae">&#9670;&#160;</a></span>getSmallestRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> Rose::BinaryAnalysis::RegisterDictionary::getSmallestRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of the smallest non-overlapping registers. </p>
<p>For instance, for a 32-bit x86 dictionary the return value will contain AX, AH, AL, BX, BH, BL, etc. rather than EAX and EBX. It will also return the high 16-bit parts of EAX and EBX even though they're not represented with explicit definitions in the dictionary.</p>
<p>This is a one-liner in terms of filter_nonoverlapping. If you don't want the unnamed parts to appear in the return value (e.g., the high-order 16 bits of EAX), then call filter_nonoverlapping() like this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary_1_1SortBySize.html">SortBySize</a> order(SortBySize::ASCENDING);</div>
<div class="line"><a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDescriptors</a> smallest = dict.filter_nonoverlapping(dict.get_descriptors(), order, <span class="keyword">false</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a93f47ba79a993e060377a651f2d5b570" name="a93f47ba79a993e060377a651f2d5b570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f47ba79a993e060377a651f2d5b570">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::RegisterDictionary::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of this register dictionary. </p>
<p>The first line of output contains the dictionary name. One additional line of output will be generated for each entry in the dictionary. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RegisterDictionary_8h_source.html">RegisterDictionary.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
