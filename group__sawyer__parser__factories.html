<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Command line parser factories</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">Command line parser factories<div class="ingroups"><a class="el" href="group__sawyer.html">Sawyer Support Library</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Factories for creating instances of <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">Sawyer::CommandLine::ValueParser</a> subclasses. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for the various subclasses of <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a>, and they sometimes alleviate the user from having to specify template arguments. They take the same arguments as the <code>instance</code> method(s) and have the same name as the class they return, except their initial letter is lower case. These two calls are equivalent:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1CommandLine_1_1ValueParser.html#a3de19c96113379c520bcbd1e23b1b6db">ValueParser::Ptr</a> parser1 = IntegerParser::instance&lt;short&gt;(storage);</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1CommandLine_1_1ValueParser.html#a3de19c96113379c520bcbd1e23b1b6db">ValueParser::Ptr</a> parser2 = <a class="code hl_function" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">integerParser</a>(storage);</div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ValueParser_html_a3de19c96113379c520bcbd1e23b1b6db"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ValueParser.html#a3de19c96113379c520bcbd1e23b1b6db">Sawyer::CommandLine::ValueParser::Ptr</a></div><div class="ttdeci">SharedPointer&lt; ValueParser &gt; Ptr</div><div class="ttdoc">Reference counting pointer for this class.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l00711">Sawyer/CommandLine.h:711</a></div></div>
<div class="ttc" id="agroup__sawyer__parser__factories_html_gad46b4ed8c608b0600da92afbb563252c"><div class="ttname"><a href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">Sawyer::CommandLine::integerParser</a></div><div class="ttdeci">IntegerParser&lt; T &gt;::Ptr integerParser()</div><div class="ttdoc">Factory for value parsers.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l01444">Sawyer/CommandLine.h:1444</a></div></div>
</div><!-- fragment --><p>Most parser factories come in three varieties:</p>
<ul>
<li>A factory that takes no function or template arguments creates a parser that uses a specific, hard-coded C++ type to represent its value and does not attempt to copy the parsed value to a user-specified storage location. The value, assuming it is kept, is stored only in the <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html" title="The result from parsing a command line.">ParserResult</a>. </li>
<li>A factory that takes a template typename argument creates a parser that uses the specified type to represent its value, and does not attempt to copy the parsed value to a user-supplied storage location. The value, assuming it is kept, is stored only in the <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html" title="The result from parsing a command line.">ParserResult</a>. </li>
<li>A factory that takes a function argument that is an L-value (and an inferred template argument) creates a parser that uses the inferred type to represent its value and also stores that value in the user-supplied location when <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b" title="Saves parsed values in switch-specified locations.">ParserResult::apply</a> is called. If the L-value is an <code>std::vector</code> then parsed values are pushed onto the back of the the vector.</li>
</ul>
<p>The <a class="el" href="group__sawyer__parser__factories.html#ga1d22f77e7d79ab0e52ba7ceb52172f97">integerParser</a> factory is an example for all three of these varieties:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">integerParser</a>()         <span class="comment">// saves an int value in ParserResult</span></div>
<div class="line"><a class="code hl_function" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">integerParser</a>&lt;<span class="keywordtype">short</span>&gt;()  <span class="comment">// saves a short value in ParserResult</span></div>
<div class="line"><span class="keywordtype">long</span> result;</div>
<div class="line"><a class="code hl_function" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">integerParser</a>(result);  <span class="comment">// saves a long value in ParserResult and in result</span></div>
<div class="line">std::vector&lt;<span class="keywordtype">int</span>&gt; results;</div>
<div class="line"><a class="code hl_function" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">integerParser</a>(results); <span class="comment">// saves more than one integer</span></div>
</div><!-- fragment --><h1><a class="anchor" id="sawer_parser_factories_factories"></a>
Factories</h1>
<div class="dynheader">
Collaboration diagram for Command line parser factories:</div>
<div class="dyncontent">
<div class="center"><img src="group__sawyer__parser__factories.png" border="0" usemap="#agroup____sawyer____parser____factories" alt=""/></div>
<map name="agroup____sawyer____parser____factories" id="agroup____sawyer____parser____factories">
<area shape="rect" href="group__sawyer.html" title="Sawyer is a library for library writers." alt="" coords="5,13,164,38"/>
<area shape="rect" title="Factories for creating instances of Sawyer::CommandLine::ValueParser subclasses." alt="" coords="212,5,359,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="memitem:gacae2de0691a7091623edbc92bffcc89f" id="r_gacae2de0691a7091623edbc92bffcc89f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacae2de0691a7091623edbc92bffcc89f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gacae2de0691a7091623edbc92bffcc89f">Sawyer::CommandLine::anyParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:gacae2de0691a7091623edbc92bffcc89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gacae2de0691a7091623edbc92bffcc89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30ff6a8f7d77bc97d3384a1c958f720" id="r_gaf30ff6a8f7d77bc97d3384a1c958f720"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf30ff6a8f7d77bc97d3384a1c958f720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gaf30ff6a8f7d77bc97d3384a1c958f720">Sawyer::CommandLine::anyParser</a> ()</td></tr>
<tr class="memdesc:gaf30ff6a8f7d77bc97d3384a1c958f720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gaf30ff6a8f7d77bc97d3384a1c958f720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24d99917d4de00ae1858335003f8a99" id="r_gac24d99917d4de00ae1858335003f8a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; std::string &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gac24d99917d4de00ae1858335003f8a99">Sawyer::CommandLine::anyParser</a> ()</td></tr>
<tr class="memdesc:gac24d99917d4de00ae1858335003f8a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gac24d99917d4de00ae1858335003f8a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d22f77e7d79ab0e52ba7ceb52172f97" id="r_ga1d22f77e7d79ab0e52ba7ceb52172f97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d22f77e7d79ab0e52ba7ceb52172f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga1d22f77e7d79ab0e52ba7ceb52172f97">Sawyer::CommandLine::integerParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:ga1d22f77e7d79ab0e52ba7ceb52172f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga1d22f77e7d79ab0e52ba7ceb52172f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46b4ed8c608b0600da92afbb563252c" id="r_gad46b4ed8c608b0600da92afbb563252c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad46b4ed8c608b0600da92afbb563252c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gad46b4ed8c608b0600da92afbb563252c">Sawyer::CommandLine::integerParser</a> ()</td></tr>
<tr class="memdesc:gad46b4ed8c608b0600da92afbb563252c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gad46b4ed8c608b0600da92afbb563252c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25340c3b07cdaefeb7e4eb1bd1df381" id="r_gaa25340c3b07cdaefeb7e4eb1bd1df381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; int &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gaa25340c3b07cdaefeb7e4eb1bd1df381">Sawyer::CommandLine::integerParser</a> ()</td></tr>
<tr class="memdesc:gaa25340c3b07cdaefeb7e4eb1bd1df381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gaa25340c3b07cdaefeb7e4eb1bd1df381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb6b516cab1939935478119ac38af9f" id="r_ga9cb6b516cab1939935478119ac38af9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9cb6b516cab1939935478119ac38af9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga9cb6b516cab1939935478119ac38af9f">Sawyer::CommandLine::nonNegativeIntegerParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:ga9cb6b516cab1939935478119ac38af9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga9cb6b516cab1939935478119ac38af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09f6e84013cd4d1d30430dcf8980690" id="r_gab09f6e84013cd4d1d30430dcf8980690"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab09f6e84013cd4d1d30430dcf8980690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gab09f6e84013cd4d1d30430dcf8980690">Sawyer::CommandLine::nonNegativeIntegerParser</a> ()</td></tr>
<tr class="memdesc:gab09f6e84013cd4d1d30430dcf8980690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gab09f6e84013cd4d1d30430dcf8980690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f1978970912e3a8427767d10c2dc70" id="r_gac5f1978970912e3a8427767d10c2dc70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; unsigned &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gac5f1978970912e3a8427767d10c2dc70">Sawyer::CommandLine::nonNegativeIntegerParser</a> ()</td></tr>
<tr class="memdesc:gac5f1978970912e3a8427767d10c2dc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gac5f1978970912e3a8427767d10c2dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2ac7da4bbbe7f1702a852fa6159890" id="r_ga1b2ac7da4bbbe7f1702a852fa6159890"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b2ac7da4bbbe7f1702a852fa6159890"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga1b2ac7da4bbbe7f1702a852fa6159890">Sawyer::CommandLine::positiveIntegerParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:ga1b2ac7da4bbbe7f1702a852fa6159890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga1b2ac7da4bbbe7f1702a852fa6159890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e1fc2f4fe42ece9a23abdaa51ff476" id="r_ga43e1fc2f4fe42ece9a23abdaa51ff476"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga43e1fc2f4fe42ece9a23abdaa51ff476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga43e1fc2f4fe42ece9a23abdaa51ff476">Sawyer::CommandLine::positiveIntegerParser</a> ()</td></tr>
<tr class="memdesc:ga43e1fc2f4fe42ece9a23abdaa51ff476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga43e1fc2f4fe42ece9a23abdaa51ff476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b11af6f285d1025593acd014308c7e" id="r_gab1b11af6f285d1025593acd014308c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; unsigned &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gab1b11af6f285d1025593acd014308c7e">Sawyer::CommandLine::positiveIntegerParser</a> ()</td></tr>
<tr class="memdesc:gab1b11af6f285d1025593acd014308c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gab1b11af6f285d1025593acd014308c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd230da218fd01cfb4a841fcb8884e51" id="r_gafd230da218fd01cfb4a841fcb8884e51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafd230da218fd01cfb4a841fcb8884e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gafd230da218fd01cfb4a841fcb8884e51">Sawyer::CommandLine::realNumberParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:gafd230da218fd01cfb4a841fcb8884e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gafd230da218fd01cfb4a841fcb8884e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b0d8d9ddde6b69f2e9f337eb4b3406" id="r_ga59b0d8d9ddde6b69f2e9f337eb4b3406"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga59b0d8d9ddde6b69f2e9f337eb4b3406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga59b0d8d9ddde6b69f2e9f337eb4b3406">Sawyer::CommandLine::realNumberParser</a> ()</td></tr>
<tr class="memdesc:ga59b0d8d9ddde6b69f2e9f337eb4b3406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga59b0d8d9ddde6b69f2e9f337eb4b3406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900371b003e37ba536efa5a3d87c723a" id="r_ga900371b003e37ba536efa5a3d87c723a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; double &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga900371b003e37ba536efa5a3d87c723a">Sawyer::CommandLine::realNumberParser</a> ()</td></tr>
<tr class="memdesc:ga900371b003e37ba536efa5a3d87c723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga900371b003e37ba536efa5a3d87c723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad059c0a56347df93607ac38cf08f7ea7" id="r_gad059c0a56347df93607ac38cf08f7ea7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad059c0a56347df93607ac38cf08f7ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gad059c0a56347df93607ac38cf08f7ea7">Sawyer::CommandLine::booleanParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:gad059c0a56347df93607ac38cf08f7ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gad059c0a56347df93607ac38cf08f7ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b822b7f603ff0578432a7b03691ac3" id="r_gae1b822b7f603ff0578432a7b03691ac3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae1b822b7f603ff0578432a7b03691ac3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gae1b822b7f603ff0578432a7b03691ac3">Sawyer::CommandLine::booleanParser</a> ()</td></tr>
<tr class="memdesc:gae1b822b7f603ff0578432a7b03691ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gae1b822b7f603ff0578432a7b03691ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad341075809c52659893c04db029ac79c" id="r_gad341075809c52659893c04db029ac79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; bool &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gad341075809c52659893c04db029ac79c">Sawyer::CommandLine::booleanParser</a> ()</td></tr>
<tr class="memdesc:gad341075809c52659893c04db029ac79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gad341075809c52659893c04db029ac79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68ae9dd37de1c2873700041ad4a84ca" id="r_gaf68ae9dd37de1c2873700041ad4a84ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf68ae9dd37de1c2873700041ad4a84ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gaf68ae9dd37de1c2873700041ad4a84ca">Sawyer::CommandLine::enumParser</a> (T &amp;storage)</td></tr>
<tr class="memdesc:gaf68ae9dd37de1c2873700041ad4a84ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gaf68ae9dd37de1c2873700041ad4a84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb57b62900f6410d9b592961438898a" id="r_ga4fb57b62900f6410d9b592961438898a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fb57b62900f6410d9b592961438898a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga4fb57b62900f6410d9b592961438898a">Sawyer::CommandLine::enumParser</a> (std::vector&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:ga4fb57b62900f6410d9b592961438898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga4fb57b62900f6410d9b592961438898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636f440c0915fe49e98dd73b2412e9b1" id="r_ga636f440c0915fe49e98dd73b2412e9b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga636f440c0915fe49e98dd73b2412e9b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#ga636f440c0915fe49e98dd73b2412e9b1">Sawyer::CommandLine::enumParser</a> (<a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:ga636f440c0915fe49e98dd73b2412e9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:ga636f440c0915fe49e98dd73b2412e9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81ccedd27128ca466dc3a90d5d77c76" id="r_gad81ccedd27128ca466dc3a90d5d77c76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad81ccedd27128ca466dc3a90d5d77c76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gad81ccedd27128ca466dc3a90d5d77c76">Sawyer::CommandLine::enumParser</a> (<a class="el" href="classSawyer_1_1BitFlags.html">BitFlags</a>&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:gad81ccedd27128ca466dc3a90d5d77c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gad81ccedd27128ca466dc3a90d5d77c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78a878dec632d19a2cdf4a9b75f7047" id="r_gae78a878dec632d19a2cdf4a9b75f7047"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae78a878dec632d19a2cdf4a9b75f7047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gae78a878dec632d19a2cdf4a9b75f7047">Sawyer::CommandLine::enumParser</a> ()</td></tr>
<tr class="memdesc:gae78a878dec632d19a2cdf4a9b75f7047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gae78a878dec632d19a2cdf4a9b75f7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae41b55046c7cd4367e5436acb6414872" id="r_gae41b55046c7cd4367e5436acb6414872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1StringSetParser.html#a904d71077358e89e0a68365e66f6de53">StringSetParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gae41b55046c7cd4367e5436acb6414872">Sawyer::CommandLine::stringSetParser</a> (std::string &amp;storage)</td></tr>
<tr class="memdesc:gae41b55046c7cd4367e5436acb6414872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gae41b55046c7cd4367e5436acb6414872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9c5c9b9ac1ef6ccff4145dfc197a8d" id="r_gabc9c5c9b9ac1ef6ccff4145dfc197a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1StringSetParser.html#a904d71077358e89e0a68365e66f6de53">StringSetParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gabc9c5c9b9ac1ef6ccff4145dfc197a8d">Sawyer::CommandLine::stringSetParser</a> ()</td></tr>
<tr class="memdesc:gabc9c5c9b9ac1ef6ccff4145dfc197a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gabc9c5c9b9ac1ef6ccff4145dfc197a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b9a4df05e09326001e945c99d482f9" id="r_gac5b9a4df05e09326001e945c99d482f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1ListParser.html#a70441692d740f6749523fd5380218dc9">ListParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sawyer__parser__factories.html#gac5b9a4df05e09326001e945c99d482f9">Sawyer::CommandLine::listParser</a> (const <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html#a3de19c96113379c520bcbd1e23b1b6db">ValueParser::Ptr</a> &amp;, const std::string &amp;sepRe=&quot;[,;:]\\s*&quot;)</td></tr>
<tr class="memdesc:gac5b9a4df05e09326001e945c99d482f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for value parsers.  <br /></td></tr>
<tr class="separator:gac5b9a4df05e09326001e945c99d482f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacae2de0691a7091623edbc92bffcc89f" name="gacae2de0691a7091623edbc92bffcc89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacae2de0691a7091623edbc92bffcc89f">&#9670;&#160;</a></span>anyParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::anyParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01430">1430</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l00879">Sawyer::CommandLine::AnyParser&lt; T &gt;::instance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01544">Sawyer::CommandLine::SwitchArgument::SwitchArgument()</a>, <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#a09bbb18de4bf7165c48f6d7300fc593d">Sawyer::CommandLine::Switch::argument()</a>, and <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02355">Sawyer::CommandLine::Switch::intrinsicValue()</a>.</p>

</div>
</div>
<a id="gaf30ff6a8f7d77bc97d3384a1c958f720" name="gaf30ff6a8f7d77bc97d3384a1c958f720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf30ff6a8f7d77bc97d3384a1c958f720">&#9670;&#160;</a></span>anyParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::anyParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01434">1434</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l00879">Sawyer::CommandLine::AnyParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gac24d99917d4de00ae1858335003f8a99" name="gac24d99917d4de00ae1858335003f8a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24d99917d4de00ae1858335003f8a99">&#9670;&#160;</a></span>anyParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1AnyParser.html">AnyParser</a>&lt; std::string &gt;::Ptr Sawyer::CommandLine::anyParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1d22f77e7d79ab0e52ba7ceb52172f97" name="ga1d22f77e7d79ab0e52ba7ceb52172f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d22f77e7d79ab0e52ba7ceb52172f97">&#9670;&#160;</a></span>integerParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::integerParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01440">1440</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l00997">Sawyer::CommandLine::IntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gad46b4ed8c608b0600da92afbb563252c" name="gad46b4ed8c608b0600da92afbb563252c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad46b4ed8c608b0600da92afbb563252c">&#9670;&#160;</a></span>integerParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::integerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01444">1444</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l00997">Sawyer::CommandLine::IntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gaa25340c3b07cdaefeb7e4eb1bd1df381" name="gaa25340c3b07cdaefeb7e4eb1bd1df381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25340c3b07cdaefeb7e4eb1bd1df381">&#9670;&#160;</a></span>integerParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1IntegerParser.html">IntegerParser</a>&lt; int &gt;::Ptr Sawyer::CommandLine::integerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9cb6b516cab1939935478119ac38af9f" name="ga9cb6b516cab1939935478119ac38af9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb6b516cab1939935478119ac38af9f">&#9670;&#160;</a></span>nonNegativeIntegerParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::nonNegativeIntegerParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01450">1450</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01045">Sawyer::CommandLine::NonNegativeIntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gab09f6e84013cd4d1d30430dcf8980690" name="gab09f6e84013cd4d1d30430dcf8980690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09f6e84013cd4d1d30430dcf8980690">&#9670;&#160;</a></span>nonNegativeIntegerParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::nonNegativeIntegerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01454">1454</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01045">Sawyer::CommandLine::NonNegativeIntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gac5f1978970912e3a8427767d10c2dc70" name="gac5f1978970912e3a8427767d10c2dc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5f1978970912e3a8427767d10c2dc70">&#9670;&#160;</a></span>nonNegativeIntegerParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1NonNegativeIntegerParser.html">NonNegativeIntegerParser</a>&lt; unsigned &gt;::Ptr Sawyer::CommandLine::nonNegativeIntegerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1b2ac7da4bbbe7f1702a852fa6159890" name="ga1b2ac7da4bbbe7f1702a852fa6159890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b2ac7da4bbbe7f1702a852fa6159890">&#9670;&#160;</a></span>positiveIntegerParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::positiveIntegerParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01460">1460</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01093">Sawyer::CommandLine::PositiveIntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="ga43e1fc2f4fe42ece9a23abdaa51ff476" name="ga43e1fc2f4fe42ece9a23abdaa51ff476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43e1fc2f4fe42ece9a23abdaa51ff476">&#9670;&#160;</a></span>positiveIntegerParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::positiveIntegerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01464">1464</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01093">Sawyer::CommandLine::PositiveIntegerParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gab1b11af6f285d1025593acd014308c7e" name="gab1b11af6f285d1025593acd014308c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b11af6f285d1025593acd014308c7e">&#9670;&#160;</a></span>positiveIntegerParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1PositiveIntegerParser.html">PositiveIntegerParser</a>&lt; unsigned &gt;::Ptr Sawyer::CommandLine::positiveIntegerParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd230da218fd01cfb4a841fcb8884e51" name="gafd230da218fd01cfb4a841fcb8884e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd230da218fd01cfb4a841fcb8884e51">&#9670;&#160;</a></span>realNumberParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::realNumberParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01470">1470</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01140">Sawyer::CommandLine::RealNumberParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="ga59b0d8d9ddde6b69f2e9f337eb4b3406" name="ga59b0d8d9ddde6b69f2e9f337eb4b3406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59b0d8d9ddde6b69f2e9f337eb4b3406">&#9670;&#160;</a></span>realNumberParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::realNumberParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01474">1474</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01140">Sawyer::CommandLine::RealNumberParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="ga900371b003e37ba536efa5a3d87c723a" name="ga900371b003e37ba536efa5a3d87c723a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900371b003e37ba536efa5a3d87c723a">&#9670;&#160;</a></span>realNumberParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1RealNumberParser.html">RealNumberParser</a>&lt; double &gt;::Ptr Sawyer::CommandLine::realNumberParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad059c0a56347df93607ac38cf08f7ea7" name="gad059c0a56347df93607ac38cf08f7ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad059c0a56347df93607ac38cf08f7ea7">&#9670;&#160;</a></span>booleanParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::booleanParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01480">1480</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01178">Sawyer::CommandLine::BooleanParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gae1b822b7f603ff0578432a7b03691ac3" name="gae1b822b7f603ff0578432a7b03691ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1b822b7f603ff0578432a7b03691ac3">&#9670;&#160;</a></span>booleanParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::booleanParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01484">1484</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01178">Sawyer::CommandLine::BooleanParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gad341075809c52659893c04db029ac79c" name="gad341075809c52659893c04db029ac79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad341075809c52659893c04db029ac79c">&#9670;&#160;</a></span>booleanParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1BooleanParser.html">BooleanParser</a>&lt; bool &gt;::Ptr Sawyer::CommandLine::booleanParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf68ae9dd37de1c2873700041ad4a84ca" name="gaf68ae9dd37de1c2873700041ad4a84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf68ae9dd37de1c2873700041ad4a84ca">&#9670;&#160;</a></span>enumParser() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::enumParser </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01490">1490</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01292">Sawyer::CommandLine::EnumParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="ga4fb57b62900f6410d9b592961438898a" name="ga4fb57b62900f6410d9b592961438898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb57b62900f6410d9b592961438898a">&#9670;&#160;</a></span>enumParser() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::enumParser </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01494">1494</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01292">Sawyer::CommandLine::EnumParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="ga636f440c0915fe49e98dd73b2412e9b1" name="ga636f440c0915fe49e98dd73b2412e9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga636f440c0915fe49e98dd73b2412e9b1">&#9670;&#160;</a></span>enumParser() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::enumParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01498">1498</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01292">Sawyer::CommandLine::EnumParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gad81ccedd27128ca466dc3a90d5d77c76" name="gad81ccedd27128ca466dc3a90d5d77c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad81ccedd27128ca466dc3a90d5d77c76">&#9670;&#160;</a></span>enumParser() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::enumParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1BitFlags.html">BitFlags</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01502">1502</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01292">Sawyer::CommandLine::EnumParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gae78a878dec632d19a2cdf4a9b75f7047" name="gae78a878dec632d19a2cdf4a9b75f7047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae78a878dec632d19a2cdf4a9b75f7047">&#9670;&#160;</a></span>enumParser() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1EnumParser.html">EnumParser</a>&lt; T &gt;::Ptr Sawyer::CommandLine::enumParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01506">1506</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l01292">Sawyer::CommandLine::EnumParser&lt; T &gt;::instance()</a>.</p>

</div>
</div>
<a id="gae41b55046c7cd4367e5436acb6414872" name="gae41b55046c7cd4367e5436acb6414872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae41b55046c7cd4367e5436acb6414872">&#9670;&#160;</a></span>stringSetParser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1StringSetParser.html#a904d71077358e89e0a68365e66f6de53">StringSetParser::Ptr</a> Sawyer::CommandLine::stringSetParser </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabc9c5c9b9ac1ef6ccff4145dfc197a8d" name="gabc9c5c9b9ac1ef6ccff4145dfc197a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc9c5c9b9ac1ef6ccff4145dfc197a8d">&#9670;&#160;</a></span>stringSetParser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1StringSetParser.html#a904d71077358e89e0a68365e66f6de53">StringSetParser::Ptr</a> Sawyer::CommandLine::stringSetParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac5b9a4df05e09326001e945c99d482f9" name="gac5b9a4df05e09326001e945c99d482f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b9a4df05e09326001e945c99d482f9">&#9670;&#160;</a></span>listParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1ListParser.html#a70441692d740f6749523fd5380218dc9">ListParser::Ptr</a> Sawyer::CommandLine::listParser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html#a3de19c96113379c520bcbd1e23b1b6db">ValueParser::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sepRe</em> = <code>&quot;[,;:]\\s*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory for value parsers. </p>
<p>A factory function is a more terse and convenient way of calling the <code>instance</code> allocating constructors for <a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html" title="Base class parsing a value from input.">ValueParser</a> subclasses and often alleviates the user from having to specify template arguments. Most parser factories come in two varieties, and some in three varieties.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="group__sawyer__parser__factories.html">Command line parser factories</a> </li>
<li><a class="el" href="classSawyer_1_1CommandLine_1_1ValueParser.html">ValueParser</a> base class </li>
<li>Documentation for the returned class </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:08:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
