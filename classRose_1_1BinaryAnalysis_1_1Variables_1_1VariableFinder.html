<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Variables::VariableFinder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html">Variables</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html">VariableFinder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Variables::VariableFinder Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classAnalysis.html">Analysis</a> to find variable locations. </p>

<p class="definition">Definition at line <a class="el" href="Variables_8h_source.html#l00461">461</a> of file <a class="el" href="Variables_8h_source.html">Variables.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Variables_8h_source.html">Rose/BinaryAnalysis/Variables.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Variables::VariableFinder:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_inherit__map">
<area shape="rect" title="Analysis to find variable locations." alt="" coords="5,79,179,119"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="15,5,169,31"/>
<area shape="poly" title=" " alt="" coords="95,44,95,78,89,78,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Variables::VariableFinder:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_coll__map" id="aRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_coll__map">
<area shape="rect" title="Analysis to find variable locations." alt="" coords="5,79,179,119"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="15,5,169,31"/>
<area shape="poly" title=" " alt="" coords="95,44,95,78,89,78,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html" title="Settings that control this analysis.">Settings</a> that control this analysis.  <a href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2ee5524ecbe911735528cf21e1d2df1d" id="r_a2ee5524ecbe911735528cf21e1d2df1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a2ee5524ecbe911735528cf21e1d2df1d">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#ac49414c26c4ddc61dd89fc4e1ad450b6">VariableFinderPtr</a></td></tr>
<tr class="memdesc:a2ee5524ecbe911735528cf21e1d2df1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html">VariableFinder</a>.  <br /></td></tr>
<tr class="separator:a2ee5524ecbe911735528cf21e1d2df1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0fd793e2a523b4456efc478cfcabbbe" id="r_ab0fd793e2a523b4456efc478cfcabbbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a701286bb9c1d8a76612cc46c9df9e112">GlobalVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#ab0fd793e2a523b4456efc478cfcabbbe">findGlobalVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:ab0fd793e2a523b4456efc478cfcabbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find global variables.  <br /></td></tr>
<tr class="separator:ab0fd793e2a523b4456efc478cfcabbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8af5df5986da4775690d721fe00fe95" id="r_ab8af5df5986da4775690d721fe00fe95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#ab8af5df5986da4775690d721fe00fe95">isCached</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:ab8af5df5986da4775690d721fe00fe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether local variable information is cached.  <br /></td></tr>
<tr class="separator:ab8af5df5986da4775690d721fe00fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e85bc2457390cb8be315c3dc5eca189" id="r_a2e85bc2457390cb8be315c3dc5eca189"><td class="memItemLeft" align="right" valign="top"><a id="a2e85bc2457390cb8be315c3dc5eca189" name="a2e85bc2457390cb8be315c3dc5eca189"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><b>detectFrameAttributes</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a2e85bc2457390cb8be315c3dc5eca189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out attributes describing the stack frame for the specified function. <br /></td></tr>
<tr class="separator:a2e85bc2457390cb8be315c3dc5eca189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673db148fee337c1e4f484a8c2082246" id="r_a673db148fee337c1e4f484a8c2082246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a673db148fee337c1e4f484a8c2082246">initializeFrameBoundaries</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackVariable.html#a4d66055ed20303096dc3891cd1d7e492">StackVariable::Boundaries</a> &amp;boundaries)</td></tr>
<tr class="memdesc:a673db148fee337c1e4f484a8c2082246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initilialize offsets for function prologue.  <br /></td></tr>
<tr class="separator:a673db148fee337c1e4f484a8c2082246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f10c17ecff8062f36e45e7d78cc3f6d" id="r_a2f10c17ecff8062f36e45e7d78cc3f6d"><td class="memItemLeft" align="right" valign="top">std::set&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a2f10c17ecff8062f36e45e7d78cc3f6d">findFrameOffsets</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:a2f10c17ecff8062f36e45e7d78cc3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find stack variable addresses.  <br /></td></tr>
<tr class="separator:a2f10c17ecff8062f36e45e7d78cc3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e25eda197da6e0bf54c83b2d2d5f8c" id="r_af6e25eda197da6e0bf54c83b2d2d5f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#af6e25eda197da6e0bf54c83b2d2d5f8c">functionForInstruction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:af6e25eda197da6e0bf54c83b2d2d5f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> that owns an instruction.  <br /></td></tr>
<tr class="separator:af6e25eda197da6e0bf54c83b2d2d5f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac79fbf5cc6295d4d89f4adab3ae509" id="r_aeac79fbf5cc6295d4d89f4adab3ae509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a24611814a9787faff90fdb41997ed2cd">AddressToAddresses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#aeac79fbf5cc6295d4d89f4adab3ae509">findGlobalVariableVas</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:aeac79fbf5cc6295d4d89f4adab3ae509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find global variable addresses.  <br /></td></tr>
<tr class="separator:aeac79fbf5cc6295d4d89f4adab3ae509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaf1b2edba4cd8e4ba478c2b62c4eaf" id="r_abdaf1b2edba4cd8e4ba478c2b62c4eaf"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#abdaf1b2edba4cd8e4ba478c2b62c4eaf">findConstants</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:abdaf1b2edba4cd8e4ba478c2b62c4eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find address constants in an expression.  <br /></td></tr>
<tr class="separator:abdaf1b2edba4cd8e4ba478c2b62c4eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b24e9ea91bee650df3d65def4d68d7" id="r_ab7b24e9ea91bee650df3d65def4d68d7"><td class="memItemLeft" align="right" valign="top"><a id="ab7b24e9ea91bee650df3d65def4d68d7" name="ab7b24e9ea91bee650df3d65def4d68d7"></a>
std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findConstants</b> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:ab7b24e9ea91bee650df3d65def4d68d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find constants syntactically in an instruction. <br /></td></tr>
<tr class="separator:ab7b24e9ea91bee650df3d65def4d68d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d18e1aee8d12c7ea5d4619542dd2e1" id="r_a79d18e1aee8d12c7ea5d4619542dd2e1"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a79d18e1aee8d12c7ea5d4619542dd2e1">getMemoryAddresses</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ab9750a0c3830c74c55a99019d17d3a55">InstructionSemantics::BaseSemantics::MemoryCellStatePtr</a> &amp;)</td></tr>
<tr class="memdesc:a79d18e1aee8d12c7ea5d4619542dd2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find addresses in memory state.  <br /></td></tr>
<tr class="separator:a79d18e1aee8d12c7ea5d4619542dd2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2568179a00a7180eb361c80f8588d63b" id="r_a2568179a00a7180eb361c80f8588d63b"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a2568179a00a7180eb361c80f8588d63b">findAddressConstants</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ab9750a0c3830c74c55a99019d17d3a55">InstructionSemantics::BaseSemantics::MemoryCellStatePtr</a> &amp;)</td></tr>
<tr class="memdesc:a2568179a00a7180eb361c80f8588d63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find constants in memory.  <br /></td></tr>
<tr class="separator:a2568179a00a7180eb361c80f8588d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f97878aff0ba37ade38a5156185d48" id="r_a41f97878aff0ba37ade38a5156185d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a41f97878aff0ba37ade38a5156185d48">removeOutliers</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackVariable.html#a4d66055ed20303096dc3891cd1d7e492">StackVariable::Boundaries</a> &amp;sortedBoundaries)</td></tr>
<tr class="memdesc:a41f97878aff0ba37ade38a5156185d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove boundaries that are outside a stack frame.  <br /></td></tr>
<tr class="separator:a41f97878aff0ba37ade38a5156185d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4f2c97418cc518c12a32c4d3ecbd9b5a" id="r_a4f2c97418cc518c12a32c4d3ecbd9b5a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a4f2c97418cc518c12a32c4d3ecbd9b5a">settings</a> () const</td></tr>
<tr class="memdesc:a4f2c97418cc518c12a32c4d3ecbd9b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html" title="Settings that control this analysis.">Settings</a> for this analysis.  <br /></td></tr>
<tr class="separator:a4f2c97418cc518c12a32c4d3ecbd9b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5154d435200218a271dc3a453cf2a09d" id="r_a5154d435200218a271dc3a453cf2a09d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a5154d435200218a271dc3a453cf2a09d">settings</a> ()</td></tr>
<tr class="memdesc:a5154d435200218a271dc3a453cf2a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html" title="Settings that control this analysis.">Settings</a> for this analysis.  <br /></td></tr>
<tr class="separator:a5154d435200218a271dc3a453cf2a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acebad6ae5a31e1b166c5352ac6e90d06" id="r_acebad6ae5a31e1b166c5352ac6e90d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">StackVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#acebad6ae5a31e1b166c5352ac6e90d06">findStackVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:acebad6ae5a31e1b166c5352ac6e90d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local variables in a function.  <br /></td></tr>
<tr class="separator:acebad6ae5a31e1b166c5352ac6e90d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab929e78cce1a1ace137f6b6d1691d0" id="r_a4ab929e78cce1a1ace137f6b6d1691d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">StackVariables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a4ab929e78cce1a1ace137f6b6d1691d0">findStackVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:a4ab929e78cce1a1ace137f6b6d1691d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find local variables in a function.  <br /></td></tr>
<tr class="separator:a4ab929e78cce1a1ace137f6b6d1691d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab99a29de9d7a11ed10db26f0f21b3296" id="r_ab99a29de9d7a11ed10db26f0f21b3296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#ab99a29de9d7a11ed10db26f0f21b3296">evict</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:ab99a29de9d7a11ed10db26f0f21b3296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed cached information.  <br /></td></tr>
<tr class="separator:ab99a29de9d7a11ed10db26f0f21b3296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33eb7e79122c1fef5ab6acdc669e5b24" id="r_a33eb7e79122c1fef5ab6acdc669e5b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a33eb7e79122c1fef5ab6acdc669e5b24">evict</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a33eb7e79122c1fef5ab6acdc669e5b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed cached information.  <br /></td></tr>
<tr class="separator:a33eb7e79122c1fef5ab6acdc669e5b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a901264f77a0e6ed36d5107c1538c0497" id="r_a901264f77a0e6ed36d5107c1538c0497"><td class="memItemLeft" align="right" valign="top"><a id="a901264f77a0e6ed36d5107c1538c0497" name="a901264f77a0e6ed36d5107c1538c0497"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a2ee5524ecbe911735528cf21e1d2df1d">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a4f2c97418cc518c12a32c4d3ecbd9b5a">settings</a>=<a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a>())</td></tr>
<tr class="memdesc:a901264f77a0e6ed36d5107c1538c0497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor. <br /></td></tr>
<tr class="separator:a901264f77a0e6ed36d5107c1538c0497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90278757d23964ed635eedcdbddc038a" id="r_a90278757d23964ed635eedcdbddc038a"><td class="memItemLeft" align="right" valign="top"><a id="a90278757d23964ed635eedcdbddc038a" name="a90278757d23964ed635eedcdbddc038a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regionContainsInstructions</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:a90278757d23964ed635eedcdbddc038a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if memory region contains any decoded instructions. <br /></td></tr>
<tr class="separator:a90278757d23964ed635eedcdbddc038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99a2a83fb801114421fc01338185bff" id="r_af99a2a83fb801114421fc01338185bff"><td class="memItemLeft" align="right" valign="top"><a id="af99a2a83fb801114421fc01338185bff" name="af99a2a83fb801114421fc01338185bff"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regionIsFullyMapped</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:af99a2a83fb801114421fc01338185bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if memory region is fully mapped. <br /></td></tr>
<tr class="separator:af99a2a83fb801114421fc01338185bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138747dbc6dc6f8fcfd6d64354c61d2e" id="r_a138747dbc6dc6f8fcfd6d64354c61d2e"><td class="memItemLeft" align="right" valign="top"><a id="a138747dbc6dc6f8fcfd6d64354c61d2e" name="a138747dbc6dc6f8fcfd6d64354c61d2e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regionIsFullyReadWrite</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:a138747dbc6dc6f8fcfd6d64354c61d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if memory region is fully mapped with read and write access. <br /></td></tr>
<tr class="separator:a138747dbc6dc6f8fcfd6d64354c61d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abebff3bb8d460a335fe189be23a339d9" id="r_abebff3bb8d460a335fe189be23a339d9"><td class="memItemLeft" align="right" valign="top"><a id="abebff3bb8d460a335fe189be23a339d9" name="abebff3bb8d460a335fe189be23a339d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VariableFinder</b> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="separator:abebff3bb8d460a335fe189be23a339d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2ee5524ecbe911735528cf21e1d2df1d" name="a2ee5524ecbe911735528cf21e1d2df1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee5524ecbe911735528cf21e1d2df1d">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#a2ee5524ecbe911735528cf21e1d2df1d">Rose::BinaryAnalysis::Variables::VariableFinder::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#ac49414c26c4ddc61dd89fc4e1ad450b6">VariableFinderPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html">VariableFinder</a>. </p>

<p class="definition">Definition at line <a class="el" href="Variables_8h_source.html#l00473">473</a> of file <a class="el" href="Variables_8h_source.html">Variables.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f2c97418cc518c12a32c4d3ecbd9b5a" name="a4f2c97418cc518c12a32c4d3ecbd9b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2c97418cc518c12a32c4d3ecbd9b5a">&#9670;&#160;</a></span>settings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Variables::VariableFinder::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html" title="Settings that control this analysis.">Settings</a> for this analysis. </p>

<p class="definition">Definition at line <a class="el" href="Variables_8h_source.html#l00490">490</a> of file <a class="el" href="Variables_8h_source.html">Variables.h</a>.</p>

</div>
</div>
<a id="a5154d435200218a271dc3a453cf2a09d" name="a5154d435200218a271dc3a453cf2a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5154d435200218a271dc3a453cf2a09d">&#9670;&#160;</a></span>settings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Variables::VariableFinder::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder_1_1Settings.html" title="Settings that control this analysis.">Settings</a> for this analysis. </p>

<p class="definition">Definition at line <a class="el" href="Variables_8h_source.html#l00491">491</a> of file <a class="el" href="Variables_8h_source.html">Variables.h</a>.</p>

</div>
</div>
<a id="acebad6ae5a31e1b166c5352ac6e90d06" name="acebad6ae5a31e1b166c5352ac6e90d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebad6ae5a31e1b166c5352ac6e90d06">&#9670;&#160;</a></span>findStackVariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">StackVariables</a> Rose::BinaryAnalysis::Variables::VariableFinder::findStackVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find local variables in a function. </p>
<p>Analyzes the given function to find the local (stack) variables, caches and returns the list. If this information is already cached, then this method just returns the cached value.</p>
<p>The second argument can be either a function or an instruction. When it's an instruction, we arbitrarily choose one of the functions that owns the instruction. Usually each instruction is owned by only one function, but there are exceptions. </p>

</div>
</div>
<a id="a4ab929e78cce1a1ace137f6b6d1691d0" name="a4ab929e78cce1a1ace137f6b6d1691d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab929e78cce1a1ace137f6b6d1691d0">&#9670;&#160;</a></span>findStackVariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a499dc9e215a3f65f878818f14d5cf252">StackVariables</a> Rose::BinaryAnalysis::Variables::VariableFinder::findStackVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find local variables in a function. </p>
<p>Analyzes the given function to find the local (stack) variables, caches and returns the list. If this information is already cached, then this method just returns the cached value.</p>
<p>The second argument can be either a function or an instruction. When it's an instruction, we arbitrarily choose one of the functions that owns the instruction. Usually each instruction is owned by only one function, but there are exceptions. </p>

</div>
</div>
<a id="ab0fd793e2a523b4456efc478cfcabbbe" name="ab0fd793e2a523b4456efc478cfcabbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fd793e2a523b4456efc478cfcabbbe">&#9670;&#160;</a></span>findGlobalVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a701286bb9c1d8a76612cc46c9df9e112">GlobalVariables</a> Rose::BinaryAnalysis::Variables::VariableFinder::findGlobalVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find global variables. </p>
<p>Finds global variables by examining all functions represented by the given partitioner. Global variables can be found only if they're read or written by some code, and not through a pointer. For example, this method detects variable <code>g1</code> but not <code>g2</code> in the following compiled C code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> g1, g2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> foo() {</div>
<div class="line">    <span class="keywordflow">return</span> g1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> bar(<span class="keywordtype">int</span> *ptr) {</div>
<div class="line">    <span class="keywordflow">return</span> *ptr; <span class="comment">// no static address even if ptr points to g2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If previous results are already cached then they're returned, otherwise new results are computed, cached, and returned. </p>

</div>
</div>
<a id="ab99a29de9d7a11ed10db26f0f21b3296" name="ab99a29de9d7a11ed10db26f0f21b3296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a29de9d7a11ed10db26f0f21b3296">&#9670;&#160;</a></span>evict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Variables::VariableFinder::evict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed cached information. </p>
<p>If a function is supplied as an argument, remove information cached by this analysis for that function. If a partitioner is specified then remove information from all functions. </p>

</div>
</div>
<a id="a33eb7e79122c1fef5ab6acdc669e5b24" name="a33eb7e79122c1fef5ab6acdc669e5b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33eb7e79122c1fef5ab6acdc669e5b24">&#9670;&#160;</a></span>evict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Variables::VariableFinder::evict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed cached information. </p>
<p>If a function is supplied as an argument, remove information cached by this analysis for that function. If a partitioner is specified then remove information from all functions. </p>

</div>
</div>
<a id="ab8af5df5986da4775690d721fe00fe95" name="ab8af5df5986da4775690d721fe00fe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8af5df5986da4775690d721fe00fe95">&#9670;&#160;</a></span>isCached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Variables::VariableFinder::isCached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether local variable information is cached. </p>
<p>Returns true if <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#acebad6ae5a31e1b166c5352ac6e90d06">findStackVariables</a> has been run for the specified function and the results are currently cached in that function. </p>

</div>
</div>
<a id="a673db148fee337c1e4f484a8c2082246" name="a673db148fee337c1e4f484a8c2082246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673db148fee337c1e4f484a8c2082246">&#9670;&#160;</a></span>initializeFrameBoundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Variables::VariableFinder::initializeFrameBoundaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackVariable.html#a4d66055ed20303096dc3891cd1d7e492">StackVariable::Boundaries</a> &amp;&#160;</td>
          <td class="paramname"><em>boundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initilialize offsets for function prologue. </p>
<p>At the start of a function, we sometimes know where certain things are on the stack and their sizes. For instance, for powerpc after the function prologue sets up the stack frame, we know that the stack frame header contain two 4-byte quantities: the pointer to the parent frame, and the LR save area for callees and therefore we can add the three offsets that delimit the boundaries of these two "variables". </p>

</div>
</div>
<a id="a2f10c17ecff8062f36e45e7d78cc3f6d" name="a2f10c17ecff8062f36e45e7d78cc3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f10c17ecff8062f36e45e7d78cc3f6d">&#9670;&#160;</a></span>findFrameOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int64_t &gt; Rose::BinaryAnalysis::Variables::VariableFinder::findFrameOffsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find stack variable addresses. </p>
<p>Given an instruction, look for operand subexpressions that reference memory based from a stack frame pointer, such as x86 "mov eax, [ebp - 12]". Returns the set of offsets from the frame pointer. </p>

</div>
</div>
<a id="af6e25eda197da6e0bf54c83b2d2d5f8c" name="af6e25eda197da6e0bf54c83b2d2d5f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e25eda197da6e0bf54c83b2d2d5f8c">&#9670;&#160;</a></span>functionForInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> Rose::BinaryAnalysis::Variables::VariableFinder::functionForInstruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classFunction.html">Function</a> that owns an instruction. </p>
<p>Given an instruction, return one of the owning functions chosen arbitrarily. This is the method used by the version of <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1VariableFinder.html#acebad6ae5a31e1b166c5352ac6e90d06">findStackVariables</a> that takes an instruction argument. </p>

</div>
</div>
<a id="aeac79fbf5cc6295d4d89f4adab3ae509" name="aeac79fbf5cc6295d4d89f4adab3ae509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac79fbf5cc6295d4d89f4adab3ae509">&#9670;&#160;</a></span>findGlobalVariableVas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Variables.html#a24611814a9787faff90fdb41997ed2cd">AddressToAddresses</a> Rose::BinaryAnalysis::Variables::VariableFinder::findGlobalVariableVas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find global variable addresses. </p>
<p>Returns a list of addresses that are possibly the beginning of global variables. We're only able to find global variables that are referenced by instructions that read or write to the variable. If the global variable is an array then one of two things happen:</p>
<ul>
<li>If the array elements are only accessed with indices that are unknown statically, then the address of the beginning of the array is returned. This applies to C code like:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> get(<span class="keywordtype">int</span> i) {</div>
<div class="line">    <span class="keywordflow">return</span> array[i];</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> sum(<span class="keywordtype">int</span> n) {</div>
<div class="line">    <span class="keywordtype">int</span> s = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i)</div>
<div class="line">        s += array[i];</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>If the array elements are accessed with constant indices, then it's impossible to distinguish between accessing an array with constant indexes and accessing a non-array variable. This applies to C code like:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> get() {</div>
<div class="line">    <span class="keywordflow">return</span> array[3];</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> sum() {</div>
<div class="line">    <span class="keywordtype">int</span> s = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; 4; ++i) <span class="comment">// assume loop unrolling optimization</span></div>
<div class="line">        s += array[i];</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abdaf1b2edba4cd8e4ba478c2b62c4eaf" name="abdaf1b2edba4cd8e4ba478c2b62c4eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaf1b2edba4cd8e4ba478c2b62c4eaf">&#9670;&#160;</a></span>findConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Variables::VariableFinder::findConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find address constants in an expression. </p>
<p>Given a symbolic expression, return all the constants that appear in it that have a potential for being addresses. </p>

</div>
</div>
<a id="a79d18e1aee8d12c7ea5d4619542dd2e1" name="a79d18e1aee8d12c7ea5d4619542dd2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d18e1aee8d12c7ea5d4619542dd2e1">&#9670;&#160;</a></span>getMemoryAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt; Rose::BinaryAnalysis::Variables::VariableFinder::getMemoryAddresses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ab9750a0c3830c74c55a99019d17d3a55">InstructionSemantics::BaseSemantics::MemoryCellStatePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find addresses in memory state. </p>
<p>Given a cell-based symbolic memory state, return all the memory addresses that appear in it. </p>

</div>
</div>
<a id="a2568179a00a7180eb361c80f8588d63b" name="a2568179a00a7180eb361c80f8588d63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2568179a00a7180eb361c80f8588d63b">&#9670;&#160;</a></span>findAddressConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Variables::VariableFinder::findAddressConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ab9750a0c3830c74c55a99019d17d3a55">InstructionSemantics::BaseSemantics::MemoryCellStatePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find constants in memory. </p>
<p>Given an cell-based symbolic memory state, return all constants that appear in the cell addresses. </p>

</div>
</div>
<a id="a41f97878aff0ba37ade38a5156185d48" name="a41f97878aff0ba37ade38a5156185d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f97878aff0ba37ade38a5156185d48">&#9670;&#160;</a></span>removeOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Variables::VariableFinder::removeOutliers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackFrame.html">StackFrame</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Variables_1_1StackVariable.html#a4d66055ed20303096dc3891cd1d7e492">StackVariable::Boundaries</a> &amp;&#160;</td>
          <td class="paramname"><em>sortedBoundaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove boundaries that are outside a stack frame. </p>
<p>If the frame's lowest address is known, then boundaries that begin before the frame are removed. Except if there is no boundary at the beginning of the frame, then the greatest boundary before the frame is moved to the beginning of the frame instead of being removed entirely.</p>
<p>If the frame's upper address is known, then any boundary above that address is removed from the list. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Variables_8h_source.html">Variables.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
