<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Tree::Vertex&lt; B &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Tree.html">Tree</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Vertex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classSawyer_1_1Tree_1_1Vertex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Tree::Vertex&lt; B &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class B&gt;<br />
class Sawyer::Tree::Vertex&lt; B &gt;</div><p>Base class for tree vertices. </p>
<p>A tree vertex is a type with zero or more edges that point to child vertices. The set of all vertices recursively reachable from any particular vertex along these edges forms a tree data structure.</p>
<p>The user might want to have multiple independent tree types whose vertices aren't derived from any common base class. This is accomplished by the user's base class inheriting from this class template, whose argument is the user's base class.</p>
<p>All vertex instantiations are reference counted and ponted to by <code>std::shared_ptr</code>. Some good practices are:</p>
<ul>
<li>In a separate header file intended to be lightweight, often named "BasicTypes.h", create a forward declaration for the class.</li>
</ul>
<ul>
<li>Declare the C++ constructors with protected access and replace them with public, static member functions named <code>instance</code> that allocate a new object in the heap and return a pointer to it. This prevents users from accidentally instantiating objects on the stack or in the data segment.</li>
</ul>
<ul>
<li>Create a nested type named <code>Ptr</code> inside the class. This should be an alias for the <code>std::shared_ptr</code> type. If you do this consistently, then you can always use "Ptr" instead of the much longer "std::shared_ptr&lt;MyClassName&gt;". Since one often needs this type outside this header file, adding an alias to the aforementioned "BasicTypes.h" is prudent, in which case the one in BasicTypes.h should be like "MyClassNamePtr" (i.e., ending with "Ptr") and the alias inside the class would be "using Ptr =
 MyClassNamePtr".</li>
</ul>
<p>As mentioned, a vertex may have zero or more edges that point to children of the same tree. These are data members whose type is <code>Edge&lt;T&gt;</code> or <code>EdgeList&lt;T&gt;</code> (or anything else that inherits from <code>EdgeBase</code>). These types do not have default constructors, so the constructor in the containing class is expected to construct them by passing <code>*this</code> as the first argument to their constructors.</p>
<p>In addition to edges that are part of the tree, it is permissible for a vertex to point directly to other vertices inside or outside the tree from which they're pointed. These are called "cross tree" pointers and do not use the <code>EdgeBase</code> types. By the way, the difference between an "edge" and a "pointer" in this context is that an edge is bidirectional.</p>
<p>Every vertex also has a <code>parent</code> public data member that points to the parent vertex in the tree. The <code>parent</code> data member is updated automatically whenever a child is attached to or detached from a parent vertex. A vertex may have exactly zero or one parent. If vertex <em>v</em> has no parent, then there does not exist any vertex that has an edge pointing to <em>v</em>. Vice versa, if there exists a vertex pointing to <em>v</em> then <em>v</em>-&gt;parent points to that vertex.</p>
<p>Two types of traversals are defined: forward and reverse. The traversals visit only vertices of the specified type (or derivatives thereof), they support both pre- and post-order depth-first traversals, and they can return user-defined types, and they can short-circuit by returning a certain class of values. For more information, see <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad7be4e76c4377d761b492d1992d204c1">traverse</a> and <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aaf2e142b923923901916c790c271f2b1">traverseReverse</a>. All other traversals can be defined in terms of these two.</p>
<p>Example of a class that has two scalar children one of which is always allocated, one vector child, and one cross-tree pointer.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test: <span class="keyword">public</span> Base {  <span class="comment">// Base ultimately inherits from Tree::Vertex&lt;T&gt;</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>Ptr = TestPtr;   <span class="comment">// defined in BasicTypes.h as &quot;using TestPtr = std::shared_ptr&lt;Test&gt;&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge&lt;Test&gt;</a> left;       <span class="comment">// tree edge to the &quot;left&quot; child</span></div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge&lt;Other&gt;</a> right;     <span class="comment">// tree edge to the &quot;right&quot; child, always allocated. Other must also inherit from Base.</span></div>
<div class="line">    EdgeList&lt;Test&gt; list;   <span class="comment">// tree edges to a bunch of children</span></div>
<div class="line">    TestPtr cross;         <span class="comment">// non-tree pointer to some other vertex</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    Test()                 <span class="comment">// C++ constructor hidden from casual users</span></div>
<div class="line">        : left(*this),</div>
<div class="line">          right(*this, Other::instance()),</div>
<div class="line">          list(*this) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> Ptr instance(<span class="keyword">const</span> Ptr &amp;a, <span class="keyword">const</span> Ptr &amp;b) {</div>
<div class="line">        <span class="keyword">auto</span> self = Ptr(<span class="keyword">new</span> Test);</div>
<div class="line">        self-&gt;left = a;</div>
<div class="line">        self-&gt;list.push_back(b);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Adjustments the parents happens automatically</span></div>
<div class="line">        assert(self-&gt;left == a &amp;&amp; a-&gt;parent == self);</div>
<div class="line">        assert(self-&gt;list.front() == b &amp;&amp; b-&gt;parent == self);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> self;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassSawyer_1_1Tree_1_1Vertex_1_1Edge_html"><div class="ttname"><a href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Sawyer::Tree::Vertex::Edge</a></div><div class="ttdoc">A parent-to-child edge in a tree.</div><div class="ttdef"><b>Definition</b> <a href="Tree_8h_source.html#l00358">Tree.h:358</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00125">125</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Sawyer/Tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Tree::Vertex&lt; B &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Vertex__inherit__graph.png" border="0" usemap="#aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_inherit__map" id="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_inherit__map">
<area shape="rect" title="Base class for tree vertices." alt="" coords="5,95,183,120"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Vertex.html" title=" " alt="" coords="22,183,166,223"/>
<area shape="poly" title=" " alt="" coords="97,134,97,182,91,182,91,134"/>
<area shape="rect" title=" " alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="97,59,97,94,91,94,91,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Tree::Vertex&lt; B &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Vertex__coll__graph.png" border="0" usemap="#aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_coll__map" id="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_coll__map">
<area shape="rect" title="Base class for tree vertices." alt="" coords="272,45,449,70"/>
<area shape="rect" title=" " alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="196,35,272,44,271,49,196,40"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html" title="Points from a child to a parent in the tree." alt="" coords="22,69,166,109"/>
<area shape="poly" title=" " alt="" coords="179,76,271,65,272,71,180,82"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1CycleError.html">CycleError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Error.html" title="Error value.">Error</a> when attaching a vertex to a tree would cause a cycle.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1CycleError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parent-to-child edge in a tree.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1EdgeVector.html">EdgeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 1:N tree edge from parent to children.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1EdgeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for errors and exceptions for this vertex type.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html">InsertionError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Error.html" title="Error value.">Error</a> when attaching a vertex to a tree and the vertex is already attached somewhere else.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points from a child to a parent in the tree.  <a href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aca09343f0861a4d024bc2f3340bf5e97" id="r_aca09343f0861a4d024bc2f3340bf5e97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> = B</td></tr>
<tr class="memdesc:aca09343f0861a4d024bc2f3340bf5e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">User's base class.  <br /></td></tr>
<tr class="separator:aca09343f0861a4d024bc2f3340bf5e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166ccc76337e352321b3e90a077be69" id="r_ab166ccc76337e352321b3e90a077be69"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a> = std::shared_ptr&lt; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> &gt;</td></tr>
<tr class="memdesc:ab166ccc76337e352321b3e90a077be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to user's base class.  <br /></td></tr>
<tr class="separator:ab166ccc76337e352321b3e90a077be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c05e1a69aedf9b673c79821b715b2bc" id="r_a9c05e1a69aedf9b673c79821b715b2bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a9c05e1a69aedf9b673c79821b715b2bc">TraversalEvent</a> = <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">Sawyer::Tree::TraversalEvent</a></td></tr>
<tr class="memdesc:a9c05e1a69aedf9b673c79821b715b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for traversal events.  <br /></td></tr>
<tr class="separator:a9c05e1a69aedf9b673c79821b715b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac73d066caddda9a4b5703eb93797336d" id="r_ac73d066caddda9a4b5703eb93797336d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ac73d066caddda9a4b5703eb93797336d">pointer</a> ()</td></tr>
<tr class="memdesc:ac73d066caddda9a4b5703eb93797336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to this vertex.  <br /></td></tr>
<tr class="separator:ac73d066caddda9a4b5703eb93797336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ec565990d9c0dff9e5fb87dcfc1399" id="r_a41ec565990d9c0dff9e5fb87dcfc1399"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41ec565990d9c0dff9e5fb87dcfc1399"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a41ec565990d9c0dff9e5fb87dcfc1399">isa</a> ()</td></tr>
<tr class="memdesc:a41ec565990d9c0dff9e5fb87dcfc1399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this object is a certain type.  <br /></td></tr>
<tr class="separator:a41ec565990d9c0dff9e5fb87dcfc1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2e142b923923901916c790c271f2b1" id="r_aaf2e142b923923901916c790c271f2b1"><td class="memTemplParams" colspan="2">template&lt;class T , class Visitor &gt; </td></tr>
<tr class="memitem:aaf2e142b923923901916c790c271f2b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aaf2e142b923923901916c790c271f2b1">traverseReverse</a> (const Visitor &amp;visitor)</td></tr>
<tr class="memdesc:aaf2e142b923923901916c790c271f2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse in reverse direction from children to parents.  <br /></td></tr>
<tr class="separator:aaf2e142b923923901916c790c271f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be4e76c4377d761b492d1992d204c1" id="r_ad7be4e76c4377d761b492d1992d204c1"><td class="memTemplParams" colspan="2">template&lt;class T , class Visitor &gt; </td></tr>
<tr class="memitem:ad7be4e76c4377d761b492d1992d204c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad7be4e76c4377d761b492d1992d204c1">traverse</a> (const Visitor &amp;visitor)</td></tr>
<tr class="memdesc:ad7be4e76c4377d761b492d1992d204c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse in forward direction from parents to children.  <br /></td></tr>
<tr class="separator:ad7be4e76c4377d761b492d1992d204c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a836c12b441645e56ff98e003d06e4" id="r_a46a836c12b441645e56ff98e003d06e4"><td class="memTemplParams" colspan="2">template&lt;class T , class Visitor &gt; </td></tr>
<tr class="memitem:a46a836c12b441645e56ff98e003d06e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a46a836c12b441645e56ff98e003d06e4">traversePre</a> (const Visitor &amp;visitor)</td></tr>
<tr class="memdesc:a46a836c12b441645e56ff98e003d06e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-order forward traversal.  <br /></td></tr>
<tr class="separator:a46a836c12b441645e56ff98e003d06e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390ca037d867c596d95aa91070523b3b" id="r_a390ca037d867c596d95aa91070523b3b"><td class="memTemplParams" colspan="2">template&lt;class T , class Visitor &gt; </td></tr>
<tr class="memitem:a390ca037d867c596d95aa91070523b3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a390ca037d867c596d95aa91070523b3b">traversePost</a> (const Visitor &amp;visitor)</td></tr>
<tr class="memdesc:a390ca037d867c596d95aa91070523b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-order forward traversal.  <br /></td></tr>
<tr class="separator:a390ca037d867c596d95aa91070523b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f768f103c1d0acb1e3873dd534fc88" id="r_a44f768f103c1d0acb1e3873dd534fc88"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a44f768f103c1d0acb1e3873dd534fc88"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a44f768f103c1d0acb1e3873dd534fc88">findFirstAncestor</a> ()</td></tr>
<tr class="memdesc:a44f768f103c1d0acb1e3873dd534fc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal that finds the closest ancestor of type T or derived from T.  <br /></td></tr>
<tr class="separator:a44f768f103c1d0acb1e3873dd534fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d6fc1816db6549c6f82e933ea743c" id="r_ad02d6fc1816db6549c6f82e933ea743c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad02d6fc1816db6549c6f82e933ea743c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad02d6fc1816db6549c6f82e933ea743c">findLastAncestor</a> ()</td></tr>
<tr class="memdesc:ad02d6fc1816db6549c6f82e933ea743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal that finds the farthest ancestor of type T or derived from T.  <br /></td></tr>
<tr class="separator:ad02d6fc1816db6549c6f82e933ea743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d61ac390f6d10f77e4886f8b3397404" id="r_a8d61ac390f6d10f77e4886f8b3397404"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d61ac390f6d10f77e4886f8b3397404"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a8d61ac390f6d10f77e4886f8b3397404">findDescendants</a> ()</td></tr>
<tr class="memdesc:a8d61ac390f6d10f77e4886f8b3397404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal that finds all the descendants of a particular type.  <br /></td></tr>
<tr class="separator:a8d61ac390f6d10f77e4886f8b3397404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afb3d01af45a09ac593f1577ff2bc3" id="r_ab9afb3d01af45a09ac593f1577ff2bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab9afb3d01af45a09ac593f1577ff2bc3">child</a> (size_t i) const</td></tr>
<tr class="memdesc:ab9afb3d01af45a09ac593f1577ff2bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer for a child.  <br /></td></tr>
<tr class="separator:ab9afb3d01af45a09ac593f1577ff2bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae6d0a0068ed93e12ffcc0941dfa025" id="r_afae6d0a0068ed93e12ffcc0941dfa025"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#afae6d0a0068ed93e12ffcc0941dfa025">nChildren</a> () const</td></tr>
<tr class="memdesc:afae6d0a0068ed93e12ffcc0941dfa025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children.  <br /></td></tr>
<tr class="separator:afae6d0a0068ed93e12ffcc0941dfa025"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5605ce3a8f9a875e41a56b00b549d222" id="r_a5605ce3a8f9a875e41a56b00b549d222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a5605ce3a8f9a875e41a56b00b549d222">parent</a></td></tr>
<tr class="memdesc:a5605ce3a8f9a875e41a56b00b549d222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the parent in the tree.  <br /></td></tr>
<tr class="separator:a5605ce3a8f9a875e41a56b00b549d222"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8bcb9a546ab94941797ebb7388db45dd" id="r_a8bcb9a546ab94941797ebb7388db45dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a8bcb9a546ab94941797ebb7388db45dd">destructorHelper</a> ()</td></tr>
<tr class="separator:a8bcb9a546ab94941797ebb7388db45dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aca09343f0861a4d024bc2f3340bf5e97" name="aca09343f0861a4d024bc2f3340bf5e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca09343f0861a4d024bc2f3340bf5e97">&#9670;&#160;</a></span>UserBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::UserBase =  B</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User's base class. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00129">129</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ab166ccc76337e352321b3e90a077be69" name="ab166ccc76337e352321b3e90a077be69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab166ccc76337e352321b3e90a077be69">&#9670;&#160;</a></span>UserBasePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::UserBasePtr =  std::shared_ptr&lt;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to user's base class. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00132">132</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a9c05e1a69aedf9b673c79821b715b2bc" name="a9c05e1a69aedf9b673c79821b715b2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c05e1a69aedf9b673c79821b715b2bc">&#9670;&#160;</a></span>TraversalEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::TraversalEvent =  <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">Sawyer::Tree::TraversalEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for traversal events. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00135">135</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a97488994a2482d70da74e1b91d40e169" name="a97488994a2482d70da74e1b91d40e169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97488994a2482d70da74e1b91d40e169">&#9670;&#160;</a></span>Vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vertex::Vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01326">1326</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8bcb9a546ab94941797ebb7388db45dd" name="a8bcb9a546ab94941797ebb7388db45dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb9a546ab94941797ebb7388db45dd">&#9670;&#160;</a></span>destructorHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::destructorHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00944">944</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ac73d066caddda9a4b5703eb93797336d" name="ac73d066caddda9a4b5703eb93797336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73d066caddda9a4b5703eb93797336d">&#9670;&#160;</a></span>pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Vertex</a>&lt; B &gt;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">::UserBasePtr</a> Vertex::pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shared pointer to this vertex. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01331">1331</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tree_8h_source.html#l01127">Sawyer::Tree::Vertex&lt; B &gt;::ReverseEdge::operator()()</a>, <a class="el" href="Tree_8h_source.html#l01017">Sawyer::Tree::Vertex&lt; B &gt;::traverse()</a>, and <a class="el" href="Tree_8h_source.html#l00989">Sawyer::Tree::Vertex&lt; B &gt;::traverseReverse()</a>.</p>

</div>
</div>
<a id="a41ec565990d9c0dff9e5fb87dcfc1399" name="a41ec565990d9c0dff9e5fb87dcfc1399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ec565990d9c0dff9e5fb87dcfc1399">&#9670;&#160;</a></span>isa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; Vertex::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether this object is a certain type. </p>
<p>Returns a shared pointer to the object if the object is of dynamic type T, otherwise returns a null pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01340">1340</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="aaf2e142b923923901916c790c271f2b1" name="aaf2e142b923923901916c790c271f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2e142b923923901916c790c271f2b1">&#9670;&#160;</a></span>traverseReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T , class Visitor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::traverseReverse </td>
          <td>(</td>
          <td class="paramtype">const Visitor &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse in reverse direction from children to parents. </p>
<p>The visitor is called for each vertex from the current vertex whose type is <code>T</code> until the root of the tree is reached unless the visitor indicates that the traversal should end. It does so by returning a value that is true in a Boolean context, and this value becomes the return value for the entire traversal.</p>
<p>Example: Find the closest ancestor whose type is Foo or is derived from Foo.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foundFirst = tree-&gt;traverseReverse&lt;Foo&gt;([](<span class="keyword">const</span> Foo::Ptr &amp;foo, <a class="code hl_enumeration" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">TraversalEvent</a> event) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">TraversalEvent::ENTER</a> == <span class="keyword">event</span> ? foo : <span class="keyword">nullptr</span>;</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceSawyer_1_1Tree_html_af53536c0a2ff7cbcb82651e2faf6991f"><div class="ttname"><a href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">Sawyer::Tree::TraversalEvent</a></div><div class="ttdeci">TraversalEvent</div><div class="ttdoc">Traversal event.</div><div class="ttdef"><b>Definition</b> <a href="Tree_8h_source.html#l00044">Tree.h:44</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Tree_html_af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13"><div class="ttname"><a href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::TraversalEvent::ENTER</a></div><div class="ttdeci">@ ENTER</div><div class="ttdoc">Pre-order visitation.</div></div>
</div><!-- fragment --><p>Example: Find the most distant ancestor whose type is Foo or is derived from Foo. The only change from the previous example is that we test as we leave the vertices. I.e., as the depth-first traversal is returning.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foundLast = tree-&gt;traverseReverse&lt;Foo&gt;([](<span class="keyword">const</span> Foo::Ptr &amp;foo, <a class="code hl_enumeration" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">TraversalEvent</a> event) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">TraversalEvent::LEAVE</a> == <span class="keyword">event</span> ? foo : <span class="keyword">nullptr</span>;</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceSawyer_1_1Tree_html_af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781"><div class="ttname"><a href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">Sawyer::Tree::TraversalEvent::LEAVE</a></div><div class="ttdeci">@ LEAVE</div><div class="ttdoc">Post-order visitation.</div></div>
</div><!-- fragment --><p>If you want to exclude the current vertex from the traversal, start searching at the parent instead, but be careful that the parent is not null or else its arrow operator will fail.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foundFirstNotMe = tree-&gt;parent-&gt;traverseReverse&lt;Foo&gt;([](<span class="keyword">const</span> Foo::Ptr &amp;foo, <a class="code hl_enumeration" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991f">TraversalEvent</a> event) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">TraversalEvent::ENTER</a> == <span class="keyword">event</span> ? foo : <span class="keyword">nullptr</span>;</div>
<div class="line">});</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00989">989</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::ENTER</a>, <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">Sawyer::Tree::LEAVE</a>, <a class="el" href="Tree_8h_source.html#l00856">Sawyer::Tree::Vertex&lt; B &gt;::parent</a>, and <a class="el" href="Tree_8h_source.html#l01331">Sawyer::Tree::Vertex&lt; B &gt;::pointer()</a>.</p>

</div>
</div>
<a id="ad7be4e76c4377d761b492d1992d204c1" name="ad7be4e76c4377d761b492d1992d204c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be4e76c4377d761b492d1992d204c1">&#9670;&#160;</a></span>traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T , class Visitor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">const Visitor &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse in forward direction from parents to children. </p>
<p>Perform a depth-first traversal of the tree starting with this vertex. The visitor functor is called twice for each vertex, first in the forward direction from the parent, then in the reverse direction from the children. The functor takes two arguments: the vertex being visited and an enum indicating whether the visit is the first (<code>Traverse::ENTER</code>) or the second (<code>Traverse::LEAVE</code>) visitation. The traversal has the same return type as the functor. If the functor returns a value which evaluates to true in Boolean context, then the traversal immediately returns that value, otherwise it continues until the entire subtree is visited and returns a default-constructed value. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01017">1017</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::ENTER</a>, <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">Sawyer::Tree::LEAVE</a>, and <a class="el" href="Tree_8h_source.html#l01331">Sawyer::Tree::Vertex&lt; B &gt;::pointer()</a>.</p>

</div>
</div>
<a id="a46a836c12b441645e56ff98e003d06e4" name="a46a836c12b441645e56ff98e003d06e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a836c12b441645e56ff98e003d06e4">&#9670;&#160;</a></span>traversePre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T , class Visitor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::traversePre </td>
          <td>(</td>
          <td class="paramtype">const Visitor &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-order forward traversal. </p>
<p>Perform a depth-first pre-order traversal. The functor is called once for each vertex before any of its children are traversed. This is equivalent to the <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad7be4e76c4377d761b492d1992d204c1">traverse</a> traversal where the functor checks that the event is an <code>ENTER</code> event before doing anything. If the functor returns a value which evaluates to true in Boolean context, then the traversal immediately returns that value, otherwise it continues until the entire subtree is visited and returns a default-constructed value. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01042">1042</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::ENTER</a>.</p>

</div>
</div>
<a id="a390ca037d867c596d95aa91070523b3b" name="a390ca037d867c596d95aa91070523b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390ca037d867c596d95aa91070523b3b">&#9670;&#160;</a></span>traversePost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T , class Visitor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::traversePost </td>
          <td>(</td>
          <td class="paramtype">const Visitor &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-order forward traversal. </p>
<p>Perform a depth-first post-order traversal. The functor is called once for each vertex all of its children are traversed. This is equivalent to the <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad7be4e76c4377d761b492d1992d204c1">traverse</a> traversal where the functor checks that the event is an <code>LEAVE</code> event before doing anything. If the functor returns a value which evaluates to true in Boolean context, then the traversal immediately returns that value, otherwise it continues until the entire subtree is visited and returns a default-constructed value. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01060">1060</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">Sawyer::Tree::LEAVE</a>.</p>

</div>
</div>
<a id="a44f768f103c1d0acb1e3873dd534fc88" name="a44f768f103c1d0acb1e3873dd534fc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f768f103c1d0acb1e3873dd534fc88">&#9670;&#160;</a></span>findFirstAncestor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::findFirstAncestor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal that finds the closest ancestor of type T or derived from T. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01072">1072</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::ENTER</a>.</p>

</div>
</div>
<a id="ad02d6fc1816db6549c6f82e933ea743c" name="ad02d6fc1816db6549c6f82e933ea743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02d6fc1816db6549c6f82e933ea743c">&#9670;&#160;</a></span>findLastAncestor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::findLastAncestor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal that finds the farthest ancestor of type T or derived from T. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01080">1080</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fae0f9ef6d3025baf33497bafcca7ff781">Sawyer::Tree::LEAVE</a>.</p>

</div>
</div>
<a id="a8d61ac390f6d10f77e4886f8b3397404" name="a8d61ac390f6d10f77e4886f8b3397404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d61ac390f6d10f77e4886f8b3397404">&#9670;&#160;</a></span>findDescendants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; T &gt; &gt; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::findDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traversal that finds all the descendants of a particular type. </p>
<p>Note that this is probably not the way you want to do this because it's expensive to create the list of all matching pointers. Instead, you probably want to call <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ad7be4e76c4377d761b492d1992d204c1">traverse</a> and handle each matching vertex inside the functor. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01091">1091</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceSawyer_1_1Tree.html#af53536c0a2ff7cbcb82651e2faf6991fa331b3100a485d8cacff1d3df8e9b0c13">Sawyer::Tree::ENTER</a>.</p>

</div>
</div>
<a id="ab9afb3d01af45a09ac593f1577ff2bc3" name="ab9afb3d01af45a09ac593f1577ff2bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9afb3d01af45a09ac593f1577ff2bc3">&#9670;&#160;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Vertex</a>&lt; B &gt;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">::UserBasePtr</a> Vertex::child </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pointer for a child. </p>
<p>Returns the pointer for the child at index <code>i</code>. If <code>i</code> is out of range, then a null pointer is returned, which is indistinguishable from the case when a valid index is specified but that child is a null pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01346">1346</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="afae6d0a0068ed93e12ffcc0941dfa025" name="afae6d0a0068ed93e12ffcc0941dfa025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae6d0a0068ed93e12ffcc0941dfa025">&#9670;&#160;</a></span>nChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Vertex::nChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children. </p>
<p>This is the number of children for this class and the base class, recursively. Some children may be null pointers. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01362">1362</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5605ce3a8f9a875e41a56b00b549d222" name="a5605ce3a8f9a875e41a56b00b549d222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605ce3a8f9a875e41a56b00b549d222">&#9670;&#160;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a> <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the parent in the tree. </p>
<p>A vertex's parent pointer is adjusted automatically when the vertex is inserted or removed as a child of another vertex. An invariant of this design is that whenever vertex A is a child of vertex B, then vertex B is a parent of vertex A. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00856">856</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tree_8h_source.html#l01198">Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt;::~Edge()</a>, <a class="el" href="Tree_8h_source.html#l00476">Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt;::operator=()</a>, and <a class="el" href="Tree_8h_source.html#l00989">Sawyer::Tree::Vertex&lt; B &gt;::traverseReverse()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
