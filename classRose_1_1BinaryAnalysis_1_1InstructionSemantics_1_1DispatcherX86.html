<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html">DispatcherX86</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86 Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Semantically evaluates Intel x86 instructions. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00031">31</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="DispatcherX86_8h_source.html">Rose/BinaryAnalysis/InstructionSemantics/DispatcherX86.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_inherit__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_inherit__map">
<area shape="rect" title="Semantically evaluates Intel x86 instructions." alt="" coords="25,108,179,163"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html" title="Dispatches instructions through the RISC layer." alt="" coords="5,5,199,60"/>
<area shape="poly" title=" " alt="" coords="105,74,105,108,99,108,99,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_coll__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86_coll__map">
<area shape="rect" title="Semantically evaluates Intel x86 instructions." alt="" coords="304,96,457,151"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html" title="Dispatches instructions through the RISC layer." alt="" coords="5,5,199,60"/>
<area shape="poly" title=" " alt="" coords="213,33,247,39,281,49,320,69,353,94,349,98,317,74,279,54,246,44,212,38"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register." alt="" coords="28,194,176,234"/>
<area shape="poly" title=" " alt="" coords="189,227,235,226,279,216,303,203,325,186,359,149,363,153,328,190,306,207,281,220,236,231,190,232"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aebaaac87dc0ba747cae1a7105bf4cbdb" id="r_aebaaac87dc0ba747cae1a7105bf4cbdb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>AccessMode</b> { <br />
&#160;&#160;<b>READ_REGISTER</b>
, <br />
&#160;&#160;<b>PEEK_REGISTER</b>
<br />
 }</td></tr>
<tr class="separator:aebaaac87dc0ba747cae1a7105bf4cbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89eff1ff3e14a7eca258348d13be94b" id="r_aa89eff1ff3e14a7eca258348d13be94b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa89eff1ff3e14a7eca258348d13be94b">Super</a> = <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">BaseSemantics::Dispatcher</a></td></tr>
<tr class="memdesc:aa89eff1ff3e14a7eca258348d13be94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <br /></td></tr>
<tr class="separator:aa89eff1ff3e14a7eca258348d13be94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af0e6a25687041b368ca56fed2c260" id="r_ab4af0e6a25687041b368ca56fed2c260"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab4af0e6a25687041b368ca56fed2c260">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a></td></tr>
<tr class="memdesc:ab4af0e6a25687041b368ca56fed2c260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:ab4af0e6a25687041b368ca56fed2c260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a></td></tr>
<tr class="memitem:aba83aa8cc8aafe5b0552bea311dda4d7 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_aba83aa8cc8aafe5b0552bea311dda4d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aba83aa8cc8aafe5b0552bea311dda4d7">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">DispatcherPtr</a></td></tr>
<tr class="memdesc:aba83aa8cc8aafe5b0552bea311dda4d7 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:aba83aa8cc8aafe5b0552bea311dda4d7 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa58d05091576e0a51b92ca72509cca4d" id="r_aa58d05091576e0a51b92ca72509cca4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa58d05091576e0a51b92ca72509cca4d">iproc_init</a> ()</td></tr>
<tr class="memdesc:aa58d05091576e0a51b92ca72509cca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the iproc table with instruction processing functors.  <br /></td></tr>
<tr class="separator:aa58d05091576e0a51b92ca72509cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87f06e45f39c052c2b13269b1d42cc9" id="r_ab87f06e45f39c052c2b13269b1d42cc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab87f06e45f39c052c2b13269b1d42cc9">regcache_init</a> ()</td></tr>
<tr class="memdesc:ab87f06e45f39c052c2b13269b1d42cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the cached register descriptors.  <br /></td></tr>
<tr class="separator:ab87f06e45f39c052c2b13269b1d42cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121c0b3524e354ef614627636186171e" id="r_a121c0b3524e354ef614627636186171e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a121c0b3524e354ef614627636186171e">memory_init</a> ()</td></tr>
<tr class="memdesc:a121c0b3524e354ef614627636186171e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure memory properties are set up correctly.  <br /></td></tr>
<tr class="separator:a121c0b3524e354ef614627636186171e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b566b54d4dfd835677cda2d1687285" id="r_a58b566b54d4dfd835677cda2d1687285"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a58b566b54d4dfd835677cda2d1687285">create</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;) const override</td></tr>
<tr class="memdesc:a58b566b54d4dfd835677cda2d1687285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor.  <br /></td></tr>
<tr class="separator:a58b566b54d4dfd835677cda2d1687285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac074b29b286891bd2fe828bcc4a10918" id="r_ac074b29b286891bd2fe828bcc4a10918"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac074b29b286891bd2fe828bcc4a10918">get_usual_registers</a> () const</td></tr>
<tr class="memdesc:ac074b29b286891bd2fe828bcc4a10918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of common registers.  <br /></td></tr>
<tr class="separator:ac074b29b286891bd2fe828bcc4a10918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9dc8b716dceab013ec14122f4cf01b" id="r_afc9dc8b716dceab013ec14122f4cf01b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#afc9dc8b716dceab013ec14122f4cf01b">instructionPointerRegister</a> () const override</td></tr>
<tr class="memdesc:afc9dc8b716dceab013ec14122f4cf01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction pointer register.  <br /></td></tr>
<tr class="separator:afc9dc8b716dceab013ec14122f4cf01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29201526ecc83115ab9ffc18acf518e" id="r_ac29201526ecc83115ab9ffc18acf518e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac29201526ecc83115ab9ffc18acf518e">stackPointerRegister</a> () const override</td></tr>
<tr class="memdesc:ac29201526ecc83115ab9ffc18acf518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack pointer register.  <br /></td></tr>
<tr class="separator:ac29201526ecc83115ab9ffc18acf518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a6aae7bd6c8841df264b662f9c004e" id="r_a69a6aae7bd6c8841df264b662f9c004e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a69a6aae7bd6c8841df264b662f9c004e">stackFrameRegister</a> () const override</td></tr>
<tr class="memdesc:a69a6aae7bd6c8841df264b662f9c004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack call frame register.  <br /></td></tr>
<tr class="separator:a69a6aae7bd6c8841df264b662f9c004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132a176304a818b96b5eed5d730d642b" id="r_a132a176304a818b96b5eed5d730d642b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a132a176304a818b96b5eed5d730d642b">callReturnRegister</a> () const override</td></tr>
<tr class="memdesc:a132a176304a818b96b5eed5d730d642b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function call return address register.  <br /></td></tr>
<tr class="separator:a132a176304a818b96b5eed5d730d642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660ac92fd1d5550f4135084653f2ceb4" id="r_a660ac92fd1d5550f4135084653f2ceb4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a660ac92fd1d5550f4135084653f2ceb4">iprocKey</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn_) const override</td></tr>
<tr class="memdesc:a660ac92fd1d5550f4135084653f2ceb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an instruction, return the InsnProcessor key that can be used as an index into the iproc_table.  <br /></td></tr>
<tr class="separator:a660ac92fd1d5550f4135084653f2ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac450f0cf6ba26a8caf5f7361bbf95d" id="r_acac450f0cf6ba26a8caf5f7361bbf95d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#acac450f0cf6ba26a8caf5f7361bbf95d">write</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *e, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;value, size_t addr_nbits=0) override</td></tr>
<tr class="memdesc:acac450f0cf6ba26a8caf5f7361bbf95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to an L-value expression.  <br /></td></tr>
<tr class="separator:acac450f0cf6ba26a8caf5f7361bbf95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b4b454345f20dc83d932519ba00bde" id="r_ab6b4b454345f20dc83d932519ba00bde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab6b4b454345f20dc83d932519ba00bde">initializeState</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;) override</td></tr>
<tr class="memdesc:ab6b4b454345f20dc83d932519ba00bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the state.  <br /></td></tr>
<tr class="separator:ab6b4b454345f20dc83d932519ba00bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f385265465904b9c90fe932dc3eb2" id="r_a481f385265465904b9c90fe932dc3eb2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a481f385265465904b9c90fe932dc3eb2">readRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>, AccessMode mode=READ_REGISTER)</td></tr>
<tr class="memdesc:a481f385265465904b9c90fe932dc3eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific read from register.  <br /></td></tr>
<tr class="separator:a481f385265465904b9c90fe932dc3eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dc8c09c26ed0a9cf27458569151991" id="r_a71dc8c09c26ed0a9cf27458569151991"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a71dc8c09c26ed0a9cf27458569151991">writeRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;result)</td></tr>
<tr class="memdesc:a71dc8c09c26ed0a9cf27458569151991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific write to register.  <br /></td></tr>
<tr class="separator:a71dc8c09c26ed0a9cf27458569151991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987afecc59a4063fbc3f305af803aff0" id="r_a987afecc59a4063fbc3f305af803aff0"><td class="memItemLeft" align="right" valign="top"><a id="a987afecc59a4063fbc3f305af803aff0" name="a987afecc59a4063fbc3f305af803aff0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlagsForResult</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;result)</td></tr>
<tr class="memdesc:a987afecc59a4063fbc3f305af803aff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parity, sign, and zero flags appropriate for result value. <br /></td></tr>
<tr class="separator:a987afecc59a4063fbc3f305af803aff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dee0ef4c675b08a05996b9f23dea7a" id="r_ae7dee0ef4c675b08a05996b9f23dea7a"><td class="memItemLeft" align="right" valign="top"><a id="ae7dee0ef4c675b08a05996b9f23dea7a" name="ae7dee0ef4c675b08a05996b9f23dea7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFlagsForResult</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;result, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;cond)</td></tr>
<tr class="memdesc:ae7dee0ef4c675b08a05996b9f23dea7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally set parity, sign, and zero flags appropriate for result value. <br /></td></tr>
<tr class="separator:ae7dee0ef4c675b08a05996b9f23dea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa342ac20dac418e0b31be1c8b2de43c9" id="r_aa342ac20dac418e0b31be1c8b2de43c9"><td class="memItemLeft" align="right" valign="top"><a id="aa342ac20dac418e0b31be1c8b2de43c9" name="aa342ac20dac418e0b31be1c8b2de43c9"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parity</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;v)</td></tr>
<tr class="memdesc:aa342ac20dac418e0b31be1c8b2de43c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if byte <code>v</code> has an even number of bits set; false for an odd number. <br /></td></tr>
<tr class="separator:aa342ac20dac418e0b31be1c8b2de43c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311679faf4331fa134b54189c9170ea7" id="r_a311679faf4331fa134b54189c9170ea7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a311679faf4331fa134b54189c9170ea7">invertMaybe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;value, bool maybe)</td></tr>
<tr class="memdesc:a311679faf4331fa134b54189c9170ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally invert the bits of <code>value</code>.  <br /></td></tr>
<tr class="separator:a311679faf4331fa134b54189c9170ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccc10042cfbeef5ea48427f9a3c7a3" id="r_ad7ccc10042cfbeef5ea48427f9a3c7a3"><td class="memItemLeft" align="right" valign="top"><a id="ad7ccc10042cfbeef5ea48427f9a3c7a3" name="ad7ccc10042cfbeef5ea48427f9a3c7a3"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>greaterOrEqualToTen</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;value)</td></tr>
<tr class="memdesc:ad7ccc10042cfbeef5ea48427f9a3c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>value</code> is greater than or equal to ten. <br /></td></tr>
<tr class="separator:ad7ccc10042cfbeef5ea48427f9a3c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba5bcec47e3af74a6b586dc803244bc" id="r_a5ba5bcec47e3af74a6b586dc803244bc"><td class="memItemLeft" align="right" valign="top"><a id="a5ba5bcec47e3af74a6b586dc803244bc" name="a5ba5bcec47e3af74a6b586dc803244bc"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flagsCombo</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a60d901bdb3369239fda973246fc9d014">X86InstructionKind</a> k)</td></tr>
<tr class="memdesc:a5ba5bcec47e3af74a6b586dc803244bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Boolean for the specified flag combo for an instruction. <br /></td></tr>
<tr class="separator:a5ba5bcec47e3af74a6b586dc803244bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa2ac2df69c075baebb4aab40671044" id="r_abfa2ac2df69c075baebb4aab40671044"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abfa2ac2df69c075baebb4aab40671044">repEnter</a> (X86RepeatPrefix)</td></tr>
<tr class="memdesc:abfa2ac2df69c075baebb4aab40671044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters a loop for a REP-, REPE-, or REPNE-prefixed instruction.  <br /></td></tr>
<tr class="separator:abfa2ac2df69c075baebb4aab40671044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476c45429118a5b472b0b8c7512c0ad9" id="r_a476c45429118a5b472b0b8c7512c0ad9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a476c45429118a5b472b0b8c7512c0ad9">repLeave</a> (X86RepeatPrefix, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;in_loop, rose_addr_t insn_va, bool honorZeroFlag)</td></tr>
<tr class="memdesc:a476c45429118a5b472b0b8c7512c0ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a loop for a REP-, REPE-, or REPNE-prefixed instruction.  <br /></td></tr>
<tr class="separator:a476c45429118a5b472b0b8c7512c0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3c9bb72ce53076b6d5a049fdc3bd1a" id="r_a6f3c9bb72ce53076b6d5a049fdc3bd1a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a6f3c9bb72ce53076b6d5a049fdc3bd1a">doIncOperation</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a, bool dec, bool setCarry)</td></tr>
<tr class="memdesc:a6f3c9bb72ce53076b6d5a049fdc3bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments or decrements a value and adjusts flags.  <br /></td></tr>
<tr class="separator:a6f3c9bb72ce53076b6d5a049fdc3bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2234c540b75a492d6a42606a5512f342" id="r_a2234c540b75a492d6a42606a5512f342"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a2234c540b75a492d6a42606a5512f342">doRotateOperation</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a60d901bdb3369239fda973246fc9d014">X86InstructionKind</a> kind, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;operand, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;total_rotate, size_t rotateSignificantBits)</td></tr>
<tr class="memdesc:a2234c540b75a492d6a42606a5512f342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the RCL, RCR, ROL, and ROR instructions for various operand sizes.  <br /></td></tr>
<tr class="separator:a2234c540b75a492d6a42606a5512f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5fe087c27844d9eb7019d71f8365a1" id="r_abe5fe087c27844d9eb7019d71f8365a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abe5fe087c27844d9eb7019d71f8365a1">doShiftOperation</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a60d901bdb3369239fda973246fc9d014">X86InstructionKind</a> kind, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;operand, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;source_bits, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;total_shift, size_t shiftSignificantBits)</td></tr>
<tr class="memdesc:abe5fe087c27844d9eb7019d71f8365a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the SHR, SAR, SHL, SAL, SHRD, and SHLD instructions for various operand sizes.  <br /></td></tr>
<tr class="separator:abe5fe087c27844d9eb7019d71f8365a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98dfdcfbfdf474c2dad51d736e19edf" id="r_ae98dfdcfbfdf474c2dad51d736e19edf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae98dfdcfbfdf474c2dad51d736e19edf">pushFloatingPoint</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;valueToPush)</td></tr>
<tr class="memdesc:ae98dfdcfbfdf474c2dad51d736e19edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push floating-point value onto FP stack.  <br /></td></tr>
<tr class="separator:ae98dfdcfbfdf474c2dad51d736e19edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc5b3daf7633db88a3e231c9739bb78" id="r_a1cc5b3daf7633db88a3e231c9739bb78"><td class="memItemLeft" align="right" valign="top"><a id="a1cc5b3daf7633db88a3e231c9739bb78" name="a1cc5b3daf7633db88a3e231c9739bb78"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>readFloatingPointStack</b> (size_t position)</td></tr>
<tr class="memdesc:a1cc5b3daf7633db88a3e231c9739bb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from the floating point stack. <br /></td></tr>
<tr class="separator:a1cc5b3daf7633db88a3e231c9739bb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fffd5a359fd160bbd839c77258fc19" id="r_a04fffd5a359fd160bbd839c77258fc19"><td class="memItemLeft" align="right" valign="top"><a id="a04fffd5a359fd160bbd839c77258fc19" name="a04fffd5a359fd160bbd839c77258fc19"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>popFloatingPoint</b> ()</td></tr>
<tr class="memdesc:a04fffd5a359fd160bbd839c77258fc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the top item from the floating point stack. <br /></td></tr>
<tr class="separator:a04fffd5a359fd160bbd839c77258fc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa79ce6c62b1b9ca15d66156795804" id="r_a1eaa79ce6c62b1b9ca15d66156795804"><td class="memItemLeft" align="right" valign="top"><a id="a1eaa79ce6c62b1b9ca15d66156795804" name="a1eaa79ce6c62b1b9ca15d66156795804"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fixMemoryAddress</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;address) const</td></tr>
<tr class="memdesc:a1eaa79ce6c62b1b9ca15d66156795804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend or truncate value to propert memory address width. <br /></td></tr>
<tr class="separator:a1eaa79ce6c62b1b9ca15d66156795804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be5ac9b26d60fbc6ca16e60591e60c" id="r_aa0be5ac9b26d60fbc6ca16e60591e60c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa0be5ac9b26d60fbc6ca16e60591e60c">saturateSignedToUnsigned</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;, size_t narrowerWidth)</td></tr>
<tr class="memdesc:aa0be5ac9b26d60fbc6ca16e60591e60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signed value to a narrower unsigned type.  <br /></td></tr>
<tr class="separator:aa0be5ac9b26d60fbc6ca16e60591e60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0bc6b8fd8bc194b9e3f8968de765fa" id="r_afd0bc6b8fd8bc194b9e3f8968de765fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#afd0bc6b8fd8bc194b9e3f8968de765fa">saturateSignedToSigned</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;, size_t narrowerWidth)</td></tr>
<tr class="memdesc:afd0bc6b8fd8bc194b9e3f8968de765fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signed value to a narrower signed type.  <br /></td></tr>
<tr class="separator:afd0bc6b8fd8bc194b9e3f8968de765fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8fa383f6cae76a0cb497159bfe752c" id="r_a6a8fa383f6cae76a0cb497159bfe752c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a6a8fa383f6cae76a0cb497159bfe752c">saturateUnsignedToUnsigned</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;, size_t narrowerWidth)</td></tr>
<tr class="memdesc:a6a8fa383f6cae76a0cb497159bfe752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned value to a narrower unsigned type.  <br /></td></tr>
<tr class="separator:a6a8fa383f6cae76a0cb497159bfe752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a989e1bd1e79730680bc1e84ac3e428b9" id="r_a989e1bd1e79730680bc1e84ac3e428b9"><td class="memItemLeft" align="right" valign="top">X86InstructionSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a989e1bd1e79730680bc1e84ac3e428b9">processorMode</a> () const</td></tr>
<tr class="memdesc:a989e1bd1e79730680bc1e84ac3e428b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU mode of operation.  <br /></td></tr>
<tr class="separator:a989e1bd1e79730680bc1e84ac3e428b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2d0948023bf8e28d459aecf44347d3" id="r_a2c2d0948023bf8e28d459aecf44347d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a2c2d0948023bf8e28d459aecf44347d3">processorMode</a> (X86InstructionSize m)</td></tr>
<tr class="memdesc:a2c2d0948023bf8e28d459aecf44347d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU mode of operation.  <br /></td></tr>
<tr class="separator:a2c2d0948023bf8e28d459aecf44347d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36f5fdc3671dba626ce455e8ccd90b20" id="r_a36f5fdc3671dba626ce455e8ccd90b20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a36f5fdc3671dba626ce455e8ccd90b20">doAddOperation</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> a, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> b, bool invertCarries, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;carryIn)</td></tr>
<tr class="memdesc:a36f5fdc3671dba626ce455e8ccd90b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two values and adjusts flags.  <br /></td></tr>
<tr class="separator:a36f5fdc3671dba626ce455e8ccd90b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778b72136ea46c37735f35375e4d404" id="r_a8778b72136ea46c37735f35375e4d404"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a8778b72136ea46c37735f35375e4d404">doAddOperation</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> a, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> b, bool invertCarries, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;carryIn, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;cond)</td></tr>
<tr class="memdesc:a8778b72136ea46c37735f35375e4d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two values and adjusts flags.  <br /></td></tr>
<tr class="separator:a8778b72136ea46c37735f35375e4d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a></td></tr>
<tr class="memitem:a8f9821e5f9103b613fa166e85a69cb3e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a8f9821e5f9103b613fa166e85a69cb3e"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>processInstruction</b> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a8f9821e5f9103b613fa166e85a69cb3e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a single instruction. <br /></td></tr>
<tr class="separator:a8f9821e5f9103b613fa166e85a69cb3e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aef72da7c3dea593ae12f8364738ca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a16aef72da7c3dea593ae12f8364738ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1InsnProcessor.html">InsnProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a16aef72da7c3dea593ae12f8364738ca">iprocLookup</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a16aef72da7c3dea593ae12f8364738ca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the processor for an instruction.  <br /></td></tr>
<tr class="separator:a16aef72da7c3dea593ae12f8364738ca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f5205e6614e17e9f74eda965f3220c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a89f5205e6614e17e9f74eda965f3220c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a89f5205e6614e17e9f74eda965f3220c">iprocReplace</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1InsnProcessor.html">InsnProcessor</a> *iproc)</td></tr>
<tr class="memdesc:a89f5205e6614e17e9f74eda965f3220c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an instruction processor with another.  <br /></td></tr>
<tr class="separator:a89f5205e6614e17e9f74eda965f3220c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923f64d1c228fbffa9a9fee67d0cc92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_ae923f64d1c228fbffa9a9fee67d0cc92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#ae923f64d1c228fbffa9a9fee67d0cc92">iprocSet</a> (int key, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1InsnProcessor.html">InsnProcessor</a> *iproc)</td></tr>
<tr class="memdesc:ae923f64d1c228fbffa9a9fee67d0cc92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an iproc table entry to the specified value.  <br /></td></tr>
<tr class="separator:ae923f64d1c228fbffa9a9fee67d0cc92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d7c3dbdaee2162cbb0b4422e70f28 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a6e5d7c3dbdaee2162cbb0b4422e70f28"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1InsnProcessor.html">InsnProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>iprocGet</b> (int key)</td></tr>
<tr class="memdesc:a6e5d7c3dbdaee2162cbb0b4422e70f28 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an iproc table entry for the specified key. <br /></td></tr>
<tr class="separator:a6e5d7c3dbdaee2162cbb0b4422e70f28 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a9eb5e4f868d9c08dae40a2ed36603 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a16a9eb5e4f868d9c08dae40a2ed36603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a16a9eb5e4f868d9c08dae40a2ed36603">architecture</a> () const</td></tr>
<tr class="memdesc:a16a9eb5e4f868d9c08dae40a2ed36603 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>.  <br /></td></tr>
<tr class="separator:a16a9eb5e4f868d9c08dae40a2ed36603 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0aab79f974c3d55056869f0943c7b9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a3d0aab79f974c3d55056869f0943c7b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a3d0aab79f974c3d55056869f0943c7b9">currentState</a> () const</td></tr>
<tr class="memdesc:a3d0aab79f974c3d55056869f0943c7b9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the state object.  <br /></td></tr>
<tr class="separator:a3d0aab79f974c3d55056869f0943c7b9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2348a14e91b4f686215ca9934b5e691b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a2348a14e91b4f686215ca9934b5e691b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a2348a14e91b4f686215ca9934b5e691b">protoval</a> () const</td></tr>
<tr class="memdesc:a2348a14e91b4f686215ca9934b5e691b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the prototypical value.  <br /></td></tr>
<tr class="separator:a2348a14e91b4f686215ca9934b5e691b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56bb02c9c1596853119d7ed38b0fad3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_ac56bb02c9c1596853119d7ed38b0fad3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#ac56bb02c9c1596853119d7ed38b0fad3">currentInstruction</a> () const</td></tr>
<tr class="memdesc:ac56bb02c9c1596853119d7ed38b0fad3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction that is being processed.  <br /></td></tr>
<tr class="separator:ac56bb02c9c1596853119d7ed38b0fad3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d160607c90a3006d20cccfc386b5b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a4a4d160607c90a3006d20cccfc386b5b"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>number_</b> (size_t nbits, uint64_t number) const</td></tr>
<tr class="memdesc:a4a4d160607c90a3006d20cccfc386b5b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a semantic value representing a number. <br /></td></tr>
<tr class="separator:a4a4d160607c90a3006d20cccfc386b5b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeaae59a296ef66bb42935d57c36ee2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_aebeaae59a296ef66bb42935d57c36ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> () const</td></tr>
<tr class="memdesc:aebeaae59a296ef66bb42935d57c36ee2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register dictionary.  <br /></td></tr>
<tr class="separator:aebeaae59a296ef66bb42935d57c36ee2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721dac0c13cedbdfbe9c2c3fd77f6c91 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a721dac0c13cedbdfbe9c2c3fd77f6c91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a721dac0c13cedbdfbe9c2c3fd77f6c91">findRegister</a> (const std::string &amp;regname, size_t nbits=0, bool allowMissing=false) const</td></tr>
<tr class="memdesc:a721dac0c13cedbdfbe9c2c3fd77f6c91 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a register by name.  <br /></td></tr>
<tr class="separator:a721dac0c13cedbdfbe9c2c3fd77f6c91 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd2a58a9d9bcb0071af540251f08f2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_aacd2a58a9d9bcb0071af540251f08f2e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aacd2a58a9d9bcb0071af540251f08f2e">addressWidth</a> () const</td></tr>
<tr class="memdesc:aacd2a58a9d9bcb0071af540251f08f2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Width of memory addresses in bits.  <br /></td></tr>
<tr class="separator:aacd2a58a9d9bcb0071af540251f08f2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fbe33a091e72487af026352fb30a55 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_ad4fbe33a091e72487af026352fb30a55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#ad4fbe33a091e72487af026352fb30a55">advanceInstructionPointer</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:ad4fbe33a091e72487af026352fb30a55 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the instruction pointer register.  <br /></td></tr>
<tr class="separator:ad4fbe33a091e72487af026352fb30a55 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae328bd5fc9a88e3272214a6372c676df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_ae328bd5fc9a88e3272214a6372c676df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#ae328bd5fc9a88e3272214a6372c676df">segmentRegister</a> (<a class="el" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *)</td></tr>
<tr class="memdesc:ae328bd5fc9a88e3272214a6372c676df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a register descriptor for the segment part of a memory reference expression.  <br /></td></tr>
<tr class="separator:ae328bd5fc9a88e3272214a6372c676df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc23330202bac4a18d2f6fafe25918 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a53dc23330202bac4a18d2f6fafe25918"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a53dc23330202bac4a18d2f6fafe25918">incrementRegisters</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *)</td></tr>
<tr class="memdesc:a53dc23330202bac4a18d2f6fafe25918 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment all auto-increment registers in the expression.  <br /></td></tr>
<tr class="separator:a53dc23330202bac4a18d2f6fafe25918 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62323ad51bb87bbb5534b9b42b1ddf66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a62323ad51bb87bbb5534b9b42b1ddf66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a62323ad51bb87bbb5534b9b42b1ddf66">decrementRegisters</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *)</td></tr>
<tr class="memdesc:a62323ad51bb87bbb5534b9b42b1ddf66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement all auto-decrement registers in the expression.  <br /></td></tr>
<tr class="separator:a62323ad51bb87bbb5534b9b42b1ddf66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84e257fe94c194581dac72704a84e2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a2c84e257fe94c194581dac72704a84e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a2c84e257fe94c194581dac72704a84e2">preUpdate</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;enabled)</td></tr>
<tr class="memdesc:a2c84e257fe94c194581dac72704a84e2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update registers for pre-add expressions.  <br /></td></tr>
<tr class="separator:a2c84e257fe94c194581dac72704a84e2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f04649231673752e70177916e5d1ad1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a1f04649231673752e70177916e5d1ad1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a1f04649231673752e70177916e5d1ad1">postUpdate</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;enabled)</td></tr>
<tr class="memdesc:a1f04649231673752e70177916e5d1ad1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update registers for post-add expressions.  <br /></td></tr>
<tr class="separator:a1f04649231673752e70177916e5d1ad1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aeeafff241d9c268521fc1c8859eb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a78aeeafff241d9c268521fc1c8859eb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a78aeeafff241d9c268521fc1c8859eb5">effectiveAddress</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, size_t nbits=0)</td></tr>
<tr class="memdesc:a78aeeafff241d9c268521fc1c8859eb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a memory address by evaluating the address expression.  <br /></td></tr>
<tr class="separator:a78aeeafff241d9c268521fc1c8859eb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373ac4ad46e434812fac9bc58ae5b8c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a373ac4ad46e434812fac9bc58ae5b8c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a373ac4ad46e434812fac9bc58ae5b8c9">read</a> (<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, size_t value_nbits=0, size_t addr_nbits=0)</td></tr>
<tr class="memdesc:a373ac4ad46e434812fac9bc58ae5b8c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an R-value expression.  <br /></td></tr>
<tr class="separator:a373ac4ad46e434812fac9bc58ae5b8c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce81ae380ce539fd013897c75a10ab2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_afce81ae380ce539fd013897c75a10ab2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#afce81ae380ce539fd013897c75a10ab2">operators</a> () const</td></tr>
<tr class="memdesc:afce81ae380ce539fd013897c75a10ab2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: RISC operators.  <br /></td></tr>
<tr class="separator:afce81ae380ce539fd013897c75a10ab2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0532eb61453a9328dc8935bb6f4feafd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a0532eb61453a9328dc8935bb6f4feafd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a0532eb61453a9328dc8935bb6f4feafd">operators</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="memdesc:a0532eb61453a9328dc8935bb6f4feafd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: RISC operators.  <br /></td></tr>
<tr class="separator:a0532eb61453a9328dc8935bb6f4feafd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adc80f3dad7be835b7f136130166d87 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a5adc80f3dad7be835b7f136130166d87"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>undefined_</b> (size_t nbits) const</td></tr>
<tr class="memdesc:a5adc80f3dad7be835b7f136130166d87 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new undefined semantic value. <br /></td></tr>
<tr class="separator:a5adc80f3dad7be835b7f136130166d87 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a16db8575a25ba54a8a926868cfede inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a31a16db8575a25ba54a8a926868cfede"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unspecified_</b> (size_t nbits) const</td></tr>
<tr class="memdesc:a31a16db8575a25ba54a8a926868cfede inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new undefined semantic value. <br /></td></tr>
<tr class="separator:a31a16db8575a25ba54a8a926868cfede inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f8cba48cf0fbb698078e6d84fe86c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a875f8cba48cf0fbb698078e6d84fe86c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a875f8cba48cf0fbb698078e6d84fe86c">autoResetInstructionPointer</a> () const</td></tr>
<tr class="memdesc:a875f8cba48cf0fbb698078e6d84fe86c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reset instruction pointer register for each instruction.  <br /></td></tr>
<tr class="separator:a875f8cba48cf0fbb698078e6d84fe86c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdba49f8ab92e6a7593d81de7507061 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_adfdba49f8ab92e6a7593d81de7507061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#adfdba49f8ab92e6a7593d81de7507061">autoResetInstructionPointer</a> (bool b)</td></tr>
<tr class="memdesc:adfdba49f8ab92e6a7593d81de7507061 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reset instruction pointer register for each instruction.  <br /></td></tr>
<tr class="separator:adfdba49f8ab92e6a7593d81de7507061 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab7547e287b8af0e64abe24b0735c2f3e" id="r_ab7547e287b8af0e64abe24b0735c2f3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab7547e287b8af0e64abe24b0735c2f3e">instance</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:ab7547e287b8af0e64abe24b0735c2f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a prototypical dispatcher.  <br /></td></tr>
<tr class="separator:ab7547e287b8af0e64abe24b0735c2f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f735ed1538fa6ee48a31f13fe22b4e" id="r_a10f735ed1538fa6ee48a31f13fe22b4e"><td class="memItemLeft" align="right" valign="top"><a id="a10f735ed1538fa6ee48a31f13fe22b4e" name="a10f735ed1538fa6ee48a31f13fe22b4e"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="memdesc:a10f735ed1538fa6ee48a31f13fe22b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a10f735ed1538fa6ee48a31f13fe22b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22538cc5963833702c00e892719c582b" id="r_a22538cc5963833702c00e892719c582b"><td class="memItemLeft" align="right" valign="top"><a id="a22538cc5963833702c00e892719c582b" name="a22538cc5963833702c00e892719c582b"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>promote</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">BaseSemantics::DispatcherPtr</a> &amp;)</td></tr>
<tr class="memdesc:a22538cc5963833702c00e892719c582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast to a DispatcherX86Ptr with assertion. <br /></td></tr>
<tr class="separator:a22538cc5963833702c00e892719c582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a55cc19a3b2e45750125d83026a3ff461" id="r_a55cc19a3b2e45750125d83026a3ff461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a55cc19a3b2e45750125d83026a3ff461">REG_anyAX</a></td></tr>
<tr class="memdesc:a55cc19a3b2e45750125d83026a3ff461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a55cc19a3b2e45750125d83026a3ff461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0972ff505cae143eeb43eb3a0bfa4a0" id="r_aa0972ff505cae143eeb43eb3a0bfa4a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa0972ff505cae143eeb43eb3a0bfa4a0">REG_anyBX</a></td></tr>
<tr class="memdesc:aa0972ff505cae143eeb43eb3a0bfa4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aa0972ff505cae143eeb43eb3a0bfa4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1319b241ca2c93493e9f0dc12829f442" id="r_a1319b241ca2c93493e9f0dc12829f442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a1319b241ca2c93493e9f0dc12829f442">REG_anyCX</a></td></tr>
<tr class="memdesc:a1319b241ca2c93493e9f0dc12829f442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a1319b241ca2c93493e9f0dc12829f442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcad0c795f03e4378cb12fab6e3b9a89" id="r_abcad0c795f03e4378cb12fab6e3b9a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abcad0c795f03e4378cb12fab6e3b9a89">REG_anyDX</a></td></tr>
<tr class="memdesc:abcad0c795f03e4378cb12fab6e3b9a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:abcad0c795f03e4378cb12fab6e3b9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194cc7f22b089565f7a8a0f6df00e18" id="r_ab194cc7f22b089565f7a8a0f6df00e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab194cc7f22b089565f7a8a0f6df00e18">REG_RAX</a></td></tr>
<tr class="memdesc:ab194cc7f22b089565f7a8a0f6df00e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ab194cc7f22b089565f7a8a0f6df00e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ba529c72ffa07aebd5ed5ea4f23664" id="r_a47ba529c72ffa07aebd5ed5ea4f23664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a47ba529c72ffa07aebd5ed5ea4f23664">REG_RBX</a></td></tr>
<tr class="memdesc:a47ba529c72ffa07aebd5ed5ea4f23664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a47ba529c72ffa07aebd5ed5ea4f23664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327caf94621290999ae2c12afac11098" id="r_a327caf94621290999ae2c12afac11098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a327caf94621290999ae2c12afac11098">REG_RCX</a></td></tr>
<tr class="memdesc:a327caf94621290999ae2c12afac11098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a327caf94621290999ae2c12afac11098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e921e97aa06486f63571bd5cf2cc69" id="r_ab9e921e97aa06486f63571bd5cf2cc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab9e921e97aa06486f63571bd5cf2cc69">REG_RDX</a></td></tr>
<tr class="memdesc:ab9e921e97aa06486f63571bd5cf2cc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ab9e921e97aa06486f63571bd5cf2cc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55fe8197897aff7e35c79742a9724e7" id="r_ad55fe8197897aff7e35c79742a9724e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ad55fe8197897aff7e35c79742a9724e7">REG_EAX</a></td></tr>
<tr class="memdesc:ad55fe8197897aff7e35c79742a9724e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ad55fe8197897aff7e35c79742a9724e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd65749b29531afafcd880cfef249a" id="r_a1ebd65749b29531afafcd880cfef249a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a1ebd65749b29531afafcd880cfef249a">REG_EBX</a></td></tr>
<tr class="memdesc:a1ebd65749b29531afafcd880cfef249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a1ebd65749b29531afafcd880cfef249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6b9e73b4deee5217d23745b11db82" id="r_ad5d6b9e73b4deee5217d23745b11db82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ad5d6b9e73b4deee5217d23745b11db82">REG_ECX</a></td></tr>
<tr class="memdesc:ad5d6b9e73b4deee5217d23745b11db82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ad5d6b9e73b4deee5217d23745b11db82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061a35aee364f40049ded82f8c0e5518" id="r_a061a35aee364f40049ded82f8c0e5518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a061a35aee364f40049ded82f8c0e5518">REG_EDX</a></td></tr>
<tr class="memdesc:a061a35aee364f40049ded82f8c0e5518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a061a35aee364f40049ded82f8c0e5518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6f0d8dfbe1517ddb6ac03fb8b4f566" id="r_a1f6f0d8dfbe1517ddb6ac03fb8b4f566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a1f6f0d8dfbe1517ddb6ac03fb8b4f566">REG_AX</a></td></tr>
<tr class="memdesc:a1f6f0d8dfbe1517ddb6ac03fb8b4f566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a1f6f0d8dfbe1517ddb6ac03fb8b4f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3131682754dc166aae1e7fb07dd87d" id="r_a9d3131682754dc166aae1e7fb07dd87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a9d3131682754dc166aae1e7fb07dd87d">REG_BX</a></td></tr>
<tr class="memdesc:a9d3131682754dc166aae1e7fb07dd87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a9d3131682754dc166aae1e7fb07dd87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcdace135434fda1223ac25f9c5c981" id="r_aefcdace135434fda1223ac25f9c5c981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aefcdace135434fda1223ac25f9c5c981">REG_CX</a></td></tr>
<tr class="memdesc:aefcdace135434fda1223ac25f9c5c981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aefcdace135434fda1223ac25f9c5c981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace685e735a6daafbbfc8025efa166790" id="r_ace685e735a6daafbbfc8025efa166790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ace685e735a6daafbbfc8025efa166790">REG_DX</a></td></tr>
<tr class="memdesc:ace685e735a6daafbbfc8025efa166790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ace685e735a6daafbbfc8025efa166790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7542a1f326b7a358ceb868a8c3181" id="r_a4aa7542a1f326b7a358ceb868a8c3181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a4aa7542a1f326b7a358ceb868a8c3181">REG_AL</a></td></tr>
<tr class="memdesc:a4aa7542a1f326b7a358ceb868a8c3181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a4aa7542a1f326b7a358ceb868a8c3181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cac70ad8f6230630d84ae364d0fa9f0" id="r_a4cac70ad8f6230630d84ae364d0fa9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a4cac70ad8f6230630d84ae364d0fa9f0">REG_BL</a></td></tr>
<tr class="memdesc:a4cac70ad8f6230630d84ae364d0fa9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a4cac70ad8f6230630d84ae364d0fa9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea78a4f6796587503ddd7d7891347e8" id="r_adea78a4f6796587503ddd7d7891347e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#adea78a4f6796587503ddd7d7891347e8">REG_CL</a></td></tr>
<tr class="memdesc:adea78a4f6796587503ddd7d7891347e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:adea78a4f6796587503ddd7d7891347e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66be4f5a2c2affd09ff22e49666c00" id="r_a7e66be4f5a2c2affd09ff22e49666c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a7e66be4f5a2c2affd09ff22e49666c00">REG_DL</a></td></tr>
<tr class="memdesc:a7e66be4f5a2c2affd09ff22e49666c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a7e66be4f5a2c2affd09ff22e49666c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b3da59dacc522a2f140ca3df2c9c45" id="r_ae5b3da59dacc522a2f140ca3df2c9c45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae5b3da59dacc522a2f140ca3df2c9c45">REG_AH</a></td></tr>
<tr class="memdesc:ae5b3da59dacc522a2f140ca3df2c9c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ae5b3da59dacc522a2f140ca3df2c9c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c2729cf86a127d6633786843190c3" id="r_a457c2729cf86a127d6633786843190c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a457c2729cf86a127d6633786843190c3">REG_BH</a></td></tr>
<tr class="memdesc:a457c2729cf86a127d6633786843190c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a457c2729cf86a127d6633786843190c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87d1a1fff52f3f8c85846b604b86305" id="r_aa87d1a1fff52f3f8c85846b604b86305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa87d1a1fff52f3f8c85846b604b86305">REG_CH</a></td></tr>
<tr class="memdesc:aa87d1a1fff52f3f8c85846b604b86305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aa87d1a1fff52f3f8c85846b604b86305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a68662aef62bed8fa8394914f0b43e9" id="r_a5a68662aef62bed8fa8394914f0b43e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a5a68662aef62bed8fa8394914f0b43e9">REG_DH</a></td></tr>
<tr class="memdesc:a5a68662aef62bed8fa8394914f0b43e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a5a68662aef62bed8fa8394914f0b43e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1dc1b9a4dab9d85301febb55abdd09" id="r_a0c1dc1b9a4dab9d85301febb55abdd09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a0c1dc1b9a4dab9d85301febb55abdd09">REG_R8</a></td></tr>
<tr class="memdesc:a0c1dc1b9a4dab9d85301febb55abdd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a0c1dc1b9a4dab9d85301febb55abdd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a2490bf6acbcae772ec4b813aa8cd8" id="r_a88a2490bf6acbcae772ec4b813aa8cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a88a2490bf6acbcae772ec4b813aa8cd8">REG_R9</a></td></tr>
<tr class="memdesc:a88a2490bf6acbcae772ec4b813aa8cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a88a2490bf6acbcae772ec4b813aa8cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b76bde543b0627d492c363d03ed85" id="r_ac54b76bde543b0627d492c363d03ed85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac54b76bde543b0627d492c363d03ed85">REG_R10</a></td></tr>
<tr class="memdesc:ac54b76bde543b0627d492c363d03ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac54b76bde543b0627d492c363d03ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da067b168027f7cb753088392d7bda" id="r_af1da067b168027f7cb753088392d7bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#af1da067b168027f7cb753088392d7bda">REG_R11</a></td></tr>
<tr class="memdesc:af1da067b168027f7cb753088392d7bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:af1da067b168027f7cb753088392d7bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa2287f12ba0d04ad1a880cc4a38c67" id="r_aeaa2287f12ba0d04ad1a880cc4a38c67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aeaa2287f12ba0d04ad1a880cc4a38c67">REG_R12</a></td></tr>
<tr class="memdesc:aeaa2287f12ba0d04ad1a880cc4a38c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aeaa2287f12ba0d04ad1a880cc4a38c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe92701559e6a8fe1776bca85db5a8f" id="r_aabe92701559e6a8fe1776bca85db5a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aabe92701559e6a8fe1776bca85db5a8f">REG_R13</a></td></tr>
<tr class="memdesc:aabe92701559e6a8fe1776bca85db5a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aabe92701559e6a8fe1776bca85db5a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23493275b1e13a69e97353ac74071614" id="r_a23493275b1e13a69e97353ac74071614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a23493275b1e13a69e97353ac74071614">REG_R14</a></td></tr>
<tr class="memdesc:a23493275b1e13a69e97353ac74071614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a23493275b1e13a69e97353ac74071614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc96dad353d6ffd10f4d75fddba723" id="r_ae6dc96dad353d6ffd10f4d75fddba723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae6dc96dad353d6ffd10f4d75fddba723">REG_R15</a></td></tr>
<tr class="memdesc:ae6dc96dad353d6ffd10f4d75fddba723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ae6dc96dad353d6ffd10f4d75fddba723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8504ce4e7565c747977b76ecc7df246" id="r_ae8504ce4e7565c747977b76ecc7df246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae8504ce4e7565c747977b76ecc7df246">REG_anyDI</a></td></tr>
<tr class="memdesc:ae8504ce4e7565c747977b76ecc7df246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ae8504ce4e7565c747977b76ecc7df246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b6b619438604f99aa1294c65ee604d" id="r_a79b6b619438604f99aa1294c65ee604d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a79b6b619438604f99aa1294c65ee604d">REG_anySI</a></td></tr>
<tr class="memdesc:a79b6b619438604f99aa1294c65ee604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a79b6b619438604f99aa1294c65ee604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0e8552a5abb8538a10a408f2c688f" id="r_a41b0e8552a5abb8538a10a408f2c688f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a41b0e8552a5abb8538a10a408f2c688f">REG_anySP</a></td></tr>
<tr class="memdesc:a41b0e8552a5abb8538a10a408f2c688f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a41b0e8552a5abb8538a10a408f2c688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ff7a6895c4d71d027dd14b5ec7ba7" id="r_aee8ff7a6895c4d71d027dd14b5ec7ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aee8ff7a6895c4d71d027dd14b5ec7ba7">REG_anyBP</a></td></tr>
<tr class="memdesc:aee8ff7a6895c4d71d027dd14b5ec7ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aee8ff7a6895c4d71d027dd14b5ec7ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00ad3652d13b5a1724553b49ef6608e" id="r_ab00ad3652d13b5a1724553b49ef6608e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab00ad3652d13b5a1724553b49ef6608e">REG_anyIP</a></td></tr>
<tr class="memdesc:ab00ad3652d13b5a1724553b49ef6608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ab00ad3652d13b5a1724553b49ef6608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fbae18ba5b42326dd1030c4f5e08d7" id="r_ac7fbae18ba5b42326dd1030c4f5e08d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac7fbae18ba5b42326dd1030c4f5e08d7">REG_RDI</a></td></tr>
<tr class="memdesc:ac7fbae18ba5b42326dd1030c4f5e08d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac7fbae18ba5b42326dd1030c4f5e08d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f2ec0f6c89f6f2f9b6b5d761bc686c" id="r_ad0f2ec0f6c89f6f2f9b6b5d761bc686c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ad0f2ec0f6c89f6f2f9b6b5d761bc686c">REG_RSI</a></td></tr>
<tr class="memdesc:ad0f2ec0f6c89f6f2f9b6b5d761bc686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ad0f2ec0f6c89f6f2f9b6b5d761bc686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40665d6ed05c09ca830b1cd1b8f90caa" id="r_a40665d6ed05c09ca830b1cd1b8f90caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a40665d6ed05c09ca830b1cd1b8f90caa">REG_RSP</a></td></tr>
<tr class="memdesc:a40665d6ed05c09ca830b1cd1b8f90caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a40665d6ed05c09ca830b1cd1b8f90caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa1ff8f4da0345bbe97b424108e85e5" id="r_abaa1ff8f4da0345bbe97b424108e85e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abaa1ff8f4da0345bbe97b424108e85e5">REG_RBP</a></td></tr>
<tr class="memdesc:abaa1ff8f4da0345bbe97b424108e85e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:abaa1ff8f4da0345bbe97b424108e85e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c51ac46c79baf9da99f4ac47bfff1e" id="r_a63c51ac46c79baf9da99f4ac47bfff1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a63c51ac46c79baf9da99f4ac47bfff1e">REG_RIP</a></td></tr>
<tr class="memdesc:a63c51ac46c79baf9da99f4ac47bfff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a63c51ac46c79baf9da99f4ac47bfff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28ba58ca1b248ac73a3db0f7d6d6cd2" id="r_ac28ba58ca1b248ac73a3db0f7d6d6cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac28ba58ca1b248ac73a3db0f7d6d6cd2">REG_EDI</a></td></tr>
<tr class="memdesc:ac28ba58ca1b248ac73a3db0f7d6d6cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac28ba58ca1b248ac73a3db0f7d6d6cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a6e2316d6beabc012fd558c60ac9f4" id="r_ac7a6e2316d6beabc012fd558c60ac9f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac7a6e2316d6beabc012fd558c60ac9f4">REG_ESI</a></td></tr>
<tr class="memdesc:ac7a6e2316d6beabc012fd558c60ac9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac7a6e2316d6beabc012fd558c60ac9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1164fe5e49df25fbab88f21120fe75ad" id="r_a1164fe5e49df25fbab88f21120fe75ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a1164fe5e49df25fbab88f21120fe75ad">REG_ESP</a></td></tr>
<tr class="memdesc:a1164fe5e49df25fbab88f21120fe75ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a1164fe5e49df25fbab88f21120fe75ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239fdde9e979315d62addedf2d68b632" id="r_a239fdde9e979315d62addedf2d68b632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a239fdde9e979315d62addedf2d68b632">REG_EBP</a></td></tr>
<tr class="memdesc:a239fdde9e979315d62addedf2d68b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a239fdde9e979315d62addedf2d68b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e06bb1cfd41290af2508ef4d302401" id="r_ad1e06bb1cfd41290af2508ef4d302401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ad1e06bb1cfd41290af2508ef4d302401">REG_EIP</a></td></tr>
<tr class="memdesc:ad1e06bb1cfd41290af2508ef4d302401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ad1e06bb1cfd41290af2508ef4d302401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7dc6fa20eb0d63793a3f3aecc7c893" id="r_a1a7dc6fa20eb0d63793a3f3aecc7c893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a1a7dc6fa20eb0d63793a3f3aecc7c893">REG_DI</a></td></tr>
<tr class="memdesc:a1a7dc6fa20eb0d63793a3f3aecc7c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a1a7dc6fa20eb0d63793a3f3aecc7c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8763368fbd169d904750b196d634e68" id="r_af8763368fbd169d904750b196d634e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#af8763368fbd169d904750b196d634e68">REG_SI</a></td></tr>
<tr class="memdesc:af8763368fbd169d904750b196d634e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:af8763368fbd169d904750b196d634e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc83005dc47a9e173b33e7909662a55" id="r_aadc83005dc47a9e173b33e7909662a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aadc83005dc47a9e173b33e7909662a55">REG_SP</a></td></tr>
<tr class="memdesc:aadc83005dc47a9e173b33e7909662a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aadc83005dc47a9e173b33e7909662a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788286c0b96a5c6eea49f518a722ee43" id="r_a788286c0b96a5c6eea49f518a722ee43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a788286c0b96a5c6eea49f518a722ee43">REG_BP</a></td></tr>
<tr class="memdesc:a788286c0b96a5c6eea49f518a722ee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a788286c0b96a5c6eea49f518a722ee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9e57719588f7c3a64670a8d2443ad" id="r_a45c9e57719588f7c3a64670a8d2443ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a45c9e57719588f7c3a64670a8d2443ad">REG_IP</a></td></tr>
<tr class="memdesc:a45c9e57719588f7c3a64670a8d2443ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a45c9e57719588f7c3a64670a8d2443ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56f6402e1fcc1e328b98e762e57abdc" id="r_af56f6402e1fcc1e328b98e762e57abdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#af56f6402e1fcc1e328b98e762e57abdc">REG_CS</a></td></tr>
<tr class="memdesc:af56f6402e1fcc1e328b98e762e57abdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:af56f6402e1fcc1e328b98e762e57abdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042565563e2184c4a9d7508e6fcf2eb3" id="r_a042565563e2184c4a9d7508e6fcf2eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a042565563e2184c4a9d7508e6fcf2eb3">REG_DS</a></td></tr>
<tr class="memdesc:a042565563e2184c4a9d7508e6fcf2eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a042565563e2184c4a9d7508e6fcf2eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ed11ac49fc6c9acac1a2a72542349b" id="r_ac1ed11ac49fc6c9acac1a2a72542349b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac1ed11ac49fc6c9acac1a2a72542349b">REG_ES</a></td></tr>
<tr class="memdesc:ac1ed11ac49fc6c9acac1a2a72542349b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac1ed11ac49fc6c9acac1a2a72542349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6020b9b2ec8c46d8680984073ae29b90" id="r_a6020b9b2ec8c46d8680984073ae29b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a6020b9b2ec8c46d8680984073ae29b90">REG_SS</a></td></tr>
<tr class="memdesc:a6020b9b2ec8c46d8680984073ae29b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a6020b9b2ec8c46d8680984073ae29b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fc6fc780972d633acc2e4d82463309" id="r_a18fc6fc780972d633acc2e4d82463309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a18fc6fc780972d633acc2e4d82463309">REG_FS</a></td></tr>
<tr class="memdesc:a18fc6fc780972d633acc2e4d82463309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a18fc6fc780972d633acc2e4d82463309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c2a18e554476b58e8414475ac81ee" id="r_afc9c2a18e554476b58e8414475ac81ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#afc9c2a18e554476b58e8414475ac81ee">REG_GS</a></td></tr>
<tr class="memdesc:afc9c2a18e554476b58e8414475ac81ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:afc9c2a18e554476b58e8414475ac81ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac058f8fa0654bb9da5fdeb8489b1b3a6" id="r_ac058f8fa0654bb9da5fdeb8489b1b3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ac058f8fa0654bb9da5fdeb8489b1b3a6">REG_anyFLAGS</a></td></tr>
<tr class="memdesc:ac058f8fa0654bb9da5fdeb8489b1b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ac058f8fa0654bb9da5fdeb8489b1b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d77472ff19600ceea6c3991afd34c81" id="r_a6d77472ff19600ceea6c3991afd34c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a6d77472ff19600ceea6c3991afd34c81">REG_RFLAGS</a></td></tr>
<tr class="memdesc:a6d77472ff19600ceea6c3991afd34c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a6d77472ff19600ceea6c3991afd34c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366404ae72f34cadfdcc7e1d87354499" id="r_a366404ae72f34cadfdcc7e1d87354499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a366404ae72f34cadfdcc7e1d87354499">REG_EFLAGS</a></td></tr>
<tr class="memdesc:a366404ae72f34cadfdcc7e1d87354499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a366404ae72f34cadfdcc7e1d87354499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d26dba18b066926ccef4d840eb6a95" id="r_af1d26dba18b066926ccef4d840eb6a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#af1d26dba18b066926ccef4d840eb6a95">REG_FLAGS</a></td></tr>
<tr class="memdesc:af1d26dba18b066926ccef4d840eb6a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:af1d26dba18b066926ccef4d840eb6a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dc8e78c44bad306d159c64fc05eebe" id="r_a14dc8e78c44bad306d159c64fc05eebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a14dc8e78c44bad306d159c64fc05eebe">REG_AF</a></td></tr>
<tr class="memdesc:a14dc8e78c44bad306d159c64fc05eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a14dc8e78c44bad306d159c64fc05eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bdf6e2029776d32bcb34ef1816ec30" id="r_a23bdf6e2029776d32bcb34ef1816ec30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a23bdf6e2029776d32bcb34ef1816ec30">REG_CF</a></td></tr>
<tr class="memdesc:a23bdf6e2029776d32bcb34ef1816ec30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a23bdf6e2029776d32bcb34ef1816ec30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c799e421f90f871800a083b2e0fcd93" id="r_a4c799e421f90f871800a083b2e0fcd93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a4c799e421f90f871800a083b2e0fcd93">REG_DF</a></td></tr>
<tr class="memdesc:a4c799e421f90f871800a083b2e0fcd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a4c799e421f90f871800a083b2e0fcd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c505ee24ee56c807dbbb7aeafa806b" id="r_ae4c505ee24ee56c807dbbb7aeafa806b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae4c505ee24ee56c807dbbb7aeafa806b">REG_OF</a></td></tr>
<tr class="memdesc:ae4c505ee24ee56c807dbbb7aeafa806b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ae4c505ee24ee56c807dbbb7aeafa806b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa63aeaf37f9a1664090cab4f98d4be6" id="r_aaa63aeaf37f9a1664090cab4f98d4be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aaa63aeaf37f9a1664090cab4f98d4be6">REG_PF</a></td></tr>
<tr class="memdesc:aaa63aeaf37f9a1664090cab4f98d4be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aaa63aeaf37f9a1664090cab4f98d4be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0735fc88e58eb3ff44b9c16ba9e1e15" id="r_ab0735fc88e58eb3ff44b9c16ba9e1e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab0735fc88e58eb3ff44b9c16ba9e1e15">REG_SF</a></td></tr>
<tr class="memdesc:ab0735fc88e58eb3ff44b9c16ba9e1e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:ab0735fc88e58eb3ff44b9c16ba9e1e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9b42461754788586b17d9a4f6b5ad0" id="r_acd9b42461754788586b17d9a4f6b5ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#acd9b42461754788586b17d9a4f6b5ad0">REG_TF</a></td></tr>
<tr class="memdesc:acd9b42461754788586b17d9a4f6b5ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:acd9b42461754788586b17d9a4f6b5ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d71e18d6eecbfb9cb3224645b9fee6" id="r_a70d71e18d6eecbfb9cb3224645b9fee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a70d71e18d6eecbfb9cb3224645b9fee6">REG_ZF</a></td></tr>
<tr class="memdesc:a70d71e18d6eecbfb9cb3224645b9fee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a70d71e18d6eecbfb9cb3224645b9fee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88abcf976f822e4e5af77d6484f1124" id="r_aa88abcf976f822e4e5af77d6484f1124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa88abcf976f822e4e5af77d6484f1124">REG_ST0</a></td></tr>
<tr class="memdesc:aa88abcf976f822e4e5af77d6484f1124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:aa88abcf976f822e4e5af77d6484f1124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a1eb9f1c7fea3cca95b9133fa07b2" id="r_a739a1eb9f1c7fea3cca95b9133fa07b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a739a1eb9f1c7fea3cca95b9133fa07b2">REG_FPSTATUS</a></td></tr>
<tr class="memdesc:a739a1eb9f1c7fea3cca95b9133fa07b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a739a1eb9f1c7fea3cca95b9133fa07b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26639b9f6cff7218014d3f20d523cb8e" id="r_a26639b9f6cff7218014d3f20d523cb8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a26639b9f6cff7218014d3f20d523cb8e">REG_FPSTATUS_TOP</a></td></tr>
<tr class="memdesc:a26639b9f6cff7218014d3f20d523cb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a26639b9f6cff7218014d3f20d523cb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183b37bf562e02ccc7f90ff1147fcfca" id="r_a183b37bf562e02ccc7f90ff1147fcfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a183b37bf562e02ccc7f90ff1147fcfca">REG_FPCTL</a></td></tr>
<tr class="memdesc:a183b37bf562e02ccc7f90ff1147fcfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a183b37bf562e02ccc7f90ff1147fcfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fab0739129388748b3f790d4d8d7b5" id="r_a82fab0739129388748b3f790d4d8d7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a82fab0739129388748b3f790d4d8d7b5">REG_MXCSR</a></td></tr>
<tr class="memdesc:a82fab0739129388748b3f790d4d8d7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached register.  <br /></td></tr>
<tr class="separator:a82fab0739129388748b3f790d4d8d7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a566ec3c4ead638a0e9df293dc2a63768" id="r_a566ec3c4ead638a0e9df293dc2a63768"><td class="memItemLeft" align="right" valign="top"><a id="a566ec3c4ead638a0e9df293dc2a63768" name="a566ec3c4ead638a0e9df293dc2a63768"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherX86</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:a566ec3c4ead638a0e9df293dc2a63768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0a0617f05b79fb910771cde6aaaba6" id="r_aaa0a0617f05b79fb910771cde6aaaba6"><td class="memItemLeft" align="right" valign="top"><a id="aaa0a0617f05b79fb910771cde6aaaba6" name="aaa0a0617f05b79fb910771cde6aaaba6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DispatcherX86</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="separator:aaa0a0617f05b79fb910771cde6aaaba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a></td></tr>
<tr class="memitem:aba7f2d2d7ca311fd87215369bd56290b inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_aba7f2d2d7ca311fd87215369bd56290b"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:aba7f2d2d7ca311fd87215369bd56290b inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec7c72f093832292b83b10439d2475 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a10ec7c72f093832292b83b10439d2475"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Dispatcher</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="separator:a10ec7c72f093832292b83b10439d2475 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae972a21e9f342f897e2c583ab3e34d04" id="r_ae972a21e9f342f897e2c583ab3e34d04"><td class="memItemLeft" align="right" valign="top">X86InstructionSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ae972a21e9f342f897e2c583ab3e34d04">processorMode_</a></td></tr>
<tr class="separator:ae972a21e9f342f897e2c583ab3e34d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a></td></tr>
<tr class="memitem:a275b5514a883af198964f9b4a169efbf inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_a275b5514a883af198964f9b4a169efbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a275b5514a883af198964f9b4a169efbf">autoResetInstructionPointer_</a> = true</td></tr>
<tr class="memdesc:a275b5514a883af198964f9b4a169efbf inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset instruction pointer register for each instruction.  <br /></td></tr>
<tr class="separator:a275b5514a883af198964f9b4a169efbf inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaabe1cb66d47e1a978047bdb5f2b0bc inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_adaabe1cb66d47e1a978047bdb5f2b0bc"><td class="memItemLeft" align="right" valign="top">InsnProcessors&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#adaabe1cb66d47e1a978047bdb5f2b0bc">iproc_table</a></td></tr>
<tr class="separator:adaabe1cb66d47e1a978047bdb5f2b0bc inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a></td></tr>
<tr class="memitem:af42cef3c16485fb9b2ab37d94db0bb29 inherit pro_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher" id="r_af42cef3c16485fb9b2ab37d94db0bb29"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1InsnProcessor.html">InsnProcessor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#af42cef3c16485fb9b2ab37d94db0bb29">InsnProcessors</a></td></tr>
<tr class="separator:af42cef3c16485fb9b2ab37d94db0bb29 inherit pro_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa89eff1ff3e14a7eca258348d13be94b" name="aa89eff1ff3e14a7eca258348d13be94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89eff1ff3e14a7eca258348d13be94b">&#9670;&#160;</a></span>Super</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#aa89eff1ff3e14a7eca258348d13be94b">Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::Super</a> =  <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html">BaseSemantics::Dispatcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00034">34</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ab4af0e6a25687041b368ca56fed2c260" name="ab4af0e6a25687041b368ca56fed2c260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af0e6a25687041b368ca56fed2c260">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#ab4af0e6a25687041b368ca56fed2c260">Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00037">37</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aebaaac87dc0ba747cae1a7105bf4cbdb" name="aebaaac87dc0ba747cae1a7105bf4cbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaaac87dc0ba747cae1a7105bf4cbdb">&#9670;&#160;</a></span>AccessMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00158">158</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa58d05091576e0a51b92ca72509cca4d" name="aa58d05091576e0a51b92ca72509cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58d05091576e0a51b92ca72509cca4d">&#9670;&#160;</a></span>iproc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::iproc_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the iproc table with instruction processing functors. </p>
<p>This normally happens from the constructor. </p>

</div>
</div>
<a id="ab87f06e45f39c052c2b13269b1d42cc9" name="ab87f06e45f39c052c2b13269b1d42cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87f06e45f39c052c2b13269b1d42cc9">&#9670;&#160;</a></span>regcache_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::regcache_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the cached register descriptors. </p>
<p>This happens at construction and when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed. </p>

</div>
</div>
<a id="a121c0b3524e354ef614627636186171e" name="a121c0b3524e354ef614627636186171e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121c0b3524e354ef614627636186171e">&#9670;&#160;</a></span>memory_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::memory_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure memory properties are set up correctly. </p>
<p>For instance, byte order should be little endian. </p>

</div>
</div>
<a id="ab7547e287b8af0e64abe24b0735c2f3e" name="ab7547e287b8af0e64abe24b0735c2f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7547e287b8af0e64abe24b0735c2f3e">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html#a90db6f28357786d9537040c99bd7ba23">DispatcherX86Ptr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a prototypical dispatcher. </p>
<p>The only thing this dispatcher can be used for is to create another dispatcher with the virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a58b566b54d4dfd835677cda2d1687285">create</a> method. </p>

</div>
</div>
<a id="a58b566b54d4dfd835677cda2d1687285" name="a58b566b54d4dfd835677cda2d1687285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b566b54d4dfd835677cda2d1687285">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">BaseSemantics::DispatcherPtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#adde1875d63169dae9641cf67585c894f">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="a989e1bd1e79730680bc1e84ac3e428b9" name="a989e1bd1e79730680bc1e84ac3e428b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989e1bd1e79730680bc1e84ac3e428b9">&#9670;&#160;</a></span>processorMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X86InstructionSize Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::processorMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CPU mode of operation. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00142">142</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a2c2d0948023bf8e28d459aecf44347d3" name="a2c2d0948023bf8e28d459aecf44347d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2d0948023bf8e28d459aecf44347d3">&#9670;&#160;</a></span>processorMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::processorMode </td>
          <td>(</td>
          <td class="paramtype">X86InstructionSize&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CPU mode of operation. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00143">143</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac074b29b286891bd2fe828bcc4a10918" name="ac074b29b286891bd2fe828bcc4a10918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac074b29b286891bd2fe828bcc4a10918">&#9670;&#160;</a></span>get_usual_registers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDictionary.html#a500242df223c9f4975874de40e081444">RegisterDictionary::RegisterDescriptors</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::get_usual_registers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list of common registers. </p>
<p>Returns a list of non-overlapping registers composed of the largest registers except using individual flags for the fields of the FLAGS/EFLAGS register. </p>

</div>
</div>
<a id="afc9dc8b716dceab013ec14122f4cf01b" name="afc9dc8b716dceab013ec14122f4cf01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9dc8b716dceab013ec14122f4cf01b">&#9670;&#160;</a></span>instructionPointerRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instruction pointer register. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#af2f89eaeac845eed15161632d2979b11">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="ac29201526ecc83115ab9ffc18acf518e" name="ac29201526ecc83115ab9ffc18acf518e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29201526ecc83115ab9ffc18acf518e">&#9670;&#160;</a></span>stackPointerRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::stackPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stack pointer register. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a1c79d020a90dc075d4d8a2b8cdee789f">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="a69a6aae7bd6c8841df264b662f9c004e" name="a69a6aae7bd6c8841df264b662f9c004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a6aae7bd6c8841df264b662f9c004e">&#9670;&#160;</a></span>stackFrameRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::stackFrameRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stack call frame register. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a43340c65c91715ce146b59bcc8c2744b">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="a132a176304a818b96b5eed5d730d642b" name="a132a176304a818b96b5eed5d730d642b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132a176304a818b96b5eed5d730d642b">&#9670;&#160;</a></span>callReturnRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::callReturnRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function call return address register. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a4d263b74cf9f31778137bfb63b63244f">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="a660ac92fd1d5550f4135084653f2ceb4" name="a660ac92fd1d5550f4135084653f2ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660ac92fd1d5550f4135084653f2ceb4">&#9670;&#160;</a></span>iprocKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::iprocKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an instruction, return the InsnProcessor key that can be used as an index into the iproc_table. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a46b6c1eb9174a484cc88920b484a993b">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="acac450f0cf6ba26a8caf5f7361bbf95d" name="acac450f0cf6ba26a8caf5f7361bbf95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac450f0cf6ba26a8caf5f7361bbf95d">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addr_nbits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes to an L-value expression. </p>
<p>The expression can be a register or memory reference. The width of the address passed to lower-level memory access functions is specified by <code>addr_nbits</code>. If <code>addr_nbits</code> is zero then the natural width of the effective address is passed to lower level functions. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#ac8498f6505aad9009f2febc11d0d5f77">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="ab6b4b454345f20dc83d932519ba00bde" name="ab6b4b454345f20dc83d932519ba00bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b4b454345f20dc83d932519ba00bde">&#9670;&#160;</a></span>initializeState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::initializeState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the state. </p>
<p>Some architectures benefit from having their initial state initialized in a certain way. For instance, on x86/amd64 the segment registers CS, DS, and SS typically refer to the entire machine memory and can be initialized to have a zero base address. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#a142cd8cb14f74a37582d3f34c9da0b20">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Dispatcher</a>.</p>

</div>
</div>
<a id="a481f385265465904b9c90fe932dc3eb2" name="a481f385265465904b9c90fe932dc3eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481f385265465904b9c90fe932dc3eb2">&#9670;&#160;</a></span>readRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::readRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>READ_REGISTER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Architecture-specific read from register. </p>
<p>Similar to RiscOperators::readRegister, but might do additional architecture-specific things. </p>

</div>
</div>
<a id="a71dc8c09c26ed0a9cf27458569151991" name="a71dc8c09c26ed0a9cf27458569151991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dc8c09c26ed0a9cf27458569151991">&#9670;&#160;</a></span>writeRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::writeRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Architecture-specific write to register. </p>
<p>Similar to RiscOperators::writeRegister, but might do additional architecture-specific things. For instance, writing to a 32-bit GPR such as "eax" on x86-64 will write zeros to the upper half of "rax". </p>

</div>
</div>
<a id="a311679faf4331fa134b54189c9170ea7" name="a311679faf4331fa134b54189c9170ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311679faf4331fa134b54189c9170ea7">&#9670;&#160;</a></span>invertMaybe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::invertMaybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maybe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally invert the bits of <code>value</code>. </p>
<p>The bits are inverted if <code>maybe</code> is true, otherwise <code>value</code> is returned. </p>

</div>
</div>
<a id="abfa2ac2df69c075baebb4aab40671044" name="abfa2ac2df69c075baebb4aab40671044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa2ac2df69c075baebb4aab40671044">&#9670;&#160;</a></span>repEnter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::repEnter </td>
          <td>(</td>
          <td class="paramtype">X86RepeatPrefix&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enters a loop for a REP-, REPE-, or REPNE-prefixed instruction. </p>
<p>The return value is true if ECX is non-zero or the instruction doesn't have repeat prefix, and false otherwise. Use this in conjunction with <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#a476c45429118a5b472b0b8c7512c0ad9" title="Leave a loop for a REP-, REPE-, or REPNE-prefixed instruction.">repLeave()</a>. </p>

</div>
</div>
<a id="a476c45429118a5b472b0b8c7512c0ad9" name="a476c45429118a5b472b0b8c7512c0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476c45429118a5b472b0b8c7512c0ad9">&#9670;&#160;</a></span>repLeave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::repLeave </td>
          <td>(</td>
          <td class="paramtype">X86RepeatPrefix&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>in_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>insn_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>honorZeroFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leave a loop for a REP-, REPE-, or REPNE-prefixed instruction. </p>
<p>The <code>in_loop</code> argument is the Boolean that indicates whether we just executed the instruction, and is usually the return value from the previous <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abfa2ac2df69c075baebb4aab40671044" title="Enters a loop for a REP-, REPE-, or REPNE-prefixed instruction.">repEnter()</a> call. If <code>in_loop</code> is false then this function is a no-op. Otherwise, the ECX register is decremented and, if it is non-zero and the repeat condition (true, equal, or not-equal) is satisified, then the EIP register is reset to the specified instruction address causing the instruction to be repeated. Use this in conjunction with <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html#abfa2ac2df69c075baebb4aab40671044" title="Enters a loop for a REP-, REPE-, or REPNE-prefixed instruction.">repEnter()</a>. The REP and REPE prefixes are shared, both represented by x86_repeat_repe, and we use the honorZeroFlag to decide whether the prefix is REP (false) or REPE (true). </p>

</div>
</div>
<a id="a36f5fdc3671dba626ce455e8ccd90b20" name="a36f5fdc3671dba626ce455e8ccd90b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f5fdc3671dba626ce455e8ccd90b20">&#9670;&#160;</a></span>doAddOperation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::doAddOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertCarries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>carryIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two values and adjusts flags. </p>
<p>This method can be used for subtraction if <code>b</code> is two's complement and <code>invertCarries</code> is set. If <code>cond</code> is supplied, then the addition and flag adjustments are conditional. </p>

</div>
</div>
<a id="a8778b72136ea46c37735f35375e4d404" name="a8778b72136ea46c37735f35375e4d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8778b72136ea46c37735f35375e4d404">&#9670;&#160;</a></span>doAddOperation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::doAddOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertCarries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>carryIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two values and adjusts flags. </p>
<p>This method can be used for subtraction if <code>b</code> is two's complement and <code>invertCarries</code> is set. If <code>cond</code> is supplied, then the addition and flag adjustments are conditional. </p>

</div>
</div>
<a id="a6f3c9bb72ce53076b6d5a049fdc3bd1a" name="a6f3c9bb72ce53076b6d5a049fdc3bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3c9bb72ce53076b6d5a049fdc3bd1a">&#9670;&#160;</a></span>doIncOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::doIncOperation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setCarry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments or decrements a value and adjusts flags. </p>
<p>If <code>dec</code> is set then the value is decremented instead of incremented. If <code>setCarry</code> is set then the CF flag is affected. </p>

</div>
</div>
<a id="a2234c540b75a492d6a42606a5512f342" name="a2234c540b75a492d6a42606a5512f342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2234c540b75a492d6a42606a5512f342">&#9670;&#160;</a></span>doRotateOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::doRotateOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a60d901bdb3369239fda973246fc9d014">X86InstructionKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>total_rotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rotateSignificantBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the RCL, RCR, ROL, and ROR instructions for various operand sizes. </p>
<p>The rotate amount is always 8 bits wide in the instruction, but the semantics mask off all but the low-order bits, keeping 5 bits in 32-bit mode and 6 bits in 64-bit mode (indicated by the rotateSignificantBits argument). </p>

</div>
</div>
<a id="abe5fe087c27844d9eb7019d71f8365a1" name="abe5fe087c27844d9eb7019d71f8365a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5fe087c27844d9eb7019d71f8365a1">&#9670;&#160;</a></span>doShiftOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::doShiftOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a60d901bdb3369239fda973246fc9d014">X86InstructionKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>total_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shiftSignificantBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the SHR, SAR, SHL, SAL, SHRD, and SHLD instructions for various operand sizes. </p>
<p>The shift amount is always 8 bits wide in the instruction, but the semantics mask off all but the low-order bits, keeping 5 bits in 32-bit mode and 7 bits in 64-bit mode (indicated by the <code>shiftSignificantBits</code> argument). The semantics of SHL and SAL are identical (in fact, ROSE doesn't even define x86_sal). The <code>source_bits</code> argument contains the bits to be shifted into the result and is used only for SHRD and SHLD instructions. </p>

</div>
</div>
<a id="ae98dfdcfbfdf474c2dad51d736e19edf" name="ae98dfdcfbfdf474c2dad51d736e19edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98dfdcfbfdf474c2dad51d736e19edf">&#9670;&#160;</a></span>pushFloatingPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::pushFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>valueToPush</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push floating-point value onto FP stack. </p>
<p>Pushes the specified value onto the floating-point circular stack. The current top-of-stack is the REG_ST register, but whose minor number is the value stored in the REG_ST_TOP register. The value in REG_ST_TOP (which must be concrete) is decremented modulo eight before being used. </p>

</div>
</div>
<a id="aa0be5ac9b26d60fbc6ca16e60591e60c" name="aa0be5ac9b26d60fbc6ca16e60591e60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0be5ac9b26d60fbc6ca16e60591e60c">&#9670;&#160;</a></span>saturateSignedToUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::saturateSignedToUnsigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>narrowerWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a signed value to a narrower unsigned type. </p>
<p>Returns the truncated source value except when the value cannot be represented in the narrower type, in which case the closest unsigned value is returned (zero or all bits set). </p>

</div>
</div>
<a id="afd0bc6b8fd8bc194b9e3f8968de765fa" name="afd0bc6b8fd8bc194b9e3f8968de765fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0bc6b8fd8bc194b9e3f8968de765fa">&#9670;&#160;</a></span>saturateSignedToSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::saturateSignedToSigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>narrowerWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a signed value to a narrower signed type. </p>
<p>Returns the truncated source value except when the value cannot be represented by the narrower type, in which case the closest signed value is returned. The closest signed value is either 0b1000...0 (minimum signed value) or 0b0111...1 (maximum signed value). </p>

</div>
</div>
<a id="a6a8fa383f6cae76a0cb497159bfe752c" name="a6a8fa383f6cae76a0cb497159bfe752c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8fa383f6cae76a0cb497159bfe752c">&#9670;&#160;</a></span>saturateUnsignedToUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::saturateUnsignedToUnsigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>narrowerWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsigned value to a narrower unsigned type. </p>
<p>Returns the truncated source value except when the value cannot be represented by the narrower type, in which case the closest unsigned value is returned. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae972a21e9f342f897e2c583ab3e34d04" name="ae972a21e9f342f897e2c583ab3e34d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae972a21e9f342f897e2c583ab3e34d04">&#9670;&#160;</a></span>processorMode_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X86InstructionSize Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::processorMode_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00040">40</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a55cc19a3b2e45750125d83026a3ff461" name="a55cc19a3b2e45750125d83026a3ff461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cc19a3b2e45750125d83026a3ff461">&#9670;&#160;</a></span>REG_anyAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00051">51</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aa0972ff505cae143eeb43eb3a0bfa4a0" name="aa0972ff505cae143eeb43eb3a0bfa4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0972ff505cae143eeb43eb3a0bfa4a0">&#9670;&#160;</a></span>REG_anyBX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyBX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00051">51</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a1319b241ca2c93493e9f0dc12829f442" name="a1319b241ca2c93493e9f0dc12829f442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1319b241ca2c93493e9f0dc12829f442">&#9670;&#160;</a></span>REG_anyCX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyCX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00051">51</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="abcad0c795f03e4378cb12fab6e3b9a89" name="abcad0c795f03e4378cb12fab6e3b9a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcad0c795f03e4378cb12fab6e3b9a89">&#9670;&#160;</a></span>REG_anyDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyDX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00051">51</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ab194cc7f22b089565f7a8a0f6df00e18" name="ab194cc7f22b089565f7a8a0f6df00e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab194cc7f22b089565f7a8a0f6df00e18">&#9670;&#160;</a></span>REG_RAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00052">52</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a47ba529c72ffa07aebd5ed5ea4f23664" name="a47ba529c72ffa07aebd5ed5ea4f23664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ba529c72ffa07aebd5ed5ea4f23664">&#9670;&#160;</a></span>REG_RBX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RBX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00052">52</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a327caf94621290999ae2c12afac11098" name="a327caf94621290999ae2c12afac11098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327caf94621290999ae2c12afac11098">&#9670;&#160;</a></span>REG_RCX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RCX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00052">52</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ab9e921e97aa06486f63571bd5cf2cc69" name="ab9e921e97aa06486f63571bd5cf2cc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e921e97aa06486f63571bd5cf2cc69">&#9670;&#160;</a></span>REG_RDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RDX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00052">52</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ad55fe8197897aff7e35c79742a9724e7" name="ad55fe8197897aff7e35c79742a9724e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55fe8197897aff7e35c79742a9724e7">&#9670;&#160;</a></span>REG_EAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00053">53</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a1ebd65749b29531afafcd880cfef249a" name="a1ebd65749b29531afafcd880cfef249a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebd65749b29531afafcd880cfef249a">&#9670;&#160;</a></span>REG_EBX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EBX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00053">53</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ad5d6b9e73b4deee5217d23745b11db82" name="ad5d6b9e73b4deee5217d23745b11db82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d6b9e73b4deee5217d23745b11db82">&#9670;&#160;</a></span>REG_ECX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ECX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00053">53</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a061a35aee364f40049ded82f8c0e5518" name="a061a35aee364f40049ded82f8c0e5518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061a35aee364f40049ded82f8c0e5518">&#9670;&#160;</a></span>REG_EDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EDX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00053">53</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a1f6f0d8dfbe1517ddb6ac03fb8b4f566" name="a1f6f0d8dfbe1517ddb6ac03fb8b4f566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6f0d8dfbe1517ddb6ac03fb8b4f566">&#9670;&#160;</a></span>REG_AX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_AX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00054">54</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a9d3131682754dc166aae1e7fb07dd87d" name="a9d3131682754dc166aae1e7fb07dd87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3131682754dc166aae1e7fb07dd87d">&#9670;&#160;</a></span>REG_BX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_BX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00054">54</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aefcdace135434fda1223ac25f9c5c981" name="aefcdace135434fda1223ac25f9c5c981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcdace135434fda1223ac25f9c5c981">&#9670;&#160;</a></span>REG_CX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_CX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00054">54</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ace685e735a6daafbbfc8025efa166790" name="ace685e735a6daafbbfc8025efa166790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace685e735a6daafbbfc8025efa166790">&#9670;&#160;</a></span>REG_DX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00054">54</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a4aa7542a1f326b7a358ceb868a8c3181" name="a4aa7542a1f326b7a358ceb868a8c3181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa7542a1f326b7a358ceb868a8c3181">&#9670;&#160;</a></span>REG_AL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_AL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00055">55</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a4cac70ad8f6230630d84ae364d0fa9f0" name="a4cac70ad8f6230630d84ae364d0fa9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cac70ad8f6230630d84ae364d0fa9f0">&#9670;&#160;</a></span>REG_BL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_BL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00055">55</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="adea78a4f6796587503ddd7d7891347e8" name="adea78a4f6796587503ddd7d7891347e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea78a4f6796587503ddd7d7891347e8">&#9670;&#160;</a></span>REG_CL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_CL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00055">55</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a7e66be4f5a2c2affd09ff22e49666c00" name="a7e66be4f5a2c2affd09ff22e49666c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66be4f5a2c2affd09ff22e49666c00">&#9670;&#160;</a></span>REG_DL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00055">55</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ae5b3da59dacc522a2f140ca3df2c9c45" name="ae5b3da59dacc522a2f140ca3df2c9c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b3da59dacc522a2f140ca3df2c9c45">&#9670;&#160;</a></span>REG_AH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_AH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00056">56</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a457c2729cf86a127d6633786843190c3" name="a457c2729cf86a127d6633786843190c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457c2729cf86a127d6633786843190c3">&#9670;&#160;</a></span>REG_BH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_BH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00056">56</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aa87d1a1fff52f3f8c85846b604b86305" name="aa87d1a1fff52f3f8c85846b604b86305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87d1a1fff52f3f8c85846b604b86305">&#9670;&#160;</a></span>REG_CH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_CH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00056">56</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a5a68662aef62bed8fa8394914f0b43e9" name="a5a68662aef62bed8fa8394914f0b43e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a68662aef62bed8fa8394914f0b43e9">&#9670;&#160;</a></span>REG_DH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00056">56</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a0c1dc1b9a4dab9d85301febb55abdd09" name="a0c1dc1b9a4dab9d85301febb55abdd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1dc1b9a4dab9d85301febb55abdd09">&#9670;&#160;</a></span>REG_R8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00058">58</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a88a2490bf6acbcae772ec4b813aa8cd8" name="a88a2490bf6acbcae772ec4b813aa8cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a2490bf6acbcae772ec4b813aa8cd8">&#9670;&#160;</a></span>REG_R9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00058">58</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac54b76bde543b0627d492c363d03ed85" name="ac54b76bde543b0627d492c363d03ed85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54b76bde543b0627d492c363d03ed85">&#9670;&#160;</a></span>REG_R10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00058">58</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="af1da067b168027f7cb753088392d7bda" name="af1da067b168027f7cb753088392d7bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da067b168027f7cb753088392d7bda">&#9670;&#160;</a></span>REG_R11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00058">58</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aeaa2287f12ba0d04ad1a880cc4a38c67" name="aeaa2287f12ba0d04ad1a880cc4a38c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa2287f12ba0d04ad1a880cc4a38c67">&#9670;&#160;</a></span>REG_R12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00059">59</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aabe92701559e6a8fe1776bca85db5a8f" name="aabe92701559e6a8fe1776bca85db5a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe92701559e6a8fe1776bca85db5a8f">&#9670;&#160;</a></span>REG_R13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00059">59</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a23493275b1e13a69e97353ac74071614" name="a23493275b1e13a69e97353ac74071614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23493275b1e13a69e97353ac74071614">&#9670;&#160;</a></span>REG_R14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00059">59</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ae6dc96dad353d6ffd10f4d75fddba723" name="ae6dc96dad353d6ffd10f4d75fddba723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc96dad353d6ffd10f4d75fddba723">&#9670;&#160;</a></span>REG_R15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_R15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00059">59</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ae8504ce4e7565c747977b76ecc7df246" name="ae8504ce4e7565c747977b76ecc7df246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8504ce4e7565c747977b76ecc7df246">&#9670;&#160;</a></span>REG_anyDI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyDI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00061">61</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a79b6b619438604f99aa1294c65ee604d" name="a79b6b619438604f99aa1294c65ee604d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b6b619438604f99aa1294c65ee604d">&#9670;&#160;</a></span>REG_anySI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anySI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00061">61</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a41b0e8552a5abb8538a10a408f2c688f" name="a41b0e8552a5abb8538a10a408f2c688f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b0e8552a5abb8538a10a408f2c688f">&#9670;&#160;</a></span>REG_anySP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anySP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00061">61</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aee8ff7a6895c4d71d027dd14b5ec7ba7" name="aee8ff7a6895c4d71d027dd14b5ec7ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8ff7a6895c4d71d027dd14b5ec7ba7">&#9670;&#160;</a></span>REG_anyBP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyBP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00061">61</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ab00ad3652d13b5a1724553b49ef6608e" name="ab00ad3652d13b5a1724553b49ef6608e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00ad3652d13b5a1724553b49ef6608e">&#9670;&#160;</a></span>REG_anyIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyIP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00061">61</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac7fbae18ba5b42326dd1030c4f5e08d7" name="ac7fbae18ba5b42326dd1030c4f5e08d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fbae18ba5b42326dd1030c4f5e08d7">&#9670;&#160;</a></span>REG_RDI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RDI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00062">62</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ad0f2ec0f6c89f6f2f9b6b5d761bc686c" name="ad0f2ec0f6c89f6f2f9b6b5d761bc686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f2ec0f6c89f6f2f9b6b5d761bc686c">&#9670;&#160;</a></span>REG_RSI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RSI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00062">62</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a40665d6ed05c09ca830b1cd1b8f90caa" name="a40665d6ed05c09ca830b1cd1b8f90caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40665d6ed05c09ca830b1cd1b8f90caa">&#9670;&#160;</a></span>REG_RSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RSP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00062">62</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="abaa1ff8f4da0345bbe97b424108e85e5" name="abaa1ff8f4da0345bbe97b424108e85e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa1ff8f4da0345bbe97b424108e85e5">&#9670;&#160;</a></span>REG_RBP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RBP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00062">62</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a63c51ac46c79baf9da99f4ac47bfff1e" name="a63c51ac46c79baf9da99f4ac47bfff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c51ac46c79baf9da99f4ac47bfff1e">&#9670;&#160;</a></span>REG_RIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RIP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00062">62</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac28ba58ca1b248ac73a3db0f7d6d6cd2" name="ac28ba58ca1b248ac73a3db0f7d6d6cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28ba58ca1b248ac73a3db0f7d6d6cd2">&#9670;&#160;</a></span>REG_EDI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EDI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00063">63</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac7a6e2316d6beabc012fd558c60ac9f4" name="ac7a6e2316d6beabc012fd558c60ac9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a6e2316d6beabc012fd558c60ac9f4">&#9670;&#160;</a></span>REG_ESI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ESI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00063">63</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a1164fe5e49df25fbab88f21120fe75ad" name="a1164fe5e49df25fbab88f21120fe75ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1164fe5e49df25fbab88f21120fe75ad">&#9670;&#160;</a></span>REG_ESP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ESP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00063">63</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a239fdde9e979315d62addedf2d68b632" name="a239fdde9e979315d62addedf2d68b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239fdde9e979315d62addedf2d68b632">&#9670;&#160;</a></span>REG_EBP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EBP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00063">63</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ad1e06bb1cfd41290af2508ef4d302401" name="ad1e06bb1cfd41290af2508ef4d302401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e06bb1cfd41290af2508ef4d302401">&#9670;&#160;</a></span>REG_EIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EIP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00063">63</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a1a7dc6fa20eb0d63793a3f3aecc7c893" name="a1a7dc6fa20eb0d63793a3f3aecc7c893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7dc6fa20eb0d63793a3f3aecc7c893">&#9670;&#160;</a></span>REG_DI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00064">64</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="af8763368fbd169d904750b196d634e68" name="af8763368fbd169d904750b196d634e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8763368fbd169d904750b196d634e68">&#9670;&#160;</a></span>REG_SI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_SI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00064">64</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aadc83005dc47a9e173b33e7909662a55" name="aadc83005dc47a9e173b33e7909662a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc83005dc47a9e173b33e7909662a55">&#9670;&#160;</a></span>REG_SP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_SP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00064">64</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a788286c0b96a5c6eea49f518a722ee43" name="a788286c0b96a5c6eea49f518a722ee43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788286c0b96a5c6eea49f518a722ee43">&#9670;&#160;</a></span>REG_BP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_BP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00064">64</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a45c9e57719588f7c3a64670a8d2443ad" name="a45c9e57719588f7c3a64670a8d2443ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9e57719588f7c3a64670a8d2443ad">&#9670;&#160;</a></span>REG_IP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_IP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00064">64</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="af56f6402e1fcc1e328b98e762e57abdc" name="af56f6402e1fcc1e328b98e762e57abdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56f6402e1fcc1e328b98e762e57abdc">&#9670;&#160;</a></span>REG_CS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_CS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a042565563e2184c4a9d7508e6fcf2eb3" name="a042565563e2184c4a9d7508e6fcf2eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042565563e2184c4a9d7508e6fcf2eb3">&#9670;&#160;</a></span>REG_DS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac1ed11ac49fc6c9acac1a2a72542349b" name="ac1ed11ac49fc6c9acac1a2a72542349b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ed11ac49fc6c9acac1a2a72542349b">&#9670;&#160;</a></span>REG_ES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a6020b9b2ec8c46d8680984073ae29b90" name="a6020b9b2ec8c46d8680984073ae29b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6020b9b2ec8c46d8680984073ae29b90">&#9670;&#160;</a></span>REG_SS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_SS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a18fc6fc780972d633acc2e4d82463309" name="a18fc6fc780972d633acc2e4d82463309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fc6fc780972d633acc2e4d82463309">&#9670;&#160;</a></span>REG_FS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_FS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="afc9c2a18e554476b58e8414475ac81ee" name="afc9c2a18e554476b58e8414475ac81ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c2a18e554476b58e8414475ac81ee">&#9670;&#160;</a></span>REG_GS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_GS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00066">66</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ac058f8fa0654bb9da5fdeb8489b1b3a6" name="ac058f8fa0654bb9da5fdeb8489b1b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac058f8fa0654bb9da5fdeb8489b1b3a6">&#9670;&#160;</a></span>REG_anyFLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_anyFLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00068">68</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a6d77472ff19600ceea6c3991afd34c81" name="a6d77472ff19600ceea6c3991afd34c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d77472ff19600ceea6c3991afd34c81">&#9670;&#160;</a></span>REG_RFLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_RFLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00068">68</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a366404ae72f34cadfdcc7e1d87354499" name="a366404ae72f34cadfdcc7e1d87354499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366404ae72f34cadfdcc7e1d87354499">&#9670;&#160;</a></span>REG_EFLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_EFLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00068">68</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="af1d26dba18b066926ccef4d840eb6a95" name="af1d26dba18b066926ccef4d840eb6a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d26dba18b066926ccef4d840eb6a95">&#9670;&#160;</a></span>REG_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_FLAGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00068">68</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a14dc8e78c44bad306d159c64fc05eebe" name="a14dc8e78c44bad306d159c64fc05eebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dc8e78c44bad306d159c64fc05eebe">&#9670;&#160;</a></span>REG_AF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_AF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a23bdf6e2029776d32bcb34ef1816ec30" name="a23bdf6e2029776d32bcb34ef1816ec30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bdf6e2029776d32bcb34ef1816ec30">&#9670;&#160;</a></span>REG_CF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_CF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a4c799e421f90f871800a083b2e0fcd93" name="a4c799e421f90f871800a083b2e0fcd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c799e421f90f871800a083b2e0fcd93">&#9670;&#160;</a></span>REG_DF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_DF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ae4c505ee24ee56c807dbbb7aeafa806b" name="ae4c505ee24ee56c807dbbb7aeafa806b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c505ee24ee56c807dbbb7aeafa806b">&#9670;&#160;</a></span>REG_OF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_OF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aaa63aeaf37f9a1664090cab4f98d4be6" name="aaa63aeaf37f9a1664090cab4f98d4be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa63aeaf37f9a1664090cab4f98d4be6">&#9670;&#160;</a></span>REG_PF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_PF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="ab0735fc88e58eb3ff44b9c16ba9e1e15" name="ab0735fc88e58eb3ff44b9c16ba9e1e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0735fc88e58eb3ff44b9c16ba9e1e15">&#9670;&#160;</a></span>REG_SF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_SF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="acd9b42461754788586b17d9a4f6b5ad0" name="acd9b42461754788586b17d9a4f6b5ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9b42461754788586b17d9a4f6b5ad0">&#9670;&#160;</a></span>REG_TF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_TF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a70d71e18d6eecbfb9cb3224645b9fee6" name="a70d71e18d6eecbfb9cb3224645b9fee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d71e18d6eecbfb9cb3224645b9fee6">&#9670;&#160;</a></span>REG_ZF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ZF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00069">69</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="aa88abcf976f822e4e5af77d6484f1124" name="aa88abcf976f822e4e5af77d6484f1124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88abcf976f822e4e5af77d6484f1124">&#9670;&#160;</a></span>REG_ST0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_ST0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00071">71</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a739a1eb9f1c7fea3cca95b9133fa07b2" name="a739a1eb9f1c7fea3cca95b9133fa07b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739a1eb9f1c7fea3cca95b9133fa07b2">&#9670;&#160;</a></span>REG_FPSTATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_FPSTATUS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00071">71</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a26639b9f6cff7218014d3f20d523cb8e" name="a26639b9f6cff7218014d3f20d523cb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26639b9f6cff7218014d3f20d523cb8e">&#9670;&#160;</a></span>REG_FPSTATUS_TOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_FPSTATUS_TOP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00071">71</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a183b37bf562e02ccc7f90ff1147fcfca" name="a183b37bf562e02ccc7f90ff1147fcfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183b37bf562e02ccc7f90ff1147fcfca">&#9670;&#160;</a></span>REG_FPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_FPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00071">71</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<a id="a82fab0739129388748b3f790d4d8d7b5" name="a82fab0739129388748b3f790d4d8d7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fab0739129388748b3f790d4d8d7b5">&#9670;&#160;</a></span>REG_MXCSR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::REG_MXCSR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached register. </p>
<p>This register is cached so that there are not so many calls to Dispatcher::findRegister(). The register descriptor is updated only when the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Dispatcher.html#aebeaae59a296ef66bb42935d57c36ee2">registerDictionary</a> property is changed.</p>
<p>Register names like REG_anyAX have sizes that depend on the architecture: 16 bits for 16-bit architectures, 32 bits for 32-bit architectures, etc. The other register names have specific sizes&ndash;such as REG_EAX being 32 bits&ndash;and are defined only on architectures that support them. </p>

<p class="definition">Definition at line <a class="el" href="DispatcherX86_8h_source.html#l00071">71</a> of file <a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="DispatcherX86_8h_source.html">DispatcherX86.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
