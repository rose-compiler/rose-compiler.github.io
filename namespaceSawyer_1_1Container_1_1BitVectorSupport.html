<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::BitVectorSupport Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html">BitVectorSupport</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::BitVectorSupport Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Support functions for bit vectors. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1AddBits.html">AddBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1AndBits.html">AndBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1bitsPerWord.html">bitsPerWord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits per word.  <a href="structSawyer_1_1Container_1_1BitVectorSupport_1_1bitsPerWord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1ClearBits.html">ClearBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1CompareBits.html">CompareBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1CopyBits.html">CopyBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1CountClearBits.html">CountClearBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1CountSetBits.html">CountSetBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Decrement.html">Decrement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1EqualTo.html">EqualTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Increment.html">Increment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1InvertBits.html">InvertBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LeastSignificantClearBit.html">LeastSignificantClearBit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LeastSignificantDifference.html">LeastSignificantDifference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LeastSignificantSetBit.html">LeastSignificantSetBit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for traversal directions.  <a href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1MostSignificantClearBit.html">MostSignificantClearBit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1MostSignificantDifference.html">MostSignificantDifference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1MostSignificantSetBit.html">MostSignificantSetBit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1OrBits.html">OrBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1RemoveConst.html">RemoveConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For removing const qualifiers.  <a href="structSawyer_1_1Container_1_1BitVectorSupport_1_1RemoveConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1RemoveConst_3_01const_01T_01_4.html">RemoveConst&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1SetBits.html">SetBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1SwapBits.html">SwapBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1ToBytes.html">ToBytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1ToString.html">ToString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1XorBits.html">XorBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad5b9ffa8f871fb468d9bd374a90b1a8d" id="r_ad5b9ffa8f871fb468d9bd374a90b1a8d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Interval</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ad5b9ffa8f871fb468d9bd374a90b1a8d">BitRange</a></td></tr>
<tr class="separator:ad5b9ffa8f871fb468d9bd374a90b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeb44f7c946dc2afbfa5a1e4921d42cc2" id="r_aeb44f7c946dc2afbfa5a1e4921d42cc2"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aeb44f7c946dc2afbfa5a1e4921d42cc2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aeb44f7c946dc2afbfa5a1e4921d42cc2">wordIndex</a> (size_t idx)</td></tr>
<tr class="memdesc:aeb44f7c946dc2afbfa5a1e4921d42cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to bit vector word.  <br /></td></tr>
<tr class="separator:aeb44f7c946dc2afbfa5a1e4921d42cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1bb15b759bd3d017595d2f6552feb9" id="r_aea1bb15b759bd3d017595d2f6552feb9"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aea1bb15b759bd3d017595d2f6552feb9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aea1bb15b759bd3d017595d2f6552feb9">bitIndex</a> (size_t idx)</td></tr>
<tr class="memdesc:aea1bb15b759bd3d017595d2f6552feb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index to bit within word.  <br /></td></tr>
<tr class="separator:aea1bb15b759bd3d017595d2f6552feb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1730bf7a76c31891dcb7ca3bade1219f" id="r_a1730bf7a76c31891dcb7ca3bade1219f"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a1730bf7a76c31891dcb7ca3bade1219f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a1730bf7a76c31891dcb7ca3bade1219f">numberOfWords</a> (size_t nbits)</td></tr>
<tr class="memdesc:a1730bf7a76c31891dcb7ca3bade1219f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of words to hold indicated number of bits.  <br /></td></tr>
<tr class="separator:a1730bf7a76c31891dcb7ca3bade1219f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4b68d40e7343bb8cca259148533ca5" id="r_a8f4b68d40e7343bb8cca259148533ca5"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a8f4b68d40e7343bb8cca259148533ca5"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a8f4b68d40e7343bb8cca259148533ca5">bitMask</a> (size_t offset, size_t nbits)</td></tr>
<tr class="memdesc:a8f4b68d40e7343bb8cca259148533ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask.  <br /></td></tr>
<tr class="separator:a8f4b68d40e7343bb8cca259148533ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aef7fddd157160622524a2d8e7d83fe" id="r_a4aef7fddd157160622524a2d8e7d83fe"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a4aef7fddd157160622524a2d8e7d83fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a4aef7fddd157160622524a2d8e7d83fe">nonoverlappingCopy</a> (const Word *src, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;srcRange, Word *dst, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;dstRange)</td></tr>
<tr class="separator:a4aef7fddd157160622524a2d8e7d83fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319b94e255da648c8af90e6432e81305" id="r_a319b94e255da648c8af90e6432e81305"><td class="memTemplParams" colspan="2">template&lt;class Src , class Dst &gt; </td></tr>
<tr class="memitem:a319b94e255da648c8af90e6432e81305"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a319b94e255da648c8af90e6432e81305">conditionalCopy</a> (const Src *src, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;srcRange, Dst *dst, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;dstRange)</td></tr>
<tr class="separator:a319b94e255da648c8af90e6432e81305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5d76240db2bbbf86535445ad837bbc" id="r_a3d5d76240db2bbbf86535445ad837bbc"><td class="memTemplParams" colspan="2">template&lt;class Src , class Dst &gt; </td></tr>
<tr class="memitem:a3d5d76240db2bbbf86535445ad837bbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a3d5d76240db2bbbf86535445ad837bbc">conditionalCopy</a> (const Src *, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;, const Dst *, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;)</td></tr>
<tr class="separator:a3d5d76240db2bbbf86535445ad837bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc438763608a5808fa1d155f013d9e23" id="r_acc438763608a5808fa1d155f013d9e23"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:acc438763608a5808fa1d155f013d9e23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#acc438763608a5808fa1d155f013d9e23">traverse</a> (Processor &amp;processor, Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>)</td></tr>
<tr class="memdesc:acc438763608a5808fa1d155f013d9e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses a range of bits.  <br /></td></tr>
<tr class="separator:acc438763608a5808fa1d155f013d9e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cc0cfada6c56bf657bc0cc110e9b5" id="r_ab08cc0cfada6c56bf657bc0cc110e9b5"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:ab08cc0cfada6c56bf657bc0cc110e9b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab08cc0cfada6c56bf657bc0cc110e9b5">traverse</a> (Processor &amp;processor, Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a>)</td></tr>
<tr class="memdesc:ab08cc0cfada6c56bf657bc0cc110e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse one range of bits starting with the most significant bit.  <br /></td></tr>
<tr class="separator:ab08cc0cfada6c56bf657bc0cc110e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609864a5be23260d53d9a4da675ec412" id="r_a609864a5be23260d53d9a4da675ec412"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word1 , class Word2 &gt; </td></tr>
<tr class="memitem:a609864a5be23260d53d9a4da675ec412"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a609864a5be23260d53d9a4da675ec412">traverse2</a> (Processor &amp;processor, Word1 *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word2 *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>)</td></tr>
<tr class="memdesc:a609864a5be23260d53d9a4da675ec412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse two ranges of bits from low to high.  <br /></td></tr>
<tr class="separator:a609864a5be23260d53d9a4da675ec412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ee713f08e6152de753c93fb7901576" id="r_ac5ee713f08e6152de753c93fb7901576"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word1 , class Word2 &gt; </td></tr>
<tr class="memitem:ac5ee713f08e6152de753c93fb7901576"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ac5ee713f08e6152de753c93fb7901576">traverse2</a> (Processor &amp;processor, Word1 *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word2 *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a>)</td></tr>
<tr class="memdesc:ac5ee713f08e6152de753c93fb7901576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse two ranges of bits from high to low.  <br /></td></tr>
<tr class="separator:ac5ee713f08e6152de753c93fb7901576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bc759f7c3b0caeac0caa648639510e" id="r_a23bc759f7c3b0caeac0caa648639510e"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a23bc759f7c3b0caeac0caa648639510e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a23bc759f7c3b0caeac0caa648639510e">traverse</a> (Processor &amp;processor, const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a> dir)</td></tr>
<tr class="separator:a23bc759f7c3b0caeac0caa648639510e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2e1bf7ce6681708fcec68528857fe" id="r_a5bc2e1bf7ce6681708fcec68528857fe"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a5bc2e1bf7ce6681708fcec68528857fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a5bc2e1bf7ce6681708fcec68528857fe">traverse</a> (Processor &amp;processor, const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a> dir)</td></tr>
<tr class="separator:a5bc2e1bf7ce6681708fcec68528857fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87978eabb3c818068492a2c52868158" id="r_aa87978eabb3c818068492a2c52868158"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:aa87978eabb3c818068492a2c52868158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aa87978eabb3c818068492a2c52868158">traverse</a> (Processor &amp;processor, const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a> dir)</td></tr>
<tr class="separator:aa87978eabb3c818068492a2c52868158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277028563d12d31e896b838fe5dadb63" id="r_a277028563d12d31e896b838fe5dadb63"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a277028563d12d31e896b838fe5dadb63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a277028563d12d31e896b838fe5dadb63">traverse</a> (Processor &amp;processor, Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, <a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a> dir)</td></tr>
<tr class="separator:a277028563d12d31e896b838fe5dadb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b33c1888d241c1ef777bcef0eacc3c" id="r_a98b33c1888d241c1ef777bcef0eacc3c"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a98b33c1888d241c1ef777bcef0eacc3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a98b33c1888d241c1ef777bcef0eacc3c">get</a> (const Word *words, size_t idx)</td></tr>
<tr class="memdesc:a98b33c1888d241c1ef777bcef0eacc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single bit.  <br /></td></tr>
<tr class="separator:a98b33c1888d241c1ef777bcef0eacc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca01114382a97afa15c25b29579dff" id="r_a5fca01114382a97afa15c25b29579dff"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a5fca01114382a97afa15c25b29579dff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a5fca01114382a97afa15c25b29579dff">clear</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;where)</td></tr>
<tr class="memdesc:a5fca01114382a97afa15c25b29579dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear some bits.  <br /></td></tr>
<tr class="separator:a5fca01114382a97afa15c25b29579dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1434bde1bc4974b3224a9856a352b0" id="r_a6a1434bde1bc4974b3224a9856a352b0"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a6a1434bde1bc4974b3224a9856a352b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a6a1434bde1bc4974b3224a9856a352b0">set</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;where)</td></tr>
<tr class="memdesc:a6a1434bde1bc4974b3224a9856a352b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> some bits.  <br /></td></tr>
<tr class="separator:a6a1434bde1bc4974b3224a9856a352b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68ac2d6efbbb861299c4cfe02e8a148" id="r_af68ac2d6efbbb861299c4cfe02e8a148"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:af68ac2d6efbbb861299c4cfe02e8a148"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#af68ac2d6efbbb861299c4cfe02e8a148">setValue</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;where, bool value)</td></tr>
<tr class="memdesc:af68ac2d6efbbb861299c4cfe02e8a148"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> or clear some bits.  <br /></td></tr>
<tr class="separator:af68ac2d6efbbb861299c4cfe02e8a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6810c441e283e64b214bd4d9bbc0a6" id="r_aff6810c441e283e64b214bd4d9bbc0a6"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aff6810c441e283e64b214bd4d9bbc0a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aff6810c441e283e64b214bd4d9bbc0a6">copy</a> (const Word *src, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;srcRange, Word *dst, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;dstRange)</td></tr>
<tr class="memdesc:aff6810c441e283e64b214bd4d9bbc0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy some bits.  <br /></td></tr>
<tr class="separator:aff6810c441e283e64b214bd4d9bbc0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b21530bd4cace95455a936ec463cc5" id="r_a50b21530bd4cace95455a936ec463cc5"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a50b21530bd4cace95455a936ec463cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a50b21530bd4cace95455a936ec463cc5">swap</a> (Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a50b21530bd4cace95455a936ec463cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap some bits.  <br /></td></tr>
<tr class="separator:a50b21530bd4cace95455a936ec463cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34e3f3ec9da5b48f618db562a06899f" id="r_aa34e3f3ec9da5b48f618db562a06899f"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aa34e3f3ec9da5b48f618db562a06899f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aa34e3f3ec9da5b48f618db562a06899f">equalTo</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:aa34e3f3ec9da5b48f618db562a06899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits for equality.  <br /></td></tr>
<tr class="separator:aa34e3f3ec9da5b48f618db562a06899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f4bb98cec1411a09cbdc4f308208fb" id="r_ab2f4bb98cec1411a09cbdc4f308208fb"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ab2f4bb98cec1411a09cbdc4f308208fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab2f4bb98cec1411a09cbdc4f308208fb">leastSignificantSetBit</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:ab2f4bb98cec1411a09cbdc4f308208fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of least significant set bit.  <br /></td></tr>
<tr class="separator:ab2f4bb98cec1411a09cbdc4f308208fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ddf3b56a4612e37437a8b1ac43bab" id="r_a4c7ddf3b56a4612e37437a8b1ac43bab"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a4c7ddf3b56a4612e37437a8b1ac43bab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a4c7ddf3b56a4612e37437a8b1ac43bab">leastSignificantClearBit</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a4c7ddf3b56a4612e37437a8b1ac43bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of least significant zero bit.  <br /></td></tr>
<tr class="separator:a4c7ddf3b56a4612e37437a8b1ac43bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab765f2a6a14917a4d271525c0b323387" id="r_ab765f2a6a14917a4d271525c0b323387"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ab765f2a6a14917a4d271525c0b323387"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab765f2a6a14917a4d271525c0b323387">mostSignificantSetBit</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:ab765f2a6a14917a4d271525c0b323387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of most significant set bit.  <br /></td></tr>
<tr class="separator:ab765f2a6a14917a4d271525c0b323387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d58f1688dbdcb762a04c083824f0d" id="r_a611d58f1688dbdcb762a04c083824f0d"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a611d58f1688dbdcb762a04c083824f0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a611d58f1688dbdcb762a04c083824f0d">mostSignificantClearBit</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a611d58f1688dbdcb762a04c083824f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of most significant clear bit.  <br /></td></tr>
<tr class="separator:a611d58f1688dbdcb762a04c083824f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3f1a28dce4fdc8606b7295e22e7047" id="r_a0d3f1a28dce4fdc8606b7295e22e7047"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a0d3f1a28dce4fdc8606b7295e22e7047"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a0d3f1a28dce4fdc8606b7295e22e7047">isAllSet</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a0d3f1a28dce4fdc8606b7295e22e7047"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are set.  <br /></td></tr>
<tr class="separator:a0d3f1a28dce4fdc8606b7295e22e7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcbf585635b282b0403decf667968b1" id="r_adfcbf585635b282b0403decf667968b1"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:adfcbf585635b282b0403decf667968b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#adfcbf585635b282b0403decf667968b1">isAllClear</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:adfcbf585635b282b0403decf667968b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are clear.  <br /></td></tr>
<tr class="separator:adfcbf585635b282b0403decf667968b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed4cf10f38ee25fa4ac40481563f4be" id="r_a5ed4cf10f38ee25fa4ac40481563f4be"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a5ed4cf10f38ee25fa4ac40481563f4be"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a5ed4cf10f38ee25fa4ac40481563f4be">nSet</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a5ed4cf10f38ee25fa4ac40481563f4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of set bits.  <br /></td></tr>
<tr class="separator:a5ed4cf10f38ee25fa4ac40481563f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e336b3864ef78d36449e93ff6e56b37" id="r_a1e336b3864ef78d36449e93ff6e56b37"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a1e336b3864ef78d36449e93ff6e56b37"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a1e336b3864ef78d36449e93ff6e56b37">nClear</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a1e336b3864ef78d36449e93ff6e56b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of clear bits.  <br /></td></tr>
<tr class="separator:a1e336b3864ef78d36449e93ff6e56b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ea9e2a7e12ef35f95c253a686b0e67" id="r_ae8ea9e2a7e12ef35f95c253a686b0e67"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ae8ea9e2a7e12ef35f95c253a686b0e67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ae8ea9e2a7e12ef35f95c253a686b0e67">leastSignificantDifference</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:ae8ea9e2a7e12ef35f95c253a686b0e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find least significant different bits.  <br /></td></tr>
<tr class="separator:ae8ea9e2a7e12ef35f95c253a686b0e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142fdfb66b4a2960cc3325cbebdfb7d5" id="r_a142fdfb66b4a2960cc3325cbebdfb7d5"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a142fdfb66b4a2960cc3325cbebdfb7d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a142fdfb66b4a2960cc3325cbebdfb7d5">mostSignificantDifference</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a142fdfb66b4a2960cc3325cbebdfb7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find most significant different bits.  <br /></td></tr>
<tr class="separator:a142fdfb66b4a2960cc3325cbebdfb7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1201c7c514dbd1f585bcf7541a21572" id="r_ad1201c7c514dbd1f585bcf7541a21572"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ad1201c7c514dbd1f585bcf7541a21572"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ad1201c7c514dbd1f585bcf7541a21572">areEqual</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:ad1201c7c514dbd1f585bcf7541a21572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality predicate.  <br /></td></tr>
<tr class="separator:ad1201c7c514dbd1f585bcf7541a21572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3367be46207c33fbf910613c4a4ebf" id="r_a2b3367be46207c33fbf910613c4a4ebf"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a2b3367be46207c33fbf910613c4a4ebf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2b3367be46207c33fbf910613c4a4ebf">shiftLeft</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:a2b3367be46207c33fbf910613c4a4ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits left.  <br /></td></tr>
<tr class="separator:a2b3367be46207c33fbf910613c4a4ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf56586a8f4f0df59c5ad26f1e34cb69" id="r_abf56586a8f4f0df59c5ad26f1e34cb69"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:abf56586a8f4f0df59c5ad26f1e34cb69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#abf56586a8f4f0df59c5ad26f1e34cb69">shiftRight</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:abf56586a8f4f0df59c5ad26f1e34cb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right.  <br /></td></tr>
<tr class="separator:abf56586a8f4f0df59c5ad26f1e34cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe4587b61f4f030664a721f7707fb7" id="r_a47fe4587b61f4f030664a721f7707fb7"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a47fe4587b61f4f030664a721f7707fb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a47fe4587b61f4f030664a721f7707fb7">shiftRightArithmetic</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:a47fe4587b61f4f030664a721f7707fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right arithmetically.  <br /></td></tr>
<tr class="separator:a47fe4587b61f4f030664a721f7707fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f3549a2581b19987078144c8b8180" id="r_a998f3549a2581b19987078144c8b8180"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a998f3549a2581b19987078144c8b8180"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a998f3549a2581b19987078144c8b8180">rotateRight</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:a998f3549a2581b19987078144c8b8180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits to the right.  <br /></td></tr>
<tr class="separator:a998f3549a2581b19987078144c8b8180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131103b09701a2e3a6beaf060e8ac94e" id="r_a131103b09701a2e3a6beaf060e8ac94e"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a131103b09701a2e3a6beaf060e8ac94e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a131103b09701a2e3a6beaf060e8ac94e">rotateLeft</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:a131103b09701a2e3a6beaf060e8ac94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits to the left.  <br /></td></tr>
<tr class="separator:a131103b09701a2e3a6beaf060e8ac94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbad33ae9f4ca7bfd6bb36e67229a87e" id="r_acbad33ae9f4ca7bfd6bb36e67229a87e"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:acbad33ae9f4ca7bfd6bb36e67229a87e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#acbad33ae9f4ca7bfd6bb36e67229a87e">invert</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:acbad33ae9f4ca7bfd6bb36e67229a87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert bits.  <br /></td></tr>
<tr class="separator:acbad33ae9f4ca7bfd6bb36e67229a87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c01bb897ba8ee5da25b9d3b526e85d" id="r_a67c01bb897ba8ee5da25b9d3b526e85d"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a67c01bb897ba8ee5da25b9d3b526e85d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a67c01bb897ba8ee5da25b9d3b526e85d">bitwiseAnd</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a67c01bb897ba8ee5da25b9d3b526e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise AND.  <br /></td></tr>
<tr class="separator:a67c01bb897ba8ee5da25b9d3b526e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a81b38b21f001f523b256e6e61e3b0" id="r_a26a81b38b21f001f523b256e6e61e3b0"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a26a81b38b21f001f523b256e6e61e3b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a26a81b38b21f001f523b256e6e61e3b0">bitwiseOr</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a26a81b38b21f001f523b256e6e61e3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise OR.  <br /></td></tr>
<tr class="separator:a26a81b38b21f001f523b256e6e61e3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7157a3e0d62d073ecc0530712e9061" id="r_a9e7157a3e0d62d073ecc0530712e9061"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a9e7157a3e0d62d073ecc0530712e9061"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a9e7157a3e0d62d073ecc0530712e9061">bitwiseXor</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a9e7157a3e0d62d073ecc0530712e9061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise XOR.  <br /></td></tr>
<tr class="separator:a9e7157a3e0d62d073ecc0530712e9061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc91eac654663790f3ab541a2b6d6d9" id="r_abcc91eac654663790f3ab541a2b6d6d9"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:abcc91eac654663790f3ab541a2b6d6d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#abcc91eac654663790f3ab541a2b6d6d9">fromInteger</a> (Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, boost::uint64_t value)</td></tr>
<tr class="memdesc:abcc91eac654663790f3ab541a2b6d6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an unsigned value to a bit range.  <br /></td></tr>
<tr class="separator:abcc91eac654663790f3ab541a2b6d6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d55e93178e7cb1c96e9e379f93d9bcf" id="r_a2d55e93178e7cb1c96e9e379f93d9bcf"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a2d55e93178e7cb1c96e9e379f93d9bcf"><td class="memTemplItemLeft" align="right" valign="top">boost::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2d55e93178e7cb1c96e9e379f93d9bcf">toInteger</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a2d55e93178e7cb1c96e9e379f93d9bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bit vector to an integer.  <br /></td></tr>
<tr class="separator:a2d55e93178e7cb1c96e9e379f93d9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af421cd57cce86580f892cbe4f4579021" id="r_af421cd57cce86580f892cbe4f4579021"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:af421cd57cce86580f892cbe4f4579021"><td class="memTemplItemLeft" align="right" valign="top">boost::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#af421cd57cce86580f892cbe4f4579021">toInteger</a> (const Word *words, size_t nbits)</td></tr>
<tr class="memdesc:af421cd57cce86580f892cbe4f4579021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a small bit vector to an integer.  <br /></td></tr>
<tr class="separator:af421cd57cce86580f892cbe4f4579021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f95c1c9254e3087db8427d8a96225" id="r_aa40f95c1c9254e3087db8427d8a96225"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aa40f95c1c9254e3087db8427d8a96225"><td class="memTemplItemLeft" align="right" valign="top">boost::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aa40f95c1c9254e3087db8427d8a96225">toSignedInteger</a> (const Word *words, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:aa40f95c1c9254e3087db8427d8a96225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bit vector to a signed integer.  <br /></td></tr>
<tr class="separator:aa40f95c1c9254e3087db8427d8a96225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5ed5664d8ccf2cfa6d4fc33962cf20" id="r_a8c5ed5664d8ccf2cfa6d4fc33962cf20"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a8c5ed5664d8ccf2cfa6d4fc33962cf20"><td class="memTemplItemLeft" align="right" valign="top">boost::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a8c5ed5664d8ccf2cfa6d4fc33962cf20">toSignedInteger</a> (const Word *words, size_t nBits)</td></tr>
<tr class="memdesc:a8c5ed5664d8ccf2cfa6d4fc33962cf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a small bit vector to a signed integer.  <br /></td></tr>
<tr class="separator:a8c5ed5664d8ccf2cfa6d4fc33962cf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85fceeb0bfbcea09685113c95dd49d7" id="r_aa85fceeb0bfbcea09685113c95dd49d7"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aa85fceeb0bfbcea09685113c95dd49d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aa85fceeb0bfbcea09685113c95dd49d7">increment</a> (Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:aa85fceeb0bfbcea09685113c95dd49d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Increment.html">Increment</a>.  <br /></td></tr>
<tr class="separator:aa85fceeb0bfbcea09685113c95dd49d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222fbcde16e4d71e886ac1094aac0d2e" id="r_a222fbcde16e4d71e886ac1094aac0d2e"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a222fbcde16e4d71e886ac1094aac0d2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a222fbcde16e4d71e886ac1094aac0d2e">decrement</a> (Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:a222fbcde16e4d71e886ac1094aac0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Decrement.html">Decrement</a>.  <br /></td></tr>
<tr class="separator:a222fbcde16e4d71e886ac1094aac0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168da62308ccdde364a4793eaa675f88" id="r_a168da62308ccdde364a4793eaa675f88"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a168da62308ccdde364a4793eaa675f88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a168da62308ccdde364a4793eaa675f88">negate</a> (Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a168da62308ccdde364a4793eaa675f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate bits as an integer.  <br /></td></tr>
<tr class="separator:a168da62308ccdde364a4793eaa675f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f84b9c0638d1b4785b9a9884420375" id="r_ab0f84b9c0638d1b4785b9a9884420375"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ab0f84b9c0638d1b4785b9a9884420375"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab0f84b9c0638d1b4785b9a9884420375">add</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2, bool carryIn=false)</td></tr>
<tr class="memdesc:ab0f84b9c0638d1b4785b9a9884420375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bits.  <br /></td></tr>
<tr class="separator:ab0f84b9c0638d1b4785b9a9884420375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e59f3428ec7731a3200b95d54b3fa29" id="r_a2e59f3428ec7731a3200b95d54b3fa29"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a2e59f3428ec7731a3200b95d54b3fa29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2e59f3428ec7731a3200b95d54b3fa29">subtract</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a2e59f3428ec7731a3200b95d54b3fa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract bits.  <br /></td></tr>
<tr class="separator:a2e59f3428ec7731a3200b95d54b3fa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21054f8a03caaa2db161bce295442c7e" id="r_a21054f8a03caaa2db161bce295442c7e"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a21054f8a03caaa2db161bce295442c7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a21054f8a03caaa2db161bce295442c7e">signExtend</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a21054f8a03caaa2db161bce295442c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign extend.  <br /></td></tr>
<tr class="separator:a21054f8a03caaa2db161bce295442c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1a5421e50db760e7711d615688ca79" id="r_a2e1a5421e50db760e7711d615688ca79"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a2e1a5421e50db760e7711d615688ca79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2e1a5421e50db760e7711d615688ca79">multiply10</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a2e1a5421e50db760e7711d615688ca79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by 10.  <br /></td></tr>
<tr class="separator:a2e1a5421e50db760e7711d615688ca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0632cfc90ca23f6f55513456d477cc5a" id="r_a0632cfc90ca23f6f55513456d477cc5a"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a0632cfc90ca23f6f55513456d477cc5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a0632cfc90ca23f6f55513456d477cc5a">isEqualToZero</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:a0632cfc90ca23f6f55513456d477cc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares with zero.  <br /></td></tr>
<tr class="separator:a0632cfc90ca23f6f55513456d477cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b849b9f8cb2af310d49c83c9ebaf1cc" id="r_a2b849b9f8cb2af310d49c83c9ebaf1cc"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a2b849b9f8cb2af310d49c83c9ebaf1cc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2b849b9f8cb2af310d49c83c9ebaf1cc">compare</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a2b849b9f8cb2af310d49c83c9ebaf1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned comparison.  <br /></td></tr>
<tr class="separator:a2b849b9f8cb2af310d49c83c9ebaf1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac31573c5ac632dde2e0bcba0bffbe5f" id="r_aac31573c5ac632dde2e0bcba0bffbe5f"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aac31573c5ac632dde2e0bcba0bffbe5f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aac31573c5ac632dde2e0bcba0bffbe5f">compareSigned</a> (const Word *vec1, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range1, const Word *vec2, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:aac31573c5ac632dde2e0bcba0bffbe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed comparison.  <br /></td></tr>
<tr class="separator:aac31573c5ac632dde2e0bcba0bffbe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab789f91a7988ba2be7ebe96a4b2cd9fa" id="r_ab789f91a7988ba2be7ebe96a4b2cd9fa"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ab789f91a7988ba2be7ebe96a4b2cd9fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab789f91a7988ba2be7ebe96a4b2cd9fa">toBytes</a> (const Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="separator:ab789f91a7988ba2be7ebe96a4b2cd9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae276ef74e92702569d01247446e2709e" id="r_ae276ef74e92702569d01247446e2709e"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ae276ef74e92702569d01247446e2709e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ae276ef74e92702569d01247446e2709e">fromBytes</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::vector&lt; uint8_t &gt; &amp;input)</td></tr>
<tr class="separator:ae276ef74e92702569d01247446e2709e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede0d28cdd8ab4e5c7b8b2fa53697def" id="r_aede0d28cdd8ab4e5c7b8b2fa53697def"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:aede0d28cdd8ab4e5c7b8b2fa53697def"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aede0d28cdd8ab4e5c7b8b2fa53697def">toHex</a> (const Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:aede0d28cdd8ab4e5c7b8b2fa53697def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexadecimal representation.  <br /></td></tr>
<tr class="separator:aede0d28cdd8ab4e5c7b8b2fa53697def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0ed1c2909c326032de178c9886a0fd" id="r_abb0ed1c2909c326032de178c9886a0fd"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:abb0ed1c2909c326032de178c9886a0fd"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#abb0ed1c2909c326032de178c9886a0fd">toOctal</a> (const Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:abb0ed1c2909c326032de178c9886a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Octal representation.  <br /></td></tr>
<tr class="separator:abb0ed1c2909c326032de178c9886a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ff72aee3332fac82f7164715ebfe3" id="r_a1c7ff72aee3332fac82f7164715ebfe3"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a1c7ff72aee3332fac82f7164715ebfe3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a1c7ff72aee3332fac82f7164715ebfe3">toBinary</a> (const Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a1c7ff72aee3332fac82f7164715ebfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary representation.  <br /></td></tr>
<tr class="separator:a1c7ff72aee3332fac82f7164715ebfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f1eb8242f737cf52852cf7e9027f15" id="r_ac3f1eb8242f737cf52852cf7e9027f15"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:ac3f1eb8242f737cf52852cf7e9027f15"><td class="memTemplItemLeft" align="right" valign="top">Word&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ac3f1eb8242f737cf52852cf7e9027f15">charToDigit</a> (char ch)</td></tr>
<tr class="separator:ac3f1eb8242f737cf52852cf7e9027f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050c1d79ad3103834b79913f4588217" id="r_a6050c1d79ad3103834b79913f4588217"><td class="memTemplParams" colspan="2">template&lt;class Word , size_t bitsPerDigit&gt; </td></tr>
<tr class="memitem:a6050c1d79ad3103834b79913f4588217"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a6050c1d79ad3103834b79913f4588217">fromString</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="separator:a6050c1d79ad3103834b79913f4588217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dce682e900925e0043015663657450" id="r_a44dce682e900925e0043015663657450"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a44dce682e900925e0043015663657450"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a44dce682e900925e0043015663657450">fromDecimal</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a44dce682e900925e0043015663657450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a decimal representation.  <br /></td></tr>
<tr class="separator:a44dce682e900925e0043015663657450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972dd1f887812a17f7cd69047d5973fe" id="r_a972dd1f887812a17f7cd69047d5973fe"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a972dd1f887812a17f7cd69047d5973fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a972dd1f887812a17f7cd69047d5973fe">fromHex</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a972dd1f887812a17f7cd69047d5973fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a hexadecimal representation.  <br /></td></tr>
<tr class="separator:a972dd1f887812a17f7cd69047d5973fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0f149ca9f098453f35753ccf5c72a3" id="r_a3d0f149ca9f098453f35753ccf5c72a3"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a3d0f149ca9f098453f35753ccf5c72a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a3d0f149ca9f098453f35753ccf5c72a3">fromOctal</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a3d0f149ca9f098453f35753ccf5c72a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from an octal representation.  <br /></td></tr>
<tr class="separator:a3d0f149ca9f098453f35753ccf5c72a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f69e010ddfab0959b4dd0a59b7d90d" id="r_a38f69e010ddfab0959b4dd0a59b7d90d"><td class="memTemplParams" colspan="2">template&lt;class Word &gt; </td></tr>
<tr class="memitem:a38f69e010ddfab0959b4dd0a59b7d90d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a38f69e010ddfab0959b4dd0a59b7d90d">fromBinary</a> (Word *vec, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a38f69e010ddfab0959b4dd0a59b7d90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a binary representation.  <br /></td></tr>
<tr class="separator:a38f69e010ddfab0959b4dd0a59b7d90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ade2a0ead7d04cd603379ba45e2dc37af" id="r_ade2a0ead7d04cd603379ba45e2dc37af"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:ade2a0ead7d04cd603379ba45e2dc37af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ade2a0ead7d04cd603379ba45e2dc37af">processWord</a> (Processor &amp;processor, const Word &amp;word, size_t shift, size_t nbits)</td></tr>
<tr class="memdesc:ade2a0ead7d04cd603379ba45e2dc37af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the a processor for a vector traversal.  <br /></td></tr>
<tr class="separator:ade2a0ead7d04cd603379ba45e2dc37af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eb78124fb4be8479d1dba411e6c4d0" id="r_a31eb78124fb4be8479d1dba411e6c4d0"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a31eb78124fb4be8479d1dba411e6c4d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a31eb78124fb4be8479d1dba411e6c4d0">processWord</a> (Processor &amp;processor, Word &amp;word, size_t shift, size_t nbits)</td></tr>
<tr class="memdesc:a31eb78124fb4be8479d1dba411e6c4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the a processor for a vector traversal.  <br /></td></tr>
<tr class="separator:a31eb78124fb4be8479d1dba411e6c4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab012d9d5b49632b948025245547fc582" id="r_ab012d9d5b49632b948025245547fc582"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:ab012d9d5b49632b948025245547fc582"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#ab012d9d5b49632b948025245547fc582">processWord</a> (Processor &amp;processor, const Word &amp;src, Word &amp;dst, size_t shift, size_t nbits)</td></tr>
<tr class="memdesc:ab012d9d5b49632b948025245547fc582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the a processor for a vector traversal.  <br /></td></tr>
<tr class="separator:ab012d9d5b49632b948025245547fc582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989720f6625f205ba79b93ef1938f4bc" id="r_a989720f6625f205ba79b93ef1938f4bc"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a989720f6625f205ba79b93ef1938f4bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a989720f6625f205ba79b93ef1938f4bc">processWord</a> (Processor &amp;processor, Word &amp;w1, Word &amp;w2, size_t shift, size_t nbits)</td></tr>
<tr class="memdesc:a989720f6625f205ba79b93ef1938f4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the a processor for a vector traversal.  <br /></td></tr>
<tr class="separator:a989720f6625f205ba79b93ef1938f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643a0bccd4e2eec1003a9b028758c65" id="r_a5643a0bccd4e2eec1003a9b028758c65"><td class="memTemplParams" colspan="2">template&lt;class Processor , class Word &gt; </td></tr>
<tr class="memitem:a5643a0bccd4e2eec1003a9b028758c65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a5643a0bccd4e2eec1003a9b028758c65">processWord</a> (Processor &amp;processor, const Word &amp;w1, const Word &amp;w2, size_t shift, size_t nbits)</td></tr>
<tr class="memdesc:a5643a0bccd4e2eec1003a9b028758c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the a processor for a vector traversal.  <br /></td></tr>
<tr class="separator:a5643a0bccd4e2eec1003a9b028758c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad5b9ffa8f871fb468d9bd374a90b1a8d" name="ad5b9ffa8f871fb468d9bd374a90b1a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b9ffa8f871fb468d9bd374a90b1a8d">&#9670;&#160;</a></span>BitRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Interval</a>&lt;size_t&gt; <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::BitVectorSupport::BitRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00033">33</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeb44f7c946dc2afbfa5a1e4921d42cc2" name="aeb44f7c946dc2afbfa5a1e4921d42cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb44f7c946dc2afbfa5a1e4921d42cc2">&#9670;&#160;</a></span>wordIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVectorSupport::wordIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index to bit vector word. </p>
<p>Returns the index to a bit vector word. Bit zero of the bit vector is in word index zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00049">49</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="aea1bb15b759bd3d017595d2f6552feb9" name="aea1bb15b759bd3d017595d2f6552feb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1bb15b759bd3d017595d2f6552feb9">&#9670;&#160;</a></span>bitIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVectorSupport::bitIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index to bit within word. </p>
<p>Returns the index of a bit within a word. Bit zero is the least significant bit of the word. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00057">57</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a1730bf7a76c31891dcb7ca3bade1219f" name="a1730bf7a76c31891dcb7ca3bade1219f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1730bf7a76c31891dcb7ca3bade1219f">&#9670;&#160;</a></span>numberOfWords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVectorSupport::numberOfWords </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of words to hold indicated number of bits. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00063">63</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a8f4b68d40e7343bb8cca259148533ca5" name="a8f4b68d40e7343bb8cca259148533ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4b68d40e7343bb8cca259148533ca5">&#9670;&#160;</a></span>bitMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word Sawyer::Container::BitVectorSupport::bitMask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mask. </p>
<p>Returns a mask which contains all zeros except for <code>nbits</code> consecutive bits set beginning at <code>offset</code> and continuing in a more-significant direction. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00072">72</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="ade2a0ead7d04cd603379ba45e2dc37af" name="ade2a0ead7d04cd603379ba45e2dc37af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2a0ead7d04cd603379ba45e2dc37af">&#9670;&#160;</a></span>processWord() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::processWord </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word &amp;&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the a processor for a vector traversal. </p>
<p>Returns true when the word is "found" and the traversal can abort. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00084">84</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00231">traverse()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00299">traverse2()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00263">traverse2()</a>.</p>

</div>
</div>
<a id="a31eb78124fb4be8479d1dba411e6c4d0" name="a31eb78124fb4be8479d1dba411e6c4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eb78124fb4be8479d1dba411e6c4d0">&#9670;&#160;</a></span>processWord() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::processWord </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the a processor for a vector traversal. </p>
<p>Returns true when the word is "found" and the traversal can abort. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00092">92</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="ab012d9d5b49632b948025245547fc582" name="ab012d9d5b49632b948025245547fc582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab012d9d5b49632b948025245547fc582">&#9670;&#160;</a></span>processWord() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::processWord </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the a processor for a vector traversal. </p>
<p>Returns true when the word is "found" and the traversal can abort. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00102">102</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a989720f6625f205ba79b93ef1938f4bc" name="a989720f6625f205ba79b93ef1938f4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989720f6625f205ba79b93ef1938f4bc">&#9670;&#160;</a></span>processWord() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::processWord </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;&#160;</td>
          <td class="paramname"><em>w2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the a processor for a vector traversal. </p>
<p>Returns true when the word is "found" and the traversal can abort. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00113">113</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a5643a0bccd4e2eec1003a9b028758c65" name="a5643a0bccd4e2eec1003a9b028758c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5643a0bccd4e2eec1003a9b028758c65">&#9670;&#160;</a></span>processWord() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::processWord </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word &amp;&#160;</td>
          <td class="paramname"><em>w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word &amp;&#160;</td>
          <td class="paramname"><em>w2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the a processor for a vector traversal. </p>
<p>Returns true when the word is "found" and the traversal can abort. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00127">127</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a4aef7fddd157160622524a2d8e7d83fe" name="a4aef7fddd157160622524a2d8e7d83fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aef7fddd157160622524a2d8e7d83fe">&#9670;&#160;</a></span>nonoverlappingCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::nonoverlappingCopy </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00138">138</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a319b94e255da648c8af90e6432e81305" name="a319b94e255da648c8af90e6432e81305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319b94e255da648c8af90e6432e81305">&#9670;&#160;</a></span>conditionalCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Src , class Dst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::conditionalCopy </td>
          <td>(</td>
          <td class="paramtype">const Src *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dst *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00200">200</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a3d5d76240db2bbbf86535445ad837bbc" name="a3d5d76240db2bbbf86535445ad837bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5d76240db2bbbf86535445ad837bbc">&#9670;&#160;</a></span>conditionalCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Src , class Dst &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::conditionalCopy </td>
          <td>(</td>
          <td class="paramtype">const Src *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dst *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00204">204</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="acc438763608a5808fa1d155f013d9e23" name="acc438763608a5808fa1d155f013d9e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc438763608a5808fa1d155f013d9e23">&#9670;&#160;</a></span>traverse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses a range of bits. </p>
<p>Traverses a subset of the bits in the <code>words</code> array by invoking the <code>processor</code> function on each word. The least significant traversed word will be right-shifted if necessary so that the least significant bit of the range will be at bit index zero when the <code>processor</code> is invoked. The visit method must not modify the word. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00214">214</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00084">processWord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01135">add()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00907">bitwiseAnd()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00925">bitwiseOr()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00943">bitwiseXor()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00400">clear()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">compare()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01094">decrement()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00497">equalTo()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01067">increment()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00889">invert()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00566">leastSignificantClearBit()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00732">leastSignificantDifference()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00534">leastSignificantSetBit()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00632">mostSignificantClearBit()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00766">mostSignificantDifference()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00599">mostSignificantSetBit()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00700">nClear()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00675">nSet()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00417">set()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00470">swap()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01469">toBinary()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01445">toHex()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01457">toOctal()</a>.</p>

</div>
</div>
<a id="ab08cc0cfada6c56bf657bc0cc110e9b5" name="ab08cc0cfada6c56bf657bc0cc110e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cc0cfada6c56bf657bc0cc110e9b5">&#9670;&#160;</a></span>traverse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse one range of bits starting with the most significant bit. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00231">231</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00084">processWord()</a>.</p>

</div>
</div>
<a id="a609864a5be23260d53d9a4da675ec412" name="a609864a5be23260d53d9a4da675ec412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609864a5be23260d53d9a4da675ec412">&#9670;&#160;</a></span>traverse2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word1 , class Word2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse2 </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word1 *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse two ranges of bits from low to high. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00263">263</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00084">processWord()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="ac5ee713f08e6152de753c93fb7901576" name="ac5ee713f08e6152de753c93fb7901576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ee713f08e6152de753c93fb7901576">&#9670;&#160;</a></span>traverse2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word1 , class Word2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse2 </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word1 *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word2 *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse two ranges of bits from high to low. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00299">299</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00084">processWord()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="a23bc759f7c3b0caeac0caa648639510e" name="a23bc759f7c3b0caeac0caa648639510e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bc759f7c3b0caeac0caa648639510e">&#9670;&#160;</a></span>traverse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1HighToLow.html">HighToLow</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00345">345</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a5bc2e1bf7ce6681708fcec68528857fe" name="a5bc2e1bf7ce6681708fcec68528857fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc2e1bf7ce6681708fcec68528857fe">&#9670;&#160;</a></span>traverse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00353">353</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="aa87978eabb3c818068492a2c52868158" name="aa87978eabb3c818068492a2c52868158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87978eabb3c818068492a2c52868158">&#9670;&#160;</a></span>traverse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00360">360</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a277028563d12d31e896b838fe5dadb63" name="a277028563d12d31e896b838fe5dadb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277028563d12d31e896b838fe5dadb63">&#9670;&#160;</a></span>traverse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Processor , class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::traverse </td>
          <td>(</td>
          <td class="paramtype">Processor &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1LowToHigh.html">LowToHigh</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00367">367</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a98b33c1888d241c1ef777bcef0eacc3c" name="a98b33c1888d241c1ef777bcef0eacc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b33c1888d241c1ef777bcef0eacc3c">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::get </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a single bit. </p>
<p>Returns the bit at the specified index. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00384">384</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00271">Sawyer::Container::BitVector::get()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00829">shiftRightArithmetic()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">signExtend()</a>.</p>

</div>
</div>
<a id="a5fca01114382a97afa15c25b29579dff" name="a5fca01114382a97afa15c25b29579dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fca01114382a97afa15c25b29579dff">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::clear </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear some bits. </p>
<p>Clears all bits in the specified index range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00400">400</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00292">Sawyer::Container::BitVector::clear()</a>, <a class="el" href="BitVector_8h_source.html#l00281">Sawyer::Container::BitVector::clear()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00957">fromInteger()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00426">setValue()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">signExtend()</a>.</p>

</div>
</div>
<a id="a6a1434bde1bc4974b3224a9856a352b0" name="a6a1434bde1bc4974b3224a9856a352b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1434bde1bc4974b3224a9856a352b0">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::set </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> some bits. </p>
<p>Sets all bits in the specified index range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00417">417</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00311">Sawyer::Container::BitVector::set()</a>, <a class="el" href="BitVector_8h_source.html#l00301">Sawyer::Container::BitVector::set()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">setValue()</a>.</p>

</div>
</div>
<a id="af68ac2d6efbbb861299c4cfe02e8a148" name="af68ac2d6efbbb861299c4cfe02e8a148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68ac2d6efbbb861299c4cfe02e8a148">&#9670;&#160;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::setValue </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Set.html" title="Ordered set of values.">Set</a> or clear some bits. </p>
<p>Sets or clears all bits in the specified index range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00426">426</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00400">clear()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00417">set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00215">Sawyer::Container::BitVector::resize()</a>, <a class="el" href="BitVector_8h_source.html#l00328">Sawyer::Container::BitVector::setValue()</a>, <a class="el" href="BitVector_8h_source.html#l00319">Sawyer::Container::BitVector::setValue()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00793">shiftLeft()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00811">shiftRight()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">signExtend()</a>.</p>

</div>
</div>
<a id="aff6810c441e283e64b214bd4d9bbc0a6" name="aff6810c441e283e64b214bd4d9bbc0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6810c441e283e64b214bd4d9bbc0a6">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::copy </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy some bits. </p>
<p>Copies bits from <code>src</code> to <code>dst</code> according to the ranges <code>srcRange</code> and <code>dstRange</code>. The size of the two address ranges must be the same. The ranges may overlap, and the <code>src</code> and <code>dst</code> may be the same pointer. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00448">448</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00352">Sawyer::Container::BitVector::copy()</a>, <a class="el" href="BitVector_8h_source.html#l00340">Sawyer::Container::BitVector::copy()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01533">fromDecimal()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00957">fromInteger()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01187">multiply10()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00841">rotateRight()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00793">shiftLeft()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00811">shiftRight()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01164">signExtend()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01148">subtract()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00983">toInteger()</a>.</p>

</div>
</div>
<a id="a50b21530bd4cace95455a936ec463cc5" name="a50b21530bd4cace95455a936ec463cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b21530bd4cace95455a936ec463cc5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::swap </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap some bits. </p>
<p>Swaps bits from part of one vector with bits from part of another (or the same). The size of the two address ranges must be equal and they may not overlap within a single vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00470">470</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00243">Sawyer::Container::Interval&lt; T &gt;::overlaps()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00364">Sawyer::Container::BitVector::swap()</a>, and <a class="el" href="BitVector_8h_source.html#l00375">Sawyer::Container::BitVector::swap()</a>.</p>

</div>
</div>
<a id="aa34e3f3ec9da5b48f618db562a06899f" name="aa34e3f3ec9da5b48f618db562a06899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34e3f3ec9da5b48f618db562a06899f">&#9670;&#160;</a></span>equalTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::equalTo </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare bits for equality. </p>
<p>Returns true if and only if the ranges are the same size and contain the same bit values in the same order. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00497">497</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00385">Sawyer::Container::BitVector::equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00395">Sawyer::Container::BitVector::equalTo()</a>, and <a class="el" href="BitVector_8h_source.html#l00405">Sawyer::Container::BitVector::equalTo()</a>.</p>

</div>
</div>
<a id="ab2f4bb98cec1411a09cbdc4f308208fb" name="ab2f4bb98cec1411a09cbdc4f308208fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f4bb98cec1411a09cbdc4f308208fb">&#9670;&#160;</a></span>leastSignificantSetBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::leastSignificantSetBit </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of least significant set bit. </p>
<p>Returns the index of the least significant set bit within the specified range of bits. The return value is the absolute bit number in the entire vector. If none of the bits in the range are set then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00534">534</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00652">isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00429">Sawyer::Container::BitVector::leastSignificantSetBit()</a>, and <a class="el" href="BitVector_8h_source.html#l00420">Sawyer::Container::BitVector::leastSignificantSetBit()</a>.</p>

</div>
</div>
<a id="a4c7ddf3b56a4612e37437a8b1ac43bab" name="a4c7ddf3b56a4612e37437a8b1ac43bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ddf3b56a4612e37437a8b1ac43bab">&#9670;&#160;</a></span>leastSignificantClearBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::leastSignificantClearBit </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of least significant zero bit. </p>
<p>Returns the index of the least significant clear bit within the specified range of bits. The return value is the absolute bit number in the entire vector. If none of the bits in the range are clear then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00566">566</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00644">isAllSet()</a>, <a class="el" href="BitVector_8h_source.html#l00447">Sawyer::Container::BitVector::leastSignificantClearBit()</a>, and <a class="el" href="BitVector_8h_source.html#l00438">Sawyer::Container::BitVector::leastSignificantClearBit()</a>.</p>

</div>
</div>
<a id="ab765f2a6a14917a4d271525c0b323387" name="ab765f2a6a14917a4d271525c0b323387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab765f2a6a14917a4d271525c0b323387">&#9670;&#160;</a></span>mostSignificantSetBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::mostSignificantSetBit </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of most significant set bit. </p>
<p>Returns the index of the most significant set bit within the specified range of bits. The return value is the absolute bit number in the entire vector. If none of the bits in the range are set then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00599">599</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00465">Sawyer::Container::BitVector::mostSignificantSetBit()</a>, and <a class="el" href="BitVector_8h_source.html#l00456">Sawyer::Container::BitVector::mostSignificantSetBit()</a>.</p>

</div>
</div>
<a id="a611d58f1688dbdcb762a04c083824f0d" name="a611d58f1688dbdcb762a04c083824f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d58f1688dbdcb762a04c083824f0d">&#9670;&#160;</a></span>mostSignificantClearBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::mostSignificantClearBit </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of most significant clear bit. </p>
<p>Returns the index of the most significant zero bit within the specified range of bits. The return value is the absolute bit number in the entire vector. If none of the bits in the range are set then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00632">632</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00483">Sawyer::Container::BitVector::mostSignificantClearBit()</a>, and <a class="el" href="BitVector_8h_source.html#l00474">Sawyer::Container::BitVector::mostSignificantClearBit()</a>.</p>

</div>
</div>
<a id="a0d3f1a28dce4fdc8606b7295e22e7047" name="a0d3f1a28dce4fdc8606b7295e22e7047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3f1a28dce4fdc8606b7295e22e7047">&#9670;&#160;</a></span>isAllSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::isAllSet </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if all bits are set. </p>
<p>Returns true if the indicated range does not contain a clear bit; an empty range returns true. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00644">644</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00566">leastSignificantClearBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00499">Sawyer::Container::BitVector::isAllSet()</a>, and <a class="el" href="BitVector_8h_source.html#l00491">Sawyer::Container::BitVector::isAllSet()</a>.</p>

</div>
</div>
<a id="adfcbf585635b282b0403decf667968b1" name="adfcbf585635b282b0403decf667968b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcbf585635b282b0403decf667968b1">&#9670;&#160;</a></span>isAllClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::isAllClear </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if all bits are clear. </p>
<p>Returns true if the indicated range does not contain a set bit; an empty range returns true. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00652">652</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00534">leastSignificantSetBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00519">Sawyer::Container::BitVector::isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00509">Sawyer::Container::BitVector::isAllClear()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01206">isEqualToZero()</a>.</p>

</div>
</div>
<a id="a5ed4cf10f38ee25fa4ac40481563f4be" name="a5ed4cf10f38ee25fa4ac40481563f4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed4cf10f38ee25fa4ac40481563f4be">&#9670;&#160;</a></span>nSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVectorSupport::nSet </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of set bits. </p>
<p>Returns the number of bits that are set in the specified range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00675">675</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00534">Sawyer::Container::BitVector::nSet()</a>, and <a class="el" href="BitVector_8h_source.html#l00526">Sawyer::Container::BitVector::nSet()</a>.</p>

</div>
</div>
<a id="a1e336b3864ef78d36449e93ff6e56b37" name="a1e336b3864ef78d36449e93ff6e56b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e336b3864ef78d36449e93ff6e56b37">&#9670;&#160;</a></span>nClear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVectorSupport::nClear </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of clear bits. </p>
<p>Returns the number of bits that are clear in the specified range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00700">700</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00549">Sawyer::Container::BitVector::nClear()</a>, and <a class="el" href="BitVector_8h_source.html#l00541">Sawyer::Container::BitVector::nClear()</a>.</p>

</div>
</div>
<a id="ae8ea9e2a7e12ef35f95c253a686b0e67" name="ae8ea9e2a7e12ef35f95c253a686b0e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ea9e2a7e12ef35f95c253a686b0e67">&#9670;&#160;</a></span>leastSignificantDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::leastSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find least significant different bits. </p>
<p>Finds the least significant bit of two sub-vectors where the value is different. The return value is the offset relative to the beginning of the sub-vectors where the first difference is found; it is not a bit index within the either vector-as-a-whole (unless the ranges start at zero). If no difference is found then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00732">732</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00778">areEqual()</a>, <a class="el" href="BitVector_8h_source.html#l00618">Sawyer::Container::BitVector::leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00603">Sawyer::Container::BitVector::leastSignificantDifference()</a>, and <a class="el" href="BitVector_8h_source.html#l00629">Sawyer::Container::BitVector::leastSignificantDifference()</a>.</p>

</div>
</div>
<a id="a142fdfb66b4a2960cc3325cbebdfb7d5" name="a142fdfb66b4a2960cc3325cbebdfb7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142fdfb66b4a2960cc3325cbebdfb7d5">&#9670;&#160;</a></span>mostSignificantDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVectorSupport::mostSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find most significant different bits. </p>
<p>Finds the most significant bit of two sub-vectors where the value is different. The return value is the offset relative to the beginning of the sub-vectors where the first difference is found; it is not a bit index within the either vector-as-a-whole (unless the ranges start at zero). If no difference is found then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00766">766</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00578">Sawyer::Container::BitVector::mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00563">Sawyer::Container::BitVector::mostSignificantDifference()</a>, and <a class="el" href="BitVector_8h_source.html#l00589">Sawyer::Container::BitVector::mostSignificantDifference()</a>.</p>

</div>
</div>
<a id="ad1201c7c514dbd1f585bcf7541a21572" name="ad1201c7c514dbd1f585bcf7541a21572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1201c7c514dbd1f585bcf7541a21572">&#9670;&#160;</a></span>areEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::areEqual </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality predicate. </p>
<p>Returns true if two vectors are equal. An empty vector is equal to another empty vector, but not equal to any non-empty vector. See also, <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2b849b9f8cb2af310d49c83c9ebaf1cc">compare</a>, which treats vectors numerically and can be used in cases when they are different sizes. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00778">778</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00732">leastSignificantDifference()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a id="a2b3367be46207c33fbf910613c4a4ebf" name="a2b3367be46207c33fbf910613c4a4ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3367be46207c33fbf910613c4a4ebf">&#9670;&#160;</a></span>shiftLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::shiftLeft </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift bits left. </p>
<p>Shifts the bits in the specified range left by <code>nShift</code> places, discarding the high-order bits and introducing low-order bits with the value <code>newBits</code>. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00793">793</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">setValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01187">multiply10()</a>, <a class="el" href="BitVector_8h_source.html#l00644">Sawyer::Container::BitVector::shiftLeft()</a>, and <a class="el" href="BitVector_8h_source.html#l00657">Sawyer::Container::BitVector::shiftLeft()</a>.</p>

</div>
</div>
<a id="abf56586a8f4f0df59c5ad26f1e34cb69" name="abf56586a8f4f0df59c5ad26f1e34cb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf56586a8f4f0df59c5ad26f1e34cb69">&#9670;&#160;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::shiftRight </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift bits right. </p>
<p>Shifts the bits in the specified range right by <code>nShift</code> places, discarding the low-order bits and introducing high-order bits with the value <code>newBits</code>. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00811">811</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">setValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00841">rotateRight()</a>, <a class="el" href="BitVector_8h_source.html#l00669">Sawyer::Container::BitVector::shiftRight()</a>, <a class="el" href="BitVector_8h_source.html#l00682">Sawyer::Container::BitVector::shiftRight()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00829">shiftRightArithmetic()</a>.</p>

</div>
</div>
<a id="a47fe4587b61f4f030664a721f7707fb7" name="a47fe4587b61f4f030664a721f7707fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fe4587b61f4f030664a721f7707fb7">&#9670;&#160;</a></span>shiftRightArithmetic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::shiftRightArithmetic </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift bits right arithmetically. </p>
<p>Shifts the bits in the specified range right by <code>nShift</code> places, discarding the low-order bits and introducing high-order bits with the same value as the original high-order bit within the range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00829">829</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00384">get()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00811">shiftRight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00695">Sawyer::Container::BitVector::shiftRightArithmetic()</a>, and <a class="el" href="BitVector_8h_source.html#l00709">Sawyer::Container::BitVector::shiftRightArithmetic()</a>.</p>

</div>
</div>
<a id="a998f3549a2581b19987078144c8b8180" name="a998f3549a2581b19987078144c8b8180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998f3549a2581b19987078144c8b8180">&#9670;&#160;</a></span>rotateRight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::rotateRight </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate bits to the right. </p>
<p>Rotates the bits of the specified range to the right by <code>nShift</code> places, introducing high-order bits that are the same as the low-order bits that were removed. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00841">841</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00811">shiftRight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l00865">rotateLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00719">Sawyer::Container::BitVector::rotateRight()</a>, and <a class="el" href="BitVector_8h_source.html#l00730">Sawyer::Container::BitVector::rotateRight()</a>.</p>

</div>
</div>
<a id="a131103b09701a2e3a6beaf060e8ac94e" name="a131103b09701a2e3a6beaf060e8ac94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131103b09701a2e3a6beaf060e8ac94e">&#9670;&#160;</a></span>rotateLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::rotateLeft </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate bits to the left. </p>
<p>Rotates the bits of the specified range to the left by <code>nShift</code> places, introducing low-order bits that are the same as the high-order bits that were removed. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00865">865</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00841">rotateRight()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00740">Sawyer::Container::BitVector::rotateLeft()</a>, and <a class="el" href="BitVector_8h_source.html#l00751">Sawyer::Container::BitVector::rotateLeft()</a>.</p>

</div>
</div>
<a id="acbad33ae9f4ca7bfd6bb36e67229a87e" name="acbad33ae9f4ca7bfd6bb36e67229a87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbad33ae9f4ca7bfd6bb36e67229a87e">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::invert </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert bits. </p>
<p>Inverts all bits in the specified range. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00889">889</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01013">Sawyer::Container::BitVector::invert()</a>, <a class="el" href="BitVector_8h_source.html#l01004">Sawyer::Container::BitVector::invert()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01104">negate()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01148">subtract()</a>.</p>

</div>
</div>
<a id="a67c01bb897ba8ee5da25b9d3b526e85d" name="a67c01bb897ba8ee5da25b9d3b526e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c01bb897ba8ee5da25b9d3b526e85d">&#9670;&#160;</a></span>bitwiseAnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit-wise AND. </p>
<p>Computes the bitwise AND of equal-size sub-vectors <code>vec1</code> and <code>vec2</code> and stores the result in <code>vec2</code>. The sub-vectors may overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00907">907</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01034">Sawyer::Container::BitVector::bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01023">Sawyer::Container::BitVector::bitwiseAnd()</a>, and <a class="el" href="BitVector_8h_source.html#l01045">Sawyer::Container::BitVector::bitwiseAnd()</a>.</p>

</div>
</div>
<a id="a26a81b38b21f001f523b256e6e61e3b0" name="a26a81b38b21f001f523b256e6e61e3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a81b38b21f001f523b256e6e61e3b0">&#9670;&#160;</a></span>bitwiseOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::bitwiseOr </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit-wise OR. </p>
<p>Computes the bitwise OR of equal-size sub-vectors <code>vec1</code> and <code>vec2</code> and stores the result in <code>vec2</code>. The sub-vectors may overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00925">925</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01066">Sawyer::Container::BitVector::bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01055">Sawyer::Container::BitVector::bitwiseOr()</a>, and <a class="el" href="BitVector_8h_source.html#l01077">Sawyer::Container::BitVector::bitwiseOr()</a>.</p>

</div>
</div>
<a id="a9e7157a3e0d62d073ecc0530712e9061" name="a9e7157a3e0d62d073ecc0530712e9061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7157a3e0d62d073ecc0530712e9061">&#9670;&#160;</a></span>bitwiseXor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::bitwiseXor </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit-wise XOR. </p>
<p>Computes the bitwise exclusive-OR of equal-size sub-vectors <code>vec1</code> and <code>vec2</code> and stores the result in <code>vec2</code>. The sub-vectors may overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00943">943</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01098">Sawyer::Container::BitVector::bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01087">Sawyer::Container::BitVector::bitwiseXor()</a>, and <a class="el" href="BitVector_8h_source.html#l01109">Sawyer::Container::BitVector::bitwiseXor()</a>.</p>

</div>
</div>
<a id="abcc91eac654663790f3ab541a2b6d6d9" name="abcc91eac654663790f3ab541a2b6d6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc91eac654663790f3ab541a2b6d6d9">&#9670;&#160;</a></span>fromInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromInteger </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign an unsigned value to a bit range. </p>
<p>Zero extends or truncates <code>value</code> to the same width as <code>range</code> and copies it into the bit vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00957">957</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00400">clear()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01533">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01353">Sawyer::Container::BitVector::fromInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l01340">Sawyer::Container::BitVector::fromInteger()</a>.</p>

</div>
</div>
<a id="a2d55e93178e7cb1c96e9e379f93d9bcf" name="a2d55e93178e7cb1c96e9e379f93d9bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d55e93178e7cb1c96e9e379f93d9bcf">&#9670;&#160;</a></span>toInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::uint64_t Sawyer::Container::BitVectorSupport::toInteger </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a bit vector to an integer. </p>
<p>Converts the specified range to an unsigned 64-bit value and returns that value. Returns zero if the range is empty. If the range is wider than 64 bits then all of its high-order bits are ignored and only the lowest 64 bits are used. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l00983">983</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01233">Sawyer::Container::BitVector::toInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01224">Sawyer::Container::BitVector::toInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l01245">Sawyer::Container::BitVector::toSignedInteger()</a>.</p>

</div>
</div>
<a id="af421cd57cce86580f892cbe4f4579021" name="af421cd57cce86580f892cbe4f4579021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af421cd57cce86580f892cbe4f4579021">&#9670;&#160;</a></span>toInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::uint64_t Sawyer::Container::BitVectorSupport::toInteger </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a small bit vector to an integer. </p>
<p>Faster version of <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#a2d55e93178e7cb1c96e9e379f93d9bcf">toInteger</a> for instances where the range offset is zero and the size is not greater than 64 bits. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01004">1004</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="aa40f95c1c9254e3087db8427d8a96225" name="aa40f95c1c9254e3087db8427d8a96225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f95c1c9254e3087db8427d8a96225">&#9670;&#160;</a></span>toSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::int64_t Sawyer::Container::BitVectorSupport::toSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a bit vector to a signed integer. </p>
<p>Converts the specified range to a signed 64-bit value and returns it. If the size of the range is one then the return value is either zero or one; if the size of the range is less than or equal to 64 bits then the bits are sign-extended to 64 bits and returned; otherwise when the size of the range is larger than 64 bits the low-order 64 bits are returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01021">1021</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01256">Sawyer::Container::BitVector::toSignedInteger()</a>.</p>

</div>
</div>
<a id="a8c5ed5664d8ccf2cfa6d4fc33962cf20" name="a8c5ed5664d8ccf2cfa6d4fc33962cf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5ed5664d8ccf2cfa6d4fc33962cf20">&#9670;&#160;</a></span>toSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::int64_t Sawyer::Container::BitVectorSupport::toSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a small bit vector to a signed integer. </p>
<p>Faster version of <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html#aa40f95c1c9254e3087db8427d8a96225">toSignedInteger</a> for instances where the range offset is zero and the size is not greater than 64 bits. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01037">1037</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="aa85fceeb0bfbcea09685113c95dd49d7" name="aa85fceeb0bfbcea09685113c95dd49d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85fceeb0bfbcea09685113c95dd49d7">&#9670;&#160;</a></span>increment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::increment </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Increment.html">Increment</a>. </p>
<p>Interprets <code>range</code> of <code>vec1</code> as an integer and increments the value by one. The return value is the carry-out bit. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01067">1067</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00793">Sawyer::Container::BitVector::increment()</a>, <a class="el" href="BitVector_8h_source.html#l00784">Sawyer::Container::BitVector::increment()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01104">negate()</a>.</p>

</div>
</div>
<a id="a222fbcde16e4d71e886ac1094aac0d2e" name="a222fbcde16e4d71e886ac1094aac0d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222fbcde16e4d71e886ac1094aac0d2e">&#9670;&#160;</a></span>decrement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::decrement </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structSawyer_1_1Container_1_1BitVectorSupport_1_1Decrement.html">Decrement</a>. </p>
<p>Interprets <code>range</code> of <code>vec1</code> as an integer and decrements the value by one. Returns true if the original value was zero or empty. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01094">1094</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00811">Sawyer::Container::BitVector::decrement()</a>, and <a class="el" href="BitVector_8h_source.html#l00802">Sawyer::Container::BitVector::decrement()</a>.</p>

</div>
</div>
<a id="a168da62308ccdde364a4793eaa675f88" name="a168da62308ccdde364a4793eaa675f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168da62308ccdde364a4793eaa675f88">&#9670;&#160;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::negate </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate bits as an integer. </p>
<p>Interprets <code>range</code> of <code>vec1</code> as a two's complement integer and negates its value. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01104">1104</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01067">increment()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00889">invert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00774">Sawyer::Container::BitVector::negate()</a>, and <a class="el" href="BitVector_8h_source.html#l00764">Sawyer::Container::BitVector::negate()</a>.</p>

</div>
</div>
<a id="ab0f84b9c0638d1b4785b9a9884420375" name="ab0f84b9c0638d1b4785b9a9884420375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f84b9c0638d1b4785b9a9884420375">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::add </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>carryIn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add bits. </p>
<p>Treats two sub-vectors as unsigned values and add them together, storing the result in the second vector. Both ranges must be the same size, and the sub-vectors are permitted to overlap. The return value is the carry-out bit. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01135">1135</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00832">Sawyer::Container::BitVector::add()</a>, <a class="el" href="BitVector_8h_source.html#l00821">Sawyer::Container::BitVector::add()</a>, <a class="el" href="BitVector_8h_source.html#l00844">Sawyer::Container::BitVector::add()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01533">fromDecimal()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01187">multiply10()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01148">subtract()</a>.</p>

</div>
</div>
<a id="a2e59f3428ec7731a3200b95d54b3fa29" name="a2e59f3428ec7731a3200b95d54b3fa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e59f3428ec7731a3200b95d54b3fa29">&#9670;&#160;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::subtract </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract bits. </p>
<p>Treats two sub-vectors as unsigned values and subtracts <code>vec1</code> from <code>vec2</code> and stores the result in <code>vec2</code>. Both ranges must be the same size, and the sub-vectors are permitted to overlap. The return value is false only when an overflow occurs (i.e., vec2 is unsigned-greater-than vec1). If the vectors are interpreted as 2's complement signed integers then an overflow is indicated whan both operands ahve the same sign and the result has a different sign. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01148">1148</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">add()</a>, <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00889">invert()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00871">Sawyer::Container::BitVector::subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00857">Sawyer::Container::BitVector::subtract()</a>, and <a class="el" href="BitVector_8h_source.html#l00882">Sawyer::Container::BitVector::subtract()</a>.</p>

</div>
</div>
<a id="a21054f8a03caaa2db161bce295442c7e" name="a21054f8a03caaa2db161bce295442c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21054f8a03caaa2db161bce295442c7e">&#9670;&#160;</a></span>signExtend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::signExtend </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign extend. </p>
<p>Performs sign extension while copying bits from range1 to range2, which may overlap. If range1 is empty then range2 is cleared. If range2 is smaller than range1 then the not all bits are copied (high-order bits in range1 are omitted). If range1 is non-empty and range2 is empty then nothing is copied. The return value is the new high-order (sign) bit of range2, or false if range2 is empty. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01164">1164</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00400">clear()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00384">get()</a>, <a class="el" href="Interval_8h_source.html#l00224">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00426">setValue()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00904">Sawyer::Container::BitVector::signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00892">Sawyer::Container::BitVector::signExtend()</a>, and <a class="el" href="BitVector_8h_source.html#l00915">Sawyer::Container::BitVector::signExtend()</a>.</p>

</div>
</div>
<a id="a2e1a5421e50db760e7711d615688ca79" name="a2e1a5421e50db760e7711d615688ca79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a5421e50db760e7711d615688ca79">&#9670;&#160;</a></span>multiply10()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::multiply10 </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply by 10. </p>
<p>Treats the specified range of the vector as an unsigned integer and multiplies it by 10. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01187">1187</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">add()</a>, <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00793">shiftLeft()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01533">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l00924">Sawyer::Container::BitVector::multiply10()</a>, and <a class="el" href="BitVector_8h_source.html#l00933">Sawyer::Container::BitVector::multiply10()</a>.</p>

</div>
</div>
<a id="a0632cfc90ca23f6f55513456d477cc5a" name="a0632cfc90ca23f6f55513456d477cc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0632cfc90ca23f6f55513456d477cc5a">&#9670;&#160;</a></span>isEqualToZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVectorSupport::isEqualToZero </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares with zero. </p>
<p>Returns true if the vector is equal to zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01206">1206</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00652">isAllClear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVectorSupport_8h_source.html#l01237">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01134">Sawyer::Container::BitVector::isEqualToZero()</a>, and <a class="el" href="BitVector_8h_source.html#l01124">Sawyer::Container::BitVector::isEqualToZero()</a>.</p>

</div>
</div>
<a id="a2b849b9f8cb2af310d49c83c9ebaf1cc" name="a2b849b9f8cb2af310d49c83c9ebaf1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b849b9f8cb2af310d49c83c9ebaf1cc">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVectorSupport::compare </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned comparison. </p>
<p>Interprests two sub-vectors as unsigned integers and returns an integer whose sign indicates the relationship between those two integers. Returns negative if <code>vec1</code> is less than <code>vec2</code>; returns zero if <code>vec1</code> is equal to <code>vec2</code>; returns positive if <code>vec1</code> is greater than <code>vec2</code>. The ranges need not be the same size&ndash;the smaller of the two ranges will act as if it were zero padded on its most-significant side. Two empty vectors are interpreted as zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01237">1237</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">compare()</a>, <a class="el" href="Interval_8h_source.html#l00224">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01206">isEqualToZero()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01159">Sawyer::Container::BitVector::compare()</a>, <a class="el" href="BitVector_8h_source.html#l01146">Sawyer::Container::BitVector::compare()</a>, <a class="el" href="BitVector_8h_source.html#l01172">Sawyer::Container::BitVector::compare()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">compare()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>.</p>

</div>
</div>
<a id="aac31573c5ac632dde2e0bcba0bffbe5f" name="aac31573c5ac632dde2e0bcba0bffbe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac31573c5ac632dde2e0bcba0bffbe5f">&#9670;&#160;</a></span>compareSigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVectorSupport::compareSigned </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed comparison. </p>
<p>Interprests two sub-vectors as 2's complement signed integers and returns an integer whose sign indicates the relationship between those two integers. Returns negative if <code>vec1</code> is less than <code>vec2</code>; returns zero if <code>vec1</code> is equal to <code>vec2</code>; returns positive if <code>vec1</code> is greater than <code>vec2</code>. The ranges need not be the same size&ndash;the smaller of the two ranges will act as if it were sign-extended to the same size as the other. Empty vectors are interpreted as zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01272">1272</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">compare()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00384">get()</a>, <a class="el" href="Interval_8h_source.html#l00224">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00766">mostSignificantDifference()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00599">mostSignificantSetBit()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00675">nSet()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01199">Sawyer::Container::BitVector::compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01185">Sawyer::Container::BitVector::compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01212">Sawyer::Container::BitVector::compareSigned()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01272">compareSigned()</a>.</p>

</div>
</div>
<a id="ab789f91a7988ba2be7ebe96a4b2cd9fa" name="ab789f91a7988ba2be7ebe96a4b2cd9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab789f91a7988ba2be7ebe96a4b2cd9fa">&#9670;&#160;</a></span>toBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; Sawyer::Container::BitVectorSupport::toBytes </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01369">1369</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="ae276ef74e92702569d01247446e2709e" name="ae276ef74e92702569d01247446e2709e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae276ef74e92702569d01247446e2709e">&#9670;&#160;</a></span>fromBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromBytes </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01376">1376</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="aede0d28cdd8ab4e5c7b8b2fa53697def" name="aede0d28cdd8ab4e5c7b8b2fa53697def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede0d28cdd8ab4e5c7b8b2fa53697def">&#9670;&#160;</a></span>toHex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVectorSupport::toHex </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexadecimal representation. </p>
<p>Returns a string which is the hexadecimal representation of the bits in the specified range. No prefix or suffix is added (i.e., no leading "0x" or trailing "h"). The number of digits in the return value is the minimum required to explicitly represent the value, including leading zeros; an empty range will return an empty string. The returned string is lower case. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01445">1445</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01278">Sawyer::Container::BitVector::toHex()</a>, and <a class="el" href="BitVector_8h_source.html#l01268">Sawyer::Container::BitVector::toHex()</a>.</p>

</div>
</div>
<a id="abb0ed1c2909c326032de178c9886a0fd" name="abb0ed1c2909c326032de178c9886a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0ed1c2909c326032de178c9886a0fd">&#9670;&#160;</a></span>toOctal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVectorSupport::toOctal </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Octal representation. </p>
<p>Returns a string which is the octal representation of the bits in the specified range. No prefix or suffix is added (i.e., no leading "0" or trailing "o"). The number of digits in the return value is the minimum required to explicitly represent the value, including leading zeros. An empty range will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01457">1457</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01297">Sawyer::Container::BitVector::toOctal()</a>, and <a class="el" href="BitVector_8h_source.html#l01288">Sawyer::Container::BitVector::toOctal()</a>.</p>

</div>
</div>
<a id="a1c7ff72aee3332fac82f7164715ebfe3" name="a1c7ff72aee3332fac82f7164715ebfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ff72aee3332fac82f7164715ebfe3">&#9670;&#160;</a></span>toBinary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVectorSupport::toBinary </td>
          <td>(</td>
          <td class="paramtype">const Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary representation. </p>
<p>Returns a string which is the binary representation of the bits in the specified range. No prefix or suffix is added. The number of digits in the return value is the minimum required to explicitly represent the value, including leading zeros. An empty range will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01469">1469</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00214">traverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01316">Sawyer::Container::BitVector::toBinary()</a>, and <a class="el" href="BitVector_8h_source.html#l01307">Sawyer::Container::BitVector::toBinary()</a>.</p>

</div>
</div>
<a id="ac3f1eb8242f737cf52852cf7e9027f15" name="ac3f1eb8242f737cf52852cf7e9027f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f1eb8242f737cf52852cf7e9027f15">&#9670;&#160;</a></span>charToDigit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Word Sawyer::Container::BitVectorSupport::charToDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01480">1480</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a6050c1d79ad3103834b79913f4588217" name="a6050c1d79ad3103834b79913f4588217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6050c1d79ad3103834b79913f4588217">&#9670;&#160;</a></span>fromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word , size_t bitsPerDigit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromString </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01495">1495</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

</div>
</div>
<a id="a44dce682e900925e0043015663657450" name="a44dce682e900925e0043015663657450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dce682e900925e0043015663657450">&#9670;&#160;</a></span>fromDecimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromDecimal </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain bits from a decimal representation. </p>
<p>The <code>input</code> string must contain only valid decimal digits '0' through '9' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize the specified sub-vector, then extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire sub-vector then the high order bits of the sub-vector are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01533">1533</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">add()</a>, <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">copy()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00957">fromInteger()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01187">multiply10()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01367">Sawyer::Container::BitVector::fromDecimal()</a>, and <a class="el" href="BitVector_8h_source.html#l01381">Sawyer::Container::BitVector::fromDecimal()</a>.</p>

</div>
</div>
<a id="a972dd1f887812a17f7cd69047d5973fe" name="a972dd1f887812a17f7cd69047d5973fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972dd1f887812a17f7cd69047d5973fe">&#9670;&#160;</a></span>fromHex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromHex </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain bits from a hexadecimal representation. </p>
<p>The <code>input</code> string must contain only valid hexadecimal digits '0' through '9', 'a' through 'f', and 'A' through 'F', or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize the specified sub-vector, then extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire sub-vector then the high order bits of the sub-vector are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01575">1575</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01394">Sawyer::Container::BitVector::fromHex()</a>, and <a class="el" href="BitVector_8h_source.html#l01408">Sawyer::Container::BitVector::fromHex()</a>.</p>

</div>
</div>
<a id="a3d0f149ca9f098453f35753ccf5c72a3" name="a3d0f149ca9f098453f35753ccf5c72a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0f149ca9f098453f35753ccf5c72a3">&#9670;&#160;</a></span>fromOctal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromOctal </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain bits from an octal representation. </p>
<p>The <code>input</code> string must contain only valid octal digits '0' through '7' or the underscore (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize the specified sub-vector, then extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire sub-vector then the high order bits of the sub-vector are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01586">1586</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01421">Sawyer::Container::BitVector::fromOctal()</a>, and <a class="el" href="BitVector_8h_source.html#l01435">Sawyer::Container::BitVector::fromOctal()</a>.</p>

</div>
</div>
<a id="a38f69e010ddfab0959b4dd0a59b7d90d" name="a38f69e010ddfab0959b4dd0a59b7d90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f69e010ddfab0959b4dd0a59b7d90d">&#9670;&#160;</a></span>fromBinary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVectorSupport::fromBinary </td>
          <td>(</td>
          <td class="paramtype">Word *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain bits from a binary representation. </p>
<p>The <code>input</code> string must contain only valid binary digits '0' and '1' or the underscore (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize the specified sub-vector, then extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire sub-vector then the high order bits of the sub-vector are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVectorSupport_8h_source.html#l01597">1597</a> of file <a class="el" href="BitVectorSupport_8h_source.html">BitVectorSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l01448">Sawyer::Container::BitVector::fromBinary()</a>, and <a class="el" href="BitVector_8h_source.html#l01462">Sawyer::Container::BitVector::fromBinary()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
