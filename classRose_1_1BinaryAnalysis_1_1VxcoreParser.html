<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::VxcoreParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html">VxcoreParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1VxcoreParser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::VxcoreParser Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Parser for Vxcore format files. </p>
<p>The vxcore format is a format defined by ROSE itself for loading memory dumps from simple hardware devices. The format is intended to be as simple as possible so that it's easy to produce on the low-memory, low-powered device.</p>
<h1><a class="anchor" id="vxcore_v1"></a>
Version 1</h1>
<p>Version 1 of this file format consists of two kinds of records: memory and registers.</p>
<p>A memory record begins with header which is line of plain ASCII text terminated by a colon and line-feed. The line contains the starting address, the size in bytes, and the optional memory protection bits. These fields are separated from one another by horizontal white space. The address and size are hexadecimal values without a leading "0x". The optional protection bits are introduced with an equal sign "=" followed by zero or more of the upper-case letters "R" (read), "W" (write), "X" (execute) in any order. Within the protection bits, a hyphen "-" can be used as a placeholder if desired. The header's line-feed is immediately followed by the indicated number of bytes stored in binary format. The bytes are not terminated by any special sequence, but rather lead directly into the next header.</p>
<p>A register record (at most one per file) begins with the word "registers", a space, and the instruction set architecture name recognized by ROSE. Following the header is one line per register, each line being a register name recognized by ROSE, a colon, optional horizontal white space, and a hexadecimal value, this time with a leading "0x".</p>
<p>This format version was designed by Jim Leek.</p>
<p>@seciton vxcore_v2 Version 2</p>
<p>Version 2 of this format is a sequence of messages consisting of a binary header followed by a binary payload. Each header contains naturally aligned fields: a one byte version number having the value 2; two bytes not currently used for any purpose; one byte containing the memory access permission bits (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html">MemoryMap</a>); a four-byte little-endian payload size in bytes; an eight-byte little-endian starting memory address. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00047">47</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="BinaryVxcoreParser_8h_source.html">frontend/BinaryFormats/BinaryVxcoreParser.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::VxcoreParser:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1VxcoreParser__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1VxcoreParser_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1VxcoreParser_coll__map" id="aRose_1_1BinaryAnalysis_1_1VxcoreParser_coll__map">
<area shape="rect" title="Parser for Vxcore format files." alt="" coords="20,93,168,133"/>
<area shape="rect" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams." alt="" coords="5,5,183,31"/>
<area shape="poly" title=" " alt="" coords="97,45,97,93,91,93,91,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html" title="Exception thrown for parse errors.">Exception</a> thrown for parse errors.  <a href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> that control the parser and unparser.  <a href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a966d408b902199a303dfba951ed6efdd" id="r_a966d408b902199a303dfba951ed6efdd"><td class="memItemLeft" align="right" valign="top">boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a966d408b902199a303dfba951ed6efdd">parseUrl</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a966d408b902199a303dfba951ed6efdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a URL and adjust the settings.  <br /></td></tr>
<tr class="separator:a966d408b902199a303dfba951ed6efdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1f6dcd9904d92805feb832ff04ba49" id="r_a0c1f6dcd9904d92805feb832ff04ba49"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a0c1f6dcd9904d92805feb832ff04ba49">isaName</a> () const</td></tr>
<tr class="memdesc:a0c1f6dcd9904d92805feb832ff04ba49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed instruction set architecture name.  <br /></td></tr>
<tr class="separator:a0c1f6dcd9904d92805feb832ff04ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a11c5e4ffcd19d972dafa4481c243c07f" id="r_a11c5e4ffcd19d972dafa4481c243c07f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a11c5e4ffcd19d972dafa4481c243c07f">settings</a> () const</td></tr>
<tr class="memdesc:a11c5e4ffcd19d972dafa4481c243c07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing.  <br /></td></tr>
<tr class="separator:a11c5e4ffcd19d972dafa4481c243c07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f68e5560380683c568847abbb48b1c" id="r_a58f68e5560380683c568847abbb48b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a58f68e5560380683c568847abbb48b1c">settings</a> ()</td></tr>
<tr class="memdesc:a58f68e5560380683c568847abbb48b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing.  <br /></td></tr>
<tr class="separator:a58f68e5560380683c568847abbb48b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fb9cf8c6ccb1918dbe6bb21129b6" id="r_a3950fb9cf8c6ccb1918dbe6bb21129b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a3950fb9cf8c6ccb1918dbe6bb21129b6">settings</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp;s)</td></tr>
<tr class="memdesc:a3950fb9cf8c6ccb1918dbe6bb21129b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing.  <br /></td></tr>
<tr class="separator:a3950fb9cf8c6ccb1918dbe6bb21129b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a515a8b21d8e4e1de3423cfc63f4d1358" id="r_a515a8b21d8e4e1de3423cfc63f4d1358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a515a8b21d8e4e1de3423cfc63f4d1358">parse</a> (const boost::filesystem::path &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a515a8b21d8e4e1de3423cfc63f4d1358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse input file.  <br /></td></tr>
<tr class="separator:a515a8b21d8e4e1de3423cfc63f4d1358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c1ba3472797edda82ebc46a18f415b" id="r_aa2c1ba3472797edda82ebc46a18f415b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#aa2c1ba3472797edda82ebc46a18f415b">parse</a> (const boost::filesystem::path &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;registers, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops)</td></tr>
<tr class="memdesc:aa2c1ba3472797edda82ebc46a18f415b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse input file.  <br /></td></tr>
<tr class="separator:aa2c1ba3472797edda82ebc46a18f415b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775849651f703dd686a9cf5718dc828a" id="r_a775849651f703dd686a9cf5718dc828a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a775849651f703dd686a9cf5718dc828a">parse</a> (const boost::filesystem::path &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;registers, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops)</td></tr>
<tr class="memdesc:a775849651f703dd686a9cf5718dc828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse input file.  <br /></td></tr>
<tr class="separator:a775849651f703dd686a9cf5718dc828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8388ebf7c9775b16fe6038c9c61170" id="r_a4b8388ebf7c9775b16fe6038c9c61170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a4b8388ebf7c9775b16fe6038c9c61170">parse</a> (std::istream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;registers, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;ops, const std::string &amp;inputName=&quot;input&quot;)</td></tr>
<tr class="memdesc:a4b8388ebf7c9775b16fe6038c9c61170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse input file.  <br /></td></tr>
<tr class="separator:a4b8388ebf7c9775b16fe6038c9c61170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c6da2f0d743afc643782073b7db29ad" id="r_a4c6da2f0d743afc643782073b7db29ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a4c6da2f0d743afc643782073b7db29ad">unparse</a> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;memoryLimit, const std::string &amp;outputName=&quot;output&quot;)</td></tr>
<tr class="memdesc:a4c6da2f0d743afc643782073b7db29ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse memory and/or registers to this format.  <br /></td></tr>
<tr class="separator:a4c6da2f0d743afc643782073b7db29ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d007c3bc530301abbbf5322e22b0f" id="r_a5a6d007c3bc530301abbbf5322e22b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a5a6d007c3bc530301abbbf5322e22b0f">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;, const std::string &amp;outputName=&quot;output&quot;)</td></tr>
<tr class="memdesc:a5a6d007c3bc530301abbbf5322e22b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse memory and/or registers to this format.  <br /></td></tr>
<tr class="separator:a5a6d007c3bc530301abbbf5322e22b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c936fa0d78a29b0952e21d92338f1d1" id="r_a8c936fa0d78a29b0952e21d92338f1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a8c936fa0d78a29b0952e21d92338f1d1">unparse</a> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;memoryLimit, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;, const std::string &amp;outputName=&quot;output&quot;)</td></tr>
<tr class="memdesc:a8c936fa0d78a29b0952e21d92338f1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse memory and/or registers to this format.  <br /></td></tr>
<tr class="separator:a8c936fa0d78a29b0952e21d92338f1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a95162fe1ed5bee55c2d7aea4575bc0f4" id="r_a95162fe1ed5bee55c2d7aea4575bc0f4"><td class="memItemLeft" align="right" valign="top"><a id="a95162fe1ed5bee55c2d7aea4575bc0f4" name="a95162fe1ed5bee55c2d7aea4575bc0f4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>initDiagnostics</b> ()</td></tr>
<tr class="separator:a95162fe1ed5bee55c2d7aea4575bc0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3c33dba1985c752c508893b53bf189c1" id="r_a3c33dba1985c752c508893b53bf189c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a3c33dba1985c752c508893b53bf189c1">mlog</a></td></tr>
<tr class="memdesc:a3c33dba1985c752c508893b53bf189c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic facility for vxcore file format.  <br /></td></tr>
<tr class="separator:a3c33dba1985c752c508893b53bf189c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11c5e4ffcd19d972dafa4481c243c07f" name="a11c5e4ffcd19d972dafa4481c243c07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c5e4ffcd19d972dafa4481c243c07f">&#9670;&#160;</a></span>settings() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::VxcoreParser::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00112">112</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>

</div>
</div>
<a id="a58f68e5560380683c568847abbb48b1c" name="a58f68e5560380683c568847abbb48b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f68e5560380683c568847abbb48b1c">&#9670;&#160;</a></span>settings() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::VxcoreParser::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00113">113</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>

</div>
</div>
<a id="a3950fb9cf8c6ccb1918dbe6bb21129b6" name="a3950fb9cf8c6ccb1918dbe6bb21129b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3950fb9cf8c6ccb1918dbe6bb21129b6">&#9670;&#160;</a></span>settings() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::settings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Settings.html" title="Settings that control the parser and unparser.">Settings</a> for parsing and unparsing. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00114">114</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>

</div>
</div>
<a id="a966d408b902199a303dfba951ed6efdd" name="a966d408b902199a303dfba951ed6efdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966d408b902199a303dfba951ed6efdd">&#9670;&#160;</a></span>parseUrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::filesystem::path Rose::BinaryAnalysis::VxcoreParser::parseUrl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a URL and adjust the settings. </p>
<p>Parses the specified URL which should not include the leading "vxcore:", adjusts this object's <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser.html#a11c5e4ffcd19d972dafa4481c243c07f">settings</a>, and returns the file name part of the URL. Throws an <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a> for any parsing errors.</p>
<p>Note that this function doesn't actually parse the file, only the URL that contains the file name. </p>

</div>
</div>
<a id="a515a8b21d8e4e1de3423cfc63f4d1358" name="a515a8b21d8e4e1de3423cfc63f4d1358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515a8b21d8e4e1de3423cfc63f4d1358">&#9670;&#160;</a></span>parse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::parse </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse input file. </p>
<p>The specified file is opened and parsed and the results used to initialize memory and/or registers. If a non-null memory map is passed as an argument, then then file data is copied into the map. If a non-null register state is provided (along with a required RiscOperators object for extraction and concatenation), then registers are set to values contained in the file.</p>
<p>Parse errors throw an <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a>. </p>

</div>
</div>
<a id="aa2c1ba3472797edda82ebc46a18f415b" name="aa2c1ba3472797edda82ebc46a18f415b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c1ba3472797edda82ebc46a18f415b">&#9670;&#160;</a></span>parse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::parse </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>registers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse input file. </p>
<p>The specified file is opened and parsed and the results used to initialize memory and/or registers. If a non-null memory map is passed as an argument, then then file data is copied into the map. If a non-null register state is provided (along with a required RiscOperators object for extraction and concatenation), then registers are set to values contained in the file.</p>
<p>Parse errors throw an <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a>. </p>

</div>
</div>
<a id="a775849651f703dd686a9cf5718dc828a" name="a775849651f703dd686a9cf5718dc828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775849651f703dd686a9cf5718dc828a">&#9670;&#160;</a></span>parse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::parse </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>registers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse input file. </p>
<p>The specified file is opened and parsed and the results used to initialize memory and/or registers. If a non-null memory map is passed as an argument, then then file data is copied into the map. If a non-null register state is provided (along with a required RiscOperators object for extraction and concatenation), then registers are set to values contained in the file.</p>
<p>Parse errors throw an <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a>. </p>

</div>
</div>
<a id="a4b8388ebf7c9775b16fe6038c9c61170" name="a4b8388ebf7c9775b16fe6038c9c61170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8388ebf7c9775b16fe6038c9c61170">&#9670;&#160;</a></span>parse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::parse </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>registers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputName</em> = <code>&quot;input&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse input file. </p>
<p>The specified file is opened and parsed and the results used to initialize memory and/or registers. If a non-null memory map is passed as an argument, then then file data is copied into the map. If a non-null register state is provided (along with a required RiscOperators object for extraction and concatenation), then registers are set to values contained in the file.</p>
<p>Parse errors throw an <a class="el" href="classRose_1_1BinaryAnalysis_1_1VxcoreParser_1_1Exception.html">Exception</a>. </p>

</div>
</div>
<a id="a4c6da2f0d743afc643782073b7db29ad" name="a4c6da2f0d743afc643782073b7db29ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6da2f0d743afc643782073b7db29ad">&#9670;&#160;</a></span>unparse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>memoryLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputName</em> = <code>&quot;output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse memory and/or registers to this format. </p>
<p>If a non-null memory map is supplied, then the memory that's contained within the specified <code>memoryLimit</code> address range is output (pass <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b" title="Construct an interval that covers the entire domain.">AddressInterval::whole()</a></code> to emit all mapped memory).</p>
<p>If a non-null register state is specified, then output values for all the registers contained in that state, skipping registers that don't have a concrete value. In this case, a RiscOperators object must also be supplied in order to concat and/or extract register parts.</p>
<p>The optional <code>outputName</code> is used to identify the output stream in error messages and exceptions. </p>

</div>
</div>
<a id="a5a6d007c3bc530301abbbf5322e22b0f" name="a5a6d007c3bc530301abbbf5322e22b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d007c3bc530301abbbf5322e22b0f">&#9670;&#160;</a></span>unparse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputName</em> = <code>&quot;output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse memory and/or registers to this format. </p>
<p>If a non-null memory map is supplied, then the memory that's contained within the specified <code>memoryLimit</code> address range is output (pass <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b" title="Construct an interval that covers the entire domain.">AddressInterval::whole()</a></code> to emit all mapped memory).</p>
<p>If a non-null register state is specified, then output values for all the registers contained in that state, skipping registers that don't have a concrete value. In this case, a RiscOperators object must also be supplied in order to concat and/or extract register parts.</p>
<p>The optional <code>outputName</code> is used to identify the output stream in error messages and exceptions. </p>

</div>
</div>
<a id="a8c936fa0d78a29b0952e21d92338f1d1" name="a8c936fa0d78a29b0952e21d92338f1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c936fa0d78a29b0952e21d92338f1d1">&#9670;&#160;</a></span>unparse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::VxcoreParser::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>memoryLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#af9979602b39d09fa0afc9b6727142cf9">InstructionSemantics::BaseSemantics::RegisterStatePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputName</em> = <code>&quot;output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse memory and/or registers to this format. </p>
<p>If a non-null memory map is supplied, then the memory that's contained within the specified <code>memoryLimit</code> address range is output (pass <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b" title="Construct an interval that covers the entire domain.">AddressInterval::whole()</a></code> to emit all mapped memory).</p>
<p>If a non-null register state is specified, then output values for all the registers contained in that state, skipping registers that don't have a concrete value. In this case, a RiscOperators object must also be supplied in order to concat and/or extract register parts.</p>
<p>The optional <code>outputName</code> is used to identify the output stream in error messages and exceptions. </p>

</div>
</div>
<a id="a0c1f6dcd9904d92805feb832ff04ba49" name="a0c1f6dcd9904d92805feb832ff04ba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1f6dcd9904d92805feb832ff04ba49">&#9670;&#160;</a></span>isaName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::VxcoreParser::isaName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parsed instruction set architecture name. </p>
<p>Latest encountered instruction set architecture name parsed from the input. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00171">171</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3c33dba1985c752c508893b53bf189c1" name="a3c33dba1985c752c508893b53bf189c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c33dba1985c752c508893b53bf189c1">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Rose::BinaryAnalysis::VxcoreParser::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagnostic facility for vxcore file format. </p>

<p class="definition">Definition at line <a class="el" href="BinaryVxcoreParser_8h_source.html#l00105">105</a> of file <a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BinaryVxcoreParser_8h_source.html">BinaryVxcoreParser.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
