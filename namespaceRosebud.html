<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rosebud Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rosebud Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> is a tool to generate abstract syntax trees. </p>
<p>The <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> tool (<code>rosebud</code> command) reads class definitions for abstract syntax tree (AST) vertex types and generates C++ source code.</p>
<p>The <b>definition language</b> is C++-like, enabling any C++ programmer to author or modify AST vertex classes. The C++-like language means the input is natively understood by integrated development environments (IDEs) and code editors. <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> aims to make common class definitions easy, and more complex definitions possible. The language supports Doxygen-style comments, delayed-decision conditional compilation, independent AST class hierarchies, abstract classes with pure virtual member functions, read-only properties, and more.</p>
<p>The <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> tool uses <b>modern translation techniques</b> such as referential lexical tokens and partial parsing. <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> can process the 400 "SgAsm" AST definitions and generate code in a fraction of a second. Its diagnostic messages (warnings and errors) follow the LLVM style, are readable by almost all IDEs, include the input source line and position indicators, and are colorized. <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a>'s AST for its intermediate representation is self hosted and fully documented.</p>
<p>Depending on which backend is chosen, the generated code uses <b>modern C++ features</b> such as reference counted pointers for clearly documented vertex ownership and safe, automatic deletion; exception safe adjustment to the tree edges (vertex connectivity); immediate tree consistency checks with violations reported by exceptions; and automatic, read-only parent pointers. Generated definitions make heavy use of automatically-generated forward declarations to achieve efficient compilation (although this is currently heavily counteracted by the policy that all ROSE source code includes the huge "sage3basic.h" or "rose.h" header files).</p>
<h1><a class="anchor" id="rosebud_language"></a>
Input Language</h1>
<p>The input language is a subset of the C preprocessor and C++. As such, the input easily understood by experienced C++ programmers and can be operated on in almost any integrated development environment or code editor.</p>
<p>The various code-generation backends have slightly different rules for what they support. The documentation below indicates which backends support which input language features when support is not universal. The "yaml" backend supports everything since it simply emits the AST as a YAML document.</p>
<h2><a class="anchor" id="rosebud_language_file"></a>
Input files</h2>
<p>Each AST vertex class definition appears in its own header file. The header file name reflects the name of the class, and the directory path [reflects the namespace containing the class (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [is chosen based on the set of <code>rosebud</code> command-line options that are needed (ROSETTA)]. These files are typically named with a ".h" extension so that IDEs and code editors can recognize them as C++ without any special configuration. For instance, the [Rose::Sarif::Log class is defined in "src/AstNodes/Rose/Sarif/Log.h"] [<code><a class="el" href="classSgAsmGenericSection.html" title="Contiguous region of a file.">SgAsmGenericSection</a></code> class is defined in "src/AstNodes/BinaryAnalysis" (ROSETTA)].</p>
<ul>
<li><b>Include-once:</b> The header file should not include any C preprocessor compile-once mechanism, since this will be generated automatically.</li>
</ul>
<ul>
<li><b>Feature tests:</b> [The "featureTests.h" file is automatically included into generated code and the feature test macro is specified on the <code>rosebud</code> command-line. (ROSETTA)] [If a class is to be conditionally compiled, then all necessary preprocessor directivies must be specified. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)]</li>
</ul>
<ul>
<li><b>Definition headers:</b> Any headers needed by the class definition should be included. These preprocessor directives will be copied verbatim to the generated header file. One should strive to include as few headers as possible, and as few definitions as possible. Most of the time all that's needed are forward declarations.</li>
</ul>
<ul>
<li><b>Implementation headers:</b> Any headers needed by the implementation of automatically generated member functions must be included. The inclusion of these headers [should be surrounded by an <code>#ifdef ROSE_IMPL</code> (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [is copied verbatim to the generated header (ROSETTA)].</li>
</ul>
<ul>
<li><b>Conditional compilation:</b> Any conditional compilation directives for the class as a whole must be entirely outside the class definition and there cannot be more than one class definition when the directives are ignored. This is because <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> parses the class definition as if the preprocessor directives were not present.</li>
</ul>
<ul>
<li><b>Namespaces:</b> [If the class should be defined within a namespace then the namespace must be specified using named C++ <code>namespace</code> specifiers around the class definition and the choice of directory path should mirror the namespace hierarchy. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [All class definitions are assumed to exist within the root namespace. (ROSETTA)]</li>
</ul>
<ul>
<li><b>Post-definition code:</b> Any code appearing after the class definition is [ignored (ROSETTA)] [copied verbatim (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>) to the generated header file. [ROSETTA doesn't have any mechanism to copy class post-definition text to the generated file, so any conditional compilation directives that started before the class will have automatically generated code to close them, which may or may not match the closing directives in the input. (ROSETTA)]</li>
</ul>
<h2><a class="anchor" id="rosebud_language_class"></a>
Class definition</h2>
<p>A <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> class definition is similar to a C++ class definition. The class is introduced by a Doxygen double-asterisk C-style comment, followed by an optional list of C++ attributes (some of which are special <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attributes), followed by the word "class", the class name, an optional base class list, an opening curly brace, member specifications, a closing curly brace, and the terminating semi-colon.</p>
<p>The following <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> class attributes are understood:</p>
<ul>
<li>The <code>Rosebud::abstract</code> attribute indicates that the class cannot be instantiated. This is useful for base classes where one wants to be able to only instantiate its derived classes. [The ROSETTA backend only partially honors this: the last argument of <code>NEW_NONTERMINAL_MACRO</code> is set to false, but the generated class can still be instantiated. In fact, adding a pure virtual function to the class to force it to never be instantiated causes compilation errors in generated code. (ROSETTA)]</li>
</ul>
<ul>
<li>The <code>Rosebud::no_constructors</code> attribute prevents the backend from generating certain kinds of constructors. This is useful when the user wants to define his own constructors. [Although the usual C++ constructors are generated, no <code>instance</code> allocating constructors are generated. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)]</li>
</ul>
<ul>
<li>The <code>Rosebud::no_destructor</code> attribute [prevents the generation of a destructor so the user can define his own destructor (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [is ignored and a destructor is always generated (ROSETTA)].</li>
</ul>
<ul>
<li>The <code>Rosebud::small_header</code> attribute [is ignored since all headers are small (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [causes ROSETTA to generate a header file that contains only this single class definition (ROSETTA)].</li>
</ul>
<ul>
<li>The <code>Rosebud::suppress</code> attribute prevents the backend from generating any code at all for this class. This is useful when <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> needs to know the class definition in order to generate code for subclasses, but should not generate the base class.</li>
</ul>
<ul>
<li>[The <code>Rosebud::tag</code> attribute takes a single argument which is a symbol to use as the ROSETTA-generated type tag when it needs to be different than the automatically generated tag. The auto-generated take is the type name without the leading "Sg" and with a "Tag" suffix. For instance, the tag for the class <code><a class="el" href="classSgAsmInstruction.html" title="Base class for machine instructions.">SgAsmInstruction</a></code> would default to <code>AsmInstructionTag</code>. (ROSETTA)]</li>
</ul>
<h2><a class="anchor" id="rosebud_language_properties"></a>
Property members</h2>
<p>A property is a ROSE IR feature where a value is stored in an object and is accessed and modified with special generated functions. The <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> syntax for a property looks like a C++ data member. It consists of the Doxygen documentation comment, the list of C++ attributes one or more of which must be a <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attribute, the data member type, the data member name, the optional initialization constexpr, and the terminating semicolon.</p>
<ul>
<li>Properties should be named using nouns or noun phrases; they should not be verbs or verb phrases since little to no computation occurs when accessing or changing their values. The ROSE policy is that these names be camelCase and <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> can be configured to emit warnings when this policy is violated.</li>
</ul>
<ul>
<li>The Doxygen documentation should be immediately prior to the property declaration described above.</li>
</ul>
<ul>
<li>Access specifiers (<code>public</code>, <code>protected</code>, or <code>private</code>), if present, must appear before the Doxygen comment. [They are ignored. (ROSETTA)] [They influence the generated accessors and mutators, but not the generated data member. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)]. In the generated code, the property is always stored in a [private (ROSETTA)] [hidden (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] data member.</li>
</ul>
<ul>
<li>Conditional compilation, if present, must surround the entire property definition and its Doxygen comment. If the conditional compilation directives are ignored, then there must still be only one declaration per property. This is because <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> parses the class definition as if the preprocessor directives were absent. [Conditional compilation of properties is not supported because there is no mechanism to pass this information through ROSETTA. (ROSETTA)]</li>
</ul>
<p>The only thing that sets a property apart from a normal data member is the presence of at least one <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attribute. The following <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attributes are understood:</p>
<ul>
<li>The <code>Rosebud::property</code> attribute marks what would otherwise appear to be a data member declaration as a property declaration. Since the presence of any <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attribute is sufficient, the "property" attribute is only necessary when no other <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> attribute is specified.</li>
</ul>
<ul>
<li>The <code>Rosebud::data</code> attribute takes exactly one argument which is a symbol naming the data member that will be declared to store the property value. [This attribute has no user-visible effect since all property data members are hidden anyway. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)]</li>
</ul>
<ul>
<li>The <code>Rosebud::accessors</code> attribute, which requires an argument list even if it's empty, specifies the symbols to use as the accessor member function names. The default accessor name is [the same as the property name (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [formed by prepending "get_" to the property name, resulting in an unusual combination of snake- and camel-case (ROSETTA)]. If the attribute argument list is empty, then no accessor functions are generated, [making for a rather useless attribute since there's no other way to access it. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [but the attribute can still be accessed directly through its data member name (ROSETTA)].</li>
</ul>
<ul>
<li>The <code>Rosebud::mutators</code> attribute, which requires an argument list even if it's empty, specifies the symbols to use as the mutator member function names. The default accessor name is [the same as the property name (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [formed by prepending "set_" to the property name, resulting in an unusual combination of snake- and camel-case (ROSETTA)]. If the attribute argument list is empty, then no mutator functions are generated, but the property might still be modifiable through a non-const accessor (see <code>Rosebud::large</code>).</li>
</ul>
<ul>
<li>The <code>Rosebud::ctor_arg</code> means that the property's value will be passed to a generated constructor. <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> generates a C++ constructor that takes arguments (possibly empty) for all the <code>ctor_arg</code> properties in the current class and all base classes. [If the user doesn't want this constructor, use the class <code>Rosebud::no_constructor</code> attribute. (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [<a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> also generates a default constructor and a constructor that takes arguments only for the <code>ctor_args</code> properties for the current class (no base classes) and the unspecified properties are initialized to their default values (ROSETTA)]. Additional constructors can be defined by the user in the typical C++ manner.</li>
</ul>
<ul>
<li>The <code>Rosebud::cloneptr</code> attribute [causes the <code>copy</code> member function to allocate a new instance of the pointed object using the compile-time type of that object and its copy constructor] [is not supported (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)]. This is intended to be a temporary attribute since it can easily be done directly in C++ in many ways.</li>
</ul>
<ul>
<li>The <code>Rosebud::serialize</code> attribute, which requires an argument list even if it's empty, specifies the base name for alternate serialization and deserialization functions. If the argument list is empty, then the property is not serialized or deserialized. Otherwise serialization and deserialization function names are created by appending the strings "Serialize" and "Deserialize". The user must define these functions so that the serialization function takes the property as an argument and returns a new value that should be serialized by the default method, while the deserialization function takes an argument that is the same type returned by the serialize function and returns a value to be assigned to the property. If this attribute isn't specified, then the property is serialzied and deserialized directly.</li>
</ul>
<ul>
<li>The <code>Rosebud::large</code> attribute indicates that the property value is large and expensive to copy. Therefore, in addition to any other mutators, the accessors will be overloaded to return a non-const reference to the property's data member. Use this sparingly because it will not be compatible with all planned <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> backends (e.g., it is not possible to generate property observers or thread safe code if the property value can be modified directly through a reference.</li>
</ul>
<ul>
<li>The <code>Rosebud::not_null</code> attribute [indicates that the property value cannot be a null pointer and any attempt to assign a null pointer will result in an exception being thrown (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)] [is ignored (ROSETTA)].</li>
</ul>
<ul>
<li>The <code>Rosebud::rosetta</code> attribute [indicates that the property should be generated in a manner compatible with ROSETTA-generated properties (ROSETTA)] [is ignored (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)].</li>
</ul>
<ul>
<li>The <code>Rosebud::traverse</code> attribute [indicates that a property is a pointer to another AST vertex and that the edge formed by the pointer is part of a tree data structure, i.e., the pointee's parent pointer is assumed to point back to the object that points to that pointee (ROSETTA)] [is ignored except it produces an error diagnostic if the property's type is not <code><a class="el" href="structEdge.html">Edge</a>&lt;T&gt;</code> or <code>EdgeVector&lt;T&gt;</code> (<a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a>)].</li>
</ul>
<h1><a class="anchor" id="rosebud_backends"></a>
Backend Generators</h1>
<p>The <code>rosebud</code> tool parses the definitions from the input files (described above) to create an intermediate representation (AST) and then one or more "backends" traverse the AST to emit C++ source code or other information. The three main backends are:</p>
<ul>
<li><code>--backend=yaml</code> produces a structured YAML document describing the intermediate representation. This output can be easily parsed by other stand-alone translators. For instance, a translator to generate the alphabetical list of class names is a single line shell script using the free <code>yq</code> tool.</li>
</ul>
<ul>
<li><code>--backend=rosetta</code> produces input for the ROSETTA translator. Although ROSETTA has a number of problems (detailed below), it is also not feasible to entirely replace it in one fell swoop. Therefore, our plan is to use this backend to incrementally rewrite the ROSETTA definitions as <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> definitions, and have <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> produce the ROSETTA input. To this end, all the binary analysis AST vertex types (about 400 in total) have been converted. It is proving challenging to translate other ROSETTA classes due to their heavy use of ROSETTA macros instead of C++ language features, and the impedance mismatch in how ROSETTA and C++ define class hierarchies (bottom up versus top down).</li>
</ul>
<ul>
<li><code>--backend=sawyer</code> produces C++ source code that uses the more modern <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree</a> API and is an experimental backend that provides reference counted AST vertices using smart pointers; automatic, read-only parent pointers and immediate tree consistency checks; multiple, independent AST class hierarchies; traversals that can use lambda functions; exception safety; hidden data members; complete documentation; and unit tests. Eventually we hope to support more exotic features like signals and slots, thread safety, and user-defined class invariants. This backend is used by the <a class="el" href="namespaceRose_1_1Sarif.html">Rose::Sarif</a> API and <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> itself.</li>
</ul>
<h2><a class="anchor" id="rosebud_backend_rosetta"></a>
Features of the ROSETTA backend</h2>
<p>The ROSETTA backend does not use a special type to indicate that a pointer data member is also an edge in the tree. Instead, the data member is marked with the <code>Rosebud::traverse</code> attribute, like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SgParent: <span class="keyword">public</span> <a class="code hl_class" href="classSgNode.html">SgNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// This property is an edge in the tree</span></div>
<div class="line">    [[<span class="keyword">using </span><a class="code hl_namespace" href="namespaceRosebud.html">Rosebud</a>: rosetta, traverse]]</div>
<div class="line">    SgChild *child = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This property is not a tree edge.</span></div>
<div class="line">    [[Rosebud::rosetta]]</div>
<div class="line">    SgChild *other = <span class="keyword">nullptr</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSgNode_html"><div class="ttname"><a href="classSgNode.html">SgNode</a></div><div class="ttdoc">This class represents the base class for all IR nodes within Sage III.</div><div class="ttdef"><b>Definition</b> <a href="Cxx__Grammar_8h_source.html#l00119">Cxx_Grammar.h:120</a></div></div>
<div class="ttc" id="anamespaceRosebud_html"><div class="ttname"><a href="namespaceRosebud.html">Rosebud</a></div><div class="ttdoc">Rosebud is a tool to generate abstract syntax trees.</div><div class="ttdef"><b>Definition</b> <a href="Ast_8h_source.html#l00014">Ast.h:14</a></div></div>
</div><!-- fragment --><p>The accessor and mutator functions are, by default, named by prepending "get_" and "set_". However, much code in ROSE accesses the property data members directly by prepending "p_". This is a bad practice since it bypasses any other actions (such as invariant checking, mutex aquisition, signaling, etc) that might also need to occur when a property is modified.</p>
<div class="fragment"><div class="line">parent-&gt;p_other = node;  <span class="comment">// don&#39;t do this</span></div>
<div class="line">parent-&gt;set_other(node); <span class="comment">// do this instead</span></div>
</div><!-- fragment --><p>Each vertex class has an automatically generated <code>parent</code> pointer that must be manually adjusted so the child points back to the parent, like this:</p>
<div class="fragment"><div class="line">parent-&gt;set_child(child);</div>
<div class="line"><span class="keywordflow">if</span> (child)</div>
<div class="line">    child-&gt;set_parent(parent);</div>
</div><!-- fragment --><p>Detaching a node is similarly difficult:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> child = parent-&gt;get_child()) {</div>
<div class="line">    parent-&gt;set_child(<span class="keyword">nullptr</span>);</div>
<div class="line">    child-&gt;set_parent(<span class="keyword">nullptr</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Failing to set the child's parent pointer correctly is a detectable runtime error, but the check is delayed until the user remembers to call the appropriate whole-tree checking function at a later tmie. Similarly for other programming errors such as creating a cycle or having multiple vertices pointing to the same child&ndash;checks are delayed until some point at which the user remembers to check the tree consistency.</p>
<p>A ROSETTA-generated type should not have edges that point to individual children intermixed with vectors that point to many children. In order to do that reliably one must create an intermediate type to hold the vector:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SgArgumentList: <span class="keyword">public</span> <a class="code hl_class" href="classSgNode.html">SgNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    [[Rosebud::traverse]]</div>
<div class="line">    std::vector&lt;SgArgument*&gt; arguments;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SgFunctionCall: <span class="keyword">public</span> <a class="code hl_class" href="classSgNode.html">SgNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    [[Rosebud::traverse]]</div>
<div class="line">    <a class="code hl_class" href="classSgName.html">SgName</a> *name;</div>
<div class="line"> </div>
<div class="line">    [[Rosebud::traverse]]</div>
<div class="line">    SgArgumentList *arguments = <span class="keyword">nullptr</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SgFunctionCall* makeBinaryCall(<a class="code hl_class" href="classSgName.html">SgName</a> *name, SgArgument *arg1, SgArgument *arg2) {</div>
<div class="line">    <span class="keyword">auto</span> call = <span class="keyword">new</span> SgFunctionCall;</div>
<div class="line">    call-&gt;set_name(name);</div>
<div class="line">    <span class="keywordflow">if</span> (name)</div>
<div class="line">        name-&gt;set_parent(call);</div>
<div class="line">    <span class="keyword">auto</span> argList = <span class="keyword">new</span> SgArgumentList;</div>
<div class="line">    call-&gt;set_arguments(argList);</div>
<div class="line">    argList-&gt;set_parent(call);</div>
<div class="line">    argList-&gt;get_arguments().push_back(arg1);</div>
<div class="line">    <span class="keywordflow">if</span> (arg1)</div>
<div class="line">        arg1-&gt;set_parent(argList);</div>
<div class="line">    argList-&gt;get_arguments().push_back(arg2);</div>
<div class="line">    <span class="keywordflow">if</span> (arg2)</div>
<div class="line">        arg2-&gt;set_parent(argList);</div>
<div class="line">    <span class="keywordflow">return</span> call;</div>
<div class="line">}</div>
<div class="ttc" id="aclassSgName_html"><div class="ttname"><a href="classSgName.html">SgName</a></div><div class="ttdoc">This class represents strings within the IR nodes.</div><div class="ttdef"><b>Definition</b> <a href="Cxx__Grammar_8h_source.html#l20721">Cxx_Grammar.h:20722</a></div></div>
</div><!-- fragment --><p>Since ROSETTA uses raw pointers, it is up to the user to know when an object is no longer part of any tree and no longer pointed to by anything else in ROSE. Sometimes an analysis will cache its results, and thus have pointers into the AST. The best practice with ROSETTA-generated code is to never free any AST vertex.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> child = parent-&gt;get_child()) {</div>
<div class="line">    parent-&gt;set_child(<span class="keyword">nullptr</span>);</div>
<div class="line">    child-&gt;set_parent(<span class="keyword">nullptr</span>);</div>
<div class="line">    <a class="code hl_function" href="namespaceSageInterface.html#a57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a>(child); <span class="comment">// UNSAFE -- never do this!</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceSageInterface_html_a57437bbbb806858dda0cea7444fbafef"><div class="ttname"><a href="namespaceSageInterface.html#a57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a></div><div class="ttdeci">ROSE_DLL_API void deleteAST(SgNode *node)</div><div class="ttdoc">Function to delete AST subtree's nodes only, users must take care of any dangling pointers,...</div><div class="ttdef"><b>Definition</b> <a href="sageInterface_8C_source.html#l20291">sageInterface.C:20291</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="rosebud_backend_sawyer"></a>
Features of the Sawyer backend</h2>
<p>The <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> backend generates AST vertex classes that inherit from <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>, and it uses smart pointers. The smart pointer types have the names <code>Ptr</code> and <code>ConstPtr</code> both as members of the vertex class and by appending those names to the name of the class. The latter are useful in places like header files where one doesn't want the compiler to spend time parsing the class definition and only incomplete types are needed. Unlike the ROSETTA backend, the smart pointer data members do not need to be explicitly initialized to nullptr (their constructors take care of that). An AST edge is indicated with the type <code><a class="el" href="structEdge.html">Edge</a></code>, like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SgParent: <span class="keyword">public</span> <a class="code hl_class" href="classSgNode.html">SgNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// This property is an edge in the tree</span></div>
<div class="line">    [[Rosebud::property]]</div>
<div class="line">    <a class="code hl_struct" href="structEdge.html">Edge&lt;SgChild&gt;</a> child;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This property is not a tree edge</span></div>
<div class="line">    [[Rosebud::property]]</div>
<div class="line">    SgChildPtr other;</div>
<div class="ttc" id="astructEdge_html"><div class="ttname"><a href="structEdge.html">Edge</a></div><div class="ttdef"><b>Definition</b> <a href="SgGraphTemplate_8h_source.html#l00012">SgGraphTemplate.h:12</a></div></div>
</div><!-- fragment --><p>The accessor and mutator functions are, by default, named the same thing as the property. The data members for the properties are effectively hidden by being given names that include a random string. Therefore the bad practice of setting the data member directly is no longer possible&ndash;all property modifications must go through the generated mutators.</p>
<div class="fragment"><div class="line">parent-&gt;p_other = node;      <span class="comment">// compile-time error</span></div>
<div class="line">parent-&gt;other(node);         <span class="comment">// do this instead</span></div>
<div class="line">parent-&gt;forceSetOther(node); <span class="comment">// or do this in the defining class if there are no public mutators</span></div>
</div><!-- fragment --><p>Each vertex class has an automatically generated <code>parent</code> pointer. Unlike ROSETTA, this pointer does not need to be adjusted explicitly, and trying to do so is a compile-time error.</p>
<div class="fragment"><div class="line">parent-&gt;child(child); <span class="comment">// now child-&gt;parent() == parent</span></div>
</div><!-- fragment --><p>Detaching a node is similarly easy:</p>
<div class="fragment"><div class="line">parent-&gt;child(<span class="keyword">nullptr</span>); <span class="comment">// previous child (if any) now has a null parent pointer</span></div>
</div><!-- fragment --><p>Failing to set the parent correctly is not possible like it is with the ROSETTA backend. Also, the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> backend immediately checks that the tree is not malformed in these ways, which are all exception safe:</p>
<ul>
<li>If the vertex being assigned as a child already has a parent, then an exception is thrown.</li>
</ul>
<ul>
<li>If the vertex is being assigned as its own child, then an exception is thrown.</li>
</ul>
<ul>
<li>If the vertex being assigned as a child is also the root of the parent's tree, then an exception is thrown. Because of its nontrivial cost, this check is enabled only when ROSE is configured for debugging (when the C preprocessor <code>NDEBUG</code> symbol is undefined).</li>
</ul>
<p>The <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> backend supports mixing scalar and vector edge types within a single AST vertex class. Unlike the ROSETTA backend, there is no need to define an intermediate class to hold the vector.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SgFunctionCall: <span class="keyword">public</span> <a class="code hl_class" href="classSgNode.html">SgNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    [[Rosebud::property]]</div>
<div class="line">    <a class="code hl_struct" href="structEdge.html">Edge&lt;SgName&gt;</a> name;</div>
<div class="line"> </div>
<div class="line">    [[Rosebud::property]]</div>
<div class="line">    EdgeVector&lt;SgArgument&gt; arguments;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SgFunctionCall* makeBinaryCall(<span class="keyword">const</span> SgName::Ptr &amp;name, <span class="keyword">const</span> SgArgument::Ptr &amp;arg1, <span class="keyword">const</span> SgArgument::Ptr &amp;arg2) {</div>
<div class="line">    <span class="keyword">auto</span> call = SgFunctionCall::instance();</div>
<div class="line">    call-&gt;name(name);                      <span class="comment">// name-&gt;parent() == call</span></div>
<div class="line">    call-&gt;arguments().push_back(arg1);     <span class="comment">// arg1-&gt;parent() == call</span></div>
<div class="line">    call-&gt;arguments().push_back(arg2);     <span class="comment">// arg2-&gt;parent() == call</span></div>
<div class="line">    <span class="keywordflow">return</span> call;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> uses reference counting pointers, objects that are no longer part of a tree and which are no longer pointed to by anything else in the program are automatically and immediately deleted. The user should not evern explicitly delete AST vertices. However, the user must be careful not to introduce self-referential data structures since cycles will prevent the objects from being deleted even if there are no other pointers to the data structure. This backend does not yet support weak pointers.</p>
<div class="fragment"><div class="line">parent-&gt;child(<span class="keyword">nullptr</span>); <span class="comment">// previous child is deleted if no other references</span></div>
</div><!-- fragment --><h1><a class="anchor" id="rosebud_building"></a>
Building and running Rosebud</h1>
<p><a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> is distributed as part of the ROSE library source code under the same license. It is built and installed automatically as part of building and installing the ROSE library.</p>
<p>The ROSE library has a number of AST class hierarchies that are generated by <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a>. Some of these are also passed through the ROSETTA <code>CxxGrammarMetaProgram</code> tool using <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a>'s <code>--backend=rosetta</code> switch, and others are translated to C++ directly using <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a>'s <code>--backend=sawyer</code> switch. Other switches are also necessary in certain situations. The <code>generate</code> script makes sure the correct <code>rosebud</code> commands are run to produce all generated files. The generated files are currently checked into the ROSE library source repository for improved stability while <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> is being developed.</p>
<p>To regenerate files, go to the "src/Rosebud" directory in the build tree and build the <code>rosebud</code> executable by running your preferred build system. Then generate files by running this command from that same directory, replacing "$ROSE_SOURCE" with the top-level directory of the ROSE library repository:</p>
<div class="fragment"><div class="line">$ $ROSE_SOURCE/src/<a class="code hl_namespace" href="namespaceRosebud.html">Rosebud</a>/generate ./rosebud</div>
</div><!-- fragment --><p>You may need to add the <code>--source=$ROSE_SOURCE</code> switch before "./rosebud" if the script cannot determine the locaton of the ROSE source directory.</p>
<p>The following directories are used:</p>
<ul>
<li>$ROSE_SOURCE/src/Rosebud contains the source code for the <code>rosebud</code> command, its backends, and this documentation.</li>
</ul>
<ul>
<li>$ROSE_SOURCE/src/AstNodes contains the input files for the <code>rosebud</code> command. These files are organized into directories according to either the namespace (for the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> backend) or "Sg" prefix (for the ROSETTA backend).</li>
</ul>
<ul>
<li>$ROSE_SOURCE/src/generated contains the files generated by <code>rosebud</code>. The ROSETTA backend also modifies the <code>CxxGrammarMetaProgram</code> source code in the $ROSE_SOURCE/src/ROSETTA/src directory, and thus ROSETTA needs to be recompiled and re-run after any changes are made to <a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> inputs.</li>
</ul>
<h1><a class="anchor" id="rosebud_vs_rosetta"></a>
Comparison with ROSETTA</h1>
<p>ROSETTA is/was the previous AST vertex class definition mechanism and is still used for most parts of the main AST. It has served well for many years, but its main drawbacks are:</p>
<ul>
<li>A complicated, undocumented input language (sequence of API calls) that makes a class definition look nothing like a C++ class and splits parts of a definition into many parts stored in different files (class name list, ROSETTA API calls, documentation files, member declarations, member implementations, and member special types). As a result, few members of the ROSE team are comfortable making non-trivial modifications to the AST types. Furthermore, since ROSETTA defines a class hierarchy from bottom up, it's extremely difficult to incrementally replace ROSETTA with a more modern system that follows C++'s top-down order.</li>
</ul>
<ul>
<li>A cumbersome, slow method of generating code that takes many seconds. It produces C++ headers and source files measuring in the hundreds of thousands of lines and contributing multiplicatively to the lengthy ROSE library build times even though efforts have been made to improve the situation. Editing these files with IDEs and viewing them in debuggers can be agonizingly slow. The generated code uses unconventonal indentation without much thought to human readability, and the presence of ROSETTA macros has resulted in a high degree of duplication in the generated code. Diagnostics from the ROSETTA generator (the <code>CxxGrammarMetaProgram</code> command) seldom indicate the location of the problem, are often sent to standard output instead of standard error, and are typically ungracefully handled by a call <code>assert(0)</code>, an infinite loop, or a segmentation fault. The generated accessors, mutators, and data members are named with unconventional combination of snake- and camel-case.</li>
</ul>
<ul>
<li>A convoluted mechanism for documentation that requires the documentation to be in a separate file from the class definition and to be repeated three times (once per data member, accessor, and mutator) with each copy different only in the name of the cross reference to the entity being documented. It's not surprising that most AST classes and their member functions are undocumented.</li>
</ul>
<ul>
<li>Inability to support often used and much desired C++ mechanisms in generated code, such as abstract classes with pure virtual member functions, clear vertex ownership, safe subtree deletion, consistent parent/child pointers, traversals with lambdas, and avoidance of dynamic down-casting. </li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRosebud_1_1Ast" id="r_namespaceRosebud_1_1Ast"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud_1_1Ast.html">Ast</a></td></tr>
<tr class="memdesc:namespaceRosebud_1_1Ast"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract syntax tree. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1BoostSerializer.html">BoostSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class serializer using Boost Serialization.  <a href="classRosebud_1_1BoostSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1CerealSerializer.html">CerealSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class serializer producing JSON.  <a href="classRosebud_1_1CerealSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1CxxGenerator.html">CxxGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for generators that produce C++ code.  <a href="classRosebud_1_1CxxGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1Generator.html">Generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for backend code generators.  <a href="classRosebud_1_1Generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRosebud_1_1HierarchyKey.html">HierarchyKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key for ordering classes in the class hierarchy.  <a href="structRosebud_1_1HierarchyKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1NoneGenerator.html">NoneGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRosebud_1_1Generator.html" title="Base class for backend code generators.">Generator</a> that produces a YAML description of the input.  <a href="classRosebud_1_1NoneGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1NoneSerializer.html">NoneSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class serializer using None Serialization.  <a href="classRosebud_1_1NoneSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1RosettaGenerator.html">RosettaGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRosebud_1_1Generator.html" title="Base class for backend code generators.">Generator</a> that produces ROSETTA output.  <a href="classRosebud_1_1RosettaGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1SawyerGenerator.html">SawyerGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRosebud_1_1Generator.html" title="Base class for backend code generators.">Generator</a> that produces <a class="el" href="namespaceSawyer_1_1Tree.html" title="Tree data structure.">Sawyer::Tree</a> class hierarchies.  <a href="classRosebud_1_1SawyerGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for serialization generators.  <a href="classRosebud_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRosebud_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line settings for the rosebud tool.  <a href="structRosebud_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRosebud_1_1YamlGenerator.html">YamlGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRosebud_1_1Generator.html" title="Base class for backend code generators.">Generator</a> that produces a YAML description of the input.  <a href="classRosebud_1_1YamlGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af5fc4624140c6c98f251e155167099b7" id="r_af5fc4624140c6c98f251e155167099b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> = <a class="el" href="classSawyer_1_1Language_1_1Clexer_1_1Token.html">Sawyer::Language::Clexer::Token</a></td></tr>
<tr class="memdesc:af5fc4624140c6c98f251e155167099b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token parsed from the input file.  <br /></td></tr>
<tr class="separator:af5fc4624140c6c98f251e155167099b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc193a4c4bdd59a294aea2bef445635" id="r_a0fc193a4c4bdd59a294aea2bef445635"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a0fc193a4c4bdd59a294aea2bef445635">TokenStream</a> = <a class="el" href="classSawyer_1_1Language_1_1Clexer_1_1TokenStream.html">Sawyer::Language::Clexer::TokenStream</a></td></tr>
<tr class="memdesc:a0fc193a4c4bdd59a294aea2bef445635"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream of tokens from the input file.  <br /></td></tr>
<tr class="separator:a0fc193a4c4bdd59a294aea2bef445635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a34c72cf277eee3672aad5d3e5c985" id="r_a82a34c72cf277eee3672aad5d3e5c985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a82a34c72cf277eee3672aad5d3e5c985">GeneratorPtr</a> = std::shared_ptr&lt; <a class="el" href="classRosebud_1_1Generator.html">Generator</a> &gt;</td></tr>
<tr class="memdesc:a82a34c72cf277eee3672aad5d3e5c985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to a <a class="el" href="classRosebud_1_1Generator.html">Generator</a>.  <br /></td></tr>
<tr class="separator:a82a34c72cf277eee3672aad5d3e5c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59922f983d21f5761c1c81254af1d59" id="r_ac59922f983d21f5761c1c81254af1d59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ac59922f983d21f5761c1c81254af1d59">SerializerPtr</a> = std::shared_ptr&lt; <a class="el" href="classRosebud_1_1Serializer.html">Serializer</a> &gt;</td></tr>
<tr class="memdesc:ac59922f983d21f5761c1c81254af1d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer to a <a class="el" href="classRosebud_1_1Serializer.html">Serializer</a>.  <br /></td></tr>
<tr class="separator:ac59922f983d21f5761c1c81254af1d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca3c745f7fe5d33201e7869bdf5c3f" id="r_aaaca3c745f7fe5d33201e7869bdf5c3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> = <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a>, <a class="el" href="classSawyer_1_1Nothing.html">Sawyer::Nothing</a>, <a class="el" href="structRosebud_1_1HierarchyKey.html">HierarchyKey</a> &gt;</td></tr>
<tr class="memdesc:aaaca3c745f7fe5d33201e7869bdf5c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class hierarchy.  <br /></td></tr>
<tr class="separator:aaaca3c745f7fe5d33201e7869bdf5c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08de533e19e267055dfde82f9f6da4fa" id="r_a08de533e19e267055dfde82f9f6da4fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a> = std::vector&lt; <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a> &gt;</td></tr>
<tr class="memdesc:a08de533e19e267055dfde82f9f6da4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered sequence of classes.  <br /></td></tr>
<tr class="separator:a08de533e19e267055dfde82f9f6da4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8413fc818b380a010f6f1587a66d8360" id="r_a8413fc818b380a010f6f1587a66d8360"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360">Expand</a> { <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360abeaf3f30067cbde80b264c6bdabfcb29">INTER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360ae4bf0e3d9afa4b59492d1f1a22fb6a37">PRIOR</a>
<br />
 }</td></tr>
<tr class="memdesc:a8413fc818b380a010f6f1587a66d8360"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to obtain text when converting a sequence of tokens to a string.  <a href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360">More...</a><br /></td></tr>
<tr class="separator:a8413fc818b380a010f6f1587a66d8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7704c979755e94c4be2b15875691fb68" id="r_a7704c979755e94c4be2b15875691fb68"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68">When</a> { <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68a443475558f0168dff92ecde26b98ae5a">NEVER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68af3fc827ade4b968e50406496907ef962">ALWAYS</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68ae1f2d5134ed2543d38a0de9751cf75d9">AUTO</a>
<br />
 }</td></tr>
<tr class="memdesc:a7704c979755e94c4be2b15875691fb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">When something should be done.  <a href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68">More...</a><br /></td></tr>
<tr class="separator:a7704c979755e94c4be2b15875691fb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4adf6c23be03e9ba20c5a89fb4fef" id="r_a51a4adf6c23be03e9ba20c5a89fb4fef"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fef">Access</a> { <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fefa84c6d22cfdf3772e66b07bde636e0571">PRIVATE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fefa0c2448254108d59f7400d1c96f31d751">PROTECTED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fefacd0c6092d6a6874f379fe4827ed1db8b">PUBLIC</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fefa5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>
<br />
 }</td></tr>
<tr class="memdesc:a51a4adf6c23be03e9ba20c5a89fb4fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of access.  <a href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fef">More...</a><br /></td></tr>
<tr class="separator:a51a4adf6c23be03e9ba20c5a89fb4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d9db14824442b83b6c99619aecfdc" id="r_a4c0d9db14824442b83b6c99619aecfdc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdc">CamelCase</a> { <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdcaa7c48ba367e019d004bfb0239b85f2b3">LOWER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdca9e43f5291e6fcb2ad99c8e3f91acd179">UPPER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdca46335765005ff44b1fe1e38e5d2ddfcc">UNCHANGED</a>
<br />
 }</td></tr>
<tr class="memdesc:a4c0d9db14824442b83b6c99619aecfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">What to do with the first letter of the return value.  <a href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdc">More...</a><br /></td></tr>
<tr class="separator:a4c0d9db14824442b83b6c99619aecfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a019565867c1143b94fa047548e3c80d8" id="r_a019565867c1143b94fa047548e3c80d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a019565867c1143b94fa047548e3c80d8">splitIntoLines</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a019565867c1143b94fa047548e3c80d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a multi-line string into one string per line.  <br /></td></tr>
<tr class="separator:a019565867c1143b94fa047548e3c80d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530bb577a92642a34c6781db793f5123" id="r_a530bb577a92642a34c6781db793f5123"><td class="memItemLeft" align="right" valign="top"><a id="a530bb577a92642a34c6781db793f5123" name="a530bb577a92642a34c6781db793f5123"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eraseBlankLines</b> (std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:a530bb577a92642a34c6781db793f5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove lines that are empty or contain only white space. <br /></td></tr>
<tr class="separator:a530bb577a92642a34c6781db793f5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39dc467b3c1bacb8997a757b0f97ace" id="r_ac39dc467b3c1bacb8997a757b0f97ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ac39dc467b3c1bacb8997a757b0f97ace">trimBlankLines</a> (std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:ac39dc467b3c1bacb8997a757b0f97ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim leading, trailing, and internal blank lines and trailing white space.  <br /></td></tr>
<tr class="separator:ac39dc467b3c1bacb8997a757b0f97ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372912ea39111aa66d3490273ef2baac" id="r_a372912ea39111aa66d3490273ef2baac"><td class="memItemLeft" align="right" valign="top"><a id="a372912ea39111aa66d3490273ef2baac" name="a372912ea39111aa66d3490273ef2baac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>editDistance</b> (const std::string &amp;src, const std::string &amp;tgt)</td></tr>
<tr class="memdesc:a372912ea39111aa66d3490273ef2baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Damerau-Levenshtein edit distance between two strings. <br /></td></tr>
<tr class="separator:a372912ea39111aa66d3490273ef2baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab001e12f1d92a08fea5b8067de06a1de" id="r_ab001e12f1d92a08fea5b8067de06a1de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ab001e12f1d92a08fea5b8067de06a1de">relativeDifference</a> (const std::string &amp;src, const std::string &amp;tgt)</td></tr>
<tr class="memdesc:ab001e12f1d92a08fea5b8067de06a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative difference between two strings.  <br /></td></tr>
<tr class="separator:ab001e12f1d92a08fea5b8067de06a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b328e1a3e441e46c693f7f741f568" id="r_ab56b328e1a3e441e46c693f7f741f568"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ab56b328e1a3e441e46c693f7f741f568">bestMatch</a> (const std::vector&lt; std::string &gt; &amp;candidates, const std::string &amp;sample)</td></tr>
<tr class="memdesc:ab56b328e1a3e441e46c693f7f741f568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best match.  <br /></td></tr>
<tr class="separator:ab56b328e1a3e441e46c693f7f741f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd69848fb77cac4ab5397e56a3804b3" id="r_a8bd69848fb77cac4ab5397e56a3804b3"><td class="memItemLeft" align="right" valign="top"><a id="a8bd69848fb77cac4ab5397e56a3804b3" name="a8bd69848fb77cac4ab5397e56a3804b3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fef">Access</a>)</td></tr>
<tr class="memdesc:a8bd69848fb77cac4ab5397e56a3804b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an access enum to a C++ string. <br /></td></tr>
<tr class="separator:a8bd69848fb77cac4ab5397e56a3804b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33414b6bdc7628e4a868a8be4507de42" id="r_a33414b6bdc7628e4a868a8be4507de42"><td class="memItemLeft" align="right" valign="top"><a id="a33414b6bdc7628e4a868a8be4507de42" name="a33414b6bdc7628e4a868a8be4507de42"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>camelCase</b> (const std::string &amp;, <a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdc">CamelCase</a>=<a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdcaa7c48ba367e019d004bfb0239b85f2b3">CamelCase::LOWER</a>)</td></tr>
<tr class="memdesc:a33414b6bdc7628e4a868a8be4507de42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert snake case to camelCase. <br /></td></tr>
<tr class="separator:a33414b6bdc7628e4a868a8be4507de42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e9262a0cdbac806c5de644f30939e8" id="r_aa1e9262a0cdbac806c5de644f30939e8"><td class="memItemLeft" align="right" valign="top"><a id="aa1e9262a0cdbac806c5de644f30939e8" name="aa1e9262a0cdbac806c5de644f30939e8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pascalCase</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:aa1e9262a0cdbac806c5de644f30939e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a symbol to PascalCase. <br /></td></tr>
<tr class="separator:aa1e9262a0cdbac806c5de644f30939e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13574fc6e6ff59e522dc41220fcc60e9" id="r_a13574fc6e6ff59e522dc41220fcc60e9"><td class="memItemLeft" align="right" valign="top"><a id="a13574fc6e6ff59e522dc41220fcc60e9" name="a13574fc6e6ff59e522dc41220fcc60e9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>bourneEscape</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a13574fc6e6ff59e522dc41220fcc60e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quote string to make it shell safe. <br /></td></tr>
<tr class="separator:a13574fc6e6ff59e522dc41220fcc60e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba82b89032d54c97bbf034741f3acf" id="r_a40ba82b89032d54c97bbf034741f3acf"><td class="memItemLeft" align="right" valign="top"><a id="a40ba82b89032d54c97bbf034741f3acf" name="a40ba82b89032d54c97bbf034741f3acf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>withLeadSpace</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a40ba82b89032d54c97bbf034741f3acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">String with one leading space. <br /></td></tr>
<tr class="separator:a40ba82b89032d54c97bbf034741f3acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d5e540724bfdcba52cca93e71bba9b" id="r_ae1d5e540724bfdcba52cca93e71bba9b"><td class="memItemLeft" align="right" valign="top"><a id="ae1d5e540724bfdcba52cca93e71bba9b" name="ae1d5e540724bfdcba52cca93e71bba9b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>accessSpecifier</b> (<a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fef">Access</a>)</td></tr>
<tr class="memdesc:ae1d5e540724bfdcba52cca93e71bba9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an access specifier with colon and trailing linefeed. <br /></td></tr>
<tr class="separator:ae1d5e540724bfdcba52cca93e71bba9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24af9e8277d8b0b1a46c92a7b17751e" id="r_ad24af9e8277d8b0b1a46c92a7b17751e"><td class="memItemLeft" align="right" valign="top">boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ad24af9e8277d8b0b1a46c92a7b17751e">findRoseRootDir</a> (const boost::filesystem::path &amp;)</td></tr>
<tr class="memdesc:ad24af9e8277d8b0b1a46c92a7b17751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the root of the ROSE source tree.  <br /></td></tr>
<tr class="separator:ad24af9e8277d8b0b1a46c92a7b17751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e46ddb0b0c347e401f7adccd50906ad" id="r_a9e46ddb0b0c347e401f7adccd50906ad"><td class="memItemLeft" align="right" valign="top">boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a9e46ddb0b0c347e401f7adccd50906ad">relativeToRoseSource</a> (const boost::filesystem::path &amp;)</td></tr>
<tr class="memdesc:a9e46ddb0b0c347e401f7adccd50906ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a file path to a ROSE-relative path.  <br /></td></tr>
<tr class="separator:a9e46ddb0b0c347e401f7adccd50906ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa290860752b23858d8d5ebe71fb8b" id="r_ad2fa290860752b23858d8d5ebe71fb8b"><td class="memItemLeft" align="right" valign="top">boost::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ad2fa290860752b23858d8d5ebe71fb8b">toPath</a> (const std::string &amp;symbol, const std::string &amp;extension)</td></tr>
<tr class="memdesc:ad2fa290860752b23858d8d5ebe71fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a qualified C++ name to a relative path.  <br /></td></tr>
<tr class="separator:ad2fa290860752b23858d8d5ebe71fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6968adfa3eef45730a0766e9dd4f0" id="r_a73d6968adfa3eef45730a0766e9dd4f0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a73d6968adfa3eef45730a0766e9dd4f0">appendToDoxygen</a> (const std::string &amp;existingComment, const std::string &amp;newText)</td></tr>
<tr class="memdesc:a73d6968adfa3eef45730a0766e9dd4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append text to a Doxygen comment.  <br /></td></tr>
<tr class="separator:a73d6968adfa3eef45730a0766e9dd4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab918c14df93c769b14ae1f63d355e1b0" id="r_ab918c14df93c769b14ae1f63d355e1b0"><td class="memItemLeft" align="right" valign="top"><a id="ab918c14df93c769b14ae1f63d355e1b0" name="ab918c14df93c769b14ae1f63d355e1b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usingColor</b> ()</td></tr>
<tr class="memdesc:ab918c14df93c769b14ae1f63d355e1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we're using color output for diagnostics. <br /></td></tr>
<tr class="separator:ab918c14df93c769b14ae1f63d355e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e3a97b127ae20c2ae8629d5a64967" id="r_adb7e3a97b127ae20c2ae8629d5a64967"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#adb7e3a97b127ae20c2ae8629d5a64967">messageString</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:adb7e3a97b127ae20c2ae8629d5a64967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an importance level and message to an error output string.  <br /></td></tr>
<tr class="separator:adb7e3a97b127ae20c2ae8629d5a64967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e28ec6f290b36bc25e667eef1349c" id="r_a047e28ec6f290b36bc25e667eef1349c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a047e28ec6f290b36bc25e667eef1349c">classHierarchy</a> (const <a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a> &amp;)</td></tr>
<tr class="memdesc:a047e28ec6f290b36bc25e667eef1349c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the class hierarchy from the specified class definitions.  <br /></td></tr>
<tr class="separator:a047e28ec6f290b36bc25e667eef1349c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c795fd0613edd6157de331e7a7d1e" id="r_a6b5c795fd0613edd6157de331e7a7d1e"><td class="memItemLeft" align="right" valign="top"><a id="a6b5c795fd0613edd6157de331e7a7d1e" name="a6b5c795fd0613edd6157de331e7a7d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkClassHierarchy</b> (<a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:a6b5c795fd0613edd6157de331e7a7d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for problems such as cycles in the class hiearchy and report them as errors. <br /></td></tr>
<tr class="separator:a6b5c795fd0613edd6157de331e7a7d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad009c399cf5ee28ef9110d35a98f3d7a" id="r_ad009c399cf5ee28ef9110d35a98f3d7a"><td class="memItemLeft" align="right" valign="top"><a id="ad009c399cf5ee28ef9110d35a98f3d7a" name="ad009c399cf5ee28ef9110d35a98f3d7a"></a>
<a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>topDown</b> (<a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:ad009c399cf5ee28ef9110d35a98f3d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the class definitions so that base classes are before derived classes. <br /></td></tr>
<tr class="separator:ad009c399cf5ee28ef9110d35a98f3d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2a768a87d36854ffb45953b07b8ec" id="r_a32f2a768a87d36854ffb45953b07b8ec"><td class="memItemLeft" align="right" valign="top"><a id="a32f2a768a87d36854ffb45953b07b8ec" name="a32f2a768a87d36854ffb45953b07b8ec"></a>
<a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bottomUp</b> (<a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:a32f2a768a87d36854ffb45953b07b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the class definitions so that derived classes appear before base classes. <br /></td></tr>
<tr class="separator:a32f2a768a87d36854ffb45953b07b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eb7abdccb4ad8d051dd12f85a31dbe" id="r_ad0eb7abdccb4ad8d051dd12f85a31dbe"><td class="memItemLeft" align="right" valign="top"><a id="ad0eb7abdccb4ad8d051dd12f85a31dbe" name="ad0eb7abdccb4ad8d051dd12f85a31dbe"></a>
<a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>derivedClasses</b> (const <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:ad0eb7abdccb4ad8d051dd12f85a31dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all known subclasses. <br /></td></tr>
<tr class="separator:ad0eb7abdccb4ad8d051dd12f85a31dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46676b725ccefc778afd662005a014d9" id="r_a46676b725ccefc778afd662005a014d9"><td class="memItemLeft" align="right" valign="top"><a id="a46676b725ccefc778afd662005a014d9" name="a46676b725ccefc778afd662005a014d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBaseClass</b> (const <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:a46676b725ccefc778afd662005a014d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the class is a base class of some other class. <br /></td></tr>
<tr class="separator:a46676b725ccefc778afd662005a014d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0bf608d6f20aa8fbf2a6025616e1e" id="r_aa7e0bf608d6f20aa8fbf2a6025616e1e"><td class="memItemLeft" align="right" valign="top"><a id="aa7e0bf608d6f20aa8fbf2a6025616e1e" name="aa7e0bf608d6f20aa8fbf2a6025616e1e"></a>
std::vector&lt; <a class="el" href="namespaceRosebud_1_1Ast.html#a232ed0fcb99b4d53dd7bdf9660df0e51">Ast::PropertyPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>allConstructorArguments</b> (const <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> &amp;)</td></tr>
<tr class="memdesc:aa7e0bf608d6f20aa8fbf2a6025616e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties that form constructor arguments. <br /></td></tr>
<tr class="separator:aa7e0bf608d6f20aa8fbf2a6025616e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f00c6f18d8e3bfa9f6a6dc57d042d8" id="r_a30f00c6f18d8e3bfa9f6a6dc57d042d8"><td class="memItemLeft" align="right" valign="top"><a id="a30f00c6f18d8e3bfa9f6a6dc57d042d8" name="a30f00c6f18d8e3bfa9f6a6dc57d042d8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>firstPublicBaseClass</b> (const <a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a> &amp;)</td></tr>
<tr class="memdesc:a30f00c6f18d8e3bfa9f6a6dc57d042d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of first public base class. <br /></td></tr>
<tr class="separator:a30f00c6f18d8e3bfa9f6a6dc57d042d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7945a3fce3146e3a48e6bd1afb2765e" id="r_ad7945a3fce3146e3a48e6bd1afb2765e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ad7945a3fce3146e3a48e6bd1afb2765e">constRef</a> (const std::string &amp;type)</td></tr>
<tr class="memdesc:ad7945a3fce3146e3a48e6bd1afb2765e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a type into a const reference to the type.  <br /></td></tr>
<tr class="separator:ad7945a3fce3146e3a48e6bd1afb2765e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c88871d9c57d6533301b323fa0dff" id="r_a890c88871d9c57d6533301b323fa0dff"><td class="memItemLeft" align="right" valign="top"><a id="a890c88871d9c57d6533301b323fa0dff" name="a890c88871d9c57d6533301b323fa0dff"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>removeVolatileMutable</b> (const std::string &amp;type)</td></tr>
<tr class="memdesc:a890c88871d9c57d6533301b323fa0dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rmove "volatile" and "mutable" from the beginning of a type string. <br /></td></tr>
<tr class="separator:a890c88871d9c57d6533301b323fa0dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a9083ac943783bdd86d06ec672cd88" id="r_ae9a9083ac943783bdd86d06ec672cd88"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ae9a9083ac943783bdd86d06ec672cd88">toCppSymbol</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae9a9083ac943783bdd86d06ec672cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a C++ qualified name to a CPP symbol.  <br /></td></tr>
<tr class="separator:ae9a9083ac943783bdd86d06ec672cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae57445c44b29f9ce95dc244c3546c9" id="r_a9ae57445c44b29f9ce95dc244c3546c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a9ae57445c44b29f9ce95dc244c3546c9">extractCpp</a> (std::string &amp;, const std::regex &amp;, size_t capture)</td></tr>
<tr class="memdesc:a9ae57445c44b29f9ce95dc244c3546c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract all matching C preprocessor directives from the text.  <br /></td></tr>
<tr class="separator:a9ae57445c44b29f9ce95dc244c3546c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a71a702c02c98138d1575bcab1f18d09d" id="r_a71a702c02c98138d1575bcab1f18d09d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a71a702c02c98138d1575bcab1f18d09d">matching</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a71a702c02c98138d1575bcab1f18d09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matching opening or closing construct.  <br /></td></tr>
<tr class="separator:a71a702c02c98138d1575bcab1f18d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac792b122dc96413d5a04ca1bcf9742b9" id="r_ac792b122dc96413d5a04ca1bcf9742b9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ac792b122dc96413d5a04ca1bcf9742b9">matching</a> (char)</td></tr>
<tr class="memdesc:ac792b122dc96413d5a04ca1bcf9742b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matching opening or closing construct.  <br /></td></tr>
<tr class="separator:ac792b122dc96413d5a04ca1bcf9742b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae78d9cbeceb82cdd8ee63017d191fdf3" id="r_ae78d9cbeceb82cdd8ee63017d191fdf3"><td class="memItemLeft" align="right" valign="top"><a id="ae78d9cbeceb82cdd8ee63017d191fdf3" name="ae78d9cbeceb82cdd8ee63017d191fdf3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>prefixLines</b> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ae78d9cbeceb82cdd8ee63017d191fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a prefix to every line. <br /></td></tr>
<tr class="separator:ae78d9cbeceb82cdd8ee63017d191fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9c7a80c8a481714b8195268fbb0bc2" id="r_afe9c7a80c8a481714b8195268fbb0bc2"><td class="memItemLeft" align="right" valign="top"><a id="afe9c7a80c8a481714b8195268fbb0bc2" name="afe9c7a80c8a481714b8195268fbb0bc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prefixLines</b> (std::vector&lt; std::string &gt; &amp;lines, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:afe9c7a80c8a481714b8195268fbb0bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a prefix to every line. <br /></td></tr>
<tr class="separator:afe9c7a80c8a481714b8195268fbb0bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d94a03253523cfe34e06b96f904a444" id="r_a3d94a03253523cfe34e06b96f904a444"><td class="memItemLeft" align="right" valign="top"><a id="a3d94a03253523cfe34e06b96f904a444" name="a3d94a03253523cfe34e06b96f904a444"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>cEscape</b> (char ch, char context='\'')</td></tr>
<tr class="memdesc:a3d94a03253523cfe34e06b96f904a444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape as if in C single or double quotes. <br /></td></tr>
<tr class="separator:a3d94a03253523cfe34e06b96f904a444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab872ed265881b413bb70cad2ab45b9a3" id="r_ab872ed265881b413bb70cad2ab45b9a3"><td class="memItemLeft" align="right" valign="top"><a id="ab872ed265881b413bb70cad2ab45b9a3" name="ab872ed265881b413bb70cad2ab45b9a3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>cEscape</b> (const std::string &amp;, char context='&quot;')</td></tr>
<tr class="memdesc:ab872ed265881b413bb70cad2ab45b9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape as if in C single or double quotes. <br /></td></tr>
<tr class="separator:ab872ed265881b413bb70cad2ab45b9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff114f296247ccfd9963be57654380cb" id="r_aff114f296247ccfd9963be57654380cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#aff114f296247ccfd9963be57654380cb">makeBlockComment</a> (const std::string &amp;text, const std::string &amp;opening)</td></tr>
<tr class="memdesc:aff114f296247ccfd9963be57654380cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a block comment.  <br /></td></tr>
<tr class="separator:aff114f296247ccfd9963be57654380cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36465eba46cf5c89358f7c1b1d52517d" id="r_a36465eba46cf5c89358f7c1b1d52517d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a36465eba46cf5c89358f7c1b1d52517d">makeBlockComment</a> (const std::vector&lt; std::string &gt; &amp;textLines, const std::string &amp;opening)</td></tr>
<tr class="memdesc:a36465eba46cf5c89358f7c1b1d52517d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a block comment.  <br /></td></tr>
<tr class="separator:a36465eba46cf5c89358f7c1b1d52517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4eb10493033822b7cb2cf51efba1352d" id="r_a4eb10493033822b7cb2cf51efba1352d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a4eb10493033822b7cb2cf51efba1352d">makeTitleComment</a> (const std::string &amp;multiLine, const std::string &amp;prefix, char bar, size_t width)</td></tr>
<tr class="memdesc:a4eb10493033822b7cb2cf51efba1352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a title comment that spans the entire width of the source code.  <br /></td></tr>
<tr class="separator:a4eb10493033822b7cb2cf51efba1352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cdb2f4e61b6314b8e65b2876d8e0ad" id="r_ab9cdb2f4e61b6314b8e65b2876d8e0ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ab9cdb2f4e61b6314b8e65b2876d8e0ad">makeTitleComment</a> (const std::vector&lt; std::string &gt; &amp;lines, const std::string &amp;prefix, char bar, size_t width)</td></tr>
<tr class="memdesc:ab9cdb2f4e61b6314b8e65b2876d8e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a title comment that spans the entire width of the source code.  <br /></td></tr>
<tr class="separator:ab9cdb2f4e61b6314b8e65b2876d8e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a81596a55a67ada3267059ed553abfcb6" id="r_a81596a55a67ada3267059ed553abfcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a81596a55a67ada3267059ed553abfcb6">message</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:a81596a55a67ada3267059ed553abfcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a diagnostic message to standard error.  <br /></td></tr>
<tr class="separator:a81596a55a67ada3267059ed553abfcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2c57bb8dd5252d908dcce31243c730" id="r_aeb2c57bb8dd5252d908dcce31243c730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#aeb2c57bb8dd5252d908dcce31243c730">message</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;begin, const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;focus, const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;end, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:aeb2c57bb8dd5252d908dcce31243c730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a diagnostic message to standard error.  <br /></td></tr>
<tr class="separator:aeb2c57bb8dd5252d908dcce31243c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd259bf2ab33f0a7f6f3198ff64b10" id="r_a30dd259bf2ab33f0a7f6f3198ff64b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a30dd259bf2ab33f0a7f6f3198ff64b10">message</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;, const std::vector&lt; <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &gt; &amp;, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:a30dd259bf2ab33f0a7f6f3198ff64b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a diagnostic message to standard error.  <br /></td></tr>
<tr class="separator:a30dd259bf2ab33f0a7f6f3198ff64b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad434f33bd9fbf3482199eca65614a68b" id="r_ad434f33bd9fbf3482199eca65614a68b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ad434f33bd9fbf3482199eca65614a68b">message</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:ad434f33bd9fbf3482199eca65614a68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a diagnostic message to standard error.  <br /></td></tr>
<tr class="separator:ad434f33bd9fbf3482199eca65614a68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f68c8fb539ef96a7adc6ba3d10aa7a6" id="r_a7f68c8fb539ef96a7adc6ba3d10aa7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a7f68c8fb539ef96a7adc6ba3d10aa7a6">message</a> (<a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>, const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;, const std::string &amp;mesg)</td></tr>
<tr class="memdesc:a7f68c8fb539ef96a7adc6ba3d10aa7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a diagnostic message to standard error.  <br /></td></tr>
<tr class="separator:a7f68c8fb539ef96a7adc6ba3d10aa7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82efb48f404dac9cfba5f8a98766bc87" id="r_a82efb48f404dac9cfba5f8a98766bc87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#a82efb48f404dac9cfba5f8a98766bc87">locationDirective</a> (size_t line, const std::string &amp;file)</td></tr>
<tr class="memdesc:a82efb48f404dac9cfba5f8a98766bc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input location information.  <br /></td></tr>
<tr class="separator:a82efb48f404dac9cfba5f8a98766bc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada49939668709cd571d58d4243bdab5d" id="r_ada49939668709cd571d58d4243bdab5d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRosebud.html#ada49939668709cd571d58d4243bdab5d">locationDirective</a> (const <a class="el" href="namespaceRosebud_1_1Ast.html#a2cef00e0d1f76a5aa03fa106f4ac7aba">Ast::NodePtr</a> &amp;, const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;)</td></tr>
<tr class="memdesc:ada49939668709cd571d58d4243bdab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input location information.  <br /></td></tr>
<tr class="separator:ada49939668709cd571d58d4243bdab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af576c5d42b1390aaa97e3101d45fb68c" id="r_af576c5d42b1390aaa97e3101d45fb68c"><td class="memItemLeft" align="right" valign="top"><a id="af576c5d42b1390aaa97e3101d45fb68c" name="af576c5d42b1390aaa97e3101d45fb68c"></a>
<a class="el" href="structRosebud_1_1Settings.html">Settings</a>&#160;</td><td class="memItemRight" valign="bottom"><b>settings</b></td></tr>
<tr class="memdesc:af576c5d42b1390aaa97e3101d45fb68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line settings for the rosebud tool. <br /></td></tr>
<tr class="separator:af576c5d42b1390aaa97e3101d45fb68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba7e44d2bcede0eafbd8f4a13abc0f0" id="r_a0ba7e44d2bcede0eafbd8f4a13abc0f0"><td class="memItemLeft" align="right" valign="top"><a id="a0ba7e44d2bcede0eafbd8f4a13abc0f0" name="a0ba7e44d2bcede0eafbd8f4a13abc0f0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nErrors</b></td></tr>
<tr class="memdesc:a0ba7e44d2bcede0eafbd8f4a13abc0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of error messages reported. <br /></td></tr>
<tr class="separator:a0ba7e44d2bcede0eafbd8f4a13abc0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af5fc4624140c6c98f251e155167099b7" name="af5fc4624140c6c98f251e155167099b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fc4624140c6c98f251e155167099b7">&#9670;&#160;</a></span>Token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Rosebud::Token</a> = typedef <a class="el" href="classSawyer_1_1Language_1_1Clexer_1_1Token.html">Sawyer::Language::Clexer::Token</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A token parsed from the input file. </p>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00459">459</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a0fc193a4c4bdd59a294aea2bef445635" name="a0fc193a4c4bdd59a294aea2bef445635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc193a4c4bdd59a294aea2bef445635">&#9670;&#160;</a></span>TokenStream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#a0fc193a4c4bdd59a294aea2bef445635">Rosebud::TokenStream</a> = typedef <a class="el" href="classSawyer_1_1Language_1_1Clexer_1_1TokenStream.html">Sawyer::Language::Clexer::TokenStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A stream of tokens from the input file. </p>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00462">462</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a82a34c72cf277eee3672aad5d3e5c985" name="a82a34c72cf277eee3672aad5d3e5c985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a34c72cf277eee3672aad5d3e5c985">&#9670;&#160;</a></span>GeneratorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#a82a34c72cf277eee3672aad5d3e5c985">Rosebud::GeneratorPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classRosebud_1_1Generator.html">Generator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to a <a class="el" href="classRosebud_1_1Generator.html">Generator</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00479">479</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="ac59922f983d21f5761c1c81254af1d59" name="ac59922f983d21f5761c1c81254af1d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59922f983d21f5761c1c81254af1d59">&#9670;&#160;</a></span>SerializerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#ac59922f983d21f5761c1c81254af1d59">Rosebud::SerializerPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classRosebud_1_1Serializer.html">Serializer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer to a <a class="el" href="classRosebud_1_1Serializer.html">Serializer</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00481">481</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="aaaca3c745f7fe5d33201e7869bdf5c3f" name="aaaca3c745f7fe5d33201e7869bdf5c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaca3c745f7fe5d33201e7869bdf5c3f">&#9670;&#160;</a></span>Hierarchy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Rosebud::Hierarchy</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;<a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a>, <a class="el" href="classSawyer_1_1Nothing.html">Sawyer::Nothing</a>, <a class="el" href="structRosebud_1_1HierarchyKey.html">HierarchyKey</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class hierarchy. </p>
<p>The vertices are pointers to AST class nodes. The edges point from base classes to derived classes. </p>

<p class="definition">Definition at line <a class="el" href="ud_2Utility_8h_source.html#l00248">248</a> of file <a class="el" href="ud_2Utility_8h_source.html">ud/Utility.h</a>.</p>

</div>
</div>
<a id="a08de533e19e267055dfde82f9f6da4fa" name="a08de533e19e267055dfde82f9f6da4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08de533e19e267055dfde82f9f6da4fa">&#9670;&#160;</a></span>Classes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Rosebud::Classes</a> = typedef std::vector&lt;<a class="el" href="namespaceRosebud_1_1Ast.html#a1fcb7cbf14cf4fbca6c31ffa34ba49ea">Ast::ClassPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered sequence of classes. </p>

<p class="definition">Definition at line <a class="el" href="ud_2Utility_8h_source.html#l00251">251</a> of file <a class="el" href="ud_2Utility_8h_source.html">ud/Utility.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8413fc818b380a010f6f1587a66d8360" name="a8413fc818b380a010f6f1587a66d8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8413fc818b380a010f6f1587a66d8360">&#9670;&#160;</a></span>Expand</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceRosebud.html#a8413fc818b380a010f6f1587a66d8360">Rosebud::Expand</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to obtain text when converting a sequence of tokens to a string. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8413fc818b380a010f6f1587a66d8360ab50339a10e1de285ac99d4c3990b8693" name="a8413fc818b380a010f6f1587a66d8360ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Each token's [begin,end) individually. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8413fc818b380a010f6f1587a66d8360abeaf3f30067cbde80b264c6bdabfcb29" name="a8413fc818b380a010f6f1587a66d8360abeaf3f30067cbde80b264c6bdabfcb29"></a>INTER&#160;</td><td class="fielddoc"><p>From first token's begin to last token's end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8413fc818b380a010f6f1587a66d8360ae4bf0e3d9afa4b59492d1f1a22fb6a37" name="a8413fc818b380a010f6f1587a66d8360ae4bf0e3d9afa4b59492d1f1a22fb6a37"></a>PRIOR&#160;</td><td class="fielddoc"><p>From first token's prior to last token's end. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00465">465</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a7704c979755e94c4be2b15875691fb68" name="a7704c979755e94c4be2b15875691fb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7704c979755e94c4be2b15875691fb68">&#9670;&#160;</a></span>When</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceRosebud.html#a7704c979755e94c4be2b15875691fb68">Rosebud::When</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When something should be done. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7704c979755e94c4be2b15875691fb68a443475558f0168dff92ecde26b98ae5a" name="a7704c979755e94c4be2b15875691fb68a443475558f0168dff92ecde26b98ae5a"></a>NEVER&#160;</td><td class="fielddoc"><p>Never do it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7704c979755e94c4be2b15875691fb68af3fc827ade4b968e50406496907ef962" name="a7704c979755e94c4be2b15875691fb68af3fc827ade4b968e50406496907ef962"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Always do it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7704c979755e94c4be2b15875691fb68ae1f2d5134ed2543d38a0de9751cf75d9" name="a7704c979755e94c4be2b15875691fb68ae1f2d5134ed2543d38a0de9751cf75d9"></a>AUTO&#160;</td><td class="fielddoc"><p>Sometimes do it. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rosebud_2BasicTypes_8h_source.html#l00472">472</a> of file <a class="el" href="Rosebud_2BasicTypes_8h_source.html">Rosebud/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a51a4adf6c23be03e9ba20c5a89fb4fef" name="a51a4adf6c23be03e9ba20c5a89fb4fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4adf6c23be03e9ba20c5a89fb4fef">&#9670;&#160;</a></span>Access</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceRosebud.html#a51a4adf6c23be03e9ba20c5a89fb4fef">Rosebud::Access</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of access. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a51a4adf6c23be03e9ba20c5a89fb4fefa84c6d22cfdf3772e66b07bde636e0571" name="a51a4adf6c23be03e9ba20c5a89fb4fefa84c6d22cfdf3772e66b07bde636e0571"></a>PRIVATE&#160;</td><td class="fielddoc"><p>Like C++ <code>private</code> access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51a4adf6c23be03e9ba20c5a89fb4fefa0c2448254108d59f7400d1c96f31d751" name="a51a4adf6c23be03e9ba20c5a89fb4fefa0c2448254108d59f7400d1c96f31d751"></a>PROTECTED&#160;</td><td class="fielddoc"><p>Like C++ <code>protected</code> access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51a4adf6c23be03e9ba20c5a89fb4fefacd0c6092d6a6874f379fe4827ed1db8b" name="a51a4adf6c23be03e9ba20c5a89fb4fefacd0c6092d6a6874f379fe4827ed1db8b"></a>PUBLIC&#160;</td><td class="fielddoc"><p>Like C++ <code>public</code> access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a51a4adf6c23be03e9ba20c5a89fb4fefa5b39c8b553c821e7cddc6da64b5bd2ee" name="a51a4adf6c23be03e9ba20c5a89fb4fefa5b39c8b553c821e7cddc6da64b5bd2ee"></a>DEFAULT&#160;</td><td class="fielddoc"><p>Use whatever access is already present. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ud_2Utility_8h_source.html#l00020">20</a> of file <a class="el" href="ud_2Utility_8h_source.html">ud/Utility.h</a>.</p>

</div>
</div>
<a id="a4c0d9db14824442b83b6c99619aecfdc" name="a4c0d9db14824442b83b6c99619aecfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0d9db14824442b83b6c99619aecfdc">&#9670;&#160;</a></span>CamelCase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceRosebud.html#a4c0d9db14824442b83b6c99619aecfdc">Rosebud::CamelCase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What to do with the first letter of the return value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4c0d9db14824442b83b6c99619aecfdcaa7c48ba367e019d004bfb0239b85f2b3" name="a4c0d9db14824442b83b6c99619aecfdcaa7c48ba367e019d004bfb0239b85f2b3"></a>LOWER&#160;</td><td class="fielddoc"><p>Make the first character lower case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c0d9db14824442b83b6c99619aecfdca9e43f5291e6fcb2ad99c8e3f91acd179" name="a4c0d9db14824442b83b6c99619aecfdca9e43f5291e6fcb2ad99c8e3f91acd179"></a>UPPER&#160;</td><td class="fielddoc"><p>Make the first character upper case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c0d9db14824442b83b6c99619aecfdca46335765005ff44b1fe1e38e5d2ddfcc" name="a4c0d9db14824442b83b6c99619aecfdca46335765005ff44b1fe1e38e5d2ddfcc"></a>UNCHANGED&#160;</td><td class="fielddoc"><p>Leave the first character as it is in the input. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ud_2Utility_8h_source.html#l00095">95</a> of file <a class="el" href="ud_2Utility_8h_source.html">ud/Utility.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a71a702c02c98138d1575bcab1f18d09d" name="a71a702c02c98138d1575bcab1f18d09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a702c02c98138d1575bcab1f18d09d">&#9670;&#160;</a></span>matching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::matching </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the matching opening or closing construct. </p>
<p>E.g., if input is "{" then output is "}" and vice versa. </p>

</div>
</div>
<a id="ac792b122dc96413d5a04ca1bcf9742b9" name="ac792b122dc96413d5a04ca1bcf9742b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac792b122dc96413d5a04ca1bcf9742b9">&#9670;&#160;</a></span>matching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Rosebud::matching </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the matching opening or closing construct. </p>
<p>E.g., if input is "{" then output is "}" and vice versa. </p>

</div>
</div>
<a id="a019565867c1143b94fa047548e3c80d8" name="a019565867c1143b94fa047548e3c80d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019565867c1143b94fa047548e3c80d8">&#9670;&#160;</a></span>splitIntoLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Rosebud::splitIntoLines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a multi-line string into one string per line. </p>
<p>Splits the input string at its line termination characters and return a vector of the resulting lines without their line termination characters. Since ROSE source code is prohibited from using carriage returns, we only have to worry about line feeds. </p>

</div>
</div>
<a id="ac39dc467b3c1bacb8997a757b0f97ace" name="ac39dc467b3c1bacb8997a757b0f97ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39dc467b3c1bacb8997a757b0f97ace">&#9670;&#160;</a></span>trimBlankLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::trimBlankLines </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim leading, trailing, and internal blank lines and trailing white space. </p>
<ul>
<li>Trailing white space is removed from each line.</li>
<li>Leading blank lines are removed.</li>
<li>Trailing blank lines are removed.</li>
<li>Two or more consecutive blank lines are replaced by a single blank line </li>
</ul>

</div>
</div>
<a id="ab001e12f1d92a08fea5b8067de06a1de" name="ab001e12f1d92a08fea5b8067de06a1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab001e12f1d92a08fea5b8067de06a1de">&#9670;&#160;</a></span>relativeDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Rosebud::relativeDifference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tgt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the relative difference between two strings. </p>
<p>Computes the <a class="el" href="namespaceRosebud.html#a372912ea39111aa66d3490273ef2baac">editDistance</a> as a ratio of the string length, returning a value between zero and one. </p>

</div>
</div>
<a id="ab56b328e1a3e441e46c693f7f741f568" name="ab56b328e1a3e441e46c693f7f741f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56b328e1a3e441e46c693f7f741f568">&#9670;&#160;</a></span>bestMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::bestMatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the best match. </p>
<p>Given a list of candidate strings and a sample, return the candidate that is most similar to the sample. </p>

</div>
</div>
<a id="ad24af9e8277d8b0b1a46c92a7b17751e" name="ad24af9e8277d8b0b1a46c92a7b17751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24af9e8277d8b0b1a46c92a7b17751e">&#9670;&#160;</a></span>findRoseRootDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::filesystem::path Rosebud::findRoseRootDir </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the root of the ROSE source tree. </p>
<p>Given the name of a file inside the ROSE source tree, return the absolute name of the root directory of the ROSE source tree. If the root directory cannot be found (e.g., the specified file is not inside the ROSE source tree), then return an empty path. The file need not exist. </p>

</div>
</div>
<a id="a9e46ddb0b0c347e401f7adccd50906ad" name="a9e46ddb0b0c347e401f7adccd50906ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e46ddb0b0c347e401f7adccd50906ad">&#9670;&#160;</a></span>relativeToRoseSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::filesystem::path Rosebud::relativeToRoseSource </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a file path to a ROSE-relative path. </p>
<p>If the specified file name is inside the ROSE source tree, then return the name of the file relative to the root of the ROSE source tree. Returns the empty path if the file is not inside the ROSE source tree. The file need not exist. </p>

</div>
</div>
<a id="ad2fa290860752b23858d8d5ebe71fb8b" name="ad2fa290860752b23858d8d5ebe71fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa290860752b23858d8d5ebe71fb8b">&#9670;&#160;</a></span>toPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::filesystem::path Rosebud::toPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a qualified C++ name to a relative path. </p>
<p>The return value is a relative path of components separated by the system's path component separator ("/" on POSIX systems). The components of the path are the components of the C++ qualified name that are separated by "::". The file name extension is appended to the result before returning. </p>

</div>
</div>
<a id="aff114f296247ccfd9963be57654380cb" name="aff114f296247ccfd9963be57654380cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff114f296247ccfd9963be57654380cb">&#9670;&#160;</a></span>makeBlockComment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::makeBlockComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opening</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a block comment. </p>
<p>The string is split into lines. The first line is prefixed with the opening text and the prefix for the following lines is created automatically from the opening text. This works for both C-style and C++-style comments. If the opening contains neither a C-style nor C++-style comment opening, then C-style is assumed and the opening is used as-is for the prefix for all lines. The closing token for C-style comments hangs on the last line of text. If there is no text, then the return value is similarly empty. </p>

</div>
</div>
<a id="a36465eba46cf5c89358f7c1b1d52517d" name="a36465eba46cf5c89358f7c1b1d52517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36465eba46cf5c89358f7c1b1d52517d">&#9670;&#160;</a></span>makeBlockComment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Rosebud::makeBlockComment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>textLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opening</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a block comment. </p>
<p>The string is split into lines. The first line is prefixed with the opening text and the prefix for the following lines is created automatically from the opening text. This works for both C-style and C++-style comments. If the opening contains neither a C-style nor C++-style comment opening, then C-style is assumed and the opening is used as-is for the prefix for all lines. The closing token for C-style comments hangs on the last line of text. If there is no text, then the return value is similarly empty. </p>

</div>
</div>
<a id="a4eb10493033822b7cb2cf51efba1352d" name="a4eb10493033822b7cb2cf51efba1352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb10493033822b7cb2cf51efba1352d">&#9670;&#160;</a></span>makeTitleComment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::makeTitleComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>multiLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a title comment that spans the entire width of the source code. </p>
<p>This is similar to the wide //////... comments in this header file. </p>

</div>
</div>
<a id="ab9cdb2f4e61b6314b8e65b2876d8e0ad" name="ab9cdb2f4e61b6314b8e65b2876d8e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cdb2f4e61b6314b8e65b2876d8e0ad">&#9670;&#160;</a></span>makeTitleComment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Rosebud::makeTitleComment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a title comment that spans the entire width of the source code. </p>
<p>This is similar to the wide //////... comments in this header file. </p>

</div>
</div>
<a id="a73d6968adfa3eef45730a0766e9dd4f0" name="a73d6968adfa3eef45730a0766e9dd4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d6968adfa3eef45730a0766e9dd4f0">&#9670;&#160;</a></span>appendToDoxygen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::appendToDoxygen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existingComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append text to a Doxygen comment. </p>
<p>Given a Doxygen block comment (or nothing), append the specified multi-line text to the end of the comment. The new text should not include start or end with C-style comment delimiters or contain C++-style or box decorations at the start of each line of new text; these will be added automatically. </p>

</div>
</div>
<a id="adb7e3a97b127ae20c2ae8629d5a64967" name="adb7e3a97b127ae20c2ae8629d5a64967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7e3a97b127ae20c2ae8629d5a64967">&#9670;&#160;</a></span>messageString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::messageString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an importance level and message to an error output string. </p>
<p>The returned string may have ANSI color codes and will have line termination. </p>

</div>
</div>
<a id="a81596a55a67ada3267059ed553abfcb6" name="a81596a55a67ada3267059ed553abfcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81596a55a67ada3267059ed553abfcb6">&#9670;&#160;</a></span>message() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a diagnostic message to standard error. </p>
<p>Messages contain the following parts:</p><ul>
<li>The multi-line message</li>
<li>The importance</li>
<li>The file name if a file is provided, otherwise the program name</li>
<li>The line and column number if a token is provided</li>
<li>The lines from the source file if a token is provided</li>
<li>An indication of the important part of the line if a token is provided and a source line is emitted</li>
</ul>
<p>The message will include the name of the input file, the position in the input file, and a copy of the relevant part of the input file </p>

</div>
</div>
<a id="aeb2c57bb8dd5252d908dcce31243c730" name="aeb2c57bb8dd5252d908dcce31243c730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2c57bb8dd5252d908dcce31243c730">&#9670;&#160;</a></span>message() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>focus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a diagnostic message to standard error. </p>
<p>Messages contain the following parts:</p><ul>
<li>The multi-line message</li>
<li>The importance</li>
<li>The file name if a file is provided, otherwise the program name</li>
<li>The line and column number if a token is provided</li>
<li>The lines from the source file if a token is provided</li>
<li>An indication of the important part of the line if a token is provided and a source line is emitted</li>
</ul>
<p>The message will include the name of the input file, the position in the input file, and a copy of the relevant part of the input file </p>

</div>
</div>
<a id="a30dd259bf2ab33f0a7f6f3198ff64b10" name="a30dd259bf2ab33f0a7f6f3198ff64b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dd259bf2ab33f0a7f6f3198ff64b10">&#9670;&#160;</a></span>message() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a diagnostic message to standard error. </p>
<p>Messages contain the following parts:</p><ul>
<li>The multi-line message</li>
<li>The importance</li>
<li>The file name if a file is provided, otherwise the program name</li>
<li>The line and column number if a token is provided</li>
<li>The lines from the source file if a token is provided</li>
<li>An indication of the important part of the line if a token is provided and a source line is emitted</li>
</ul>
<p>The message will include the name of the input file, the position in the input file, and a copy of the relevant part of the input file </p>

</div>
</div>
<a id="ad434f33bd9fbf3482199eca65614a68b" name="ad434f33bd9fbf3482199eca65614a68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad434f33bd9fbf3482199eca65614a68b">&#9670;&#160;</a></span>message() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a diagnostic message to standard error. </p>
<p>Messages contain the following parts:</p><ul>
<li>The multi-line message</li>
<li>The importance</li>
<li>The file name if a file is provided, otherwise the program name</li>
<li>The line and column number if a token is provided</li>
<li>The lines from the source file if a token is provided</li>
<li>An indication of the important part of the line if a token is provided and a source line is emitted</li>
</ul>
<p>The message will include the name of the input file, the position in the input file, and a copy of the relevant part of the input file </p>

</div>
</div>
<a id="a7f68c8fb539ef96a7adc6ba3d10aa7a6" name="a7f68c8fb539ef96a7adc6ba3d10aa7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f68c8fb539ef96a7adc6ba3d10aa7a6">&#9670;&#160;</a></span>message() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rosebud::message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9">Sawyer::Message::Importance</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud_1_1Ast.html#a96c9439b4fb17b8293edfaa255b3e384">Ast::FilePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a diagnostic message to standard error. </p>
<p>Messages contain the following parts:</p><ul>
<li>The multi-line message</li>
<li>The importance</li>
<li>The file name if a file is provided, otherwise the program name</li>
<li>The line and column number if a token is provided</li>
<li>The lines from the source file if a token is provided</li>
<li>An indication of the important part of the line if a token is provided and a source line is emitted</li>
</ul>
<p>The message will include the name of the input file, the position in the input file, and a copy of the relevant part of the input file </p>

</div>
</div>
<a id="a047e28ec6f290b36bc25e667eef1349c" name="a047e28ec6f290b36bc25e667eef1349c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047e28ec6f290b36bc25e667eef1349c">&#9670;&#160;</a></span>classHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRosebud.html#aaaca3c745f7fe5d33201e7869bdf5c3f">Hierarchy</a> Rosebud::classHierarchy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#a08de533e19e267055dfde82f9f6da4fa">Classes</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the class hierarchy from the specified class definitions. </p>
<p>The edges in the graph point from base classes to derived classes. </p>

</div>
</div>
<a id="ad7945a3fce3146e3a48e6bd1afb2765e" name="ad7945a3fce3146e3a48e6bd1afb2765e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7945a3fce3146e3a48e6bd1afb2765e">&#9670;&#160;</a></span>constRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::constRef </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a type into a const reference to the type. </p>
<div class="fragment"><div class="line">Input           Output</div>
<div class="line">--------------- ----------</div>
<div class="line"><span class="keywordtype">char</span>            <span class="keywordtype">char</span> <span class="keyword">const</span>&amp;</div>
<div class="line"><span class="keywordtype">char</span>*           <span class="keywordtype">char</span>* <span class="keyword">const</span>&amp;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>*     <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>&amp;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a82efb48f404dac9cfba5f8a98766bc87" name="a82efb48f404dac9cfba5f8a98766bc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82efb48f404dac9cfba5f8a98766bc87">&#9670;&#160;</a></span>locationDirective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::locationDirective </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input location information. </p>
<p>This returns a C preprocessor #line directive with line termintion that resets source information as specified. If location information is disabled, then the empty string is returned. </p>

</div>
</div>
<a id="ada49939668709cd571d58d4243bdab5d" name="ada49939668709cd571d58d4243bdab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada49939668709cd571d58d4243bdab5d">&#9670;&#160;</a></span>locationDirective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::locationDirective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud_1_1Ast.html#a2cef00e0d1f76a5aa03fa106f4ac7aba">Ast::NodePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRosebud.html#af5fc4624140c6c98f251e155167099b7">Token</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input location information. </p>
<p>This returns a C preprocessor #line directive with line termintion that resets source information as specified. If location information is disabled, then the empty string is returned. </p>

</div>
</div>
<a id="ae9a9083ac943783bdd86d06ec672cd88" name="ae9a9083ac943783bdd86d06ec672cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a9083ac943783bdd86d06ec672cd88">&#9670;&#160;</a></span>toCppSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rosebud::toCppSymbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a C++ qualified name to a CPP symbol. </p>
<p>This is done by replacing all the "::" with "_". Leading underscores are removed. A leading "Rose_" string is replaced with "ROSE_". </p>

</div>
</div>
<a id="a9ae57445c44b29f9ce95dc244c3546c9" name="a9ae57445c44b29f9ce95dc244c3546c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae57445c44b29f9ce95dc244c3546c9">&#9670;&#160;</a></span>extractCpp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Rosebud::extractCpp </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract all matching C preprocessor directives from the text. </p>
<p>Modifies the string in place and returns one preprocessor directive per vector element. If capture is non-zero, then it refers to a parenthetical capture group in the regular expression, and just that group is saved in the return vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:35 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
