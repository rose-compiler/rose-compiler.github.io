<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::AddressMap&lt; A, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1AddressMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::AddressMap&lt; A, T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class A, class T = boost::uint8_t&gt;<br />
class Sawyer::Container::AddressMap&lt; A, T &gt;</div><p>A mapping from address space to values. </p>
<p>This object maps addresses (actually, intervals thereof) to values. Addresses must be an integral unsigned type but values may be any type as long as they are default constructible and copyable. The address type is usually an integral type whose width is the log base 2 of the size of the address space; the value type is often unsigned 8-bit bytes.</p>
<p>An address map accomplishes the mapping by inheriting from an <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>, whose intervals are <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a></code> and whose values are <code><a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment&lt;A,T&gt;</a></code>. The <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a> objects point to reference-counted <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Buffer</a> objects that hold the values. The same values can be mapped at different addresses by inserting segments at those addresses that point to a common buffer.</p>
<p>An address map implements read and write concepts for copying values between user-supplied buffers and the storage areas referenced by the map. Many of the address map methods operate over a region of the map described by a set of constraints that are matched within the map. Constraints are indicated by listing them before the map I/O operation, but they do not modify the map in any way&ndash;they exist outside the map. Constraints are combined by logical conjunction. For instance, the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">AddressMap::next</a> method returns the lowest address that satisfies the given constraints, or nothing. If we wanted to search for the lowest address beteen 1000 and 1999 inclusive, that has read access but not write access, we would do so like this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Optional.html">Optional&lt;Address&gt;</a> x = map.within(1000,1999).require(READABLE).prohibit(WRITABLE).next();</div>
<div class="ttc" id="aclassSawyer_1_1Optional_html"><div class="ttname"><a href="classSawyer_1_1Optional.html">Sawyer::Optional</a></div><div class="ttdoc">Holds a value or nothing.</div><div class="ttdef"><b>Definition</b> <a href="Optional_8h_source.html#l00056">Optional.h:56</a></div></div>
</div><!-- fragment --><p>In fact, by making use of the <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a> API, we can write a loop that iterates over such addresses, although there may be more efficient ways to do this than one address at a time:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x=1000; map.within(x,1999).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a>(READABLE).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">prohibit</a>(WRITABLE).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">next</a>().assignTo(x); ++x) ...</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a1134be6cf10571edef9ffe6ab06fd7a9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Sawyer::Container::AddressMap::Address</a></div><div class="ttdeci">A Address</div><div class="ttdoc">Type for addresses.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01017">AddressMap.h:1017</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a45d2f15072209b954e3c055bcacc2e4f"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">Sawyer::Container::AddressMap::prohibit</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; prohibit(unsigned x) const</div><div class="ttdoc">Constraint: prohibited access bits.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01082">AddressMap.h:1082</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a82d01f0d9ff8007d7b88039153c2d52d"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">Sawyer::Container::AddressMap::require</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; require(unsigned x) const</div><div class="ttdoc">Constraint: required access bits.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01069">AddressMap.h:1069</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_af1f8d5e6092f38ec348503421148dd77"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">Sawyer::Container::AddressMap::next</a></div><div class="ttdeci">Optional&lt; Address &gt; next(const AddressMapConstraints&lt; const AddressMap &gt; &amp;c, MatchFlags flags=0) const</div><div class="ttdoc">Minimum or maximum address that satisfies constraints.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01482">AddressMap.h:1482</a></div></div>
</div><!-- fragment --><p>The next example shows how to read a buffer's worth of values anchored at a particular starting value. The <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3533c4cf1642ffb3a2e0e256c11508fa">read</a> method returns an address interval to indicate what addresses were accessed, but in this case we're only interested in the number of such addresses since we know the starting address.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nAccessed = map.at(1000).limit(10).read(buf).size();</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_aa7a7317b6be4502317ab4357b5989660"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Sawyer::Container::AddressMap::Value</a></div><div class="ttdeci">T Value</div><div class="ttdoc">Type of data stored in the address space.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01018">AddressMap.h:1018</a></div></div>
</div><!-- fragment --><p>An interval return value is more useful when we don't know where the operation occurs until after it occurs. For instance, to read up to 10 values that are readable at or beyond some address:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10]</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> accessed = map.atOrAfter(1000).limit(10).require(READABLE).read(buf);</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_a664961032974fd71f132d8931edd68de"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Sawyer::Container::IntervalMap::Interval</a></div><div class="ttdeci">I Interval</div><div class="ttdoc">Interval type.</div><div class="ttdef"><b>Definition</b> <a href="IntervalMap_8h_source.html#l00182">IntervalMap.h:182</a></div></div>
</div><!-- fragment --><p>Since all map operations take the same constraints, it is possible to rewrite the previous <code>for</code> loop so that instead of searching for an address it actually reads data. Here's a loop that prints all the data that's readable but not writable and falls between two addresses, regardless of what other segments also exist in that same interval:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> bufsz = 256;</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[bufsz];</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> addr = 1000;</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> accessed = map.within(addr, 1999).require(READABLE).prohibit(WRITABLE).limit(bufsz).read(buf)) {</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> i=accessed.least(); i&lt;=accessed.greatest(); ++i)</div>
<div class="line">        std::cout &lt;&lt;i &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;buf[i-accessed.least()] &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    addr += accessed.size();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Most I/O methods require that constraints match only contiguous addresses. If there is an intervening address that does not satisfy the constraint, including addresses that are not mapped, then the matched range terminates at the non-matching address. However, the <code>MATCH_NONCONTIGUOUS</code> flag can be used to relax this, in which case the matched interval of addresses may include addresses that are not mapped. Regardless of whether contiguous addresses are required, the returned interval of addresses will never contain an address that is mapped and does not also satisfy the constraints. I/O operations (read and write) require contiguous addresses, but some other methods don't. For instance, the expressions</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> found1 = map.within(100,200).require(READABLE).available(MATCH_CONTIGUOUS);</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> found2 = map.within(100,200).require(READABLE).available(MATCH_NONCONTIGUOUS);</div>
</div><!-- fragment --><p>are the same except the second one returns an interval that might include non-mapped addresses. A few methods go even further and are able to operate across mapped addresses that don't satisfy the segment constraints, skipping over the addresses that don't satisfy the constraints. For instance, the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">prune</a> and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">keep</a> functions operate this way so that a call like:</p>
<div class="fragment"><div class="line">map.within(100,200).require(READABLE).prohibit(WRITABLE).keep();</div>
</div><!-- fragment --><p>will discard all addresses except keeping those which are between 100 and 200 (inclusive) and which are readable but not writable. The documentation for each method states whether the default is contiguous matching, non-contiguous matching, or skipping over whole segments, and the method can take a bit flag (<a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>) to change its default behavior (with some restrictions).</p>
<p>One of the <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> bits indicates whether the constraint should match the lowest or highest possible addresses. The default is to match the constraint at the lowest possible addresses. Matching at the highest addresses is useful when iterating backward. For instance, if one wants to read up to 1024 values that end at address 1023 but is not sure how many prior addresses are readable, he could use backward matching. This is much more efficient than the alternative of searching backward one address at a time, and is simpler than doing an explicit binary search:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[1024];</div>
<div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> accessed = map.at(1023).limit(1024).read(buf, MATCH_BACKWARD);</div>
</div><!-- fragment --><p>Backward and forward I/O behaves identically as far as which array element holds which value. In all cases array element zero contains the value at the lowest address read or written.</p>
<p>Here's an example that creates two buffers (they happen to point to arrays that the <a class="el" href="classSawyer_1_1Container_1_1Buffer.html" title="Base class for all buffers.">Buffer</a> objects do not own), maps them at addresses in such a way that part of the smaller of the two buffers occludes the larger buffer, and then performs a write operation that touches parts of both buffers. We then rewrite part of the mapping and do another write operation:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceSawyer_1_1Container.html">Sawyer::Container</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> Addresses;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Buffer&lt;Address, char&gt;::Ptr</a> BufferPtr;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment&lt;Address, char&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;Address, char&gt;</a> MemoryMap;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create some buffer objects</span></div>
<div class="line"><span class="keywordtype">char</span> data1[15];</div>
<div class="line">memcpy(data1, <span class="stringliteral">&quot;---------------&quot;</span>, 15);</div>
<div class="line">BufferPtr buf1 = <a class="code hl_function" href="classSawyer_1_1Container_1_1StaticBuffer.html#a9b8f220a9332d70d7c357d3601ef9049">Sawyer::Container::StaticBuffer&lt;Address, char&gt;::instance</a>(data1, 15);</div>
<div class="line"><span class="keywordtype">char</span> data2[5];</div>
<div class="line">memcpy(data2, <span class="stringliteral">&quot;##########&quot;</span>, 10);</div>
<div class="line">BufferPtr buf2 = <a class="code hl_function" href="classSawyer_1_1Container_1_1StaticBuffer.html#a9b8f220a9332d70d7c357d3601ef9049">Sawyer::Container::StaticBuffer&lt;Address, char&gt;::instance</a>(data2, 5); <span class="comment">// using only first 5 bytes</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map data2 into the middle of data1</span></div>
<div class="line">MemoryMap map;</div>
<div class="line">map.insert(Addresses::baseSize(1000, 15), <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf1));</div>
<div class="line">map.insert(Addresses::baseSize(1005,  5), <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf2)); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write across both buffers and check that data2 occluded data1</span></div>
<div class="line">Addresses accessed = map.at(1001).limit(13).write(<span class="stringliteral">&quot;bcdefghijklmn&quot;</span>);</div>
<div class="line">ASSERT_always_require(accessed.size()==13);</div>
<div class="line">ASSERT_always_require(0==memcmp(data1, <span class="stringliteral">&quot;-bcde-----klmn-&quot;</span>, 15));</div>
<div class="line">ASSERT_always_require(0==memcmp(data2,      <span class="stringliteral">&quot;fghij#####&quot;</span>, 10));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map the middle of data1 over the top of data2 again and check that the mapping has one element. I.e., the three</span></div>
<div class="line"><span class="comment">// separate parts were recombined into a single entry since they are three consecutive areas of a single buffer.</span></div>
<div class="line">map.insert(Addresses::baseSize(1005, 5), <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>(buf1, 5));</div>
<div class="line">ASSERT_always_require(map.nSegments()==1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write some data again</span></div>
<div class="line">accessed = map.at(1001).limit(13).write(<span class="stringliteral">&quot;BCDEFGHIJKLMN&quot;</span>);</div>
<div class="line">ASSERT_always_require(accessed.size()==13);</div>
<div class="line">ASSERT_always_require(0==memcmp(data1, <span class="stringliteral">&quot;-BCDEFGHIJKLMN-&quot;</span>, 15));</div>
<div class="line">ASSERT_always_require(0==memcmp(data2,      <span class="stringliteral">&quot;fghij#####&quot;</span>, 10));</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a></div><div class="ttdoc">A mapping from address space to values.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01012">AddressMap.h:1012</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a30140763fdfb3c3c12e8fd6a1dc22ea9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Sawyer::Container::AddressMap::Segment</a></div><div class="ttdeci">AddressSegment&lt; A, T &gt; Segment</div><div class="ttdoc">Type of segments stored by this map.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01019">AddressMap.h:1019</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressSegment_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressSegment.html">Sawyer::Container::AddressSegment</a></div><div class="ttdoc">A homogeneous interval of an address space.</div><div class="ttdef"><b>Definition</b> <a href="AddressSegment_8h_source.html#l00042">AddressSegment.h:42</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1StaticBuffer_html_a9b8f220a9332d70d7c357d3601ef9049"><div class="ttname"><a href="classSawyer_1_1Container_1_1StaticBuffer.html#a9b8f220a9332d70d7c357d3601ef9049">Sawyer::Container::StaticBuffer::instance</a></div><div class="ttdeci">static Buffer&lt; A, T &gt;::Ptr instance(Value *values, Address size)</div><div class="ttdoc">Construct from caller-supplied data.</div><div class="ttdef"><b>Definition</b> <a href="StaticBuffer_8h_source.html#l00111">StaticBuffer.h:111</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a></div><div class="ttdoc">Reference-counting intrusive smart pointer.</div><div class="ttdef"><b>Definition</b> <a href="SharedPointer_8h_source.html#l00065">SharedPointer.h:65</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Container_html"><div class="ttname"><a href="namespaceSawyer_1_1Container.html">Sawyer::Container</a></div><div class="ttdoc">Container classes that store user-defined values.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l00031">AddressMap.h:31</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="errors"></a>
Microsoft C++ compilers</h1>
<p>Microsoft Visual Studio 12 2013 (MSVC 18.0.30501.0) and possibly other versions look up non-dependent names in template base classes in violation of C++ standards and apparently no switch to make their behavior compliant with the standard. This causes problems for <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> because unqualified references to <code>Interval</code> should refer to the <a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Sawyer::Container::Interval</a> class template, but instead they refer to the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> typedef in the base class. Our work around is to qualify all occurrences of <code>Interval</code> where Microsoft compilers go wrong. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01012">1012</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AddressMap_8h_source.html">Sawyer/AddressMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::AddressMap&lt; A, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap__inherit__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map" id="aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_inherit__map">
<area shape="rect" title="A mapping from address space to values." alt="" coords="22,95,166,135"/>
<area shape="rect" href="classSawyer_1_1Container_1_1AddressMap.html" title=" " alt="" coords="12,197,176,252"/>
<area shape="poly" title=" " alt="" coords="97,148,97,197,91,197,91,148"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non&#45;overlapping intervals." alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="97,59,97,94,91,94,91,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Container::AddressMap&lt; A, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1AddressMap__coll__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map" id="aSawyer_1_1Container_1_1AddressMap_3_01A_00_01T_01_4_coll__map">
<area shape="rect" title="A mapping from address space to values." alt="" coords="22,93,166,133"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non&#45;overlapping intervals." alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="97,59,97,93,91,93,91,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for traversals.  <a href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1134be6cf10571edef9ffe6ab06fd7a9" id="r_a1134be6cf10571edef9ffe6ab06fd7a9"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a></td></tr>
<tr class="memdesc:a1134be6cf10571edef9ffe6ab06fd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for addresses.  <br /></td></tr>
<tr class="separator:a1134be6cf10571edef9ffe6ab06fd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a7317b6be4502317ab4357b5989660" id="r_aa7a7317b6be4502317ab4357b5989660"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a></td></tr>
<tr class="memdesc:aa7a7317b6be4502317ab4357b5989660"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of data stored in the address space.  <br /></td></tr>
<tr class="separator:aa7a7317b6be4502317ab4357b5989660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30140763fdfb3c3c12e8fd6a1dc22ea9" id="r_a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>&lt; A, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a></td></tr>
<tr class="memdesc:a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of segments stored by this map.  <br /></td></tr>
<tr class="separator:a30140763fdfb3c3c12e8fd6a1dc22ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b56b98075440d935890ac4f0c0053" id="r_a853b56b98075440d935890ac4f0c0053"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a853b56b98075440d935890ac4f0c0053">Buffer</a></td></tr>
<tr class="separator:a853b56b98075440d935890ac4f0c0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9cf858603ecda80b73929ad8fcbc9" id="r_af2c9cf858603ecda80b73929ad8fcbc9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Super::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a></td></tr>
<tr class="memdesc:af2c9cf858603ecda80b73929ad8fcbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node containing interval/segment pair.  <br /></td></tr>
<tr class="separator:af2c9cf858603ecda80b73929ad8fcbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7204596756341c0ea7eeadc5d38262" id="r_a9f7204596756341c0ea7eeadc5d38262"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">Super::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a></td></tr>
<tr class="memdesc:a9f7204596756341c0ea7eeadc5d38262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over segments in the map.  <br /></td></tr>
<tr class="separator:a9f7204596756341c0ea7eeadc5d38262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852a793027a1c74c097147546910f47" id="r_aa852a793027a1c74c097147546910f47"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">Super::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a></td></tr>
<tr class="memdesc:aa852a793027a1c74c097147546910f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators over segments in the map.  <br /></td></tr>
<tr class="separator:aa852a793027a1c74c097147546910f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0994c89a6b4a525a52f8f341ae3d28ed" id="r_a0994c89a6b4a525a52f8f341ae3d28ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">Super::ConstIntervalIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0994c89a6b4a525a52f8f341ae3d28ed">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:a0994c89a6b4a525a52f8f341ae3d28ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address intervals in the map.  <br /></td></tr>
<tr class="separator:a0994c89a6b4a525a52f8f341ae3d28ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6954614b9b130d841261ad4d2644316" id="r_ac6954614b9b130d841261ad4d2644316"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">Super::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a></td></tr>
<tr class="memdesc:ac6954614b9b130d841261ad4d2644316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval, segment pairs in the map.  <br /></td></tr>
<tr class="separator:ac6954614b9b130d841261ad4d2644316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a3b18db58eae98d782531b3f155b5" id="r_abf7a3b18db58eae98d782531b3f155b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">Super::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a></td></tr>
<tr class="memdesc:abf7a3b18db58eae98d782531b3f155b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over address interval/segment pairs in the map.  <br /></td></tr>
<tr class="separator:abf7a3b18db58eae98d782531b3f155b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a664961032974fd71f132d8931edd68de"><td class="memItemLeft" align="right" valign="top">typedef I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a></td></tr>
<tr class="memdesc:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> type.  <br /></td></tr>
<tr class="separator:a664961032974fd71f132d8931edd68de inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a7c7ef387287aa01aa632dfeafc121e95"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a></td></tr>
<tr class="memdesc:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <br /></td></tr>
<tr class="separator:a7c7ef387287aa01aa632dfeafc121e95 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae27b32aea90cdef93228cd5c978c00ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Container::Map</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a>, IntervalCompare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a></td></tr>
<tr class="memdesc:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of the underlying map.  <br /></td></tr>
<tr class="separator:ae27b32aea90cdef93228cd5c978c00ef inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad3da8180167b02f750f8138e21fea1b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Map::Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Node</a></td></tr>
<tr class="memdesc:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage node.  <br /></td></tr>
<tr class="separator:ad3da8180167b02f750f8138e21fea1b8 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae5130ce1b0e59f7bddd6b68f02da3b2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstKeyIterator.html">Map::ConstKeyIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a></td></tr>
<tr class="memdesc:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> iterator.  <br /></td></tr>
<tr class="separator:ae5130ce1b0e59f7bddd6b68f02da3b2e inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ae50e191b16e240244fb48af0232e88ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ValueIterator.html">Map::ValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a></td></tr>
<tr class="memdesc:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:ae50e191b16e240244fb48af0232e88ac inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a050e4ca3dcf0d65fba2d65b20e9730d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstValueIterator.html">Map::ConstValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a></td></tr>
<tr class="memdesc:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value iterator.  <br /></td></tr>
<tr class="separator:a050e4ca3dcf0d65fba2d65b20e9730d9 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_a643bf7e3b1413a950b3e66bd7244dacb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1NodeIterator.html">Map::NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a></td></tr>
<tr class="memdesc:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:a643bf7e3b1413a950b3e66bd7244dacb inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap" id="r_ad28df1a69755b5534a2ddb68bd447e61"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map_1_1ConstNodeIterator.html">Map::ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a></td></tr>
<tr class="memdesc:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node iterator.  <br /></td></tr>
<tr class="separator:ad28df1a69755b5534a2ddb68bd447e61 inherit pub_types_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e8cd51e41cea7489ea3f78b0d30365c" id="r_a3e8cd51e41cea7489ea3f78b0d30365c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3e8cd51e41cea7489ea3f78b0d30365c">AddressMap</a> ()</td></tr>
<tr class="memdesc:a3e8cd51e41cea7489ea3f78b0d30365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty address map.  <br /></td></tr>
<tr class="separator:a3e8cd51e41cea7489ea3f78b0d30365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac1bbe4c8188403070b62fbd6e85fa9" id="r_a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a2ac1bbe4c8188403070b62fbd6e85fa9">AddressMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &amp;other, bool copyOnWrite=false)</td></tr>
<tr class="memdesc:a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a2ac1bbe4c8188403070b62fbd6e85fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a26b869a20b7c773f75f7c3d75e04" id="r_a300a26b869a20b7c773f75f7c3d75e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a300a26b869a20b7c773f75f7c3d75e04">checkConsistency</a> () const</td></tr>
<tr class="memdesc:a300a26b869a20b7c773f75f7c3d75e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check map consistency.  <br /></td></tr>
<tr class="separator:a300a26b869a20b7c773f75f7c3d75e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1ef82354f141b3961d957e8728158" id="r_a78c1ef82354f141b3961d957e8728158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a78c1ef82354f141b3961d957e8728158">nSegments</a> () const</td></tr>
<tr class="memdesc:a78c1ef82354f141b3961d957e8728158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of segments contained in the map.  <br /></td></tr>
<tr class="separator:a78c1ef82354f141b3961d957e8728158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f8d5e6092f38ec348503421148dd77" id="r_af1f8d5e6092f38ec348503421148dd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">next</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:af1f8d5e6092f38ec348503421148dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum or maximum address that satisfies constraints.  <br /></td></tr>
<tr class="separator:af1f8d5e6092f38ec348503421148dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022219388a2d8859eae98f31e675db8d" id="r_a022219388a2d8859eae98f31e675db8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a022219388a2d8859eae98f31e675db8d">available</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a022219388a2d8859eae98f31e675db8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adress interval that satisfies constraints.  <br /></td></tr>
<tr class="separator:a022219388a2d8859eae98f31e675db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9a20f07deebeaacfeb58846102b2df" id="r_adb9a20f07deebeaacfeb58846102b2df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#adb9a20f07deebeaacfeb58846102b2df">exists</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:adb9a20f07deebeaacfeb58846102b2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an address exists with the specified constraints.  <br /></td></tr>
<tr class="separator:adb9a20f07deebeaacfeb58846102b2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a44452570a955f6e4d347cdcc9608f" id="r_ac6a44452570a955f6e4d347cdcc9608f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6a44452570a955f6e4d347cdcc9608f">unmapped</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> boundary, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ac6a44452570a955f6e4d347cdcc9608f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find unmapped interval.  <br /></td></tr>
<tr class="separator:ac6a44452570a955f6e4d347cdcc9608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c4969b86b4737401da8629fb54092" id="r_a064c4969b86b4737401da8629fb54092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a064c4969b86b4737401da8629fb54092">findFreeSpace</a> (size_t nValues, size_t alignment=1, <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; restriction=<a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;::whole(), <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a064c4969b86b4737401da8629fb54092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find free space.  <br /></td></tr>
<tr class="separator:a064c4969b86b4737401da8629fb54092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79044a63583ed0fa8cd49c945372d696" id="r_a79044a63583ed0fa8cd49c945372d696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696">prune</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a79044a63583ed0fa8cd49c945372d696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune away addresses that match constraints.  <br /></td></tr>
<tr class="separator:a79044a63583ed0fa8cd49c945372d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d024a2128d70727cfce72518a32bfd" id="r_ab1d024a2128d70727cfce72518a32bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd">keep</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ab1d024a2128d70727cfce72518a32bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep only addresses that match constraints.  <br /></td></tr>
<tr class="separator:ab1d024a2128d70727cfce72518a32bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406ad656e7e800fd01f9d17ccc297a8" id="r_a1406ad656e7e800fd01f9d17ccc297a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1406ad656e7e800fd01f9d17ccc297a8">changeAccess</a> (unsigned requiredAccess, unsigned prohibitedAccess, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a1406ad656e7e800fd01f9d17ccc297a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change access bits for addresses that match constraints.  <br /></td></tr>
<tr class="separator:a1406ad656e7e800fd01f9d17ccc297a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82d01f0d9ff8007d7b88039153c2d52d" id="r_a82d01f0d9ff8007d7b88039153c2d52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a> (unsigned x) const</td></tr>
<tr class="memdesc:a82d01f0d9ff8007d7b88039153c2d52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <br /></td></tr>
<tr class="separator:a82d01f0d9ff8007d7b88039153c2d52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84107f87cfb3f3b3cd32a6b3a981f1fb" id="r_a84107f87cfb3f3b3cd32a6b3a981f1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a84107f87cfb3f3b3cd32a6b3a981f1fb">require</a> (unsigned x)</td></tr>
<tr class="memdesc:a84107f87cfb3f3b3cd32a6b3a981f1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required access bits.  <br /></td></tr>
<tr class="separator:a84107f87cfb3f3b3cd32a6b3a981f1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a45d2f15072209b954e3c055bcacc2e4f" id="r_a45d2f15072209b954e3c055bcacc2e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">prohibit</a> (unsigned x) const</td></tr>
<tr class="memdesc:a45d2f15072209b954e3c055bcacc2e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <br /></td></tr>
<tr class="separator:a45d2f15072209b954e3c055bcacc2e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab141fc4506bb97d6574b58eeaf782378" id="r_ab141fc4506bb97d6574b58eeaf782378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab141fc4506bb97d6574b58eeaf782378">prohibit</a> (unsigned x)</td></tr>
<tr class="memdesc:ab141fc4506bb97d6574b58eeaf782378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: prohibited access bits.  <br /></td></tr>
<tr class="separator:ab141fc4506bb97d6574b58eeaf782378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1142607bf87813a913b03189b922b00" id="r_ae1142607bf87813a913b03189b922b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ae1142607bf87813a913b03189b922b00">access</a> (unsigned x) const</td></tr>
<tr class="memdesc:ae1142607bf87813a913b03189b922b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <br /></td></tr>
<tr class="separator:ae1142607bf87813a913b03189b922b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bc359d2b544bf85a518f65f8f8a5be" id="r_ab7bc359d2b544bf85a518f65f8f8a5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab7bc359d2b544bf85a518f65f8f8a5be">access</a> (unsigned x)</td></tr>
<tr class="memdesc:ab7bc359d2b544bf85a518f65f8f8a5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: required and prohibited access bits.  <br /></td></tr>
<tr class="separator:ab7bc359d2b544bf85a518f65f8f8a5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7c36dc3dc76f1b7ae01af3e7bd73b85a" id="r_a7c36dc3dc76f1b7ae01af3e7bd73b85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">substr</a> (const std::string &amp;x) const</td></tr>
<tr class="memdesc:a7c36dc3dc76f1b7ae01af3e7bd73b85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <br /></td></tr>
<tr class="separator:a7c36dc3dc76f1b7ae01af3e7bd73b85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee094304b7195f71401da1deb75a61c" id="r_a5ee094304b7195f71401da1deb75a61c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a5ee094304b7195f71401da1deb75a61c">substr</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:a5ee094304b7195f71401da1deb75a61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: segment name substring.  <br /></td></tr>
<tr class="separator:a5ee094304b7195f71401da1deb75a61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70820e2d652356ea0b0c4224d2a4a235" id="r_a70820e2d652356ea0b0c4224d2a4a235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a70820e2d652356ea0b0c4224d2a4a235">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a70820e2d652356ea0b0c4224d2a4a235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <br /></td></tr>
<tr class="separator:a70820e2d652356ea0b0c4224d2a4a235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbcda4aa2b527f0752ded21f7849ca" id="r_aafcbcda4aa2b527f0752ded21f7849ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aafcbcda4aa2b527f0752ded21f7849ca">at</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:aafcbcda4aa2b527f0752ded21f7849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchor point.  <br /></td></tr>
<tr class="separator:aafcbcda4aa2b527f0752ded21f7849ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68049818a794cf43306236fdcc9a0499" id="r_a68049818a794cf43306236fdcc9a0499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a68049818a794cf43306236fdcc9a0499">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:a68049818a794cf43306236fdcc9a0499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <br /></td></tr>
<tr class="separator:a68049818a794cf43306236fdcc9a0499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91afd9bf6d949f6cba433b36b2c21d21" id="r_a91afd9bf6d949f6cba433b36b2c21d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a91afd9bf6d949f6cba433b36b2c21d21">at</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a91afd9bf6d949f6cba433b36b2c21d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: anchored interval.  <br /></td></tr>
<tr class="separator:a91afd9bf6d949f6cba433b36b2c21d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac38bfd2f3963653a29b2c7488225f34b" id="r_ac38bfd2f3963653a29b2c7488225f34b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac38bfd2f3963653a29b2c7488225f34b">limit</a> (size_t x) const</td></tr>
<tr class="memdesc:ac38bfd2f3963653a29b2c7488225f34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <br /></td></tr>
<tr class="separator:ac38bfd2f3963653a29b2c7488225f34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71086ccca75dd0b7cfc677e276a8a2f3" id="r_a71086ccca75dd0b7cfc677e276a8a2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a71086ccca75dd0b7cfc677e276a8a2f3">limit</a> (size_t x)</td></tr>
<tr class="memdesc:a71086ccca75dd0b7cfc677e276a8a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: limit matched size.  <br /></td></tr>
<tr class="separator:a71086ccca75dd0b7cfc677e276a8a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b8c9ef37f66c1fd8b466eb9c31460d7" id="r_a4b8c9ef37f66c1fd8b466eb9c31460d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a4b8c9ef37f66c1fd8b466eb9c31460d7">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a4b8c9ef37f66c1fd8b466eb9c31460d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:a4b8c9ef37f66c1fd8b466eb9c31460d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af638e01c5db346116fc31448c9d01671" id="r_af638e01c5db346116fc31448c9d01671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af638e01c5db346116fc31448c9d01671">atOrAfter</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:af638e01c5db346116fc31448c9d01671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:af638e01c5db346116fc31448c9d01671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ade5a281e1542b9ce6fb5941f451bf129" id="r_ade5a281e1542b9ce6fb5941f451bf129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ade5a281e1542b9ce6fb5941f451bf129">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:ade5a281e1542b9ce6fb5941f451bf129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:ade5a281e1542b9ce6fb5941f451bf129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5852715c72575f5e3d8e50006cc1930" id="r_aa5852715c72575f5e3d8e50006cc1930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa5852715c72575f5e3d8e50006cc1930">atOrBefore</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:aa5852715c72575f5e3d8e50006cc1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:aa5852715c72575f5e3d8e50006cc1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a038b598dc4b28efc36d616e651021e3d" id="r_a038b598dc4b28efc36d616e651021e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a038b598dc4b28efc36d616e651021e3d">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x) const</td></tr>
<tr class="memdesc:a038b598dc4b28efc36d616e651021e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a038b598dc4b28efc36d616e651021e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae15758d951ac9470757fbd4a854f26" id="r_a6ae15758d951ac9470757fbd4a854f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a6ae15758d951ac9470757fbd4a854f26">within</a> (const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a6ae15758d951ac9470757fbd4a854f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a6ae15758d951ac9470757fbd4a854f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aed07d5c39f1a69b76f0d9375e2f26bc9" id="r_aed07d5c39f1a69b76f0d9375e2f26bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aed07d5c39f1a69b76f0d9375e2f26bc9">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y) const</td></tr>
<tr class="memdesc:aed07d5c39f1a69b76f0d9375e2f26bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aed07d5c39f1a69b76f0d9375e2f26bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d09802303534be37bb2ab2b662c33f8" id="r_a6d09802303534be37bb2ab2b662c33f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a6d09802303534be37bb2ab2b662c33f8">within</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> y)</td></tr>
<tr class="memdesc:a6d09802303534be37bb2ab2b662c33f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:a6d09802303534be37bb2ab2b662c33f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aec124932e7320a78baf6e2cc8c654aa2" id="r_aec124932e7320a78baf6e2cc8c654aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aec124932e7320a78baf6e2cc8c654aa2">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:aec124932e7320a78baf6e2cc8c654aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aec124932e7320a78baf6e2cc8c654aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd476001bdac0f00e71a8363a2ae0c8" id="r_aefd476001bdac0f00e71a8363a2ae0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aefd476001bdac0f00e71a8363a2ae0c8">baseSize</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> base, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>)</td></tr>
<tr class="memdesc:aefd476001bdac0f00e71a8363a2ae0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower and upper bounds.  <br /></td></tr>
<tr class="separator:aefd476001bdac0f00e71a8363a2ae0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0106cea41e48f180c5916e939384d49" id="r_aa0106cea41e48f180c5916e939384d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa0106cea41e48f180c5916e939384d49">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:aa0106cea41e48f180c5916e939384d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:aa0106cea41e48f180c5916e939384d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8be355c7931c9b00c621247d0f8327" id="r_acc8be355c7931c9b00c621247d0f8327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#acc8be355c7931c9b00c621247d0f8327">after</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:acc8be355c7931c9b00c621247d0f8327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address lower bound.  <br /></td></tr>
<tr class="separator:acc8be355c7931c9b00c621247d0f8327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1c10facd22691c9068519f5b06166aae" id="r_a1c10facd22691c9068519f5b06166aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1c10facd22691c9068519f5b06166aae">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x) const</td></tr>
<tr class="memdesc:a1c10facd22691c9068519f5b06166aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:a1c10facd22691c9068519f5b06166aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbc8290efe3e296e0a4ef6dd0ade7d" id="r_abedbc8290efe3e296e0a4ef6dd0ade7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abedbc8290efe3e296e0a4ef6dd0ade7d">before</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> x)</td></tr>
<tr class="memdesc:abedbc8290efe3e296e0a4ef6dd0ade7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: address upper bound.  <br /></td></tr>
<tr class="separator:abedbc8290efe3e296e0a4ef6dd0ade7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54070def208a6ef2bc441176a25e1d96" id="r_a54070def208a6ef2bc441176a25e1d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a54070def208a6ef2bc441176a25e1d96">singleSegment</a> () const</td></tr>
<tr class="memdesc:a54070def208a6ef2bc441176a25e1d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <br /></td></tr>
<tr class="separator:a54070def208a6ef2bc441176a25e1d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410ae4d161493bfb1906b392c45bd601" id="r_a410ae4d161493bfb1906b392c45bd601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a410ae4d161493bfb1906b392c45bd601">singleSegment</a> ()</td></tr>
<tr class="memdesc:a410ae4d161493bfb1906b392c45bd601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: single segment.  <br /></td></tr>
<tr class="separator:a410ae4d161493bfb1906b392c45bd601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af896378e5b63e968d0c44cfacfa0954b" id="r_af896378e5b63e968d0c44cfacfa0954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af896378e5b63e968d0c44cfacfa0954b">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p) const</td></tr>
<tr class="memdesc:af896378e5b63e968d0c44cfacfa0954b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <br /></td></tr>
<tr class="separator:af896378e5b63e968d0c44cfacfa0954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb0089fa00ad1ea3c11a18051f01484" id="r_acfb0089fa00ad1ea3c11a18051f01484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#acfb0089fa00ad1ea3c11a18051f01484">segmentPredicate</a> (<a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *p)</td></tr>
<tr class="memdesc:acfb0089fa00ad1ea3c11a18051f01484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: arbitrary segment constraint.  <br /></td></tr>
<tr class="separator:acfb0089fa00ad1ea3c11a18051f01484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a13a935200e06fbc09262a9f8452465a9" id="r_a13a935200e06fbc09262a9f8452465a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a13a935200e06fbc09262a9f8452465a9">any</a> () const</td></tr>
<tr class="memdesc:a13a935200e06fbc09262a9f8452465a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <br /></td></tr>
<tr class="separator:a13a935200e06fbc09262a9f8452465a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03d3746419b8e479b502965c60a7e9e" id="r_ac03d3746419b8e479b502965c60a7e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac03d3746419b8e479b502965c60a7e9e">any</a> ()</td></tr>
<tr class="memdesc:ac03d3746419b8e479b502965c60a7e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches anything.  <br /></td></tr>
<tr class="separator:ac03d3746419b8e479b502965c60a7e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7630d1cfb2d77700010c13c25ea20120" id="r_a7630d1cfb2d77700010c13c25ea20120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7630d1cfb2d77700010c13c25ea20120">none</a> () const</td></tr>
<tr class="memdesc:a7630d1cfb2d77700010c13c25ea20120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <br /></td></tr>
<tr class="separator:a7630d1cfb2d77700010c13c25ea20120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ae41df44c705df60531d0e2f869caa" id="r_a39ae41df44c705df60531d0e2f869caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a39ae41df44c705df60531d0e2f869caa">none</a> ()</td></tr>
<tr class="memdesc:a39ae41df44c705df60531d0e2f869caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint: matches nothing.  <br /></td></tr>
<tr class="separator:a39ae41df44c705df60531d0e2f869caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a800770e4dbdb91ad94db36031da25b33" id="r_a800770e4dbdb91ad94db36031da25b33"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a800770e4dbdb91ad94db36031da25b33">segments</a> ()</td></tr>
<tr class="memdesc:a800770e4dbdb91ad94db36031da25b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:a800770e4dbdb91ad94db36031da25b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598081918a53e58769abf182468da05" id="r_af598081918a53e58769abf182468da05"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#af598081918a53e58769abf182468da05">segments</a> () const</td></tr>
<tr class="memdesc:af598081918a53e58769abf182468da05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:af598081918a53e58769abf182468da05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ebcc9606d5be9a29130e491435345" id="r_ad53ebcc9606d5be9a29130e491435345"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad53ebcc9606d5be9a29130e491435345">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ad53ebcc9606d5be9a29130e491435345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments that overlap with constraints.  <br /></td></tr>
<tr class="separator:ad53ebcc9606d5be9a29130e491435345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9832d3eeccc2daf7b01b3f84233ed" id="r_a06e9832d3eeccc2daf7b01b3f84233ed"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a06e9832d3eeccc2daf7b01b3f84233ed">segments</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a06e9832d3eeccc2daf7b01b3f84233ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for all segments.  <br /></td></tr>
<tr class="separator:a06e9832d3eeccc2daf7b01b3f84233ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac607416127deca39cea3ba026eaa893e" id="r_ac607416127deca39cea3ba026eaa893e"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac607416127deca39cea3ba026eaa893e">nodes</a> ()</td></tr>
<tr class="memdesc:ac607416127deca39cea3ba026eaa893e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <br /></td></tr>
<tr class="separator:ac607416127deca39cea3ba026eaa893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed0ae63ebdd27bb6894fe85e6fe66c5" id="r_a7ed0ae63ebdd27bb6894fe85e6fe66c5"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7ed0ae63ebdd27bb6894fe85e6fe66c5">nodes</a> () const</td></tr>
<tr class="memdesc:a7ed0ae63ebdd27bb6894fe85e6fe66c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator range for nodes.  <br /></td></tr>
<tr class="separator:a7ed0ae63ebdd27bb6894fe85e6fe66c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad070947b7a9bb1d13b1040b0877ae9c5" id="r_ad070947b7a9bb1d13b1040b0877ae9c5"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ad070947b7a9bb1d13b1040b0877ae9c5">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:ad070947b7a9bb1d13b1040b0877ae9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <br /></td></tr>
<tr class="separator:ad070947b7a9bb1d13b1040b0877ae9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c76e29df249359dbf6383ce592cb64d" id="r_a9c76e29df249359dbf6383ce592cb64d"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9c76e29df249359dbf6383ce592cb64d">nodes</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a9c76e29df249359dbf6383ce592cb64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes that overlap with constraints.  <br /></td></tr>
<tr class="separator:a9c76e29df249359dbf6383ce592cb64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a11968c68b0efd523b24e371bff818613" id="r_a11968c68b0efd523b24e371bff818613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a11968c68b0efd523b24e371bff818613">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a11968c68b0efd523b24e371bff818613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <br /></td></tr>
<tr class="separator:a11968c68b0efd523b24e371bff818613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164562fd38d476e8c0daf810075b399f" id="r_a164562fd38d476e8c0daf810075b399f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a164562fd38d476e8c0daf810075b399f">findNode</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a164562fd38d476e8c0daf810075b399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find node containing address.  <br /></td></tr>
<tr class="separator:a164562fd38d476e8c0daf810075b399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a895d3400de898b3dd49a7bb7074dcf0e" id="r_a895d3400de898b3dd49a7bb7074dcf0e"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a895d3400de898b3dd49a7bb7074dcf0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a895d3400de898b3dd49a7bb7074dcf0e">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a895d3400de898b3dd49a7bb7074dcf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a895d3400de898b3dd49a7bb7074dcf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8b6e632d09737c2ca035640af3d565" id="r_a0a8b6e632d09737c2ca035640af3d565"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a0a8b6e632d09737c2ca035640af3d565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a0a8b6e632d09737c2ca035640af3d565">traverse</a> (Functor &amp;functor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a0a8b6e632d09737c2ca035640af3d565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a0a8b6e632d09737c2ca035640af3d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd627686043b35501fabb3b89e867a8" id="r_a9bd627686043b35501fabb3b89e867a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9bd627686043b35501fabb3b89e867a8">traverse</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a9bd627686043b35501fabb3b89e867a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a9bd627686043b35501fabb3b89e867a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c7d3e990027e75a9dbe45e10841ac" id="r_a7b9c7d3e990027e75a9dbe45e10841ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a7b9c7d3e990027e75a9dbe45e10841ac">traverse</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;visitor, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a7b9c7d3e990027e75a9dbe45e10841ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function on each address interval.  <br /></td></tr>
<tr class="separator:a7b9c7d3e990027e75a9dbe45e10841ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3533c4cf1642ffb3a2e0e256c11508fa" id="r_a3533c4cf1642ffb3a2e0e256c11508fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a3533c4cf1642ffb3a2e0e256c11508fa">read</a> (<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:a3533c4cf1642ffb3a2e0e256c11508fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <br /></td></tr>
<tr class="separator:a3533c4cf1642ffb3a2e0e256c11508fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b80d240df8d1ba24f7b4712c5f30f" id="r_aed5b80d240df8d1ba24f7b4712c5f30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aed5b80d240df8d1ba24f7b4712c5f30f">read</a> (std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0) const</td></tr>
<tr class="memdesc:aed5b80d240df8d1ba24f7b4712c5f30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the supplied buffer.  <br /></td></tr>
<tr class="separator:aed5b80d240df8d1ba24f7b4712c5f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9e7147002d95c6ae762062e8e0552b9" id="r_ac9e7147002d95c6ae762062e8e0552b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac9e7147002d95c6ae762062e8e0552b9">write</a> (const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:ac9e7147002d95c6ae762062e8e0552b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <br /></td></tr>
<tr class="separator:ac9e7147002d95c6ae762062e8e0552b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9b85c7265696674312150e69d57999" id="r_a1a9b85c7265696674312150e69d57999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1a9b85c7265696674312150e69d57999">write</a> (const std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;buf, const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; &amp;c, <a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a> flags=0)</td></tr>
<tr class="memdesc:a1a9b85c7265696674312150e69d57999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the supplied buffer.  <br /></td></tr>
<tr class="separator:a1a9b85c7265696674312150e69d57999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0c5f60fb7032334c08cf77fa731aeb26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0c5f60fb7032334c08cf77fa731aeb26">IntervalMap</a> ()</td></tr>
<tr class="memdesc:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a0c5f60fb7032334c08cf77fa731aeb26 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a5eec51514347acfef76b9b4a65654bcc"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a5eec51514347acfef76b9b4a65654bcc">IntervalMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5eec51514347acfef76b9b4a65654bcc inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af681700b55257f5ccb0078c6bca9dbfa"><td class="memTemplParams" colspan="2">template&lt;class Interval2 , class T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af681700b55257f5ccb0078c6bca9dbfa">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; Interval2, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:af681700b55257f5ccb0078c6bca9dbfa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa43368dbaee5e1dc47efab1b5b6ce9c1"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">ConstIntervalIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa43368dbaee5e1dc47efab1b5b6ce9c1">intervals</a> () const</td></tr>
<tr class="memdesc:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing keys.  <br /></td></tr>
<tr class="separator:aa43368dbaee5e1dc47efab1b5b6ce9c1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a25feb127b25f2d5f7616003a010abdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a25feb127b25f2d5f7616003a010abdca">firstUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> minAddr) const</td></tr>
<tr class="memdesc:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first unmapped region.  <br /></td></tr>
<tr class="separator:a25feb127b25f2d5f7616003a010abdca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a53ebe1dc48e4f3ef5051c97fb8d44c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a53ebe1dc48e4f3ef5051c97fb8d44c07">lastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> maxAddr) const</td></tr>
<tr class="memdesc:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last unmapped region.  <br /></td></tr>
<tr class="separator:a53ebe1dc48e4f3ef5051c97fb8d44c07 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a8da2cba60c620a2c9d4e60f57fe7a530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a8da2cba60c620a2c9d4e60f57fe7a530">exists</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>) const</td></tr>
<tr class="memdesc:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if element exists.  <br /></td></tr>
<tr class="separator:a8da2cba60c620a2c9d4e60f57fe7a530 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad069dd4df1f86cb36ca5abd79d670f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad069dd4df1f86cb36ca5abd79d670f6e">getOptional</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <br /></td></tr>
<tr class="separator:ad069dd4df1f86cb36ca5abd79d670f6e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad85884652be5225f99a9492e83252b75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad85884652be5225f99a9492e83252b75">getOrDefault</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <br /></td></tr>
<tr class="separator:ad85884652be5225f99a9492e83252b75 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acb61e91bac6aa82b6a5193726799bdf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acb61e91bac6aa82b6a5193726799bdf9">isEmpty</a> () const</td></tr>
<tr class="memdesc:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the container is empty.  <br /></td></tr>
<tr class="separator:acb61e91bac6aa82b6a5193726799bdf9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a017216edaa9c3064857c75fc63c07217"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a017216edaa9c3064857c75fc63c07217">nIntervals</a> () const</td></tr>
<tr class="memdesc:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in the container.  <br /></td></tr>
<tr class="separator:a017216edaa9c3064857c75fc63c07217 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adbf9f66a08580ead37de8f0dd96d575e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a> () const</td></tr>
<tr class="memdesc:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values represented by this container.  <br /></td></tr>
<tr class="separator:adbf9f66a08580ead37de8f0dd96d575e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6e7d3909845b1efa5c5849f60faa3192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6e7d3909845b1efa5c5849f60faa3192">least</a> () const</td></tr>
<tr class="memdesc:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum scalar key.  <br /></td></tr>
<tr class="separator:a6e7d3909845b1efa5c5849f60faa3192 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a385bbee53b2f1ba14ad34af9211f067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a385bbee53b2f1ba14ad34af9211f067d">greatest</a> () const</td></tr>
<tr class="memdesc:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum scalar key.  <br /></td></tr>
<tr class="separator:a385bbee53b2f1ba14ad34af9211f067d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a455ed64c13c1284608dfab1f6fa09ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a455ed64c13c1284608dfab1f6fa09ace">least</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum scalar key.  <br /></td></tr>
<tr class="separator:a455ed64c13c1284608dfab1f6fa09ace inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a63bc9c438221e753ed9a1539b5b14002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a63bc9c438221e753ed9a1539b5b14002">greatest</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum scalar key.  <br /></td></tr>
<tr class="separator:a63bc9c438221e753ed9a1539b5b14002 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af87b09a062b8dd2e7fe64051184fba96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af87b09a062b8dd2e7fe64051184fba96">leastUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> lowerLimit) const</td></tr>
<tr class="memdesc:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-minimum unmapped scalar key.  <br /></td></tr>
<tr class="separator:af87b09a062b8dd2e7fe64051184fba96 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac1dafe332cf7e4e2bc8da2b9993e8f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac1dafe332cf7e4e2bc8da2b9993e8f9c">greatestUnmapped</a> (typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> upperLimit) const</td></tr>
<tr class="memdesc:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the limited-maximum unmapped scalar key.  <br /></td></tr>
<tr class="separator:ac1dafe332cf7e4e2bc8da2b9993e8f9c inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4734abf74cda51aa6252ecfc38342e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> () const</td></tr>
<tr class="memdesc:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of values in this map.  <br /></td></tr>
<tr class="separator:a4734abf74cda51aa6252ecfc38342e93 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2fd736a589e045f795c917a9d16c33d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2fd736a589e045f795c917a9d16c33d2">clear</a> ()</td></tr>
<tr class="memdesc:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the container.  <br /></td></tr>
<tr class="separator:a2fd736a589e045f795c917a9d16c33d2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a797f0a6bd63f8debdcd0ccb2fcecf0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a797f0a6bd63f8debdcd0ccb2fcecf0f3">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;erasure)</td></tr>
<tr class="memdesc:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the specified interval.  <br /></td></tr>
<tr class="separator:a797f0a6bd63f8debdcd0ccb2fcecf0f3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3e96516680b59244ef196a9e885ac0ca"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3e96516680b59244ef196a9e885ac0ca">eraseMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase intervals specified in another <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html" title="An associative container whose keys are non-overlapping intervals.">IntervalMap</a>.  <br /></td></tr>
<tr class="separator:a3e96516680b59244ef196a9e885ac0ca inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1effdf10ccfb80ed11cc999e850ab2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1effdf10ccfb80ed11cc999e850ab2bd">insert</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> value, bool makeHole=true)</td></tr>
<tr class="memdesc:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair.  <br /></td></tr>
<tr class="separator:a1effdf10ccfb80ed11cc999e850ab2bd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_af596a5898489cd4c86320bd5a1aa4307"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#af596a5898489cd4c86320bd5a1aa4307">insertMultiple</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, bool makeHole=true)</td></tr>
<tr class="memdesc:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert values from another container.  <br /></td></tr>
<tr class="separator:af596a5898489cd4c86320bd5a1aa4307 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a775489990d1f4afaba7b7ee94e2e7f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a775489990d1f4afaba7b7ee94e2e7f1d">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a775489990d1f4afaba7b7ee94e2e7f1d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a11a77bbaa8abcabd5f21e3fafd19dafd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a11a77bbaa8abcabd5f21e3fafd19dafd">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a11a77bbaa8abcabd5f21e3fafd19dafd inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2e50f959ecc418c31ccf2fa8a465df80"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2e50f959ecc418c31ccf2fa8a465df80">overlaps</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a2e50f959ecc418c31ccf2fa8a465df80 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aedc79f844559a4d50a71073d40f3c495"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aedc79f844559a4d50a71073d40f3c495">isOverlapping</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:aedc79f844559a4d50a71073d40f3c495 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a28ed971cc7c018a24e1bad32b6a3cd3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a28ed971cc7c018a24e1bad32b6a3cd3d">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="separator:a28ed971cc7c018a24e1bad32b6a3cd3d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac040de688b66d2fd0f96e9e8da36ccb3"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac040de688b66d2fd0f96e9e8da36ccb3">isDistinct</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:ac040de688b66d2fd0f96e9e8da36ccb3 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a968496e5f3ddf732369084e3b9405fb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a968496e5f3ddf732369084e3b9405fb6">contains</a> (<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> key) const</td></tr>
<tr class="separator:a968496e5f3ddf732369084e3b9405fb6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a12776c478c6a1448865aa083fac5a2a4"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a12776c478c6a1448865aa083fac5a2a4">contains</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other) const</td></tr>
<tr class="separator:a12776c478c6a1448865aa083fac5a2a4 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6819a75d74d259b0862b7b48705fcf5a"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6819a75d74d259b0862b7b48705fcf5a">nodes</a> ()</td></tr>
<tr class="memdesc:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a6819a75d74d259b0862b7b48705fcf5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3f1a21b012e0404f2d12167b5444e1ed"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3f1a21b012e0404f2d12167b5444e1ed">nodes</a> () const</td></tr>
<tr class="memdesc:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing nodes.  <br /></td></tr>
<tr class="separator:a3f1a21b012e0404f2d12167b5444e1ed inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a70b9c01a8212eba072916db1d746cc9f"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> ()</td></tr>
<tr class="memdesc:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:a70b9c01a8212eba072916db1d746cc9f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf80f4f896443d489431178d0121b754"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf80f4f896443d489431178d0121b754">values</a> () const</td></tr>
<tr class="memdesc:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for traversing values.  <br /></td></tr>
<tr class="separator:acf80f4f896443d489431178d0121b754 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a87170e7d06eb8710211a65fb9bc052c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a87170e7d06eb8710211a65fb9bc052c6">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a87170e7d06eb8710211a65fb9bc052c6 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a4cdf5d3be3c2b27013876e65f69acd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4cdf5d3be3c2b27013876e65f69acd5d">lowerBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval ends at or above the specified scalar key.  <br /></td></tr>
<tr class="separator:a4cdf5d3be3c2b27013876e65f69acd5d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a56a00171503e761f08e789d07692187e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a56a00171503e761f08e789d07692187e">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a56a00171503e761f08e789d07692187e inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a1f52b31510a0edd7a3a6b99848d66df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a1f52b31510a0edd7a3a6b99848d66df7">upperBound</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first node whose interval begins above the specified scalar key.  <br /></td></tr>
<tr class="separator:a1f52b31510a0edd7a3a6b99848d66df7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ad47a0cae47f4423000356e8a46b5ae33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad47a0cae47f4423000356e8a46b5ae33">operator[]</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:ad47a0cae47f4423000356e8a46b5ae33 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a128f75d742f421056d4497519b1cbc5a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a128f75d742f421056d4497519b1cbc5a">get</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an existing value.  <br /></td></tr>
<tr class="separator:a128f75d742f421056d4497519b1cbc5a inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afd397b582b605adcab6cce46894b7bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afd397b582b605adcab6cce46894b7bc9">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:afd397b582b605adcab6cce46894b7bc9 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a0612b2970067bf6e0c858dfcb9c937a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a0612b2970067bf6e0c858dfcb9c937a2">getOrElse</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7c7ef387287aa01aa632dfeafc121e95">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:a0612b2970067bf6e0c858dfcb9c937a2 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aad53242671f18d795f3b040bdd0d7e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aad53242671f18d795f3b040bdd0d7e49">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:aad53242671f18d795f3b040bdd0d7e49 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab59f19099179c53ab74984bf74855aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab59f19099179c53ab74984bf74855aaa">findPrior</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:ab59f19099179c53ab74984bf74855aaa inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a9d4a318aba4a2a8af2a6a6e3570279a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a9d4a318aba4a2a8af2a6a6e3570279a8">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a9d4a318aba4a2a8af2a6a6e3570279a8 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6675861f9feb70004fe397d1600d466f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6675861f9feb70004fe397d1600d466f">find</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar) const</td></tr>
<tr class="memdesc:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:a6675861f9feb70004fe397d1600d466f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_aa4e9edf0de829a794a10703c21228de0"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#aa4e9edf0de829a794a10703c21228de0">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:aa4e9edf0de829a794a10703c21228de0 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_adfc6016e9440f8dee3e7f37f4dd65aa7"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adfc6016e9440f8dee3e7f37f4dd65aa7">findAll</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:adfc6016e9440f8dee3e7f37f4dd65aa7 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ab5a821909b63dedab54193fbd4a747c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ab5a821909b63dedab54193fbd4a747c5">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:ab5a821909b63dedab54193fbd4a747c5 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a48ef3aaccd8a7cb97c33359be83ca883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a48ef3aaccd8a7cb97c33359be83ca883">findFirstOverlap</a> (const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval) const</td></tr>
<tr class="memdesc:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a48ef3aaccd8a7cb97c33359be83ca883 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a7395c06804302359b2243a6016644e25"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a7395c06804302359b2243a6016644e25">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">IntervalMap::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a7395c06804302359b2243a6016644e25 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ac217c94739290a0c52debdac53020634"><td class="memTemplParams" colspan="2">template&lt;typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ac217c94739290a0c52debdac53020634">findFirstOverlap</a> (typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">IntervalMap::ConstNodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter) const</td></tr>
<tr class="memdesc:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:ac217c94739290a0c52debdac53020634 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a6f05fe11220a1d2c1e75e2fcde5a573d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a6f05fe11220a1d2c1e75e2fcde5a573d">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a6f05fe11220a1d2c1e75e2fcde5a573d inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a3710d6445b86359fc16236d2bb54a8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a3710d6445b86359fc16236d2bb54a8a1">firstFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a3710d6445b86359fc16236d2bb54a8a1 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_afa299225e9e0576bc9944dde4b29d569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#afa299225e9e0576bc9944dde4b29d569">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">NodeIterator</a> start)</td></tr>
<tr class="memdesc:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:afa299225e9e0576bc9944dde4b29d569 inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a747ae7350949b0c59e9d40db1c62286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a747ae7350949b0c59e9d40db1c62286f">bestFit</a> (const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">ConstNodeIterator</a> start) const</td></tr>
<tr class="memdesc:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a747ae7350949b0c59e9d40db1c62286f inherit pub_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1Container_1_1IntervalMap')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;</a></td></tr>
<tr class="memitem:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a2ae4f73131a2d77738a17708a7c1d262"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a2ae4f73131a2d77738a17708a7c1d262">findPriorImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last node whose interval starts at or below the specified scalar key.  <br /></td></tr>
<tr class="separator:a2ae4f73131a2d77738a17708a7c1d262 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_acf352fa4dd63a2476519d74738f026d8"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#acf352fa4dd63a2476519d74738f026d8">findImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;scalar)</td></tr>
<tr class="memdesc:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node containing the specified scalar key.  <br /></td></tr>
<tr class="separator:acf352fa4dd63a2476519d74738f026d8 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a916678d0f4bd8caf5cc70a3f2de287d6"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static boost::iterator_range&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a916678d0f4bd8caf5cc70a3f2de287d6">findAllImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all nodes overlapping the specified interval.  <br /></td></tr>
<tr class="separator:a916678d0f4bd8caf5cc70a3f2de287d6 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a55c31fa3f4ef0c963492c305154aafa3"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a55c31fa3f4ef0c963492c305154aafa3">findFirstOverlapImpl</a> (IMap &amp;imap, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a> &amp;interval)</td></tr>
<tr class="memdesc:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with the specified interval.  <br /></td></tr>
<tr class="separator:a55c31fa3f4ef0c963492c305154aafa3 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a83fd6db343d27ec8461ea48b9440c2a5"><td class="memTemplParams" colspan="2">template&lt;class IMap , typename T2 , class Policy2 &gt; </td></tr>
<tr class="memitem:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a83fd6db343d27ec8461ea48b9440c2a5">findFirstOverlapImpl</a> (IMap &amp;imap, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> thisIter, const <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt; &amp;other, typename <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html">IntervalMap</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval</a>, T2, Policy2 &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">::ConstNodeIterator</a> otherIter)</td></tr>
<tr class="memdesc:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first interval that overlaps with any in another container.  <br /></td></tr>
<tr class="separator:a83fd6db343d27ec8461ea48b9440c2a5 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_ae69e9931f89e2b57d7eccff30bddc3a1"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae69e9931f89e2b57d7eccff30bddc3a1">firstFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> start)</td></tr>
<tr class="memdesc:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:ae69e9931f89e2b57d7eccff30bddc3a1 inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap" id="r_a33a10236237378a3f6e62f501c96fd2d"><td class="memTemplParams" colspan="2">template&lt;class IMap &gt; </td></tr>
<tr class="memitem:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a33a10236237378a3f6e62f501c96fd2d">bestFitImpl</a> (IMap &amp;imap, const typename <a class="el" href="classSawyer_1_1Container_1_1Interval.html#af914f8176843c229013f7434c07f3d9a">Interval::Value</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#adbf9f66a08580ead37de8f0dd96d575e">size</a>, typename <a class="el" href="structSawyer_1_1Container_1_1IntervalMapTraits.html">IntervalMapTraits</a>&lt; IMap &gt;<a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">::NodeIterator</a> start)</td></tr>
<tr class="memdesc:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best fit node at or after a starting point.  <br /></td></tr>
<tr class="separator:a33a10236237378a3f6e62f501c96fd2d inherit pub_static_methods_classSawyer_1_1Container_1_1IntervalMap"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1134be6cf10571edef9ffe6ab06fd7a9" name="a1134be6cf10571edef9ffe6ab06fd7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1134be6cf10571edef9ffe6ab06fd7a9">&#9670;&#160;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::Address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for addresses. </p>
<p>This should be an unsigned type. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01017">1017</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="aa7a7317b6be4502317ab4357b5989660" name="aa7a7317b6be4502317ab4357b5989660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a7317b6be4502317ab4357b5989660">&#9670;&#160;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of data stored in the address space. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01018">1018</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a30140763fdfb3c3c12e8fd6a1dc22ea9" name="a30140763fdfb3c3c12e8fd6a1dc22ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30140763fdfb3c3c12e8fd6a1dc22ea9">&#9670;&#160;</a></span>Segment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressSegment</a>&lt;A, T&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::Segment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of segments stored by this map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01019">1019</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a853b56b98075440d935890ac4f0c0053" name="a853b56b98075440d935890ac4f0c0053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853b56b98075440d935890ac4f0c0053">&#9670;&#160;</a></span>Buffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Buffer.html">Sawyer::Container::Buffer</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::Buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01020">1020</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="af2c9cf858603ecda80b73929ad8fcbc9" name="af2c9cf858603ecda80b73929ad8fcbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c9cf858603ecda80b73929ad8fcbc9">&#9670;&#160;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad3da8180167b02f750f8138e21fea1b8">Super::Node</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::Node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage node containing interval/segment pair. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01021">1021</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a9f7204596756341c0ea7eeadc5d38262" name="a9f7204596756341c0ea7eeadc5d38262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7204596756341c0ea7eeadc5d38262">&#9670;&#160;</a></span>SegmentIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae50e191b16e240244fb48af0232e88ac">Super::ValueIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::SegmentIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over segments in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01022">1022</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="aa852a793027a1c74c097147546910f47" name="aa852a793027a1c74c097147546910f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa852a793027a1c74c097147546910f47">&#9670;&#160;</a></span>ConstSegmentIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a050e4ca3dcf0d65fba2d65b20e9730d9">Super::ConstValueIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::ConstSegmentIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterators over segments in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01023">1023</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a0994c89a6b4a525a52f8f341ae3d28ed" name="a0994c89a6b4a525a52f8f341ae3d28ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0994c89a6b4a525a52f8f341ae3d28ed">&#9670;&#160;</a></span>ConstIntervalIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ae5130ce1b0e59f7bddd6b68f02da3b2e">Super::ConstIntervalIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::ConstIntervalIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over address intervals in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01024">1024</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ac6954614b9b130d841261ad4d2644316" name="ac6954614b9b130d841261ad4d2644316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6954614b9b130d841261ad4d2644316">&#9670;&#160;</a></span>NodeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a643bf7e3b1413a950b3e66bd7244dacb">Super::NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::NodeIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over address interval, segment pairs in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01025">1025</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="abf7a3b18db58eae98d782531b3f155b5" name="abf7a3b18db58eae98d782531b3f155b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7a3b18db58eae98d782531b3f155b5">&#9670;&#160;</a></span>ConstNodeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#ad28df1a69755b5534a2ddb68bd447e61">Super::ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::ConstNodeIterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over address interval/segment pairs in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01026">1026</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e8cd51e41cea7489ea3f78b0d30365c" name="a3e8cd51e41cea7489ea3f78b0d30365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8cd51e41cea7489ea3f78b0d30365c">&#9670;&#160;</a></span>AddressMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::AddressMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty address map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01038">1038</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a2ac1bbe4c8188403070b62fbd6e85fa9" name="a2ac1bbe4c8188403070b62fbd6e85fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac1bbe4c8188403070b62fbd6e85fa9">&#9670;&#160;</a></span>AddressMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::AddressMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyOnWrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>The new address map has the same addresses mapped to the same buffers as the <code>other</code> map. The buffers themselves are not copied since they are reference counted.</p>
<p>If <code>copyOnWrite</code> is set then the buffers are marked so that any subsequent write to that buffer via the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac9e7147002d95c6ae762062e8e0552b9">write</a> method from any <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> object will cause a new copy to be created and used by the <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html" title="A mapping from address space to values.">AddressMap</a> that's doing the writing. One should be careful when buffers are intended to be shared because setting the copy-on-write bit on the buffer will cause the sharing to be broken. For example, if map1 is created and then copied into map2 with the copy-on-write bit cleared, then any writes to the buffer via map1 will be visible when reading from map2 and vice versa. However, if map3 is then created by copying either map1 or map2 with the copy-on-write bit set, then writes to any of the three maps will cause that map to obtain an independent copy of the buffer, effectively removing the sharing that was intended between map1 and map2. Another thing to be aware of is that some buffer types will return a different buffer type when they're copied. For instance, copying a <a class="el" href="classSawyer_1_1Container_1_1StaticBuffer.html">StaticBuffer</a> or <a class="el" href="classSawyer_1_1Container_1_1MappedBuffer.html">MappedBuffer</a> will return an <a class="el" href="classSawyer_1_1Container_1_1AllocatingBuffer.html">AllocatingBuffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01055">1055</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00322">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::values()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82d01f0d9ff8007d7b88039153c2d52d" name="a82d01f0d9ff8007d7b88039153c2d52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d01f0d9ff8007d7b88039153c2d52d">&#9670;&#160;</a></span>require() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::require </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required access bits. </p>
<p>Constrains address to those that have all of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01069">1069</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00239">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::require()</a>.</p>

</div>
</div>
<a id="a84107f87cfb3f3b3cd32a6b3a981f1fb" name="a84107f87cfb3f3b3cd32a6b3a981f1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84107f87cfb3f3b3cd32a6b3a981f1fb">&#9670;&#160;</a></span>require() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::require </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required access bits. </p>
<p>Constrains address to those that have all of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01072">1072</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00239">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::require()</a>.</p>

</div>
</div>
<a id="a45d2f15072209b954e3c055bcacc2e4f" name="a45d2f15072209b954e3c055bcacc2e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d2f15072209b954e3c055bcacc2e4f">&#9670;&#160;</a></span>prohibit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prohibit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: prohibited access bits. </p>
<p>Constrains addresses to those that have none of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01082">1082</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00246">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>.</p>

</div>
</div>
<a id="ab141fc4506bb97d6574b58eeaf782378" name="ab141fc4506bb97d6574b58eeaf782378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab141fc4506bb97d6574b58eeaf782378">&#9670;&#160;</a></span>prohibit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prohibit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: prohibited access bits. </p>
<p>Constrains addresses to those that have none of the access bits that are set in <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01085">1085</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00246">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>.</p>

</div>
</div>
<a id="ae1142607bf87813a913b03189b922b00" name="ae1142607bf87813a913b03189b922b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1142607bf87813a913b03189b922b00">&#9670;&#160;</a></span>access() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::access </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required and prohibited access bits. </p>
<p>Constrains address to those that have the specified access bits. This method is the same as calling <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a> with the specified bit vector, and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">prohibit</a> with the inverted bit vector. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01096">1096</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00253">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::access()</a>.</p>

</div>
</div>
<a id="ab7bc359d2b544bf85a518f65f8f8a5be" name="ab7bc359d2b544bf85a518f65f8f8a5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bc359d2b544bf85a518f65f8f8a5be">&#9670;&#160;</a></span>access() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::access </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: required and prohibited access bits. </p>
<p>Constrains address to those that have the specified access bits. This method is the same as calling <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a> with the specified bit vector, and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">prohibit</a> with the inverted bit vector. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01099">1099</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00253">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::access()</a>.</p>

</div>
</div>
<a id="a7c36dc3dc76f1b7ae01af3e7bd73b85a" name="a7c36dc3dc76f1b7ae01af3e7bd73b85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c36dc3dc76f1b7ae01af3e7bd73b85a">&#9670;&#160;</a></span>substr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: segment name substring. </p>
<p>Constrains addresses to those that belong to a segment that contains string <code>x</code> as part of its name. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01109">1109</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00258">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::substr()</a>.</p>

</div>
</div>
<a id="a5ee094304b7195f71401da1deb75a61c" name="a5ee094304b7195f71401da1deb75a61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee094304b7195f71401da1deb75a61c">&#9670;&#160;</a></span>substr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: segment name substring. </p>
<p>Constrains addresses to those that belong to a segment that contains string <code>x</code> as part of its name. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01112">1112</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00258">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::substr()</a>.</p>

</div>
</div>
<a id="a70820e2d652356ea0b0c4224d2a4a235" name="a70820e2d652356ea0b0c4224d2a4a235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70820e2d652356ea0b0c4224d2a4a235">&#9670;&#160;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchor point. </p>
<p>Constrains addresses to a sequence that begins at <code>x</code>. If address <code>x</code> is not part of the addresses matched by the other constraints, then no address matches. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01123">1123</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00278">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>

</div>
</div>
<a id="aafcbcda4aa2b527f0752ded21f7849ca" name="aafcbcda4aa2b527f0752ded21f7849ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcbcda4aa2b527f0752ded21f7849ca">&#9670;&#160;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchor point. </p>
<p>Constrains addresses to a sequence that begins at <code>x</code>. If address <code>x</code> is not part of the addresses matched by the other constraints, then no address matches. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01126">1126</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00278">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>

</div>
</div>
<a id="a68049818a794cf43306236fdcc9a0499" name="a68049818a794cf43306236fdcc9a0499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68049818a794cf43306236fdcc9a0499">&#9670;&#160;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchored interval. </p>
<p>Constrains addresses so that the lowest or highest matched address is the specified anchor point. When matching constraints in the forward direction (the default) then the anchor must be the lowest address, and when matching in the backward direction the anchor must be the highest address. The direction is specified by an argument to the operation.</p>
<p>For instance:</p>
<div class="fragment"><div class="line">map.at(100).limit(10).read(buf);               <span class="comment">// 1</span></div>
<div class="line">map.at(100).limit(10).read(buf, MATCH_BACKWARD); <span class="comment">// 2</span></div>
</div><!-- fragment --><p>Expression 1 reads up to 10 values such that the lowest value read is at address 100, while expression 2 reads up to 10 values such that the highest value read is at address 100. In both cases, if address 100 is not mapped (or otherwise does not satisfy the constraints) then nothing is read. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01150">1150</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00278">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>

</div>
</div>
<a id="a91afd9bf6d949f6cba433b36b2c21d21" name="a91afd9bf6d949f6cba433b36b2c21d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91afd9bf6d949f6cba433b36b2c21d21">&#9670;&#160;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: anchored interval. </p>
<p>Constrains addresses so that the lowest or highest matched address is the specified anchor point. When matching constraints in the forward direction (the default) then the anchor must be the lowest address, and when matching in the backward direction the anchor must be the highest address. The direction is specified by an argument to the operation.</p>
<p>For instance:</p>
<div class="fragment"><div class="line">map.at(100).limit(10).read(buf);               <span class="comment">// 1</span></div>
<div class="line">map.at(100).limit(10).read(buf, MATCH_BACKWARD); <span class="comment">// 2</span></div>
</div><!-- fragment --><p>Expression 1 reads up to 10 values such that the lowest value read is at address 100, while expression 2 reads up to 10 values such that the highest value read is at address 100. In both cases, if address 100 is not mapped (or otherwise does not satisfy the constraints) then nothing is read. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01153">1153</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00278">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>

</div>
</div>
<a id="ac38bfd2f3963653a29b2c7488225f34b" name="ac38bfd2f3963653a29b2c7488225f34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38bfd2f3963653a29b2c7488225f34b">&#9670;&#160;</a></span>limit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: limit matched size. </p>
<p>Constrains the matched addresses so that at most <code>x</code> addresses match. Forward matching matches the first <code>x</code> addresses while backward matching matches the last <code>x</code> addresses. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01164">1164</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>

</div>
</div>
<a id="a71086ccca75dd0b7cfc677e276a8a2f3" name="a71086ccca75dd0b7cfc677e276a8a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71086ccca75dd0b7cfc677e276a8a2f3">&#9670;&#160;</a></span>limit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: limit matched size. </p>
<p>Constrains the matched addresses so that at most <code>x</code> addresses match. Forward matching matches the first <code>x</code> addresses while backward matching matches the last <code>x</code> addresses. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01167">1167</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>

</div>
</div>
<a id="a4b8c9ef37f66c1fd8b466eb9c31460d7" name="a4b8c9ef37f66c1fd8b466eb9c31460d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8c9ef37f66c1fd8b466eb9c31460d7">&#9670;&#160;</a></span>atOrAfter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01177">1177</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00299">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l00285">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>.</p>

</div>
</div>
<a id="af638e01c5db346116fc31448c9d01671" name="af638e01c5db346116fc31448c9d01671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af638e01c5db346116fc31448c9d01671">&#9670;&#160;</a></span>atOrAfter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01180">1180</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00299">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrAfter()</a>.</p>

</div>
</div>
<a id="ade5a281e1542b9ce6fb5941f451bf129" name="ade5a281e1542b9ce6fb5941f451bf129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a281e1542b9ce6fb5941f451bf129">&#9670;&#160;</a></span>atOrBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01190">1190</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00312">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrBefore()</a>.</p>

</div>
</div>
<a id="aa5852715c72575f5e3d8e50006cc1930" name="aa5852715c72575f5e3d8e50006cc1930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5852715c72575f5e3d8e50006cc1930">&#9670;&#160;</a></span>atOrBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::atOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than or equal to <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01193">1193</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00312">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrBefore()</a>.</p>

</div>
</div>
<a id="a038b598dc4b28efc36d616e651021e3d" name="a038b598dc4b28efc36d616e651021e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038b598dc4b28efc36d616e651021e3d">&#9670;&#160;</a></span>within() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all within the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01203">1203</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00325">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>

</div>
</div>
<a id="a6ae15758d951ac9470757fbd4a854f26" name="a6ae15758d951ac9470757fbd4a854f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae15758d951ac9470757fbd4a854f26">&#9670;&#160;</a></span>within() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all within the specified interval. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01206">1206</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00325">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>

</div>
</div>
<a id="aed07d5c39f1a69b76f0d9375e2f26bc9" name="aed07d5c39f1a69b76f0d9375e2f26bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed07d5c39f1a69b76f0d9375e2f26bc9">&#9670;&#160;</a></span>within() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all greater than or equal to <code>x</code> and less than or equal to <code>y</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01216">1216</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00325">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>

</div>
</div>
<a id="a6d09802303534be37bb2ab2b662c33f8" name="a6d09802303534be37bb2ab2b662c33f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d09802303534be37bb2ab2b662c33f8">&#9670;&#160;</a></span>within() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Constrains matched addresses so they are all greater than or equal to <code>x</code> and less than or equal to <code>y</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01219">1219</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00325">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::within()</a>.</p>

</div>
</div>
<a id="aec124932e7320a78baf6e2cc8c654aa2" name="aec124932e7320a78baf6e2cc8c654aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec124932e7320a78baf6e2cc8c654aa2">&#9670;&#160;</a></span>baseSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::baseSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Specifies lower and upper bounds. The upper bound is specified indirectly by a size. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01229">1229</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00335">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::baseSize()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00704">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::size()</a>.</p>

</div>
</div>
<a id="aefd476001bdac0f00e71a8363a2ae0c8" name="aefd476001bdac0f00e71a8363a2ae0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd476001bdac0f00e71a8363a2ae0c8">&#9670;&#160;</a></span>baseSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::baseSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower and upper bounds. </p>
<p>Specifies lower and upper bounds. The upper bound is specified indirectly by a size. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01232">1232</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00335">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::baseSize()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00704">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::size()</a>.</p>

</div>
</div>
<a id="aa0106cea41e48f180c5916e939384d49" name="aa0106cea41e48f180c5916e939384d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0106cea41e48f180c5916e939384d49">&#9670;&#160;</a></span>after() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01242">1242</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00340">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::after()</a>.</p>

</div>
</div>
<a id="acc8be355c7931c9b00c621247d0f8327" name="acc8be355c7931c9b00c621247d0f8327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8be355c7931c9b00c621247d0f8327">&#9670;&#160;</a></span>after() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address lower bound. </p>
<p>Constrains matched addresses so that they are all greater than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01245">1245</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00340">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::after()</a>.</p>

</div>
</div>
<a id="a1c10facd22691c9068519f5b06166aae" name="a1c10facd22691c9068519f5b06166aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c10facd22691c9068519f5b06166aae">&#9670;&#160;</a></span>before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01255">1255</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00345">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::before()</a>.</p>

</div>
</div>
<a id="abedbc8290efe3e296e0a4ef6dd0ade7d" name="abedbc8290efe3e296e0a4ef6dd0ade7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedbc8290efe3e296e0a4ef6dd0ade7d">&#9670;&#160;</a></span>before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: address upper bound. </p>
<p>Constrains matched addresses so that they are all less than <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01258">1258</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00345">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::before()</a>.</p>

</div>
</div>
<a id="a54070def208a6ef2bc441176a25e1d96" name="a54070def208a6ef2bc441176a25e1d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54070def208a6ef2bc441176a25e1d96">&#9670;&#160;</a></span>singleSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::singleSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: single segment. </p>
<p>Constrains matched addresses so that they all come from the same segment. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01268">1268</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00350">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::singleSegment()</a>.</p>

</div>
</div>
<a id="a410ae4d161493bfb1906b392c45bd601" name="a410ae4d161493bfb1906b392c45bd601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410ae4d161493bfb1906b392c45bd601">&#9670;&#160;</a></span>singleSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::singleSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: single segment. </p>
<p>Constrains matched addresses so that they all come from the same segment. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01271">1271</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00350">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::singleSegment()</a>.</p>

</div>
</div>
<a id="af896378e5b63e968d0c44cfacfa0954b" name="af896378e5b63e968d0c44cfacfa0954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af896378e5b63e968d0c44cfacfa0954b">&#9670;&#160;</a></span>segmentPredicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segmentPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: arbitrary segment constraint. </p>
<p>Constraints matched addresses to those for which the chain of segment predicates return true. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01281">1281</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00357">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::segmentPredicate()</a>.</p>

</div>
</div>
<a id="acfb0089fa00ad1ea3c11a18051f01484" name="acfb0089fa00ad1ea3c11a18051f01484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb0089fa00ad1ea3c11a18051f01484">&#9670;&#160;</a></span>segmentPredicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segmentPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1SegmentPredicate.html">SegmentPredicate</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>, <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: arbitrary segment constraint. </p>
<p>Constraints matched addresses to those for which the chain of segment predicates return true. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01284">1284</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00357">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::segmentPredicate()</a>.</p>

</div>
</div>
<a id="a13a935200e06fbc09262a9f8452465a9" name="a13a935200e06fbc09262a9f8452465a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a935200e06fbc09262a9f8452465a9">&#9670;&#160;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches anything. </p>
<p>The null constraint matches any mapped address. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01294">1294</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ac03d3746419b8e479b502965c60a7e9e" name="ac03d3746419b8e479b502965c60a7e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03d3746419b8e479b502965c60a7e9e">&#9670;&#160;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches anything. </p>
<p>The null constraint matches any mapped address. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01297">1297</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a7630d1cfb2d77700010c13c25ea20120" name="a7630d1cfb2d77700010c13c25ea20120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7630d1cfb2d77700010c13c25ea20120">&#9670;&#160;</a></span>none() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches nothing. </p>
<p>Constrains addresses so that none of them can match. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01307">1307</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00271">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::none()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l00278">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>, <a class="el" href="AddressMap_8h_source.html#l00285">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::at()</a>, <a class="el" href="AddressMap_8h_source.html#l00299">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrAfter()</a>, <a class="el" href="AddressMap_8h_source.html#l00312">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::atOrBefore()</a>, and <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>

</div>
</div>
<a id="a39ae41df44c705df60531d0e2f869caa" name="a39ae41df44c705df60531d0e2f869caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ae41df44c705df60531d0e2f869caa">&#9670;&#160;</a></span>none() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint: matches nothing. </p>
<p>Constrains addresses so that none of them can match. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01310">1310</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00271">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::none()</a>.</p>

</div>
</div>
<a id="a300a26b869a20b7c773f75f7c3d75e04" name="a300a26b869a20b7c773f75f7c3d75e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300a26b869a20b7c773f75f7c3d75e04">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::checkConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check map consistency. </p>
<p>Performs the following consistency checks and throws an <code>std::runtime_error</code> if something is wrong.</p>
<ul>
<li>A segment should not have a null buffer pointer.</li>
</ul>
<ul>
<li>Checks that the buffers of the map are appropriate sizes for the address interval in which they're mapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01322">1322</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00224">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="AddressMap_8h_source.html#l01402">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01700">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>, and <a class="el" href="AddressMap_8h_source.html#l01761">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>

</div>
</div>
<a id="a78c1ef82354f141b3961d957e8728158" name="a78c1ef82354f141b3961d957e8728158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c1ef82354f141b3961d957e8728158">&#9670;&#160;</a></span>nSegments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of segments contained in the map. </p>
<p>Multiple segments may be pointing to the same underlying buffer, and the number of segments is not necessarily the same as the net number of segments inserted and erased. For instance, if a segment is inserted for addresses [0,99] and then a different segment is inserted at [50,59], the map will contain three segments at addresses [0,49], [50,59], and [60,99], although the first and third segment point into different parts of the same buffer. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01347">1347</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00696">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::nIntervals()</a>.</p>

</div>
</div>
<a id="a800770e4dbdb91ad94db36031da25b33" name="a800770e4dbdb91ad94db36031da25b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800770e4dbdb91ad94db36031da25b33">&#9670;&#160;</a></span>segments() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01354">1354</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00322">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::values()</a>.</p>

</div>
</div>
<a id="af598081918a53e58769abf182468da05" name="af598081918a53e58769abf182468da05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af598081918a53e58769abf182468da05">&#9670;&#160;</a></span>segments() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01355">1355</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00322">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::values()</a>.</p>

</div>
</div>
<a id="ad53ebcc9606d5be9a29130e491435345" name="ad53ebcc9606d5be9a29130e491435345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53ebcc9606d5be9a29130e491435345">&#9670;&#160;</a></span>segments() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa852a793027a1c74c097147546910f47">ConstSegmentIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Segments that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of segments that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those segments that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be segments that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having "IAT" as a substring in their name and returns the longest sequence at that position. The sequence is then used to remove execute permission from each segment.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressSegment.html">AddressMap&lt;Address,Value&gt;::Segment</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a30140763fdfb3c3c12e8fd6a1dc22ea9">Segment</a>;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classSawyer_1_1Container_1_1AddressSegment.html">Segment</a> &amp;segment: map.<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">substr</a>(<span class="stringliteral">&quot;IAT&quot;</span>).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a800770e4dbdb91ad94db36031da25b33">segments</a>(MATCH_NONCONTIGUOUS))</div>
<div class="line">    segment.accessibility(segment.accessibility() &amp; ~EXECUTABLE);</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a7c36dc3dc76f1b7ae01af3e7bd73b85a"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">Sawyer::Container::AddressMap::substr</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; substr(const std::string &amp;x) const</div><div class="ttdoc">Constraint: segment name substring.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01109">AddressMap.h:1109</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a800770e4dbdb91ad94db36031da25b33"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a800770e4dbdb91ad94db36031da25b33">Sawyer::Container::AddressMap::segments</a></div><div class="ttdeci">boost::iterator_range&lt; SegmentIterator &gt; segments()</div><div class="ttdoc">Iterator range for all segments.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01354">AddressMap.h:1354</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01378">1378</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a06e9832d3eeccc2daf7b01b3f84233ed" name="a06e9832d3eeccc2daf7b01b3f84233ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e9832d3eeccc2daf7b01b3f84233ed">&#9670;&#160;</a></span>segments() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a9f7204596756341c0ea7eeadc5d38262">SegmentIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::segments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for all segments. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a70b9c01a8212eba072916db1d746cc9f">values</a> method defined in the super class. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01387">1387</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="ac607416127deca39cea3ba026eaa893e" name="ac607416127deca39cea3ba026eaa893e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac607416127deca39cea3ba026eaa893e">&#9670;&#160;</a></span>nodes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for nodes. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#nodes">Vertices and Edges</a> method defined in the super class. See also the overloaded method of the same name that takes a constraint and thus returns only some nodes. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01402">1402</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00306">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::nodes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01322">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="AddressMap_8h_source.html#l01524">Sawyer::Container::AddressMap&lt; A, T &gt;::findNode()</a>, <a class="el" href="AddressMap_8h_source.html#l01521">Sawyer::Container::AddressMap&lt; A, T &gt;::findNode()</a>, and <a class="el" href="AddressMap_8h_source.html#l01761">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>

</div>
</div>
<a id="a7ed0ae63ebdd27bb6894fe85e6fe66c5" name="a7ed0ae63ebdd27bb6894fe85e6fe66c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed0ae63ebdd27bb6894fe85e6fe66c5">&#9670;&#160;</a></span>nodes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator range for nodes. </p>
<p>This is just an alias for the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#nodes">Vertices and Edges</a> method defined in the super class. See also the overloaded method of the same name that takes a constraint and thus returns only some nodes. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01403">1403</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00306">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::nodes()</a>.</p>

</div>
</div>
<a id="ad070947b7a9bb1d13b1040b0877ae9c5" name="ad070947b7a9bb1d13b1040b0877ae9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad070947b7a9bb1d13b1040b0877ae9c5">&#9670;&#160;</a></span>nodes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of interval/segment nodes that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those nodes that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be nodes that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having addresses between 1000 and 2000 and "IAT" as part of their name and prints their address interval and name:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map_1_1Node.html">AddressMap&lt;Address,Value&gt;::Node</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Node</a> &amp;node: map.<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a038b598dc4b28efc36d616e651021e3d">within</a>(1000,2000).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">substr</a>(<span class="stringliteral">&quot;IAT&quot;</span>).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#ac607416127deca39cea3ba026eaa893e">nodes</a>(MATCH_NONCONTIGUOUS))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;segment at &quot;</span> &lt;&lt;node.key() &lt;&lt;<span class="stringliteral">&quot; named &quot;</span> &lt;&lt;node.value().name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a038b598dc4b28efc36d616e651021e3d"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a038b598dc4b28efc36d616e651021e3d">Sawyer::Container::AddressMap::within</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; within(const Sawyer::Container::Interval&lt; Address &gt; &amp;x) const</div><div class="ttdoc">Constraint: address lower and upper bounds.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01203">AddressMap.h:1203</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_ac607416127deca39cea3ba026eaa893e"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#ac607416127deca39cea3ba026eaa893e">Sawyer::Container::AddressMap::nodes</a></div><div class="ttdeci">boost::iterator_range&lt; NodeIterator &gt; nodes()</div><div class="ttdoc">Iterator range for nodes.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01402">AddressMap.h:1402</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_af2c9cf858603ecda80b73929ad8fcbc9"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Sawyer::Container::AddressMap::Node</a></div><div class="ttdeci">Super::Node Node</div><div class="ttdoc">Storage node containing interval/segment pair.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01021">AddressMap.h:1021</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Map_1_1Node_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Map_1_1Node.html">Sawyer::Container::Map::Node</a></div><div class="ttdoc">Type for stored nodes.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2Map_8h_source.html#l00107">Sawyer/Map.h:107</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01426">1426</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a9c76e29df249359dbf6383ce592cb64d" name="a9c76e29df249359dbf6383ce592cb64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c76e29df249359dbf6383ce592cb64d">&#9670;&#160;</a></span>nodes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes that overlap with constraints. </p>
<p>Returns an iterator range for the first longest sequence of interval/segment nodes that all at least partly satisfy the specified constraints. Constraints are always matched at the address level and the return value consists of those nodes that contain at least one matched address. Constraints normally match contiguous addresses, and therefore the returned list will be nodes that are contiguous. Disabling the contiguous constraint with the <code>MATCH_NONCONTIGUOUS</code> flag relaxes the requirement that addresses be contiguous, although it still enforces that the matched interval contains only addresses that satisfy the constraints or addresses that are not mapped.</p>
<p>The following example finds the first sequence of one or more segments having addresses between 1000 and 2000 and "IAT" as part of their name and prints their address interval and name:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map_1_1Node.html">AddressMap&lt;Address,Value&gt;::Node</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#af2c9cf858603ecda80b73929ad8fcbc9">Node</a>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map_1_1Node.html">Node</a> &amp;node: map.<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a038b598dc4b28efc36d616e651021e3d">within</a>(1000,2000).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a7c36dc3dc76f1b7ae01af3e7bd73b85a">substr</a>(<span class="stringliteral">&quot;IAT&quot;</span>).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#ac607416127deca39cea3ba026eaa893e">nodes</a>(MATCH_NONCONTIGUOUS))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;segment at &quot;</span> &lt;&lt;node.key() &lt;&lt;<span class="stringliteral">&quot; named &quot;</span> &lt;&lt;node.value().name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01435">1435</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="af1f8d5e6092f38ec348503421148dd77" name="af1f8d5e6092f38ec348503421148dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f8d5e6092f38ec348503421148dd77">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum or maximum address that satisfies constraints. </p>
<p>This method returns the minimum or maximum address that satisfies the constraints, depending on whether the direction is forward or backward. It is named "next" because it is often used in loops that iterate over addresses. For instance, the following loop iterates over all readable addresses one at a time (there are more efficient ways to do this).</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;Address,Value&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> map = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> a=0; map.atOrAfter(a).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a>(READABLE).<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#af1f8d5e6092f38ec348503421148dd77">next</a>().assignTo(a); ++a) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">if</span> (a == map.<a class="code hl_function" href="classSawyer_1_1Container_1_1Map.html#aecf9fed2ebb64846bb09256376dabea3">hull</a>().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}       </div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1IntervalMap_html_ae27b32aea90cdef93228cd5c978c00ef"><div class="ttname"><a href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Sawyer::Container::IntervalMap::Map</a></div><div class="ttdeci">Container::Map&lt; Interval, Value, IntervalCompare &gt; Map</div><div class="ttdoc">Type of the underlying map.</div><div class="ttdef"><b>Definition</b> <a href="IntervalMap_8h_source.html#l00199">IntervalMap.h:199</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Map_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map&lt; Interval, Value, IntervalCompare &gt;</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Map_html_aecf9fed2ebb64846bb09256376dabea3"><div class="ttname"><a href="classSawyer_1_1Container_1_1Map.html#aecf9fed2ebb64846bb09256376dabea3">Sawyer::Container::Map::hull</a></div><div class="ttdeci">Interval&lt; Key &gt; hull() const</div><div class="ttdoc">Returns the range of keys in this map.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2Map_8h_source.html#l00463">Sawyer/Map.h:463</a></div></div>
</div><!-- fragment --><p>The conditional break at the end of the loop is to handle the case where <code>a</code> is the largest possible address, and incrementing it would result in an overflow back to a smaller address. The <a class="el" href="classSawyer_1_1Container_1_1IntervalMap.html#a4734abf74cda51aa6252ecfc38342e93">hull</a> method returns in constant time, but a slightly faster test (that is also more self-documenting) is:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a == boost::integer_traits&lt;Address&gt;::const_max)</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p>Backward iterating is similar:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;Address,Value&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> map = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> a=map.<a class="code hl_function" href="classSawyer_1_1Container_1_1Map.html#aecf9fed2ebb64846bb09256376dabea3">hull</a>().greatest(); map.atOrBefore(a).require(READABLE).next(MATCH_BACKWARD).assignTo(a); --a) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">if</span> (a == map.<a class="code hl_function" href="classSawyer_1_1Container_1_1Map.html#aecf9fed2ebb64846bb09256376dabea3">hull</a>().least())</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01482">1482</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01512">Sawyer::Container::AddressMap&lt; A, T &gt;::exists()</a>.</p>

</div>
</div>
<a id="a022219388a2d8859eae98f31e675db8d" name="a022219388a2d8859eae98f31e675db8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022219388a2d8859eae98f31e675db8d">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adress interval that satisfies constraints. </p>
<p>Returns the lowest or highest (depending on direction) largest address interval that satisfies the specified constraints. The interval can be contiguous (the default), or it may contain unmapped addresses. In any case, all mapped addresses in the returned interval satisfy the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01496">1496</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="adb9a20f07deebeaacfeb58846102b2df" name="adb9a20f07deebeaacfeb58846102b2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9a20f07deebeaacfeb58846102b2df">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an address exists with the specified constraints. </p>
<p>Checking for existence is just a wrapper around next. For instance, these two statements both check whether the address 1000 exists and has execute permission:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (map.at(1000).require(EXECUTABLE).exists()) ...</div>
<div class="line">if (map.at(1000).require(EXECUTABLE).next()) ...</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01512">1512</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01482">Sawyer::Container::AddressMap&lt; A, T &gt;::next()</a>.</p>

</div>
</div>
<a id="a11968c68b0efd523b24e371bff818613" name="a11968c68b0efd523b24e371bff818613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11968c68b0efd523b24e371bff818613">&#9670;&#160;</a></span>findNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#abf7a3b18db58eae98d782531b3f155b5">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find node containing address. </p>
<p>Finds the node that contains the first (or last, depending on direction) address that satisfies the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01521">1521</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01402">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>.</p>

</div>
</div>
<a id="a164562fd38d476e8c0daf810075b399f" name="a164562fd38d476e8c0daf810075b399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164562fd38d476e8c0daf810075b399f">&#9670;&#160;</a></span>findNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ac6954614b9b130d841261ad4d2644316">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find node containing address. </p>
<p>Finds the node that contains the first (or last, depending on direction) address that satisfies the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01524">1524</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01402">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>.</p>

</div>
</div>
<a id="ac6a44452570a955f6e4d347cdcc9608f" name="ac6a44452570a955f6e4d347cdcc9608f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a44452570a955f6e4d347cdcc9608f">&#9670;&#160;</a></span>unmapped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::unmapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find unmapped interval. </p>
<p>Searches for the lowest (or highest if direction is <code>MATCH_BACKWARD</code>) interval that is not mapped and returns its address and size. The returned interval will not contain addresses that are less than (or greater than) than <code>boundary</code>. If no such unmapped intervals exist then the empty interval is returned.</p>
<p>This method does not use constraints since it searches for addresses that do not exist in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01537">1537</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00569">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::firstUnmapped()</a>, and <a class="el" href="IntervalMap_8h_source.html#l00587">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::lastUnmapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01550">Sawyer::Container::AddressMap&lt; A, T &gt;::findFreeSpace()</a>.</p>

</div>
</div>
<a id="a064c4969b86b4737401da8629fb54092" name="a064c4969b86b4737401da8629fb54092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c4969b86b4737401da8629fb54092">&#9670;&#160;</a></span>findFreeSpace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::findFreeSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt;&#160;</td>
          <td class="paramname"><em>restriction</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt;<a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a>&gt;::whole()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find free space. </p>
<p>Finds a suitable region of unmapped address space in which <code>nValues</code> values can be mapped. The return value is either an address where the values can be mapped, or nothing if no such unmapped region is available. The <code>restriction</code> can be used to restrict which addresses are considered. The return value will have the specified alignment and will be either the lowest or highest possible address depending on whether direction is forward or backward.</p>
<p>This method does not use constraints since it searches for addresses that do not exist in the map. </p>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01550">1550</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00224">Sawyer::Container::Interval&lt; T &gt;::greatest()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>, <a class="el" href="AddressMap_8h_source.html#l01537">Sawyer::Container::AddressMap&lt; A, T &gt;::unmapped()</a>, and <a class="el" href="Interval_8h_source.html#l00191">Sawyer::Container::Interval&lt; T &gt;::whole()</a>.</p>

</div>
</div>
<a id="a895d3400de898b3dd49a7bb7074dcf0e" name="a895d3400de898b3dd49a7bb7074dcf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895d3400de898b3dd49a7bb7074dcf0e">&#9670;&#160;</a></span>traverse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;unsigned, char&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> &amp;map, <span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;unsigned&gt;</a> &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code hl_class" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
<div class="ttc" id="aclassMap_html"><div class="ttname"><a href="classMap.html">Map</a></div><div class="ttdoc">Extends std::map with methods that return optional values.</div><div class="ttdef"><b>Definition</b> <a href="util_2Map_8h_source.html#l00013">util/Map.h:13</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_1_1Visitor_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Sawyer::Container::AddressMap::Visitor</a></div><div class="ttdoc">Base class for traversals.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01602">AddressMap.h:1602</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01632">1632</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a0a8b6e632d09737c2ca035640af3d565" name="a0a8b6e632d09737c2ca035640af3d565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b6e632d09737c2ca035640af3d565">&#9670;&#160;</a></span>traverse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;unsigned, char&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> &amp;map, <span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;unsigned&gt;</a> &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code hl_class" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01643">1643</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a9bd627686043b35501fabb3b89e867a8" name="a9bd627686043b35501fabb3b89e867a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd627686043b35501fabb3b89e867a8">&#9670;&#160;</a></span>traverse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;unsigned, char&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> &amp;map, <span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;unsigned&gt;</a> &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code hl_class" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01653">1653</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a7b9c7d3e990027e75a9dbe45e10841ac" name="a7b9c7d3e990027e75a9dbe45e10841ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9c7d3e990027e75a9dbe45e10841ac">&#9670;&#160;</a></span>traverse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function on each address interval. </p>
<p>The functor is invoked with the following arguments: the memory map and an interval. If the functor returns false then the traversal is terminated. To facilitate the use of function-local types for the functor without requiring the use of explicit template parameters, one may pass a subclass of <a class="el" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> as the functor.</p>
<p>This example shows one way to print the names of segments that overlap with a given interval:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap&lt;unsigned, char&gt;</a> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#ae27b32aea90cdef93228cd5c978c00ef">Map</a>;</div>
<div class="line"><span class="keyword">struct</span>: <a class="code hl_class" href="classSawyer_1_1Container_1_1AddressMap_1_1Visitor.html">Visitor</a> {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Map.html">Map</a> &amp;map, <span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;unsigned&gt;</a> &amp;interval) {</div>
<div class="line">        <span class="keyword">const</span> Map::Segment &amp;segment = map.at(interval.least()).findNode()-&gt;value();</div>
<div class="line">        std::cerr &lt;&lt;<span class="stringliteral">&quot;segment \&quot;&quot;</span> &lt;&lt;segment.name() &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} visitor;</div>
<div class="line"><a class="code hl_class" href="classMap.html">Map</a> map = ...;</div>
<div class="line">Interval&lt;unsigned&gt; where = ...;</div>
<div class="line">map.within(where).traverse(visitor);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01656">1656</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

</div>
</div>
<a id="a3533c4cf1642ffb3a2e0e256c11508fa" name="a3533c4cf1642ffb3a2e0e256c11508fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3533c4cf1642ffb3a2e0e256c11508fa">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the supplied buffer. </p>
<p>Reads data into an array or STL vector according to the specified constraints. If the array is a null pointer then no data is read or copied and the return value indicates what addresses would have been accessed. When the buffer is an STL vector the constraints are augmented by also limiting the number of items accessed; the caller must do that explicitly for arrays. The return value is the interval of addresses that were read.</p>
<p>The constraints are usually curried before the actual read call, as in this example that reads up to 10 values starting at some address and returns the number of values read:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(start).limit(10).read(buf).size();</div>
</div><!-- fragment --><p>The following loop reads and prints all the readable values from a memory map using a large buffer for efficiency:</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buf(1024);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> accessed = map.atOrAfter(a).read(buf)) {</div>
<div class="line">    a = accessed.least();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &amp;v: buf)</div>
<div class="line">        std::cout &lt;&lt;a++ &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;v &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (accessed.greatest()==map.hull().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// to handle case when a++ overflowed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Reading can also be performed backward, such as this example that reads up to ten values such that the last value read is at address 999. The buffer will always contain results in address order, with the first element of the buffer being the value that was read with the lowest address.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(999).limit(10).read(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01700">1700</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l01322">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01723">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>.</p>

</div>
</div>
<a id="aed5b80d240df8d1ba24f7b4712c5f30f" name="aed5b80d240df8d1ba24f7b4712c5f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5b80d240df8d1ba24f7b4712c5f30f">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the supplied buffer. </p>
<p>Reads data into an array or STL vector according to the specified constraints. If the array is a null pointer then no data is read or copied and the return value indicates what addresses would have been accessed. When the buffer is an STL vector the constraints are augmented by also limiting the number of items accessed; the caller must do that explicitly for arrays. The return value is the interval of addresses that were read.</p>
<p>The constraints are usually curried before the actual read call, as in this example that reads up to 10 values starting at some address and returns the number of values read:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(start).limit(10).read(buf).size();</div>
</div><!-- fragment --><p>The following loop reads and prints all the readable values from a memory map using a large buffer for efficiency:</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buf(1024);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_typedef" href="classSawyer_1_1Container_1_1IntervalMap.html#a664961032974fd71f132d8931edd68de">Interval&lt;Address&gt;</a> accessed = map.atOrAfter(a).read(buf)) {</div>
<div class="line">    a = accessed.least();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &amp;v: buf)</div>
<div class="line">        std::cout &lt;&lt;a++ &lt;&lt;<span class="stringliteral">&quot;: &quot;</span> &lt;&lt;v &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (accessed.greatest()==map.hull().greatest())</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// to handle case when a++ overflowed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Reading can also be performed backward, such as this example that reads up to ten values such that the last value read is at address 999. The buffer will always contain results in address order, with the first element of the buffer being the value that was read with the lowest address.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10];</div>
<div class="line"><span class="keywordtype">size_t</span> nRead = map.at(999).limit(10).read(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01723">1723</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01700">Sawyer::Container::AddressMap&lt; A, T &gt;::read()</a>.</p>

</div>
</div>
<a id="ac9e7147002d95c6ae762062e8e0552b9" name="ac9e7147002d95c6ae762062e8e0552b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e7147002d95c6ae762062e8e0552b9">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data from the supplied buffer. </p>
<p>Copies data from an array or STL vector into the underlying address map buffers corresponding to the specified constraints. If the array is a null pointer then no data is written and the return value indicates what addresses would have been accessed. The constraints are agumented by also requiring that the addresses be contiguous and lack the IMMUTABLE bit, and in the case of STL vectors that not more data is written thn what is in the vector. The return value is the interval of addresses that were written.</p>
<p>The Access::IMMUTABLE bit is usually used to indicate that a buffer cannot be modified (for instance, the buffer is memory allocated with read-only access by POSIX <code>mmap</code>).</p>
<p>The constraints are usually curried before the actual read call, as in this example that writes the vector's values into the map at the first writable address greater than or equal to 1000.</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buffer = {...};</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Interval.html">Interval&lt;Address&gt;</a> written = map.atOrAfter(1000).require(WRITABLE).write(buffer);</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Interval_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a></div><div class="ttdoc">Range of values delimited by endpoints.</div><div class="ttdef"><b>Definition</b> <a href="Interval_8h_source.html#l00031">Interval.h:31</a></div></div>
</div><!-- fragment --><p>Writing can also be performed backward, such as this example that writes up to ten values such that the last value written is at address 999. The buffer contains values in their address order.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10] = { ... };</div>
<div class="line"><span class="keywordtype">size_t</span> nWritten = map.at(999).limit(10).write(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01761">1761</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; T &gt;::baseSize()</a>, <a class="el" href="AddressMap_8h_source.html#l01322">Sawyer::Container::AddressMap&lt; A, T &gt;::checkConsistency()</a>, <a class="el" href="Interval_8h_source.html#l00230">Sawyer::Container::Interval&lt; T &gt;::isEmpty()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, <a class="el" href="IntervalMap_8h_source.html#l00331">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::lowerBound()</a>, <a class="el" href="AddressMap_8h_source.html#l01402">Sawyer::Container::AddressMap&lt; A, T &gt;::nodes()</a>, <a class="el" href="AddressMap_8h_source.html#l00246">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::prohibit()</a>, and <a class="el" href="Interval_8h_source.html#l00302">Sawyer::Container::Interval&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l01804">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>

</div>
</div>
<a id="a1a9b85c7265696674312150e69d57999" name="a1a9b85c7265696674312150e69d57999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9b85c7265696674312150e69d57999">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a1134be6cf10571edef9ffe6ab06fd7a9">Address</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data from the supplied buffer. </p>
<p>Copies data from an array or STL vector into the underlying address map buffers corresponding to the specified constraints. If the array is a null pointer then no data is written and the return value indicates what addresses would have been accessed. The constraints are agumented by also requiring that the addresses be contiguous and lack the IMMUTABLE bit, and in the case of STL vectors that not more data is written thn what is in the vector. The return value is the interval of addresses that were written.</p>
<p>The Access::IMMUTABLE bit is usually used to indicate that a buffer cannot be modified (for instance, the buffer is memory allocated with read-only access by POSIX <code>mmap</code>).</p>
<p>The constraints are usually curried before the actual read call, as in this example that writes the vector's values into the map at the first writable address greater than or equal to 1000.</p>
<div class="fragment"><div class="line">std::vector&lt;Value&gt; buffer = {...};</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Interval.html">Interval&lt;Address&gt;</a> written = map.atOrAfter(1000).require(WRITABLE).write(buffer);</div>
</div><!-- fragment --><p>Writing can also be performed backward, such as this example that writes up to ten values such that the last value written is at address 999. The buffer contains values in their address order.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classSawyer_1_1Container_1_1AddressMap.html#aa7a7317b6be4502317ab4357b5989660">Value</a> buf[10] = { ... };</div>
<div class="line"><span class="keywordtype">size_t</span> nWritten = map.at(999).limit(10).write(buf, MATCH_BACKWARD).size();</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01804">1804</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00292">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::limit()</a>, and <a class="el" href="AddressMap_8h_source.html#l01761">Sawyer::Container::AddressMap&lt; A, T &gt;::write()</a>.</p>

</div>
</div>
<a id="a79044a63583ed0fa8cd49c945372d696" name="a79044a63583ed0fa8cd49c945372d696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79044a63583ed0fa8cd49c945372d696">&#9670;&#160;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prune away addresses that match constraints. </p>
<p>Removes all addresses for which the constraints match. The addresses need not be contiguous in memory (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include segments that do not satisfy the constraints (and are not pruned). For instance, to remove all segments that are writable regardless of whether other segments are interspersed:</p>
<div class="fragment"><div class="line">map.require(WRITABLE).contiguous(<span class="keyword">false</span>).prune();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#ab1d024a2128d70727cfce72518a32bfd" title="Keep only addresses that match constraints.">keep</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01821">1821</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00452">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00793">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::erase()</a>, <a class="el" href="IntervalSet_8h_source.html#l00554">Sawyer::Container::IntervalSet&lt; I &gt;::insert()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00236">Sawyer::Container::IntervalSet&lt; I &gt;::intervals()</a>.</p>

</div>
</div>
<a id="ab1d024a2128d70727cfce72518a32bfd" name="ab1d024a2128d70727cfce72518a32bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d024a2128d70727cfce72518a32bfd">&#9670;&#160;</a></span>keep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep only addresses that match constraints. </p>
<p>Keeps only those addresses that satisfy the given constraints, discarding all others. The addresses need not be contiguous (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include segments that do not satisfy the constraints (and are pruned). For instance, to remove all segments that are not writable regardless of whether other segments are interspersed:</p>
<div class="fragment"><div class="line">map.require(WRITABLE).contiguous(<span class="keyword">false</span>).keep();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a79044a63583ed0fa8cd49c945372d696" title="Prune away addresses that match constraints.">prune</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01848">1848</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressMap_8h_source.html#l00452">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00793">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::erase()</a>, <a class="el" href="IntervalSet_8h_source.html#l00554">Sawyer::Container::IntervalSet&lt; I &gt;::insert()</a>, <a class="el" href="IntervalSet_8h_source.html#l00236">Sawyer::Container::IntervalSet&lt; I &gt;::intervals()</a>, and <a class="el" href="IntervalSet_8h_source.html#l00516">Sawyer::Container::IntervalSet&lt; I &gt;::invert()</a>.</p>

</div>
</div>
<a id="a1406ad656e7e800fd01f9d17ccc297a8" name="a1406ad656e7e800fd01f9d17ccc297a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1406ad656e7e800fd01f9d17ccc297a8">&#9670;&#160;</a></span>changeAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class T  = boost::uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">Sawyer::Container::AddressMap</a>&lt; A, T &gt;::changeAccess </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>requiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>prohibitedAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1AddressMapConstraints.html">AddressMapConstraints</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html">AddressMap</a>&lt; A, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1Container.html#a35699ffedb6434460760008486f44237">MatchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change access bits for addresses that match constraints. </p>
<p>For all addresses that satisfy the specified constraints, add the <code>requiredAccess</code> and remove the <code>prohibitedAccess</code> bits. The addresses need not be contiguous (in fact, noncontiguous is the default), and the matching segments need not be consecutive segments. In other words, the interval over which this function operates can include addresses that do not satisfy the constraints and whose access bits are not modified. For instance, to add execute permission and remove write permission for all segments containing the string ".text":</p>
<div class="fragment"><div class="line">map.substr(<span class="stringliteral">&quot;.text&quot;</span>).changeAccess(EXECUTABLE, WRITABLE);</div>
</div><!-- fragment --><p>To set access bits to a specific value, supply the complement as the second argument. The following code changes all addresses between a specified range so that only the READABLE and WRITABLE bits are set and no others:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> newAccess = READABLE | WRITABLE;</div>
<div class="line">map.within(100,200).changeAccess(newAccess, ~newAccess);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AddressMap_8h_source.html#l01882">1882</a> of file <a class="el" href="AddressMap_8h_source.html">AddressMap.h</a>.</p>

<p class="reference">References <a class="el" href="AddressSegment_8h_source.html#l00193">Sawyer::Container::AddressSegment&lt; A, T &gt;::accessibility()</a>, <a class="el" href="AddressMap_8h_source.html#l00452">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::addressConstraints()</a>, <a class="el" href="IntervalMap_8h_source.html#l00861">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::insert()</a>, <a class="el" href="Interval_8h_source.html#l00218">Sawyer::Container::Interval&lt; T &gt;::least()</a>, and <a class="el" href="AddressSegment_8h_source.html#l00183">Sawyer::Container::AddressSegment&lt; A, T &gt;::offset()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AddressMap_8h_source.html">AddressMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
