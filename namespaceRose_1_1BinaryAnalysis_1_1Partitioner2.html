<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Binary function detection. </p>
<p>This namespace consists of two major parts and a number of smaller parts. The major parts are:</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>: The partitioner has two slightly conflated roles. Its primary role is to serve as a database that supports efficient queries for information that are needed during typical binary analysis. As such, it is able to describe functions, basic blocks, static data blocks, memory maps, control flow graphs, address usage maps, and more and has a fairly robust API. Its second role, less important from the view of the end user, is to accumulate the above information in a process known as <em>partitioning</em>.</li>
</ul>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a>: The engine contains the higher-level functionality that drives the process by which information is added to the partitioner, i.e., <em>partitioning</em>. The engine is customized by class derivation, and the base class (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a>) is abstract. </li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html">AllowParallelEdges</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether to allow parallel edges in a graph. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html">DataFlow</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-flow utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html">GraphViz</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for generating and reading <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a> output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html">Modules</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous supporting functions for disassembly. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesElf" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesElf"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesElf.html">ModulesElf</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesElf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utility functions for ELF. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesJvm" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesJvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesJvm.html">ModulesJvm</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesJvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utility functions for JVM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesLinux" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesLinux"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesLinux.html">ModulesLinux</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesLinux"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utilities for Linux. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesM68k" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesM68k"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesM68k.html">ModulesM68k</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesM68k"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utility functions for M68k. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesMips" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesMips"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesMips.html">ModulesMips</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesMips"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utility functions for MIPS. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe.html">ModulesPe</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utilities for PE files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPowerpc" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPowerpc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPowerpc.html">ModulesPowerpc</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPowerpc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utilities for PowerPC. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesX86" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesX86"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesX86.html">ModulesX86</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesX86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassembly and partitioning utilities for Intel x86 and amd64. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html">Precision</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of precision for analysis. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics" id="r_namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics.html">Semantics</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction semantics for the partitioner. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressConfiguration.html">AddressConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> for individual addresses.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html">AddressIntervalParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an address interval.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address usage map.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address usage item.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of virtual address users.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings that control building the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html">BasePartitionerSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings that directly control a partitioner.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic block information.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html">BasicBlockCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for adjusting basic blocks during discovery.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockConfiguration.html">BasicBlockConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information for a basic block.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockError.html">BasicBlockError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html">BasicBlockSemantics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information related to instruction semantics.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic block successor.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgAdjustmentCallback.html">CfgAdjustmentCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for CFG-adjustment callbacks.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgAdjustmentCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgEdge.html">CfgEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph edge.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html">CfgPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path through a control flow graph.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html">CfgVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph vertex.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds configuration information.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data block information.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlockConfiguration.html">DataBlockConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information for a data block.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlockConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlockError.html">DataBlockError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DisassemblerSettings.html">DisassemblerSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings that control the disassembler.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DisassemblerSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for engines driving the partitioner.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a> for specimens containing machine instructions.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a> for Java Virtual Machine (JVM) specimens.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html">EngineSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings for controling the engine behavior.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FileError.html">FileError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes one function.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">FunctionCallGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call information.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionConfiguration.html">FunctionConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information for a function.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionError.html">FunctionError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPaddingMatcher.html">FunctionPaddingMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matching function padding.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPaddingMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPrologueMatcher.html">FunctionPrologueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matching function prologues.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPrologueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Inliner.html">Inliner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary inliner.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Inliner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1InstructionMatcher.html">InstructionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matching an instruction pattern.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1InstructionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1LoaderSettings.html">LoaderSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings for loading specimens.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1LoaderSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions instructions into basic blocks and functions.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html">PartitionerSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings that control the engine partitioning.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PlaceholderError.html">PlaceholderError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html">Reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html" title="Reference to a function, basic block, instruction, or address.">Reference</a> to a function, basic block, instruction, or address.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for thunk detectors.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html">ThunkPredicates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of thunk predicates.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Trigger.html">Trigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Trigger.html" title="Trigger based on number of times called.">Trigger</a> based on number of times called.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae227a7c4cae4b57dc31f0dbbfaac051c" id="r_ae227a7c4cae4b57dc31f0dbbfaac051c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a> &gt;</td></tr>
<tr class="memdesc:ae227a7c4cae4b57dc31f0dbbfaac051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownersip pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a>.  <br /></td></tr>
<tr class="separator:ae227a7c4cae4b57dc31f0dbbfaac051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de8cd858d089760eb1e1253e4ea045" id="r_ab1de8cd858d089760eb1e1253e4ea045"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">BasicBlockCallbackPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html">BasicBlockCallback</a> &gt;</td></tr>
<tr class="memdesc:ab1de8cd858d089760eb1e1253e4ea045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:ab1de8cd858d089760eb1e1253e4ea045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7595093daccb663b9934aa6264656473" id="r_a7595093daccb663b9934aa6264656473"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">BasicBlockSuccessors</a> = std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a> &gt;</td></tr>
<tr class="memdesc:a7595093daccb663b9934aa6264656473"><td class="mdescLeft">&#160;</td><td class="mdescRight">All successors in no particular order.  <br /></td></tr>
<tr class="separator:a7595093daccb663b9934aa6264656473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ae81db0c94017acd9a2d94c5c41f04" id="r_a89ae81db0c94017acd9a2d94c5c41f04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> = <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html">CfgVertex</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgEdge.html">CfgEdge</a> &gt;</td></tr>
<tr class="memdesc:a89ae81db0c94017acd9a2d94c5c41f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph.  <br /></td></tr>
<tr class="separator:a89ae81db0c94017acd9a2d94c5c41f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d95e808e98c66e47216bd15f405718" id="r_aa7d95e808e98c66e47216bd15f405718"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a> &gt;</td></tr>
<tr class="memdesc:aa7d95e808e98c66e47216bd15f405718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a>.  <br /></td></tr>
<tr class="separator:aa7d95e808e98c66e47216bd15f405718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0297052d619e690d7c3566b57c4eb" id="r_ae3c0297052d619e690d7c3566b57c4eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &gt;</td></tr>
<tr class="memdesc:ae3c0297052d619e690d7c3566b57c4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a>.  <br /></td></tr>
<tr class="separator:ae3c0297052d619e690d7c3566b57c4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09434c6e84f43282c892a559b18da7d4" id="r_a09434c6e84f43282c892a559b18da7d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">EngineBinaryPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a> &gt;</td></tr>
<tr class="memdesc:a09434c6e84f43282c892a559b18da7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a>.  <br /></td></tr>
<tr class="separator:a09434c6e84f43282c892a559b18da7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7e6f19ab285addbe8be2111869eb1f" id="r_acd7e6f19ab285addbe8be2111869eb1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#acd7e6f19ab285addbe8be2111869eb1f">EngineJvmPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> &gt;</td></tr>
<tr class="memdesc:acd7e6f19ab285addbe8be2111869eb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a>.  <br /></td></tr>
<tr class="separator:acd7e6f19ab285addbe8be2111869eb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80531f2b8cbb5250b1a0813b4abb3584" id="r_a80531f2b8cbb5250b1a0813b4abb3584"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html">Function</a> &gt;</td></tr>
<tr class="memdesc:a80531f2b8cbb5250b1a0813b4abb3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classFunction.html">Function</a>.  <br /></td></tr>
<tr class="separator:a80531f2b8cbb5250b1a0813b4abb3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c6a30b832738a71f9884b0bc6aabc" id="r_a252c6a30b832738a71f9884b0bc6aabc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Functions</a> = <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; rose_addr_t, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;</td></tr>
<tr class="memdesc:a252c6a30b832738a71f9884b0bc6aabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from address to function.  <br /></td></tr>
<tr class="separator:a252c6a30b832738a71f9884b0bc6aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175cf54eba5910f765929bfd48d46eb8" id="r_a175cf54eba5910f765929bfd48d46eb8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a175cf54eba5910f765929bfd48d46eb8">FunctionPaddingMatcherPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPaddingMatcher.html">FunctionPaddingMatcher</a> &gt;</td></tr>
<tr class="memdesc:a175cf54eba5910f765929bfd48d46eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:a175cf54eba5910f765929bfd48d46eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b33641b1367157839de7546737ae099" id="r_a3b33641b1367157839de7546737ae099"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">FunctionPrologueMatcherPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPrologueMatcher.html">FunctionPrologueMatcher</a> &gt;</td></tr>
<tr class="memdesc:a3b33641b1367157839de7546737ae099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:a3b33641b1367157839de7546737ae099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d20f1665ce8329b95f8fae0e33a8422" id="r_a9d20f1665ce8329b95f8fae0e33a8422"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9d20f1665ce8329b95f8fae0e33a8422">FunctionSet</a> = <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;</td></tr>
<tr class="memdesc:a9d20f1665ce8329b95f8fae0e33a8422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of functions.  <br /></td></tr>
<tr class="separator:a9d20f1665ce8329b95f8fae0e33a8422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30252e56f3ed8c058c29b65be2f92b83" id="r_a30252e56f3ed8c058c29b65be2f92b83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> &gt;</td></tr>
<tr class="memdesc:a30252e56f3ed8c058c29b65be2f92b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>.  <br /></td></tr>
<tr class="separator:a30252e56f3ed8c058c29b65be2f92b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461d763e33e7cf0364b64e0af0c267a0" id="r_a461d763e33e7cf0364b64e0af0c267a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> &gt;</td></tr>
<tr class="memdesc:a461d763e33e7cf0364b64e0af0c267a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>.  <br /></td></tr>
<tr class="separator:a461d763e33e7cf0364b64e0af0c267a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07949625915032b8fb8e94219ec1c86" id="r_ac07949625915032b8fb8e94219ec1c86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac07949625915032b8fb8e94219ec1c86">ReferenceSet</a> = std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html">Reference</a> &gt;</td></tr>
<tr class="memdesc:ac07949625915032b8fb8e94219ec1c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of references.  <br /></td></tr>
<tr class="separator:ac07949625915032b8fb8e94219ec1c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290cbfd543686205aeeba62d70b8aace" id="r_a290cbfd543686205aeeba62d70b8aace"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a290cbfd543686205aeeba62d70b8aace">CrossReferences</a> = <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html">Reference</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac07949625915032b8fb8e94219ec1c86">ReferenceSet</a> &gt;</td></tr>
<tr class="memdesc:a290cbfd543686205aeeba62d70b8aace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross references.  <br /></td></tr>
<tr class="separator:a290cbfd543686205aeeba62d70b8aace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5314166bb1791357eac01fc00f72fc55" id="r_a5314166bb1791357eac01fc00f72fc55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html">ThunkPredicates</a> &gt;</td></tr>
<tr class="memdesc:a5314166bb1791357eac01fc00f72fc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html">ThunkPredicates</a>.  <br /></td></tr>
<tr class="separator:a5314166bb1791357eac01fc00f72fc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ca0af83aad7ce4d9dcf42a322c9cbf" id="r_aa2ca0af83aad7ce4d9dcf42a322c9cbf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; rose_addr_t, ControlFlowGraph::VertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa2ca0af83aad7ce4d9dcf42a322c9cbf">CfgVertexIndex</a></td></tr>
<tr class="memdesc:aa2ca0af83aad7ce4d9dcf42a322c9cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from basic block starting address to CFG vertex.  <br /></td></tr>
<tr class="separator:aa2ca0af83aad7ce4d9dcf42a322c9cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779f94969e75f3365fcf4ea2f8369dc2" id="r_a779f94969e75f3365fcf4ea2f8369dc2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorBiMap.html">Sawyer::Container::GraphIteratorBiMap</a>&lt; ControlFlowGraph::ConstVertexIterator, ControlFlowGraph::ConstVertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a></td></tr>
<tr class="memdesc:a779f94969e75f3365fcf4ea2f8369dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> vertices from one CFG to another CFG and vice versa.  <br /></td></tr>
<tr class="separator:a779f94969e75f3365fcf4ea2f8369dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76391af9e1a278b1b126107a5785724a" id="r_a76391af9e1a278b1b126107a5785724a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a76391af9e1a278b1b126107a5785724a">ThunkPredicate</a>) (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a76391af9e1a278b1b126107a5785724a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> signature for finding thunks.  <br /></td></tr>
<tr class="separator:a76391af9e1a278b1b126107a5785724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aab861479561d92ac3f1e2abdeffc2f95" id="r_aab861479561d92ac3f1e2abdeffc2f95"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; ControlFlowGraph::VertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aab861479561d92ac3f1e2abdeffc2f95">CfgVertexList</a></td></tr>
<tr class="memdesc:aab861479561d92ac3f1e2abdeffc2f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of CFG vertex pointers.  <br /></td></tr>
<tr class="separator:aab861479561d92ac3f1e2abdeffc2f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e380297ce5469b011147565f033c371" id="r_a1e380297ce5469b011147565f033c371"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; ControlFlowGraph::ConstVertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1e380297ce5469b011147565f033c371">CfgConstVertexList</a></td></tr>
<tr class="memdesc:a1e380297ce5469b011147565f033c371"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of CFG vertex pointers.  <br /></td></tr>
<tr class="separator:a1e380297ce5469b011147565f033c371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2e08f98142f554fa9a70edb2a670ffd1" id="r_a2e08f98142f554fa9a70edb2a670ffd1"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; ControlFlowGraph::EdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a2e08f98142f554fa9a70edb2a670ffd1">CfgEdgeList</a></td></tr>
<tr class="memdesc:a2e08f98142f554fa9a70edb2a670ffd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of CFG edge pointers.  <br /></td></tr>
<tr class="separator:a2e08f98142f554fa9a70edb2a670ffd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21262ca68805c755bcbb2703755e9cd" id="r_ab21262ca68805c755bcbb2703755e9cd"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab21262ca68805c755bcbb2703755e9cd">CfgConstEdgeList</a></td></tr>
<tr class="memdesc:ab21262ca68805c755bcbb2703755e9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of CFG edge pointers.  <br /></td></tr>
<tr class="separator:ab21262ca68805c755bcbb2703755e9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad9e669152fce302f670608026e641df7" id="r_ad9e669152fce302f670608026e641df7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt; ControlFlowGraph::VertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ad9e669152fce302f670608026e641df7">CfgVertexSet</a></td></tr>
<tr class="memdesc:ad9e669152fce302f670608026e641df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of CFG vertex pointers.  <br /></td></tr>
<tr class="separator:ad9e669152fce302f670608026e641df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7d20f5b9234df626c576eb2279ce4e" id="r_abe7d20f5b9234df626c576eb2279ce4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt; ControlFlowGraph::ConstVertexIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a></td></tr>
<tr class="memdesc:abe7d20f5b9234df626c576eb2279ce4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of CFG vertex pointers.  <br /></td></tr>
<tr class="separator:abe7d20f5b9234df626c576eb2279ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac609d02f7190a512292210593a97db33" id="r_ac609d02f7190a512292210593a97db33"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt; ControlFlowGraph::EdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac609d02f7190a512292210593a97db33">CfgEdgeSet</a></td></tr>
<tr class="memdesc:ac609d02f7190a512292210593a97db33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of CFG edge pointers.  <br /></td></tr>
<tr class="separator:ac609d02f7190a512292210593a97db33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630831dc80c819aec7ae3ae31ea5149" id="r_a9630831dc80c819aec7ae3ae31ea5149"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt; ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a></td></tr>
<tr class="memdesc:a9630831dc80c819aec7ae3ae31ea5149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of CFG edge pointers.  <br /></td></tr>
<tr class="separator:a9630831dc80c819aec7ae3ae31ea5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aec4f331fd4ff97ca588f50435cd0b797" id="r_aec4f331fd4ff97ca588f50435cd0b797"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797">VertexType</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a443b7ff922a8607fd07162a87e0c5b7d">V_BASIC_BLOCK</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a52373ac58f9dd1394d939f8ba3de4cea">V_UNDISCOVERED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a8c41e56b594be1074f159dc7d2d29f42">V_INDETERMINATE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797aedb78bf04ed6f85a182dc01ca2fdee1e">V_NONEXISTING</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a18b509ae536cf7077191bec9fe4b1214">V_USER_DEFINED</a>
<br />
 }</td></tr>
<tr class="memdesc:aec4f331fd4ff97ca588f50435cd0b797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioner control flow vertex types.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797">More...</a><br /></td></tr>
<tr class="separator:aec4f331fd4ff97ca588f50435cd0b797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c65d98b5dc4b8b62b640a77af63f6a9" id="r_a8c65d98b5dc4b8b62b640a77af63f6a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a> = 0x00000001
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> = 0x00000002
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6">E_FUNCTION_RETURN</a> = 0x00000004
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> = 0x00000008
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5">E_FUNCTION_XFER</a> = 0x00000010
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af5349e3eb9ad0f639ca34300977eec44">E_USER_DEFINED</a> = 0x00000020
<br />
 }</td></tr>
<tr class="memdesc:a8c65d98b5dc4b8b62b640a77af63f6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioner control flow edge types.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">More...</a><br /></td></tr>
<tr class="separator:a8c65d98b5dc4b8b62b640a77af63f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe96c83c4b19e6723fc7e63c05643d3" id="r_a8fe96c83c4b19e6723fc7e63c05643d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Confidence</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc">ASSUMED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a3fa9e2e343b016021efbd45842ad84ef">PROVED</a>
<br />
 }</td></tr>
<tr class="memdesc:a8fe96c83c4b19e6723fc7e63c05643d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">How sure are we of something.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">More...</a><br /></td></tr>
<tr class="separator:a8fe96c83c4b19e6723fc7e63c05643d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadadf7e7180c2ad4b04995fa7f4df7c5" id="r_aadadf7e7180c2ad4b04995fa7f4df7c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5a4da3d025c1c3ba7b3b186da4246e34b3">LIST_BASED_MEMORY</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5aaa673358a7dd8e6a98fdbf9e58950afc">MAP_BASED_MEMORY</a>
<br />
 }</td></tr>
<tr class="memdesc:aadadf7e7180c2ad4b04995fa7f4df7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Organization of semantic memory.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">More...</a><br /></td></tr>
<tr class="separator:aadadf7e7180c2ad4b04995fa7f4df7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a791307e5ce17914d6e081a63a4d049" id="r_a1a791307e5ce17914d6e081a63a4d049"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049">MemoryDataAdjustment</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049aea97871405cf6e1c1e9ae9b439a89fa6">DATA_IS_CONSTANT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049a6fbcb498a180728fc7b4bd30d7255d92">DATA_IS_INITIALIZED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049a26b7a99ee9e65a7c1788c3e398722e4d">DATA_NO_CHANGE</a>
<br />
 }</td></tr>
<tr class="memdesc:a1a791307e5ce17914d6e081a63a4d049"><td class="mdescLeft">&#160;</td><td class="mdescRight">How the partitioner should globally treat memory.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049">More...</a><br /></td></tr>
<tr class="separator:a1a791307e5ce17914d6e081a63a4d049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8f796bc37a7b105a0c092ccfec084" id="r_abdc8f796bc37a7b105a0c092ccfec084"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084">FunctionReturnAnalysis</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084a1f5cdbd3e1d558964eca20747aacabbd">MAYRETURN_DEFAULT_YES</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084ae45b718b7c7e1beae7c037df11366aad">MAYRETURN_DEFAULT_NO</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084a2f3e6735c0cbc230cef4cb7fb6de7705">MAYRETURN_ALWAYS_YES</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084a19d87061fe1c1c3d9ba562d8fa16ec3d">MAYRETURN_ALWAYS_NO</a>
<br />
 }</td></tr>
<tr class="memdesc:abdc8f796bc37a7b105a0c092ccfec084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether the function may-return analysis runs.  <a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084">More...</a><br /></td></tr>
<tr class="separator:abdc8f796bc37a7b105a0c092ccfec084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad7ad7ba0c7e791509eb676c33f289e09" id="r_ad7ad7ba0c7e791509eb676c33f289e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ad7ad7ba0c7e791509eb676c33f289e09">findPathReachableEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;graph, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:ad7ad7ba0c7e791509eb676c33f289e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find edges that are reachable.  <br /></td></tr>
<tr class="separator:ad7ad7ba0c7e791509eb676c33f289e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991c34cf44432aba34056d8d14c7b5a3" id="r_a991c34cf44432aba34056d8d14c7b5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a991c34cf44432aba34056d8d14c7b5a3">findPathUnreachableEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;graph, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:a991c34cf44432aba34056d8d14c7b5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find edges that are unreachable.  <br /></td></tr>
<tr class="separator:a991c34cf44432aba34056d8d14c7b5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99124dd8446bff0e10bb40fcdc10d509" id="r_a99124dd8446bff0e10bb40fcdc10d509"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a99124dd8446bff0e10bb40fcdc10d509">eraseUnreachablePaths</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;graph, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html">CfgPath</a> &amp;path)</td></tr>
<tr class="memdesc:a99124dd8446bff0e10bb40fcdc10d509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges and vertices that cannot be on the paths.  <br /></td></tr>
<tr class="separator:a99124dd8446bff0e10bb40fcdc10d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996ca2ab4bc79d0ce391c7c900e69afb" id="r_a996ca2ab4bc79d0ce391c7c900e69afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a996ca2ab4bc79d0ce391c7c900e69afb">findPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:a996ca2ab4bc79d0ce391c7c900e69afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths.  <br /></td></tr>
<tr class="separator:a996ca2ab4bc79d0ce391c7c900e69afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc16d4524d790b543570ad40a70ccab" id="r_a5bc16d4524d790b543570ad40a70ccab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5bc16d4524d790b543570ad40a70ccab">findPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:a5bc16d4524d790b543570ad40a70ccab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths.  <br /></td></tr>
<tr class="separator:a5bc16d4524d790b543570ad40a70ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f1a29e16a1c931de0fb940a4d80ee3" id="r_ae6f1a29e16a1c931de0fb940a4d80ee3"><td class="memItemLeft" align="right" valign="top"><a id="ae6f1a29e16a1c931de0fb940a4d80ee3" name="ae6f1a29e16a1c931de0fb940a4d80ee3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html">CfgPath</a> &amp;path)</td></tr>
<tr class="separator:ae6f1a29e16a1c931de0fb940a4d80ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5659a025c20f1f4efa4ee5f2592efa" id="r_a6e5659a025c20f1f4efa4ee5f2592efa"><td class="memItemLeft" align="right" valign="top"><a id="a6e5659a025c20f1f4efa4ee5f2592efa" name="a6e5659a025c20f1f4efa4ee5f2592efa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortEdgesBySrc</b> (const ControlFlowGraph::ConstEdgeIterator &amp;, const ControlFlowGraph::ConstEdgeIterator &amp;)</td></tr>
<tr class="memdesc:a6e5659a025c20f1f4efa4ee5f2592efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort edges by source vertex address. <br /></td></tr>
<tr class="separator:a6e5659a025c20f1f4efa4ee5f2592efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69679bb2aec664771c0b2a9004cb0795" id="r_a69679bb2aec664771c0b2a9004cb0795"><td class="memItemLeft" align="right" valign="top"><a id="a69679bb2aec664771c0b2a9004cb0795" name="a69679bb2aec664771c0b2a9004cb0795"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortEdgesByDst</b> (const ControlFlowGraph::ConstEdgeIterator &amp;, const ControlFlowGraph::ConstEdgeIterator &amp;)</td></tr>
<tr class="memdesc:a69679bb2aec664771c0b2a9004cb0795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort edges by target vertex address. <br /></td></tr>
<tr class="separator:a69679bb2aec664771c0b2a9004cb0795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade86f53354c4eb5f09953693d3b425c6" id="r_ade86f53354c4eb5f09953693d3b425c6"><td class="memItemLeft" align="right" valign="top"><a id="ade86f53354c4eb5f09953693d3b425c6" name="ade86f53354c4eb5f09953693d3b425c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortEdgesById</b> (const ControlFlowGraph::ConstEdgeIterator &amp;, const ControlFlowGraph::ConstEdgeIterator &amp;)</td></tr>
<tr class="memdesc:ade86f53354c4eb5f09953693d3b425c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort edges by edge ID number. <br /></td></tr>
<tr class="separator:ade86f53354c4eb5f09953693d3b425c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762a4435dae0a6f88e399b46595f7608" id="r_a762a4435dae0a6f88e399b46595f7608"><td class="memItemLeft" align="right" valign="top"><a id="a762a4435dae0a6f88e399b46595f7608" name="a762a4435dae0a6f88e399b46595f7608"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortVerticesByAddress</b> (const ControlFlowGraph::ConstVertexIterator &amp;, const ControlFlowGraph::ConstVertexIterator &amp;)</td></tr>
<tr class="memdesc:a762a4435dae0a6f88e399b46595f7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort vertices by address. <br /></td></tr>
<tr class="separator:a762a4435dae0a6f88e399b46595f7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8350773205f0a6c3b1d918add0348e4e" id="r_a8350773205f0a6c3b1d918add0348e4e"><td class="memItemLeft" align="right" valign="top"><a id="a8350773205f0a6c3b1d918add0348e4e" name="a8350773205f0a6c3b1d918add0348e4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortVerticesById</b> (const ControlFlowGraph::ConstVertexIterator &amp;, const ControlFlowGraph::ConstVertexIterator &amp;)</td></tr>
<tr class="memdesc:a8350773205f0a6c3b1d918add0348e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort vertices by vertex ID number. <br /></td></tr>
<tr class="separator:a8350773205f0a6c3b1d918add0348e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e14aba4e830ccb3528aaf0f266aef" id="r_a935e14aba4e830ccb3528aaf0f266aef"><td class="memItemLeft" align="right" valign="top"><a id="a935e14aba4e830ccb3528aaf0f266aef" name="a935e14aba4e830ccb3528aaf0f266aef"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const ControlFlowGraph::Vertex &amp;)</td></tr>
<tr class="memdesc:a935e14aba4e830ccb3528aaf0f266aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print control flow graph vertex. <br /></td></tr>
<tr class="separator:a935e14aba4e830ccb3528aaf0f266aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7225589ee57b7401daa27e488bd46896" id="r_a7225589ee57b7401daa27e488bd46896"><td class="memItemLeft" align="right" valign="top"><a id="a7225589ee57b7401daa27e488bd46896" name="a7225589ee57b7401daa27e488bd46896"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const ControlFlowGraph::Edge &amp;)</td></tr>
<tr class="memdesc:a7225589ee57b7401daa27e488bd46896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print control flow graph edge. <br /></td></tr>
<tr class="separator:a7225589ee57b7401daa27e488bd46896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b73d37f5debcff96499b44d028127d0" id="r_a1b73d37f5debcff96499b44d028127d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1b73d37f5debcff96499b44d028127d0">insertCfg</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;dst, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;src, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap)</td></tr>
<tr class="memdesc:a1b73d37f5debcff96499b44d028127d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert one control flow graph into another.  <br /></td></tr>
<tr class="separator:a1b73d37f5debcff96499b44d028127d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27ee4f33152b1cb359aad2619667e2e" id="r_ae27ee4f33152b1cb359aad2619667e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae27ee4f33152b1cb359aad2619667e2e">findBackEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg, const ControlFlowGraph::ConstVertexIterator &amp;begin)</td></tr>
<tr class="memdesc:ae27ee4f33152b1cb359aad2619667e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find back edges.  <br /></td></tr>
<tr class="separator:ae27ee4f33152b1cb359aad2619667e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764755074de6fb8b5f457d8cc1ef5066" id="r_a764755074de6fb8b5f457d8cc1ef5066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a764755074de6fb8b5f457d8cc1ef5066">findCallEdges</a> (const ControlFlowGraph::ConstVertexIterator &amp;callSite)</td></tr>
<tr class="memdesc:a764755074de6fb8b5f457d8cc1ef5066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find function call edges.  <br /></td></tr>
<tr class="separator:a764755074de6fb8b5f457d8cc1ef5066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9488743ebe901043208e5fb71045dcc" id="r_ae9488743ebe901043208e5fb71045dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae9488743ebe901043208e5fb71045dcc">findCalledFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg, const ControlFlowGraph::ConstVertexIterator &amp;callSite)</td></tr>
<tr class="memdesc:ae9488743ebe901043208e5fb71045dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find called functions.  <br /></td></tr>
<tr class="separator:ae9488743ebe901043208e5fb71045dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200ccd907c5f4ca6f47518e906453b6" id="r_a4200ccd907c5f4ca6f47518e906453b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a4200ccd907c5f4ca6f47518e906453b6">findFunctionReturns</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg, const ControlFlowGraph::ConstVertexIterator &amp;beginVertex)</td></tr>
<tr class="memdesc:a4200ccd907c5f4ca6f47518e906453b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all function return vertices.  <br /></td></tr>
<tr class="separator:a4200ccd907c5f4ca6f47518e906453b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce95b16a860802a8f9dd679b4b7ee02" id="r_adce95b16a860802a8f9dd679b4b7ee02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#adce95b16a860802a8f9dd679b4b7ee02">eraseEdges</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;toErase)</td></tr>
<tr class="memdesc:adce95b16a860802a8f9dd679b4b7ee02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase multiple edges.  <br /></td></tr>
<tr class="separator:adce95b16a860802a8f9dd679b4b7ee02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a560bf4d011af5876bdde8b0675b09b" id="r_a2a560bf4d011af5876bdde8b0675b09b"><td class="memItemLeft" align="right" valign="top"><a id="a2a560bf4d011af5876bdde8b0675b09b" name="a2a560bf4d011af5876bdde8b0675b09b"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findIncidentVertices</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;)</td></tr>
<tr class="memdesc:a2a560bf4d011af5876bdde8b0675b09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertices that are incident to specified edges. <br /></td></tr>
<tr class="separator:a2a560bf4d011af5876bdde8b0675b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f20b9c066d754a766ae3adf82bad3" id="r_a141f20b9c066d754a766ae3adf82bad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a141f20b9c066d754a766ae3adf82bad3">forwardMapped</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;)</td></tr>
<tr class="memdesc:a141f20b9c066d754a766ae3adf82bad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return corresponding iterators.  <br /></td></tr>
<tr class="separator:a141f20b9c066d754a766ae3adf82bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92949274a2a50a1c215ea5a61600e45" id="r_ab92949274a2a50a1c215ea5a61600e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab92949274a2a50a1c215ea5a61600e45">reverseMapped</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;)</td></tr>
<tr class="memdesc:ab92949274a2a50a1c215ea5a61600e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return corresponding iterators.  <br /></td></tr>
<tr class="separator:ab92949274a2a50a1c215ea5a61600e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff695c3f80a34774d151f5642a737f" id="r_a5eff695c3f80a34774d151f5642a737f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5eff695c3f80a34774d151f5642a737f">expandFunctionReturnEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg)</td></tr>
<tr class="memdesc:a5eff695c3f80a34774d151f5642a737f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite function return edges.  <br /></td></tr>
<tr class="separator:a5eff695c3f80a34774d151f5642a737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482717ed73ec351ee764982431c85c4" id="r_ae482717ed73ec351ee764982431c85c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae482717ed73ec351ee764982431c85c4">functionCfgByErasure</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;gcfg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, ControlFlowGraph::VertexIterator &amp;entry)</td></tr>
<tr class="memdesc:ae482717ed73ec351ee764982431c85c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a function control flow graph.  <br /></td></tr>
<tr class="separator:ae482717ed73ec351ee764982431c85c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10c4c068707efe580c792cf693ef63" id="r_a5d10c4c068707efe580c792cf693ef63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5d10c4c068707efe580c792cf693ef63">functionCfgByReachability</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;gcfg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, const ControlFlowGraph::ConstVertexIterator &amp;gcfgEntry)</td></tr>
<tr class="memdesc:a5d10c4c068707efe580c792cf693ef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a function control flow graph.  <br /></td></tr>
<tr class="separator:a5d10c4c068707efe580c792cf693ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5b4c359e2dce7b7e1f821c8e00e68f" id="r_a6d5b4c359e2dce7b7e1f821c8e00e68f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a6d5b4c359e2dce7b7e1f821c8e00e68f">isX86JmpImmThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a6d5b4c359e2dce7b7e1f821c8e00e68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether x86 instructions begin with "jmp ADDRESS".  <br /></td></tr>
<tr class="separator:a6d5b4c359e2dce7b7e1f821c8e00e68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ba313822fa0c567bf36bfc0002c592" id="r_a09ba313822fa0c567bf36bfc0002c592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09ba313822fa0c567bf36bfc0002c592">isX86JmpMemThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a09ba313822fa0c567bf36bfc0002c592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether x86 instruction begin with "jmp [ADDRESS]".  <br /></td></tr>
<tr class="separator:a09ba313822fa0c567bf36bfc0002c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e4acb93980a74a74aefa23312fb12" id="r_a785e4acb93980a74a74aefa23312fb12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a785e4acb93980a74a74aefa23312fb12">isX86LeaJmpThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a785e4acb93980a74a74aefa23312fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether x86 instructions begin with an LEA JMP pair.  <br /></td></tr>
<tr class="separator:a785e4acb93980a74a74aefa23312fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c1d8e2f9f1006465ca7d640a02ea2a" id="r_a26c1d8e2f9f1006465ca7d640a02ea2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a26c1d8e2f9f1006465ca7d640a02ea2a">isX86MovJmpThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a26c1d8e2f9f1006465ca7d640a02ea2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether x86 instructions begin with "mov R, [ADDR]; jmp R".  <br /></td></tr>
<tr class="separator:a26c1d8e2f9f1006465ca7d640a02ea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb1a729175dc797985d98e4134f2ba1" id="r_affb1a729175dc797985d98e4134f2ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#affb1a729175dc797985d98e4134f2ba1">isX86AddJmpThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:affb1a729175dc797985d98e4134f2ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether x86 instructions begin with "add R, C; jmp ADDR".  <br /></td></tr>
<tr class="separator:affb1a729175dc797985d98e4134f2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a8ea87e3921a3fb0b6b62398062139" id="r_a19a8ea87e3921a3fb0b6b62398062139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a19a8ea87e3921a3fb0b6b62398062139">splitThunkFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ThunkPredicates::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a19a8ea87e3921a3fb0b6b62398062139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split thunks off from start of functions.  <br /></td></tr>
<tr class="separator:a19a8ea87e3921a3fb0b6b62398062139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce9f2f6063e5b2cb8f9ae6da07dde9" id="r_a56ce9f2f6063e5b2cb8f9ae6da07dde9"><td class="memItemLeft" align="right" valign="top"><a id="a56ce9f2f6063e5b2cb8f9ae6da07dde9" name="a56ce9f2f6063e5b2cb8f9ae6da07dde9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initDiagnostics</b> ()</td></tr>
<tr class="separator:a56ce9f2f6063e5b2cb8f9ae6da07dde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa5b8079f109f885f49123e5d7e49b9" id="r_afaa5b8079f109f885f49123e5d7e49b9"><td class="memItemLeft" align="right" valign="top"><a id="afaa5b8079f109f885f49123e5d7e49b9" name="afaa5b8079f109f885f49123e5d7e49b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortBasicBlocksByAddress</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="separator:afaa5b8079f109f885f49123e5d7e49b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dee4a323761a5e973289359298daa0f" id="r_a2dee4a323761a5e973289359298daa0f"><td class="memItemLeft" align="right" valign="top"><a id="a2dee4a323761a5e973289359298daa0f" name="a2dee4a323761a5e973289359298daa0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortDataBlocks</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="separator:a2dee4a323761a5e973289359298daa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1047615f8632ba4bef8dbbfb3f8cd8" id="r_aba1047615f8632ba4bef8dbbfb3f8cd8"><td class="memItemLeft" align="right" valign="top"><a id="aba1047615f8632ba4bef8dbbfb3f8cd8" name="aba1047615f8632ba4bef8dbbfb3f8cd8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortFunctionsByAddress</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="separator:aba1047615f8632ba4bef8dbbfb3f8cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b5b57cf8dff606b1a3423a7485ac5" id="r_ab08b5b57cf8dff606b1a3423a7485ac5"><td class="memItemLeft" align="right" valign="top"><a id="ab08b5b57cf8dff606b1a3423a7485ac5" name="ab08b5b57cf8dff606b1a3423a7485ac5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortFunctionNodesByAddress</b> (const <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *, const <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *)</td></tr>
<tr class="separator:ab08b5b57cf8dff606b1a3423a7485ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1b4172648e1d7b64a2d648bbe5d153" id="r_aee1b4172648e1d7b64a2d648bbe5d153"><td class="memItemLeft" align="right" valign="top"><a id="aee1b4172648e1d7b64a2d648bbe5d153" name="aee1b4172648e1d7b64a2d648bbe5d153"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortByExpression</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a> &amp;)</td></tr>
<tr class="separator:aee1b4172648e1d7b64a2d648bbe5d153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119c98bf868f9ce2d417870f149d9d26" id="r_a119c98bf868f9ce2d417870f149d9d26"><td class="memItemLeft" align="right" valign="top"><a id="a119c98bf868f9ce2d417870f149d9d26" name="a119c98bf868f9ce2d417870f149d9d26"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortBlocksForAst</b> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *)</td></tr>
<tr class="separator:a119c98bf868f9ce2d417870f149d9d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff2271822ca55f9f83510be674c3a31" id="r_a9ff2271822ca55f9f83510be674c3a31"><td class="memItemLeft" align="right" valign="top"><a id="a9ff2271822ca55f9f83510be674c3a31" name="a9ff2271822ca55f9f83510be674c3a31"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortInstructionsByAddress</b> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="separator:a9ff2271822ca55f9f83510be674c3a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9391ab5ab0dd49d14799896b8888c2fc" id="r_a9391ab5ab0dd49d14799896b8888c2fc"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a9391ab5ab0dd49d14799896b8888c2fc"><td class="memTemplItemLeft" align="right" valign="top">Container::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9391ab5ab0dd49d14799896b8888c2fc">lowerBound</a> (const Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:a9391ab5ab0dd49d14799896b8888c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5e6a193f96585f65a6740b6c85095d" id="r_a7e5e6a193f96585f65a6740b6c85095d"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a7e5e6a193f96585f65a6740b6c85095d"><td class="memTemplItemLeft" align="right" valign="top">Container::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7e5e6a193f96585f65a6740b6c85095d">lowerBound</a> (Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:a7e5e6a193f96585f65a6740b6c85095d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ab69572ae6a1f23e29d8d112a8bb37" id="r_a42ab69572ae6a1f23e29d8d112a8bb37"><td class="memTemplParams" colspan="2">template&lt;class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a42ab69572ae6a1f23e29d8d112a8bb37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a42ab69572ae6a1f23e29d8d112a8bb37">equalUnique</a> (const Value &amp;a, const Value &amp;b, Comparator cmp)</td></tr>
<tr class="separator:a42ab69572ae6a1f23e29d8d112a8bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ed992a12df552bd35882a25f4d0bd3" id="r_af3ed992a12df552bd35882a25f4d0bd3"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:af3ed992a12df552bd35882a25f4d0bd3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#af3ed992a12df552bd35882a25f4d0bd3">insertUnique</a> (Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:af3ed992a12df552bd35882a25f4d0bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3f84a8e4b413c2e657d4a31a31603" id="r_a85f3f84a8e4b413c2e657d4a31a31603"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a85f3f84a8e4b413c2e657d4a31a31603"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a85f3f84a8e4b413c2e657d4a31a31603">replaceOrInsert</a> (Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:a85f3f84a8e4b413c2e657d4a31a31603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6194352c84fc3fe62042b21c0a9e902a" id="r_a6194352c84fc3fe62042b21c0a9e902a"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a6194352c84fc3fe62042b21c0a9e902a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a6194352c84fc3fe62042b21c0a9e902a">eraseUnique</a> (Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:a6194352c84fc3fe62042b21c0a9e902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae063b25039bbd51ffeab9aefce46cf82" id="r_ae063b25039bbd51ffeab9aefce46cf82"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:ae063b25039bbd51ffeab9aefce46cf82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae063b25039bbd51ffeab9aefce46cf82">existsUnique</a> (const Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:ae063b25039bbd51ffeab9aefce46cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae172ce377fc1fc8daf9bec632c00708" id="r_aae172ce377fc1fc8daf9bec632c00708"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:aae172ce377fc1fc8daf9bec632c00708"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aae172ce377fc1fc8daf9bec632c00708">getUnique</a> (const Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:aae172ce377fc1fc8daf9bec632c00708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b544e200bab0bafd05cb206600d76e" id="r_a45b544e200bab0bafd05cb206600d76e"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value , class Comparator &gt; </td></tr>
<tr class="memitem:a45b544e200bab0bafd05cb206600d76e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a45b544e200bab0bafd05cb206600d76e">getOrInsertUnique</a> (Container &amp;container, const Value &amp;item, Comparator cmp)</td></tr>
<tr class="separator:a45b544e200bab0bafd05cb206600d76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f4e9b51deef7c4d638c4ffdc9c16d" id="r_a561f4e9b51deef7c4d638c4ffdc9c16d"><td class="memTemplParams" colspan="2">template&lt;class Container , class Comparator &gt; </td></tr>
<tr class="memitem:a561f4e9b51deef7c4d638c4ffdc9c16d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a561f4e9b51deef7c4d638c4ffdc9c16d">isSupersetUnique</a> (const Container &amp;sup, const Container &amp;sub, Comparator lessThan)</td></tr>
<tr class="separator:a561f4e9b51deef7c4d638c4ffdc9c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d529166d2f7843e7ccac71d084ca850" id="r_a8d529166d2f7843e7ccac71d084ca850"><td class="memItemLeft" align="right" valign="top"><a id="a8d529166d2f7843e7ccac71d084ca850" name="a8d529166d2f7843e7ccac71d084ca850"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> &amp;)</td></tr>
<tr class="separator:a8d529166d2f7843e7ccac71d084ca850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436b9c44da4345394ccc8ff350b86a18" id="r_a436b9c44da4345394ccc8ff350b86a18"><td class="memItemLeft" align="right" valign="top"><a id="a436b9c44da4345394ccc8ff350b86a18" name="a436b9c44da4345394ccc8ff350b86a18"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> &amp;)</td></tr>
<tr class="separator:a436b9c44da4345394ccc8ff350b86a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a557a781d0bfc9fb497c88fb00b538" id="r_a81a557a781d0bfc9fb497c88fb00b538"><td class="memItemLeft" align="right" valign="top"><a id="a81a557a781d0bfc9fb497c88fb00b538" name="a81a557a781d0bfc9fb497c88fb00b538"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a> &amp;)</td></tr>
<tr class="separator:a81a557a781d0bfc9fb497c88fb00b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1301783bff46124a6fb0bc05544727" id="r_a0c1301783bff46124a6fb0bc05544727"><td class="memItemLeft" align="right" valign="top"><a id="a0c1301783bff46124a6fb0bc05544727" name="a0c1301783bff46124a6fb0bc05544727"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html#a821f84eb0ba9ceb47a455146a9e5d5b4">AddressIntervalParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addressIntervalParser</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;storage)</td></tr>
<tr class="separator:a0c1301783bff46124a6fb0bc05544727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769d819efcbb645c29d1694a2b2000f8" id="r_a769d819efcbb645c29d1694a2b2000f8"><td class="memItemLeft" align="right" valign="top"><a id="a769d819efcbb645c29d1694a2b2000f8" name="a769d819efcbb645c29d1694a2b2000f8"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html#a821f84eb0ba9ceb47a455146a9e5d5b4">AddressIntervalParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addressIntervalParser</b> (std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &gt; &amp;storage)</td></tr>
<tr class="separator:a769d819efcbb645c29d1694a2b2000f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391ce02f090b5301a13df7fafedd0de3" id="r_a391ce02f090b5301a13df7fafedd0de3"><td class="memItemLeft" align="right" valign="top"><a id="a391ce02f090b5301a13df7fafedd0de3" name="a391ce02f090b5301a13df7fafedd0de3"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html#a821f84eb0ba9ceb47a455146a9e5d5b4">AddressIntervalParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addressIntervalParser</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;storage)</td></tr>
<tr class="separator:a391ce02f090b5301a13df7fafedd0de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4943d0838ccc443ad6570e07007546c" id="r_ad4943d0838ccc443ad6570e07007546c"><td class="memItemLeft" align="right" valign="top"><a id="ad4943d0838ccc443ad6570e07007546c" name="ad4943d0838ccc443ad6570e07007546c"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressIntervalParser.html#a821f84eb0ba9ceb47a455146a9e5d5b4">AddressIntervalParser::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addressIntervalParser</b> ()</td></tr>
<tr class="separator:ad4943d0838ccc443ad6570e07007546c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa567102e1778ced014fbf6600a936aa2" id="r_aa567102e1778ced014fbf6600a936aa2"><td class="memItemLeft" align="right" valign="top"><a id="aa567102e1778ced014fbf6600a936aa2" name="aa567102e1778ced014fbf6600a936aa2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>serialNumber</b> ()</td></tr>
<tr class="memdesc:aa567102e1778ced014fbf6600a936aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next serial number. <br /></td></tr>
<tr class="separator:aa567102e1778ced014fbf6600a936aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907bfd53e7ec87b41d23abbeb6162098" id="r_a907bfd53e7ec87b41d23abbeb6162098"><td class="memItemLeft" align="right" valign="top">boost::logic::tribool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a907bfd53e7ec87b41d23abbeb6162098">hasAnyCalleeReturn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const ControlFlowGraph::ConstVertexIterator &amp;)</td></tr>
<tr class="memdesc:a907bfd53e7ec87b41d23abbeb6162098"><td class="mdescLeft">&#160;</td><td class="mdescRight">May-return status for function callees.  <br /></td></tr>
<tr class="separator:a907bfd53e7ec87b41d23abbeb6162098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9843264098cfff79aba73ed6049e88" id="r_a4d9843264098cfff79aba73ed6049e88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a4d9843264098cfff79aba73ed6049e88">hasCallReturnEdges</a> (const ControlFlowGraph::ConstVertexIterator &amp;)</td></tr>
<tr class="memdesc:a4d9843264098cfff79aba73ed6049e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether vertex has at least one call-return edge.  <br /></td></tr>
<tr class="separator:a4d9843264098cfff79aba73ed6049e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d1511a598660d57d776e7f50382d13a" id="r_a1d1511a598660d57d776e7f50382d13a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1d1511a598660d57d776e7f50382d13a">findPathEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;graph, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:a1d1511a598660d57d776e7f50382d13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds edges that can be part of some path.  <br /></td></tr>
<tr class="separator:a1d1511a598660d57d776e7f50382d13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77931c8c8a85b6e3651023bb4f1db96c" id="r_a77931c8c8a85b6e3651023bb4f1db96c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a77931c8c8a85b6e3651023bb4f1db96c">findPathEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;graph, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), bool avoidCallsAndReturns=false)</td></tr>
<tr class="memdesc:a77931c8c8a85b6e3651023bb4f1db96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds edges that can be part of some path.  <br /></td></tr>
<tr class="separator:a77931c8c8a85b6e3651023bb4f1db96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36de9d4aa79764ca83904cac846368e7" id="r_a36de9d4aa79764ca83904cac846368e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a36de9d4aa79764ca83904cac846368e7">findFunctionPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>())</td></tr>
<tr class="memdesc:a36de9d4aa79764ca83904cac846368e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths within one function.  <br /></td></tr>
<tr class="separator:a36de9d4aa79764ca83904cac846368e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9ef6070b630710cecf79fc5178251" id="r_aaca9ef6070b630710cecf79fc5178251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aaca9ef6070b630710cecf79fc5178251">findFunctionPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>())</td></tr>
<tr class="memdesc:aaca9ef6070b630710cecf79fc5178251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths within one function.  <br /></td></tr>
<tr class="separator:aaca9ef6070b630710cecf79fc5178251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a04e36e5908926ba251848f2f1ffbff7e" id="r_a04e36e5908926ba251848f2f1ffbff7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a04e36e5908926ba251848f2f1ffbff7e">findInterFunctionPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>())</td></tr>
<tr class="memdesc:a04e36e5908926ba251848f2f1ffbff7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths across function calls and returns.  <br /></td></tr>
<tr class="separator:a04e36e5908926ba251848f2f1ffbff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9da6c3971068ed6a2c333f5671de6" id="r_af0e9da6c3971068ed6a2c333f5671de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#af0e9da6c3971068ed6a2c333f5671de6">findInterFunctionPaths</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;srcCfg, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;vmap, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;beginVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;endVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;avoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;avoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>())</td></tr>
<tr class="memdesc:af0e9da6c3971068ed6a2c333f5671de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all paths across function calls and returns.  <br /></td></tr>
<tr class="separator:af0e9da6c3971068ed6a2c333f5671de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a81f7580eb5b3f9cf22b0adbf1ae32ecd" id="r_a81f7580eb5b3f9cf22b0adbf1ae32ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a81f7580eb5b3f9cf22b0adbf1ae32ecd">inlineMultipleCallees</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, const ControlFlowGraph::ConstVertexIterator &amp;pathsCallSite, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg, const ControlFlowGraph::ConstVertexIterator &amp;cfgCallSite, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;cfgAvoidVertices=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;cfgAvoidEdges=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>(), std::vector&lt; ControlFlowGraph::ConstVertexIterator &gt; *newEdges=nullptr)</td></tr>
<tr class="memdesc:a81f7580eb5b3f9cf22b0adbf1ae32ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a function at the specified call site.  <br /></td></tr>
<tr class="separator:a81f7580eb5b3f9cf22b0adbf1ae32ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddcd4c5feea80693915ce5418da7919" id="r_aaddcd4c5feea80693915ce5418da7919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aaddcd4c5feea80693915ce5418da7919">inlineOneCallee</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;paths, const ControlFlowGraph::ConstVertexIterator &amp;pathsCallSite, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;cfg, const ControlFlowGraph::ConstVertexIterator &amp;cfgCallTarget, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;cfgAvoidVertices, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;cfgAvoidEdges, std::vector&lt; ControlFlowGraph::ConstVertexIterator &gt; *newVertices=nullptr)</td></tr>
<tr class="memdesc:aaddcd4c5feea80693915ce5418da7919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a function at the specified call site.  <br /></td></tr>
<tr class="separator:aaddcd4c5feea80693915ce5418da7919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5ca96426392b9d08db8b582af821ab92" id="r_a5ca96426392b9d08db8b582af821ab92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5ca96426392b9d08db8b582af821ab92">findCallReturnEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;)</td></tr>
<tr class="memdesc:a5ca96426392b9d08db8b582af821ab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return outgoing call-return edges.  <br /></td></tr>
<tr class="separator:a5ca96426392b9d08db8b582af821ab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053244840114b6913fb332c1e8503f86" id="r_a053244840114b6913fb332c1e8503f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a053244840114b6913fb332c1e8503f86">findCallReturnEdges</a> (const ControlFlowGraph::ConstVertexIterator &amp;callSite)</td></tr>
<tr class="memdesc:a053244840114b6913fb332c1e8503f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return outgoing call-return edges.  <br /></td></tr>
<tr class="separator:a053244840114b6913fb332c1e8503f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5b931b3868fce6f6b1d231150ab90408" id="r_a5b931b3868fce6f6b1d231150ab90408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5b931b3868fce6f6b1d231150ab90408">findFunctionReturnEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a5b931b3868fce6f6b1d231150ab90408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find function return edges organized by function.  <br /></td></tr>
<tr class="separator:a5b931b3868fce6f6b1d231150ab90408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab516fc1390e277fadf4308e0b1de1360" id="r_ab516fc1390e277fadf4308e0b1de1360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab516fc1390e277fadf4308e0b1de1360">findFunctionReturnEdges</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;)</td></tr>
<tr class="memdesc:ab516fc1390e277fadf4308e0b1de1360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find function return edges organized by function.  <br /></td></tr>
<tr class="separator:ab516fc1390e277fadf4308e0b1de1360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac74bb814db446ca7bef04256ca61240f" id="r_ac74bb814db446ca7bef04256ca61240f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac74bb814db446ca7bef04256ca61240f">findDetachedVertices</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;)</td></tr>
<tr class="memdesc:ac74bb814db446ca7bef04256ca61240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find vertices that have zero degree.  <br /></td></tr>
<tr class="separator:ac74bb814db446ca7bef04256ca61240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06da0295adfc34d3d36e4ffce5bee0e" id="r_ae06da0295adfc34d3d36e4ffce5bee0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae06da0295adfc34d3d36e4ffce5bee0e">findDetachedVertices</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;vertices)</td></tr>
<tr class="memdesc:ae06da0295adfc34d3d36e4ffce5bee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find vertices that have zero degree.  <br /></td></tr>
<tr class="separator:ae06da0295adfc34d3d36e4ffce5bee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac14d964885a34bc25b36014b99ef2ea1" id="r_ac14d964885a34bc25b36014b99ef2ea1"><td class="memItemLeft" align="right" valign="top"><a id="ac14d964885a34bc25b36014b99ef2ea1" name="ac14d964885a34bc25b36014b99ef2ea1"></a>
<a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mlog</b></td></tr>
<tr class="separator:ac14d964885a34bc25b36014b99ef2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae227a7c4cae4b57dc31f0dbbfaac051c" name="ae227a7c4cae4b57dc31f0dbbfaac051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae227a7c4cae4b57dc31f0dbbfaac051c">&#9670;&#160;</a></span>BasicBlockPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Rose::BinaryAnalysis::Partitioner2::BasicBlockPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownersip pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00659">659</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="ab1de8cd858d089760eb1e1253e4ea045" name="ab1de8cd858d089760eb1e1253e4ea045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1de8cd858d089760eb1e1253e4ea045">&#9670;&#160;</a></span>BasicBlockCallbackPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Rose::BinaryAnalysis::Partitioner2::BasicBlockCallbackPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html">BasicBlockCallback</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00664">664</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a7595093daccb663b9934aa6264656473" name="a7595093daccb663b9934aa6264656473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7595093daccb663b9934aa6264656473">&#9670;&#160;</a></span>BasicBlockSuccessors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">Rose::BinaryAnalysis::Partitioner2::BasicBlockSuccessors</a> = typedef std::vector&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All successors in no particular order. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00667">667</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a89ae81db0c94017acd9a2d94c5c41f04" name="a89ae81db0c94017acd9a2d94c5c41f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ae81db0c94017acd9a2d94c5c41f04">&#9670;&#160;</a></span>ControlFlowGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">Rose::BinaryAnalysis::Partitioner2::ControlFlowGraph</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html">CfgVertex</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgEdge.html">CfgEdge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control flow graph. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00675">675</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="aa7d95e808e98c66e47216bd15f405718" name="aa7d95e808e98c66e47216bd15f405718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d95e808e98c66e47216bd15f405718">&#9670;&#160;</a></span>DataBlockPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Rose::BinaryAnalysis::Partitioner2::DataBlockPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00680">680</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="ae3c0297052d619e690d7c3566b57c4eb" name="ae3c0297052d619e690d7c3566b57c4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c0297052d619e690d7c3566b57c4eb">&#9670;&#160;</a></span>EnginePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Rose::BinaryAnalysis::Partitioner2::EnginePtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00685">685</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a09434c6e84f43282c892a559b18da7d4" name="a09434c6e84f43282c892a559b18da7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09434c6e84f43282c892a559b18da7d4">&#9670;&#160;</a></span>EngineBinaryPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">Rose::BinaryAnalysis::Partitioner2::EngineBinaryPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00688">688</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="acd7e6f19ab285addbe8be2111869eb1f" name="acd7e6f19ab285addbe8be2111869eb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7e6f19ab285addbe8be2111869eb1f">&#9670;&#160;</a></span>EngineJvmPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#acd7e6f19ab285addbe8be2111869eb1f">Rose::BinaryAnalysis::Partitioner2::EngineJvmPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00691">691</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a80531f2b8cbb5250b1a0813b4abb3584" name="a80531f2b8cbb5250b1a0813b4abb3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80531f2b8cbb5250b1a0813b4abb3584">&#9670;&#160;</a></span>FunctionPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; class <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html">Function</a> &gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Rose::BinaryAnalysis::Partitioner2::FunctionPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classFunction.html">Function</a>. </p>
<p>Shared-ownership pointer for function. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00696">696</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a252c6a30b832738a71f9884b0bc6aabc" name="a252c6a30b832738a71f9884b0bc6aabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c6a30b832738a71f9884b0bc6aabc">&#9670;&#160;</a></span>Functions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Rose::BinaryAnalysis::Partitioner2::Functions</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;rose_addr_t, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from address to function. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00698">698</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a175cf54eba5910f765929bfd48d46eb8" name="a175cf54eba5910f765929bfd48d46eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175cf54eba5910f765929bfd48d46eb8">&#9670;&#160;</a></span>FunctionPaddingMatcherPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a175cf54eba5910f765929bfd48d46eb8">Rose::BinaryAnalysis::Partitioner2::FunctionPaddingMatcherPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPaddingMatcher.html">FunctionPaddingMatcher</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00703">703</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a3b33641b1367157839de7546737ae099" name="a3b33641b1367157839de7546737ae099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b33641b1367157839de7546737ae099">&#9670;&#160;</a></span>FunctionPrologueMatcherPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Rose::BinaryAnalysis::Partitioner2::FunctionPrologueMatcherPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionPrologueMatcher.html">FunctionPrologueMatcher</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00706">706</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a9d20f1665ce8329b95f8fae0e33a8422" name="a9d20f1665ce8329b95f8fae0e33a8422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d20f1665ce8329b95f8fae0e33a8422">&#9670;&#160;</a></span>FunctionSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9d20f1665ce8329b95f8fae0e33a8422">Rose::BinaryAnalysis::Partitioner2::FunctionSet</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of functions. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00708">708</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a30252e56f3ed8c058c29b65be2f92b83" name="a30252e56f3ed8c058c29b65be2f92b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30252e56f3ed8c058c29b65be2f92b83">&#9670;&#160;</a></span>PartitionerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">Rose::BinaryAnalysis::Partitioner2::PartitionerPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00713">713</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a461d763e33e7cf0364b64e0af0c267a0" name="a461d763e33e7cf0364b64e0af0c267a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461d763e33e7cf0364b64e0af0c267a0">&#9670;&#160;</a></span>PartitionerConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Rose::BinaryAnalysis::Partitioner2::PartitionerConstPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00714">714</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="ac07949625915032b8fb8e94219ec1c86" name="ac07949625915032b8fb8e94219ec1c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07949625915032b8fb8e94219ec1c86">&#9670;&#160;</a></span>ReferenceSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac07949625915032b8fb8e94219ec1c86">Rose::BinaryAnalysis::Partitioner2::ReferenceSet</a> = typedef std::set&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html">Reference</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of references. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00719">719</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a290cbfd543686205aeeba62d70b8aace" name="a290cbfd543686205aeeba62d70b8aace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290cbfd543686205aeeba62d70b8aace">&#9670;&#160;</a></span>CrossReferences</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a290cbfd543686205aeeba62d70b8aace">Rose::BinaryAnalysis::Partitioner2::CrossReferences</a> = typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Reference.html">Reference</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac07949625915032b8fb8e94219ec1c86">ReferenceSet</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cross references. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00720">720</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a5314166bb1791357eac01fc00f72fc55" name="a5314166bb1791357eac01fc00f72fc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5314166bb1791357eac01fc00f72fc55">&#9670;&#160;</a></span>ThunkPredicatesPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">Rose::BinaryAnalysis::Partitioner2::ThunkPredicatesPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html">ThunkPredicates</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkPredicates.html">ThunkPredicates</a>. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00723">723</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="aa2ca0af83aad7ce4d9dcf42a322c9cbf" name="aa2ca0af83aad7ce4d9dcf42a322c9cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ca0af83aad7ce4d9dcf42a322c9cbf">&#9670;&#160;</a></span>CfgVertexIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt;rose_addr_t, ControlFlowGraph::VertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa2ca0af83aad7ce4d9dcf42a322c9cbf">Rose::BinaryAnalysis::Partitioner2::CfgVertexIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from basic block starting address to CFG vertex. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00198">198</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="aab861479561d92ac3f1e2abdeffc2f95" name="aab861479561d92ac3f1e2abdeffc2f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab861479561d92ac3f1e2abdeffc2f95">&#9670;&#160;</a></span>CfgVertexList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;ControlFlowGraph::VertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aab861479561d92ac3f1e2abdeffc2f95">Rose::BinaryAnalysis::Partitioner2::CfgVertexList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of CFG vertex pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00203">203</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="a1e380297ce5469b011147565f033c371" name="a1e380297ce5469b011147565f033c371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e380297ce5469b011147565f033c371">&#9670;&#160;</a></span>CfgConstVertexList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;ControlFlowGraph::ConstVertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1e380297ce5469b011147565f033c371">Rose::BinaryAnalysis::Partitioner2::CfgConstVertexList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of CFG vertex pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00204">204</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="a2e08f98142f554fa9a70edb2a670ffd1" name="a2e08f98142f554fa9a70edb2a670ffd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08f98142f554fa9a70edb2a670ffd1">&#9670;&#160;</a></span>CfgEdgeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;ControlFlowGraph::EdgeIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a2e08f98142f554fa9a70edb2a670ffd1">Rose::BinaryAnalysis::Partitioner2::CfgEdgeList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of CFG edge pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00210">210</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="ab21262ca68805c755bcbb2703755e9cd" name="ab21262ca68805c755bcbb2703755e9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21262ca68805c755bcbb2703755e9cd">&#9670;&#160;</a></span>CfgConstEdgeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;ControlFlowGraph::ConstEdgeIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab21262ca68805c755bcbb2703755e9cd">Rose::BinaryAnalysis::Partitioner2::CfgConstEdgeList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of CFG edge pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00211">211</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="ad9e669152fce302f670608026e641df7" name="ad9e669152fce302f670608026e641df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e669152fce302f670608026e641df7">&#9670;&#160;</a></span>CfgVertexSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt;ControlFlowGraph::VertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ad9e669152fce302f670608026e641df7">Rose::BinaryAnalysis::Partitioner2::CfgVertexSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of CFG vertex pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00217">217</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="abe7d20f5b9234df626c576eb2279ce4e" name="abe7d20f5b9234df626c576eb2279ce4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7d20f5b9234df626c576eb2279ce4e">&#9670;&#160;</a></span>CfgConstVertexSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt;ControlFlowGraph::ConstVertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">Rose::BinaryAnalysis::Partitioner2::CfgConstVertexSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of CFG vertex pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00218">218</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="ac609d02f7190a512292210593a97db33" name="ac609d02f7190a512292210593a97db33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac609d02f7190a512292210593a97db33">&#9670;&#160;</a></span>CfgEdgeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt;ControlFlowGraph::EdgeIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ac609d02f7190a512292210593a97db33">Rose::BinaryAnalysis::Partitioner2::CfgEdgeSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of CFG edge pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00224">224</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="a9630831dc80c819aec7ae3ae31ea5149" name="a9630831dc80c819aec7ae3ae31ea5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630831dc80c819aec7ae3ae31ea5149">&#9670;&#160;</a></span>CfgConstEdgeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorSet.html">Sawyer::Container::GraphIteratorSet</a>&lt;ControlFlowGraph::ConstEdgeIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">Rose::BinaryAnalysis::Partitioner2::CfgConstEdgeSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of CFG edge pointers. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00225">225</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="a779f94969e75f3365fcf4ea2f8369dc2" name="a779f94969e75f3365fcf4ea2f8369dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779f94969e75f3365fcf4ea2f8369dc2">&#9670;&#160;</a></span>CfgVertexMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1GraphIteratorBiMap.html">Sawyer::Container::GraphIteratorBiMap</a>&lt;ControlFlowGraph::ConstVertexIterator, ControlFlowGraph::ConstVertexIterator&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">Rose::BinaryAnalysis::Partitioner2::CfgVertexMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> vertices from one CFG to another CFG and vice versa. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowGraph_8h_source.html#l00230">230</a> of file <a class="el" href="ControlFlowGraph_8h_source.html">ControlFlowGraph.h</a>.</p>

</div>
</div>
<a id="a76391af9e1a278b1b126107a5785724a" name="a76391af9e1a278b1b126107a5785724a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76391af9e1a278b1b126107a5785724a">&#9670;&#160;</a></span>ThunkPredicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a>(* Rose::BinaryAnalysis::Partitioner2::ThunkPredicate) (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> signature for finding thunks. </p>
<p>These functions take a partitioner and a sequence of one or more instructions disassembled from memory and determine if the sequence begins with instructions that look like a thunk of some sort. If they do, then the function returns the number of initial instructions that compose the thunk and the name of the pattern that matched, otherwise it returns zero and an empty string. </p>

<p class="definition">Definition at line <a class="el" href="Thunk_8h_source.html#l00081">81</a> of file <a class="el" href="Thunk_8h_source.html">Thunk.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aec4f331fd4ff97ca588f50435cd0b797" name="aec4f331fd4ff97ca588f50435cd0b797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4f331fd4ff97ca588f50435cd0b797">&#9670;&#160;</a></span>VertexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797">Rose::BinaryAnalysis::Partitioner2::VertexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> control flow vertex types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aec4f331fd4ff97ca588f50435cd0b797a443b7ff922a8607fd07162a87e0c5b7d" name="aec4f331fd4ff97ca588f50435cd0b797a443b7ff922a8607fd07162a87e0c5b7d"></a>V_BASIC_BLOCK&#160;</td><td class="fielddoc"><p>A basic block or placeholder for a basic block. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec4f331fd4ff97ca588f50435cd0b797a52373ac58f9dd1394d939f8ba3de4cea" name="aec4f331fd4ff97ca588f50435cd0b797a52373ac58f9dd1394d939f8ba3de4cea"></a>V_UNDISCOVERED&#160;</td><td class="fielddoc"><p>The special "undiscovered" vertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec4f331fd4ff97ca588f50435cd0b797a8c41e56b594be1074f159dc7d2d29f42" name="aec4f331fd4ff97ca588f50435cd0b797a8c41e56b594be1074f159dc7d2d29f42"></a>V_INDETERMINATE&#160;</td><td class="fielddoc"><p>Special vertex destination for indeterminate edges. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec4f331fd4ff97ca588f50435cd0b797aedb78bf04ed6f85a182dc01ca2fdee1e" name="aec4f331fd4ff97ca588f50435cd0b797aedb78bf04ed6f85a182dc01ca2fdee1e"></a>V_NONEXISTING&#160;</td><td class="fielddoc"><p>Special vertex destination for non-existing basic blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec4f331fd4ff97ca588f50435cd0b797a18b509ae536cf7077191bec9fe4b1214" name="aec4f331fd4ff97ca588f50435cd0b797a18b509ae536cf7077191bec9fe4b1214"></a>V_USER_DEFINED&#160;</td><td class="fielddoc"><p>User defined vertex. </p>
<p>These vertices don't normally appear in the global control flow graph but might appear in other kinds of graphs that are closely related to a CFG, such as a paths graph. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00051">51</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a8c65d98b5dc4b8b62b640a77af63f6a9" name="a8c65d98b5dc4b8b62b640a77af63f6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c65d98b5dc4b8b62b640a77af63f6a9">&#9670;&#160;</a></span>EdgeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">Rose::BinaryAnalysis::Partitioner2::EdgeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> control flow edge types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740" name="a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740"></a>E_NORMAL&#160;</td><td class="fielddoc"><p>Normal control flow edge, nothing special. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0" name="a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0"></a>E_FUNCTION_CALL&#160;</td><td class="fielddoc"><p><a class="el" href="structEdge.html">Edge</a> is a function call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6" name="a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6"></a>E_FUNCTION_RETURN&#160;</td><td class="fielddoc"><p><a class="el" href="structEdge.html">Edge</a> is a function return. </p>
<p>Such edges represent the actual return-to-caller and usually originate from a return instruction (e.g., x86 <code>RET</code>, m68k <code>RTS</code>, etc.). </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e" name="a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e"></a>E_CALL_RETURN&#160;</td><td class="fielddoc"><p><a class="el" href="structEdge.html">Edge</a> is a function return from the call site. </p>
<p>Such edges are from a caller basic block to (probably) the fall-through address of the call and don't actually exist directly in the specimen. They represent the fact that the called function eventually returns even if the instructions for the called function are not available to analyze. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5" name="a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5"></a>E_FUNCTION_XFER&#160;</td><td class="fielddoc"><p><a class="el" href="structEdge.html">Edge</a> is a function call transfer. </p>
<p>A function call transfer is similar to <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> except the entire call frame is transferred to the target function and this function is no longer considered part of the call stack; a return from the target function will skip over this function. <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call transfers most often occur as the edge leaving a thunk. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c65d98b5dc4b8b62b640a77af63f6a9af5349e3eb9ad0f639ca34300977eec44" name="a8c65d98b5dc4b8b62b640a77af63f6a9af5349e3eb9ad0f639ca34300977eec44"></a>E_USER_DEFINED&#160;</td><td class="fielddoc"><p>User defined edge. </p>
<p>These edges don't normally appear in the global control flow graph but might appear in other kinds of graphs that are closely related to a CFG, such as a paths graph. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00062">62</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a8fe96c83c4b19e6723fc7e63c05643d3" name="a8fe96c83c4b19e6723fc7e63c05643d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe96c83c4b19e6723fc7e63c05643d3">&#9670;&#160;</a></span>Confidence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Rose::BinaryAnalysis::Partitioner2::Confidence</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How sure are we of something. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc" name="a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc"></a>ASSUMED&#160;</td><td class="fielddoc"><p>The value is an assumption without any proof. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8fe96c83c4b19e6723fc7e63c05643d3a3fa9e2e343b016021efbd45842ad84ef" name="a8fe96c83c4b19e6723fc7e63c05643d3a3fa9e2e343b016021efbd45842ad84ef"></a>PROVED&#160;</td><td class="fielddoc"><p>The value was somehow proved. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00086">86</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="aadadf7e7180c2ad4b04995fa7f4df7c5" name="aadadf7e7180c2ad4b04995fa7f4df7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadadf7e7180c2ad4b04995fa7f4df7c5">&#9670;&#160;</a></span>SemanticMemoryParadigm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Organization of semantic memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aadadf7e7180c2ad4b04995fa7f4df7c5a4da3d025c1c3ba7b3b186da4246e34b3" name="aadadf7e7180c2ad4b04995fa7f4df7c5a4da3d025c1c3ba7b3b186da4246e34b3"></a>LIST_BASED_MEMORY&#160;</td><td class="fielddoc"><p>Precise but slow. </p>
</td></tr>
<tr><td class="fieldname"><a id="aadadf7e7180c2ad4b04995fa7f4df7c5aaa673358a7dd8e6a98fdbf9e58950afc" name="aadadf7e7180c2ad4b04995fa7f4df7c5aaa673358a7dd8e6a98fdbf9e58950afc"></a>MAP_BASED_MEMORY&#160;</td><td class="fielddoc"><p>Fast but not precise. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00092">92</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a1a791307e5ce17914d6e081a63a4d049" name="a1a791307e5ce17914d6e081a63a4d049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a791307e5ce17914d6e081a63a4d049">&#9670;&#160;</a></span>MemoryDataAdjustment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a1a791307e5ce17914d6e081a63a4d049">Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How the partitioner should globally treat memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1a791307e5ce17914d6e081a63a4d049aea97871405cf6e1c1e9ae9b439a89fa6" name="a1a791307e5ce17914d6e081a63a4d049aea97871405cf6e1c1e9ae9b439a89fa6"></a>DATA_IS_CONSTANT&#160;</td><td class="fielddoc"><p>Treat all memory as if it were constant. </p>
<p>This is accomplished by removing <code>MemoryMap::READABLE</code> from all segments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a791307e5ce17914d6e081a63a4d049a6fbcb498a180728fc7b4bd30d7255d92" name="a1a791307e5ce17914d6e081a63a4d049a6fbcb498a180728fc7b4bd30d7255d92"></a>DATA_IS_INITIALIZED&#160;</td><td class="fielddoc"><p>Treat all memory as if it were initialized. </p>
<p>This is a little weaker than <code>MEMORY_IS_CONSTANT</code> in that it allows the partitioner to read the value from memory as if it were constant, but also marks the value as being indeterminate. This is accomplished by adding <code>MemoryMap::INITIALIZED</code> to all segments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a791307e5ce17914d6e081a63a4d049a26b7a99ee9e65a7c1788c3e398722e4d" name="a1a791307e5ce17914d6e081a63a4d049a26b7a99ee9e65a7c1788c3e398722e4d"></a>DATA_NO_CHANGE&#160;</td><td class="fielddoc"><p>Do not make any global changes to the memory map. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00179">179</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<a id="abdc8f796bc37a7b105a0c092ccfec084" name="abdc8f796bc37a7b105a0c092ccfec084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc8f796bc37a7b105a0c092ccfec084">&#9670;&#160;</a></span>FunctionReturnAnalysis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abdc8f796bc37a7b105a0c092ccfec084">Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether the function may-return analysis runs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abdc8f796bc37a7b105a0c092ccfec084a1f5cdbd3e1d558964eca20747aacabbd" name="abdc8f796bc37a7b105a0c092ccfec084a1f5cdbd3e1d558964eca20747aacabbd"></a>MAYRETURN_DEFAULT_YES&#160;</td><td class="fielddoc"><p>Assume a function returns if the may-return analysis cannot decide whether it may return. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdc8f796bc37a7b105a0c092ccfec084ae45b718b7c7e1beae7c037df11366aad" name="abdc8f796bc37a7b105a0c092ccfec084ae45b718b7c7e1beae7c037df11366aad"></a>MAYRETURN_DEFAULT_NO&#160;</td><td class="fielddoc"><p>Assume a function cannot return if the may-return analysis cannot decide whether it may return. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdc8f796bc37a7b105a0c092ccfec084a2f3e6735c0cbc230cef4cb7fb6de7705" name="abdc8f796bc37a7b105a0c092ccfec084a2f3e6735c0cbc230cef4cb7fb6de7705"></a>MAYRETURN_ALWAYS_YES&#160;</td><td class="fielddoc"><p>Assume that all functions return without ever running the may-return analysis. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdc8f796bc37a7b105a0c092ccfec084a19d87061fe1c1c3d9ba562d8fa16ec3d" name="abdc8f796bc37a7b105a0c092ccfec084a19d87061fe1c1c3d9ba562d8fa16ec3d"></a>MAYRETURN_ALWAYS_NO&#160;</td><td class="fielddoc"><p>Assume that a function cannot return without ever running the may-return analysis. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00312">312</a> of file <a class="el" href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1d1511a598660d57d776e7f50382d13a" name="a1d1511a598660d57d776e7f50382d13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1511a598660d57d776e7f50382d13a">&#9670;&#160;</a></span>findPathEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; Rose::BinaryAnalysis::Partitioner2::findPathEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds edges that can be part of some path. </p>
<p>Returns a Boolean vector indicating whether an edge is significant. An edge is significant if it appears on some path that originates from some vertex in <code>beginVertices</code> and reaches some vertex in <code>endVertices</code> (if <code>endVertices</code> is supplied) but is not a member of <code>avoidEdges</code> and is not incident to any vertex in <code>avoidVertices</code>. An edge is not significant if it is a function call or function return and <code>avoidCallsAndReturns</code> is true. </p>

</div>
</div>
<a id="a77931c8c8a85b6e3651023bb4f1db96c" name="a77931c8c8a85b6e3651023bb4f1db96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77931c8c8a85b6e3651023bb4f1db96c">&#9670;&#160;</a></span>findPathEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; Rose::BinaryAnalysis::Partitioner2::findPathEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds edges that can be part of some path. </p>
<p>Returns a Boolean vector indicating whether an edge is significant. An edge is significant if it appears on some path that originates from some vertex in <code>beginVertices</code> and reaches some vertex in <code>endVertices</code> (if <code>endVertices</code> is supplied) but is not a member of <code>avoidEdges</code> and is not incident to any vertex in <code>avoidVertices</code>. An edge is not significant if it is a function call or function return and <code>avoidCallsAndReturns</code> is true. </p>

</div>
</div>
<a id="ad7ad7ba0c7e791509eb676c33f289e09" name="ad7ad7ba0c7e791509eb676c33f289e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ad7ba0c7e791509eb676c33f289e09">&#9670;&#160;</a></span>findPathReachableEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findPathReachableEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find edges that are reachable. </p>
<p>Finds edges that are part of some path from any of the <code>beginVertices</code> to any of the <code>endVertices</code>. The paths that are considered must not traverse the <code>avoidEdges</code> or <code>avoidVertices</code>. </p>

</div>
</div>
<a id="a991c34cf44432aba34056d8d14c7b5a3" name="a991c34cf44432aba34056d8d14c7b5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991c34cf44432aba34056d8d14c7b5a3">&#9670;&#160;</a></span>findPathUnreachableEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findPathUnreachableEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find edges that are unreachable. </p>
<p>Finds edges that are not part of any path from any of the <code>beginVertices</code> to any of the <code>endVertices</code>. The paths that are considered must not traverse the <code>avoidEdges</code> or <code>avoidVertices</code>. </p>

</div>
</div>
<a id="a99124dd8446bff0e10bb40fcdc10d509" name="a99124dd8446bff0e10bb40fcdc10d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99124dd8446bff0e10bb40fcdc10d509">&#9670;&#160;</a></span>eraseUnreachablePaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::eraseUnreachablePaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgPath.html">CfgPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges and vertices that cannot be on the paths. </p>
<p>Removes those edges that aren't reachable in both forward and reverse directions between the specified begin and end vertices. Specified vertices must belong to the graph. After edges are removed, dangling vertices are removed. Vertices and edges are removed from all arguments. Removal of edges from <code>path</code> causes the path to be truncated.</p>
<p>Returns the number of edges that were removed from the <code>path</code>. </p>

</div>
</div>
<a id="a996ca2ab4bc79d0ce391c7c900e69afb" name="a996ca2ab4bc79d0ce391c7c900e69afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996ca2ab4bc79d0ce391c7c900e69afb">&#9670;&#160;</a></span>findPaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths. </p>
<p>Computes all paths from any <code>beginVertices</code> to any <code>endVertices</code> if that does not go through any <code>avoidVertices</code> or <code>avoidEdges</code>. The paths are returned as a paths graph (CFG) so that cycles can be represented. A paths graph can represent an exponential number of paths. The paths graph is formed by taking the global CFG and removing all <code>avoidVertices</code> and <code>avoidEdges</code>, any edge that cannot appear on a path from the <code>beginVertex</code> to any <code>endVertices</code>, and any vertex that has degree zero provided it is not one of the <code>beginVertices</code>.</p>
<p>If <code>avoidCallsAndReturns</code> is true then E_FUNCTION_CALL and E_FUNCTION_RETURN edges are not followed. Note that the normal partitioner CFG will have E_CALL_RETURN edges that essentially short circuit a call to a function that might return, and that E_FUNCTION_RETURN edges normally point to the indeterminate vertex rather than concrete return targets.</p>
<p>If the returned graph, <code>paths</code>, is empty then no paths were found. If the returned graph has a vertex but no edges then the vertex serves as both the begin and end of the path (i.e., a single path of unit length). The <code>vmap</code> is updated to indicate the mapping from <code>srcCfg</code> vertices in the corresponding vertices in the returned graph. </p>

</div>
</div>
<a id="a5bc16d4524d790b543570ad40a70ccab" name="a5bc16d4524d790b543570ad40a70ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc16d4524d790b543570ad40a70ccab">&#9670;&#160;</a></span>findPaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoidCallsAndReturns</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths. </p>
<p>Compute all paths that originate from any <code>beginVertices</code> and do not go through any <code>avoidVertices</code> or <code>avoidEdges</code>. The paths are returned as a paths graph (CFG) so that cycles can be represented. A paths graph can represent an exponential number of paths. The paths graph is formed by taking the global CFG and removing all <code>avoidVertices</code> and <code>avoidEdges</code>, and any vertex that has degree zero provided it is not one of the <code>beginVertices</code>.</p>
<p>If <code>avoidCallsAndReturns</code> is true then E_FUNCTION_CALL and E_FUNCTION_RETURN edges are not followed. Note that the normal partitioner CFG will have E_CALL_RETURN edges that essentially short circuit a call to a function that might return, and that E_FUNCTION_RETURN edges normally point to the indeterminate vertex rather than concrete return targets.</p>
<p>If the returned graph, <code>paths</code>, is empty then no paths were found. If the returned graph has a vertex but no edges then the vertex serves as both the begin and end of the path (i.e., a single path of unit length). The <code>vmap</code> is updated to indicate the mapping from <code>srcCfg</code> vertices in the corresponding vertices in the returned graph. </p>

</div>
</div>
<a id="a36de9d4aa79764ca83904cac846368e7" name="a36de9d4aa79764ca83904cac846368e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36de9d4aa79764ca83904cac846368e7">&#9670;&#160;</a></span>findFunctionPaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findFunctionPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths within one function. </p>
<p>This is a convenience method for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a996ca2ab4bc79d0ce391c7c900e69afb">findPaths</a> in a mode that avoids function call and return edges. </p>

</div>
</div>
<a id="aaca9ef6070b630710cecf79fc5178251" name="aaca9ef6070b630710cecf79fc5178251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca9ef6070b630710cecf79fc5178251">&#9670;&#160;</a></span>findFunctionPaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findFunctionPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths within one function. </p>
<p>This is a convenience method for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a996ca2ab4bc79d0ce391c7c900e69afb">findPaths</a> in a mode that avoids function call and return edges. </p>

</div>
</div>
<a id="a04e36e5908926ba251848f2f1ffbff7e" name="a04e36e5908926ba251848f2f1ffbff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e36e5908926ba251848f2f1ffbff7e">&#9670;&#160;</a></span>findInterFunctionPaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findInterFunctionPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths across function calls and returns. </p>
<p>This is a convenience method for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a996ca2ab4bc79d0ce391c7c900e69afb">findPaths</a> in a mode that follows function call and return edges. Note that in the normal partitioner CFG function return edges point to the indeterminate vertex rather than back to the place the function was called. In order to get call-sensitive paths you'll have to do something else. </p>

</div>
</div>
<a id="af0e9da6c3971068ed6a2c333f5671de6" name="af0e9da6c3971068ed6a2c333f5671de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e9da6c3971068ed6a2c333f5671de6">&#9670;&#160;</a></span>findInterFunctionPaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::findInterFunctionPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>srcCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>beginVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>endVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all paths across function calls and returns. </p>
<p>This is a convenience method for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a996ca2ab4bc79d0ce391c7c900e69afb">findPaths</a> in a mode that follows function call and return edges. Note that in the normal partitioner CFG function return edges point to the indeterminate vertex rather than back to the place the function was called. In order to get call-sensitive paths you'll have to do something else. </p>

</div>
</div>
<a id="a81f7580eb5b3f9cf22b0adbf1ae32ecd" name="a81f7580eb5b3f9cf22b0adbf1ae32ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f7580eb5b3f9cf22b0adbf1ae32ecd">&#9670;&#160;</a></span>inlineMultipleCallees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::inlineMultipleCallees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>pathsCallSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>cfgCallSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cfgAvoidVertices</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cfgAvoidEdges</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ControlFlowGraph::ConstVertexIterator &gt; *&#160;</td>
          <td class="paramname"><em>newEdges</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a function at the specified call site. </p>
<p>The <code>paths</code> graph is modified in place by inserting an inlined copy of the function(s) called from the specified <code>pathsCallSite</code> vertex. The <code>pathsCallSite</code> only serves as the attachment point&ndash;it must have the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge(s) but does not need any <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edges. The <code>cfgCallSite</code> is the vertex in the <code>cfg</code> corresponding to the <code>pathsCallSite</code> in the paths graph and provides information about which functions are called.</p>
<p>There are two similar functions: one inlines all the functions called from a particular call site in the CFG, the other inlines one specific function specified by its entry vertex. In the latter case, the CFG doesn't actually need to have an edge to the called function.</p>
<p>Usually, <code>cfgCallSite</code> has one outgoing <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edge and <code>pathsCallSite</code> (and <code>cfgCallSite</code>) has one outgoing <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge. If the <code>pathsCallSite</code> has no <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge, or the called function has no return sites, this operation is a no-op. A call site may call multiple functions, in which case each is inserted, even if some <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edges point to the same function. A called function may return to multiple addresses, such as longjmp, in which case multiple <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edges may be present&ndash;all return sites are linked to all return targets by this operation.</p>
<p>The vertices and edges in the inlined version that correspond to the <code>cfgAvoidEVertices</code> and <code>cfgAvoidEdges</code> are not copied into the <code>paths</code> graph. If this results in the called function having no paths that can return, then that function is not inserted into <code>paths</code>.</p>
<p>The <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edges in <code>paths</code> are not erased by this operation, but are usually subsequently erased by the user since they are redundant after this insertion&ndash;they represent a short-circuit over the called function(s).</p>
<p>Returns true if some function was inserted, false if no changes were made to <code>paths</code>. If <code>newVertices</code> is non-null then all newly inserted vertices are also pushed onto the end of the vector. </p>

</div>
</div>
<a id="aaddcd4c5feea80693915ce5418da7919" name="aaddcd4c5feea80693915ce5418da7919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddcd4c5feea80693915ce5418da7919">&#9670;&#160;</a></span>inlineOneCallee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::inlineOneCallee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>pathsCallSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>cfgCallTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cfgAvoidVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cfgAvoidEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ControlFlowGraph::ConstVertexIterator &gt; *&#160;</td>
          <td class="paramname"><em>newVertices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a function at the specified call site. </p>
<p>The <code>paths</code> graph is modified in place by inserting an inlined copy of the function(s) called from the specified <code>pathsCallSite</code> vertex. The <code>pathsCallSite</code> only serves as the attachment point&ndash;it must have the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge(s) but does not need any <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edges. The <code>cfgCallSite</code> is the vertex in the <code>cfg</code> corresponding to the <code>pathsCallSite</code> in the paths graph and provides information about which functions are called.</p>
<p>There are two similar functions: one inlines all the functions called from a particular call site in the CFG, the other inlines one specific function specified by its entry vertex. In the latter case, the CFG doesn't actually need to have an edge to the called function.</p>
<p>Usually, <code>cfgCallSite</code> has one outgoing <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edge and <code>pathsCallSite</code> (and <code>cfgCallSite</code>) has one outgoing <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge. If the <code>pathsCallSite</code> has no <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edge, or the called function has no return sites, this operation is a no-op. A call site may call multiple functions, in which case each is inserted, even if some <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> edges point to the same function. A called function may return to multiple addresses, such as longjmp, in which case multiple <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edges may be present&ndash;all return sites are linked to all return targets by this operation.</p>
<p>The vertices and edges in the inlined version that correspond to the <code>cfgAvoidEVertices</code> and <code>cfgAvoidEdges</code> are not copied into the <code>paths</code> graph. If this results in the called function having no paths that can return, then that function is not inserted into <code>paths</code>.</p>
<p>The <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a> edges in <code>paths</code> are not erased by this operation, but are usually subsequently erased by the user since they are redundant after this insertion&ndash;they represent a short-circuit over the called function(s).</p>
<p>Returns true if some function was inserted, false if no changes were made to <code>paths</code>. If <code>newVertices</code> is non-null then all newly inserted vertices are also pushed onto the end of the vector. </p>

</div>
</div>
<a id="a1b73d37f5debcff96499b44d028127d0" name="a1b73d37f5debcff96499b44d028127d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b73d37f5debcff96499b44d028127d0">&#9670;&#160;</a></span>insertCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::insertCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert one control flow graph into another. </p>
<p>The <code>vmap</code> is updated with the mapping of vertices from source to destination. Upon return, <code>vmap[srcVertex]</code> will point to the corresponding vertex in the destination graph. </p>

</div>
</div>
<a id="ae27ee4f33152b1cb359aad2619667e2e" name="ae27ee4f33152b1cb359aad2619667e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27ee4f33152b1cb359aad2619667e2e">&#9670;&#160;</a></span>findBackEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findBackEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find back edges. </p>
<p>Performs a depth-first forward traversal of the <code>cfg</code> beginning at the specified vertex. Any edge encountered which points back to some vertex in the current traversal path is added to the returned edge set. </p>

</div>
</div>
<a id="a764755074de6fb8b5f457d8cc1ef5066" name="a764755074de6fb8b5f457d8cc1ef5066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764755074de6fb8b5f457d8cc1ef5066">&#9670;&#160;</a></span>findCallEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findCallEdges </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>callSite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find function call edges. </p>
<p>Returns the list of function call edges for the specified vertex. </p>

</div>
</div>
<a id="ae9488743ebe901043208e5fb71045dcc" name="ae9488743ebe901043208e5fb71045dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9488743ebe901043208e5fb71045dcc">&#9670;&#160;</a></span>findCalledFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::findCalledFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>callSite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find called functions. </p>
<p>Given some vertex in a CFG, return the vertices representing the functions that are called. </p>

</div>
</div>
<a id="a5ca96426392b9d08db8b582af821ab92" name="a5ca96426392b9d08db8b582af821ab92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca96426392b9d08db8b582af821ab92">&#9670;&#160;</a></span>findCallReturnEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findCallReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return outgoing call-return edges. </p>
<p>A call-return edge represents a short-circuit control flow path across a function call, from the call site to the return target.</p>
<p>If a partitioner and control flow graph are specified, then this returns all edges of type <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>. If a vertex is specified, then it returns only those call-return edges that emanate from said vertex. </p>

</div>
</div>
<a id="a053244840114b6913fb332c1e8503f86" name="a053244840114b6913fb332c1e8503f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053244840114b6913fb332c1e8503f86">&#9670;&#160;</a></span>findCallReturnEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> Rose::BinaryAnalysis::Partitioner2::findCallReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>callSite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return outgoing call-return edges. </p>
<p>A call-return edge represents a short-circuit control flow path across a function call, from the call site to the return target.</p>
<p>If a partitioner and control flow graph are specified, then this returns all edges of type <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>. If a vertex is specified, then it returns only those call-return edges that emanate from said vertex. </p>

</div>
</div>
<a id="a4200ccd907c5f4ca6f47518e906453b6" name="a4200ccd907c5f4ca6f47518e906453b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4200ccd907c5f4ca6f47518e906453b6">&#9670;&#160;</a></span>findFunctionReturns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::findFunctionReturns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>beginVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all function return vertices. </p>
<p>Returns the list of vertices with outgoing E_FUNCTION_RETURN edges. </p>

</div>
</div>
<a id="a5b931b3868fce6f6b1d231150ab90408" name="a5b931b3868fce6f6b1d231150ab90408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b931b3868fce6f6b1d231150ab90408">&#9670;&#160;</a></span>findFunctionReturnEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &gt; Rose::BinaryAnalysis::Partitioner2::findFunctionReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find function return edges organized by function. </p>
<p>Finds all control flow graph edges that are function return edges and organizes them according to the function from which they emanate. Note that since a basic block can be shared among several functions (usually just one though), an edge may appear multiple times in the returned map.</p>
<p>If a control flow graph is supplied, it must be compatible with the specified partitioner. If no control flow graph is specified then the partitioner's own CFG is used. </p>

</div>
</div>
<a id="ab516fc1390e277fadf4308e0b1de1360" name="ab516fc1390e277fadf4308e0b1de1360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab516fc1390e277fadf4308e0b1de1360">&#9670;&#160;</a></span>findFunctionReturnEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &gt; Rose::BinaryAnalysis::Partitioner2::findFunctionReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find function return edges organized by function. </p>
<p>Finds all control flow graph edges that are function return edges and organizes them according to the function from which they emanate. Note that since a basic block can be shared among several functions (usually just one though), an edge may appear multiple times in the returned map.</p>
<p>If a control flow graph is supplied, it must be compatible with the specified partitioner. If no control flow graph is specified then the partitioner's own CFG is used. </p>

</div>
</div>
<a id="adce95b16a860802a8f9dd679b4b7ee02" name="adce95b16a860802a8f9dd679b4b7ee02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce95b16a860802a8f9dd679b4b7ee02">&#9670;&#160;</a></span>eraseEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::eraseEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a9630831dc80c819aec7ae3ae31ea5149">CfgConstEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>toErase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase multiple edges. </p>
<p>Erases each edge in the <code>toErase</code> set. Upon return, the toErase set's values will all be invalid and should not be dereferenced. </p>

</div>
</div>
<a id="ac74bb814db446ca7bef04256ca61240f" name="ac74bb814db446ca7bef04256ca61240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74bb814db446ca7bef04256ca61240f">&#9670;&#160;</a></span>findDetachedVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::findDetachedVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find vertices that have zero degree. </p>
<p>Returns a set of vertices that have no incoming or outgoing edges. If <code>vertices</code> are specified, then limit the return value to the specified vertices; this mode of operation can be significantly faster than scanning the entire graph. </p>

</div>
</div>
<a id="ae06da0295adfc34d3d36e4ffce5bee0e" name="ae06da0295adfc34d3d36e4ffce5bee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06da0295adfc34d3d36e4ffce5bee0e">&#9670;&#160;</a></span>findDetachedVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::findDetachedVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find vertices that have zero degree. </p>
<p>Returns a set of vertices that have no incoming or outgoing edges. If <code>vertices</code> are specified, then limit the return value to the specified vertices; this mode of operation can be significantly faster than scanning the entire graph. </p>

</div>
</div>
<a id="a141f20b9c066d754a766ae3adf82bad3" name="a141f20b9c066d754a766ae3adf82bad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141f20b9c066d754a766ae3adf82bad3">&#9670;&#160;</a></span>forwardMapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::forwardMapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return corresponding iterators. </p>
<p>Given a set of iterators and a vertex map, return the corresponding iterators by following the forward mapping. Any vertex in the argument that is not present in the mapping is silently ignored. </p>

</div>
</div>
<a id="ab92949274a2a50a1c215ea5a61600e45" name="ab92949274a2a50a1c215ea5a61600e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92949274a2a50a1c215ea5a61600e45">&#9670;&#160;</a></span>reverseMapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> Rose::BinaryAnalysis::Partitioner2::reverseMapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#abe7d20f5b9234df626c576eb2279ce4e">CfgConstVertexSet</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a779f94969e75f3365fcf4ea2f8369dc2">CfgVertexMap</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return corresponding iterators. </p>
<p>Given a set of iterators and a vertex map, return the corresponding iterators by following the reverse mapping. Any vertex in the argument that is not present in the mapping is silently ignored. </p>

</div>
</div>
<a id="a5eff695c3f80a34774d151f5642a737f" name="a5eff695c3f80a34774d151f5642a737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff695c3f80a34774d151f5642a737f">&#9670;&#160;</a></span>expandFunctionReturnEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::expandFunctionReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite function return edges. </p>
<p>Given a graph that has function return edges (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6">E_FUNCTION_RETURN</a>) that point to the indeterminate vertex, replace them with function return edges that point to the return sites. The return sites are the vertices pointed to by the call-return (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) edges emanating from the call sites for said function. The graph is modified in place. The resulting graph will usually have more edges than the original graph. </p>

</div>
</div>
<a id="ae482717ed73ec351ee764982431c85c4" name="ae482717ed73ec351ee764982431c85c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae482717ed73ec351ee764982431c85c4">&#9670;&#160;</a></span>functionCfgByErasure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> Rose::BinaryAnalysis::Partitioner2::functionCfgByErasure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>gcfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph::VertexIterator &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a function control flow graph. </p>
<p>A function control flow graph is created by erasing all parts of the global control flow graph (<code>gcfg</code>) that aren't owned by the specified function. The resulting graph will contain an indeterminate vertex if the global CFG contains an indeterminate vertex and the function has any edges to the indeterminate vertex that are not E_FUNCTION_RETURN edges. In other words, the indeterminate vertex is excluded unless there are things like branches or calls whose target address is a register.</p>
<p>Upon return, the <code>entry</code> iterator points to the vertex of the return value that serves as the function's entry point.</p>
<p>Note that this method of creating a function control flow graph can be slow since it starts with a global control flow graph. It has one benefit over <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5d10c4c068707efe580c792cf693ef63">functionCfgByReachability</a> though: it will find all vertices that belong to the function even if they're not reachable from the function's entry point, or even if they're only reachable by traversing through a non-owned vertex. </p>

</div>
</div>
<a id="a5d10c4c068707efe580c792cf693ef63" name="a5d10c4c068707efe580c792cf693ef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d10c4c068707efe580c792cf693ef63">&#9670;&#160;</a></span>functionCfgByReachability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> Rose::BinaryAnalysis::Partitioner2::functionCfgByReachability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>gcfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>gcfgEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a function control flow graph. </p>
<p>A function control flow graph is created by traversing the specified global control flow grap (<code>gcfg</code>) starting at the specified vertex (<code>gcfgEntry</code>). The traversal follows only vertices that are owned by the specified function, and the indeterminate vertex. The indeterminate vertex is only reachable through edges of types other than <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6">E_FUNCTION_RETURN</a>.</p>
<p>The function control flow graph entry point corresponding to <code>gcfgEntry</code> is always vertex number zero in the return value. However, if <code>gcfgEntry</code> points to a vertex not owned by <code>function</code>, or <code>gcfg</code> is empty then the returned graph is also empty.</p>
<p>Note that this method of creating a function control graph can be much faster than <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae482717ed73ec351ee764982431c85c4">functionCfgByErasure</a> since it only traverses part of the global CFG, but the drawback is that the return value won't include vertices that are not reachable from the return value's entry vertex. </p>

</div>
</div>
<a id="a6d5b4c359e2dce7b7e1f821c8e00e68f" name="a6d5b4c359e2dce7b7e1f821c8e00e68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5b4c359e2dce7b7e1f821c8e00e68f">&#9670;&#160;</a></span>isX86JmpImmThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a> Rose::BinaryAnalysis::Partitioner2::isX86JmpImmThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether x86 instructions begin with "jmp ADDRESS". </p>
<p>Tries to match "jmp ADDRESS" where ADDRESS is a constant. </p>

</div>
</div>
<a id="a09ba313822fa0c567bf36bfc0002c592" name="a09ba313822fa0c567bf36bfc0002c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ba313822fa0c567bf36bfc0002c592">&#9670;&#160;</a></span>isX86JmpMemThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a> Rose::BinaryAnalysis::Partitioner2::isX86JmpMemThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether x86 instruction begin with "jmp [ADDRESS]". </p>
<p>Tries to match "jmp [ADDRESS]" where ADDRESS is a constant. </p>

</div>
</div>
<a id="a785e4acb93980a74a74aefa23312fb12" name="a785e4acb93980a74a74aefa23312fb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e4acb93980a74a74aefa23312fb12">&#9670;&#160;</a></span>isX86LeaJmpThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a> Rose::BinaryAnalysis::Partitioner2::isX86LeaJmpThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether x86 instructions begin with an LEA JMP pair. </p>
<p>Tries to match "lea ecx, [ebp + C]; jmp ADDR" where C and ADDR are constants. </p>

</div>
</div>
<a id="a26c1d8e2f9f1006465ca7d640a02ea2a" name="a26c1d8e2f9f1006465ca7d640a02ea2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c1d8e2f9f1006465ca7d640a02ea2a">&#9670;&#160;</a></span>isX86MovJmpThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a> Rose::BinaryAnalysis::Partitioner2::isX86MovJmpThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether x86 instructions begin with "mov R, [ADDR]; jmp R". </p>
<p>Tries to match "mov R, [ADDR]; jmp R" where R is a register and ADDR is a constant. </p>

</div>
</div>
<a id="affb1a729175dc797985d98e4134f2ba1" name="affb1a729175dc797985d98e4134f2ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb1a729175dc797985d98e4134f2ba1">&#9670;&#160;</a></span>isX86AddJmpThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ThunkDetection.html">ThunkDetection</a> Rose::BinaryAnalysis::Partitioner2::isX86AddJmpThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether x86 instructions begin with "add R, C; jmp ADDR". </p>
<p>Tries to match "add R, C; jmp ADDR" where R is one of the cx registers and C and ADDR are constants. </p>

</div>
</div>
<a id="a19a8ea87e3921a3fb0b6b62398062139" name="a19a8ea87e3921a3fb0b6b62398062139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a8ea87e3921a3fb0b6b62398062139">&#9670;&#160;</a></span>splitThunkFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::splitThunkFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ThunkPredicates::Ptr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split thunks off from start of functions. </p>
<p>Splits as many thunks as possible off the front of all functions currently attached to the partitioner's CFG. </p>

</div>
</div>
<a id="a9391ab5ab0dd49d14799896b8888c2fc" name="a9391ab5ab0dd49d14799896b8888c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9391ab5ab0dd49d14799896b8888c2fc">&#9670;&#160;</a></span>lowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container::const_iterator Rose::BinaryAnalysis::Partitioner2::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00047">47</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a7e5e6a193f96585f65a6740b6c85095d" name="a7e5e6a193f96585f65a6740b6c85095d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5e6a193f96585f65a6740b6c85095d">&#9670;&#160;</a></span>lowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container::iterator Rose::BinaryAnalysis::Partitioner2::lowerBound </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00052">52</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a42ab69572ae6a1f23e29d8d112a8bb37" name="a42ab69572ae6a1f23e29d8d112a8bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ab69572ae6a1f23e29d8d112a8bb37">&#9670;&#160;</a></span>equalUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::equalUnique </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00059">59</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="af3ed992a12df552bd35882a25f4d0bd3" name="af3ed992a12df552bd35882a25f4d0bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ed992a12df552bd35882a25f4d0bd3">&#9670;&#160;</a></span>insertUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::insertUnique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00066">66</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a85f3f84a8e4b413c2e657d4a31a31603" name="a85f3f84a8e4b413c2e657d4a31a31603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f3f84a8e4b413c2e657d4a31a31603">&#9670;&#160;</a></span>replaceOrInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::replaceOrInsert </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00080">80</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a6194352c84fc3fe62042b21c0a9e902a" name="a6194352c84fc3fe62042b21c0a9e902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6194352c84fc3fe62042b21c0a9e902a">&#9670;&#160;</a></span>eraseUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::eraseUnique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00094">94</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="ae063b25039bbd51ffeab9aefce46cf82" name="ae063b25039bbd51ffeab9aefce46cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae063b25039bbd51ffeab9aefce46cf82">&#9670;&#160;</a></span>existsUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::existsUnique </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00107">107</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="aae172ce377fc1fc8daf9bec632c00708" name="aae172ce377fc1fc8daf9bec632c00708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae172ce377fc1fc8daf9bec632c00708">&#9670;&#160;</a></span>getUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; Value &gt; Rose::BinaryAnalysis::Partitioner2::getUnique </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00120">120</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a45b544e200bab0bafd05cb206600d76e" name="a45b544e200bab0bafd05cb206600d76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b544e200bab0bafd05cb206600d76e">&#9670;&#160;</a></span>getOrInsertUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; Value &gt; Rose::BinaryAnalysis::Partitioner2::getOrInsertUnique </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00133">133</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a561f4e9b51deef7c4d638c4ffdc9c16d" name="a561f4e9b51deef7c4d638c4ffdc9c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561f4e9b51deef7c4d638c4ffdc9c16d">&#9670;&#160;</a></span>isSupersetUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::isSupersetUnique </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>sup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>lessThan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html#l00147">147</a> of file <a class="el" href="BinaryAnalysis_2Partitioner2_2Utility_8h_source.html">BinaryAnalysis/Partitioner2/Utility.h</a>.</p>

</div>
</div>
<a id="a907bfd53e7ec87b41d23abbeb6162098" name="a907bfd53e7ec87b41d23abbeb6162098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907bfd53e7ec87b41d23abbeb6162098">&#9670;&#160;</a></span>hasAnyCalleeReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::logic::tribool Rose::BinaryAnalysis::Partitioner2::hasAnyCalleeReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>May-return status for function callees. </p>
<p>Returns true if any callee may-return is positive; false if all callees are negative; indeterminate if any are indeterminate. </p>

</div>
</div>
<a id="a4d9843264098cfff79aba73ed6049e88" name="a4d9843264098cfff79aba73ed6049e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9843264098cfff79aba73ed6049e88">&#9670;&#160;</a></span>hasCallReturnEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::hasCallReturnEdges </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether vertex has at least one call-return edge. </p>
<p>Returns true if the specified vertex has at least one E_CALL_RETURN edge. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
