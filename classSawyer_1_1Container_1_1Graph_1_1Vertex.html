<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html">Vertex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1Graph_1_1Vertex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class V = Nothing, class E = Nothing, class VKey = GraphVertexNoKey&lt;V&gt;, class EKey = GraphEdgeNoKey&lt;E&gt;, class Alloc = DefaultAllocator&gt;<br />
class Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex</div><p><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> node. </p>
<p>These list nodes contain all information about a vertex and are the objects returned (by reference) when a vertex node iterator (<a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> or <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a>) is dereferenced. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01205">1205</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Graph_8h_source.html">Sawyer/Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae375f32ad689430cf5bd48f3829baaf8" id="r_ae375f32ad689430cf5bd48f3829baaf8"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#ae375f32ad689430cf5bd48f3829baaf8">id</a> () const</td></tr>
<tr class="memdesc:ae375f32ad689430cf5bd48f3829baaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique vertex ID number.  <br /></td></tr>
<tr class="separator:ae375f32ad689430cf5bd48f3829baaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22b3763acb80406da6c92d2cf2bc42" id="r_a8e22b3763acb80406da6c92d2cf2bc42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a8e22b3763acb80406da6c92d2cf2bc42">nInEdges</a> () const</td></tr>
<tr class="memdesc:a8e22b3763acb80406da6c92d2cf2bc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of incoming edges.  <br /></td></tr>
<tr class="separator:a8e22b3763acb80406da6c92d2cf2bc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c5527e63eb3cbc37f81139325740e" id="r_abd7c5527e63eb3cbc37f81139325740e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#abd7c5527e63eb3cbc37f81139325740e">nOutEdges</a> () const</td></tr>
<tr class="memdesc:abd7c5527e63eb3cbc37f81139325740e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of outgoing edges.  <br /></td></tr>
<tr class="separator:abd7c5527e63eb3cbc37f81139325740e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4e8dc79b129a8d6fe2e708eb17743c" id="r_ace4e8dc79b129a8d6fe2e708eb17743c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#ace4e8dc79b129a8d6fe2e708eb17743c">degree</a> () const</td></tr>
<tr class="memdesc:ace4e8dc79b129a8d6fe2e708eb17743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of incident edges.  <br /></td></tr>
<tr class="separator:ace4e8dc79b129a8d6fe2e708eb17743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3723c78463b56264f13e66d06a8089d8" id="r_a3723c78463b56264f13e66d06a8089d8"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3723c78463b56264f13e66d06a8089d8">inEdges</a> ()</td></tr>
<tr class="memdesc:a3723c78463b56264f13e66d06a8089d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of incoming edges.  <br /></td></tr>
<tr class="separator:a3723c78463b56264f13e66d06a8089d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd74775330d02dea0fcd220a30369a8" id="r_addd74775330d02dea0fcd220a30369a8"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#addd74775330d02dea0fcd220a30369a8">inEdges</a> () const</td></tr>
<tr class="memdesc:addd74775330d02dea0fcd220a30369a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of incoming edges.  <br /></td></tr>
<tr class="separator:addd74775330d02dea0fcd220a30369a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49f327e83676c52cd1f069ece7e125fe" id="r_a49f327e83676c52cd1f069ece7e125fe"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a49f327e83676c52cd1f069ece7e125fe">outEdges</a> ()</td></tr>
<tr class="memdesc:a49f327e83676c52cd1f069ece7e125fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of outgoing edges.  <br /></td></tr>
<tr class="separator:a49f327e83676c52cd1f069ece7e125fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df4c1b53d468657710121b6a2e0a828" id="r_a7df4c1b53d468657710121b6a2e0a828"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a7df4c1b53d468657710121b6a2e0a828">outEdges</a> () const</td></tr>
<tr class="memdesc:a7df4c1b53d468657710121b6a2e0a828"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of outgoing edges.  <br /></td></tr>
<tr class="separator:a7df4c1b53d468657710121b6a2e0a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae66545024c7d4b487c9c0ed89ac31769" id="r_ae66545024c7d4b487c9c0ed89ac31769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#ae66545024c7d4b487c9c0ed89ac31769">value</a> ()</td></tr>
<tr class="memdesc:ae66545024c7d4b487c9c0ed89ac31769"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined value.  <br /></td></tr>
<tr class="separator:ae66545024c7d4b487c9c0ed89ac31769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f435ae35bfdc80b1ad4a77272bdb982" id="r_a0f435ae35bfdc80b1ad4a77272bdb982"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a0f435ae35bfdc80b1ad4a77272bdb982">value</a> () const</td></tr>
<tr class="memdesc:a0f435ae35bfdc80b1ad4a77272bdb982"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined value.  <br /></td></tr>
<tr class="separator:a0f435ae35bfdc80b1ad4a77272bdb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae375f32ad689430cf5bd48f3829baaf8" name="ae375f32ad689430cf5bd48f3829baaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae375f32ad689430cf5bd48f3829baaf8">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unique vertex ID number. </p>
<p>Vertices within a graph are numbered consecutively starting at zero, and this method returns the vertex's ID number. ID numbers are unrelated to the order in which vertices are inserted, although in the absense of vertex erasure they will be assigned consecutively. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> ID numbers are stable over insertion of vertices and edges and the erasure of edges, but are not stable over vertex erasure. In order to obtain constant-time vertex erasure (at least when it has no incident edges), after a vertex is erased the largest-ID vertex is renumbered to fill the gap.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01225">1225</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02061">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l02041">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l01986">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00286">Sawyer::Container::Algorithm::graphDependentOrder()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00176">Sawyer::Container::Algorithm::graphFindConnectedComponents()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>, <a class="el" href="Graph_8h_source.html#l01824">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, <a class="el" href="Graph_8h_source.html#l01846">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe()</a>, <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a3723c78463b56264f13e66d06a8089d8" name="a3723c78463b56264f13e66d06a8089d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3723c78463b56264f13e66d06a8089d8">&#9670;&#160;</a></span>inEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::inEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of incoming edges. </p>
<p>Returns a sublist of edges whose target vertex is this vertex. The return value is a pair of iterators which delineate the edges. The traversal is in no particular order. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterators are equality-comparable with one another even when the come from different sublists. See <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> for details.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01236">1236</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00176">Sawyer::Container::Algorithm::graphFindConnectedComponents()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>.</p>

</div>
</div>
<a id="addd74775330d02dea0fcd220a30369a8" name="addd74775330d02dea0fcd220a30369a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd74775330d02dea0fcd220a30369a8">&#9670;&#160;</a></span>inEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::inEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of incoming edges. </p>
<p>Returns a sublist of edges whose target vertex is this vertex. The return value is a pair of iterators which delineate the edges. The traversal is in no particular order. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterators are equality-comparable with one another even when the come from different sublists. See <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> for details.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01241">1241</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a49f327e83676c52cd1f069ece7e125fe" name="a49f327e83676c52cd1f069ece7e125fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f327e83676c52cd1f069ece7e125fe">&#9670;&#160;</a></span>outEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of outgoing edges. </p>
<p>Returns a sublist of edges whose source vertex is this vertex. The return value is a pair of iterators which delineate the edges. The traversal is in no particular order. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterators are equality-comparable with one another even when the come from different sublists. See <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> for details.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01257">1257</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00286">Sawyer::Container::Algorithm::graphDependentOrder()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00255">Sawyer::Container::Algorithm::graphEraseParallelEdges()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00176">Sawyer::Container::Algorithm::graphFindConnectedComponents()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>.</p>

</div>
</div>
<a id="a7df4c1b53d468657710121b6a2e0a828" name="a7df4c1b53d468657710121b6a2e0a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df4c1b53d468657710121b6a2e0a828">&#9670;&#160;</a></span>outEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of outgoing edges. </p>
<p>Returns a sublist of edges whose source vertex is this vertex. The return value is a pair of iterators which delineate the edges. The traversal is in no particular order. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterators are equality-comparable with one another even when the come from different sublists. See <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> for details.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01262">1262</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a8e22b3763acb80406da6c92d2cf2bc42" name="a8e22b3763acb80406da6c92d2cf2bc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e22b3763acb80406da6c92d2cf2bc42">&#9670;&#160;</a></span>nInEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::nInEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of incoming edges. </p>
<p>Returns the in-degree of this vertex, the length of the list returned by <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3723c78463b56264f13e66d06a8089d8">inEdges</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01272">1272</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="abd7c5527e63eb3cbc37f81139325740e" name="abd7c5527e63eb3cbc37f81139325740e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7c5527e63eb3cbc37f81139325740e">&#9670;&#160;</a></span>nOutEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::nOutEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of outgoing edges. </p>
<p>Returns the out-degree of this vertex, the length of the list returned by <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a49f327e83676c52cd1f069ece7e125fe">outEdges</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01279">1279</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00255">Sawyer::Container::Algorithm::graphEraseParallelEdges()</a>.</p>

</div>
</div>
<a id="ace4e8dc79b129a8d6fe2e708eb17743c" name="ace4e8dc79b129a8d6fe2e708eb17743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4e8dc79b129a8d6fe2e708eb17743c">&#9670;&#160;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of incident edges. </p>
<p>Returns the total number of incident edges, the sum of <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a8e22b3763acb80406da6c92d2cf2bc42">nInEdges</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#abd7c5527e63eb3cbc37f81139325740e">nOutEdges</a>. Self-edges are counted two times: once for the source end, and once for the target end. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01287">1287</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="ae66545024c7d4b487c9c0ed89ac31769" name="ae66545024c7d4b487c9c0ed89ac31769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66545024c7d4b487c9c0ed89ac31769">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined value. </p>
<p>Each vertex stores one user-defined value whose type is specified as the <code>V</code> parameter of the <a class="el" href="classSawyer_1_1Container_1_1Graph.html" title="Graph containing user-defined vertices and edges.">Graph</a> template (a.k.a., the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> type). This method returns a reference to that data, which was copied into the graph when this vertex was inserted. This is also the value that is returned when a vertex value iterator (<a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a> or <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a>) is dereferenced.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01301">1301</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01978">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a0f435ae35bfdc80b1ad4a77272bdb982" name="a0f435ae35bfdc80b1ad4a77272bdb982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f435ae35bfdc80b1ad4a77272bdb982">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined value. </p>
<p>Each vertex stores one user-defined value whose type is specified as the <code>V</code> parameter of the <a class="el" href="classSawyer_1_1Container_1_1Graph.html" title="Graph containing user-defined vertices and edges.">Graph</a> template (a.k.a., the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> type). This method returns a reference to that data, which was copied into the graph when this vertex was inserted. This is also the value that is returned when a vertex value iterator (<a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a> or <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a>) is dereferenced.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01302">1302</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
