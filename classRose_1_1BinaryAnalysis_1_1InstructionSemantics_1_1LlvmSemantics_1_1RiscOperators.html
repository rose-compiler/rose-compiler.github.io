<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html">LlvmSemantics</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00042">42</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>
</div><div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_inherit__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_inherit__map">
<area shape="rect" title=" " alt="" coords="19,108,231,163"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain." alt="" coords="5,5,244,60"/>
<area shape="poly" title=" " alt="" coords="127,74,127,108,122,108,122,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_coll__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_coll__map">
<area shape="rect" title=" " alt="" coords="19,108,231,163"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain." alt="" coords="5,5,244,60"/>
<area shape="poly" title=" " alt="" coords="127,74,127,108,122,108,122,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_1_1Indent.html">Indent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause indentation until this object is destroyed.  <a href="structRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators_1_1Indent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8c3c7ad1796cb535d699ee345187d766" id="r_a8c3c7ad1796cb535d699ee345187d766"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a8c3c7ad1796cb535d699ee345187d766">Super</a> = <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memdesc:a8c3c7ad1796cb535d699ee345187d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <br /></td></tr>
<tr class="separator:a8c3c7ad1796cb535d699ee345187d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63db9c25141b369719791207a828e40d" id="r_a63db9c25141b369719791207a828e40d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a63db9c25141b369719791207a828e40d">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a></td></tr>
<tr class="memdesc:a63db9c25141b369719791207a828e40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a63db9c25141b369719791207a828e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a17189f716df0b9be32eddbe0ae27f7b3 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a17189f716df0b9be32eddbe0ae27f7b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a17189f716df0b9be32eddbe0ae27f7b3">Super</a> = <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">BaseSemantics::RiscOperators</a></td></tr>
<tr class="memdesc:a17189f716df0b9be32eddbe0ae27f7b3 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type.  <br /></td></tr>
<tr class="separator:a17189f716df0b9be32eddbe0ae27f7b3 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006d52af82b20674ed14c213031f2fe4 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a006d52af82b20674ed14c213031f2fe4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a006d52af82b20674ed14c213031f2fe4">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae3899d47205079ff24dcfba3210bd5cd">RiscOperatorsPtr</a></td></tr>
<tr class="memdesc:a006d52af82b20674ed14c213031f2fe4 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a006d52af82b20674ed14c213031f2fe4 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators</a></td></tr>
<tr class="memitem:acbac0f80deb727275f231b8d9040b2a7 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_acbac0f80deb727275f231b8d9040b2a7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7">IteStatus</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7a9fc49374420f4310fb89e88ea2689da5">NEITHER</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7a7fc56270e7a70fa81a5935b72eacbe29">A</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7a9d5ed678fe57bcca610140957afab571">B</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7a6328e5e3186c227a021ef2ff77e40197">BOTH</a>
<br />
 }</td></tr>
<tr class="memdesc:acbac0f80deb727275f231b8d9040b2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status for <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a6e226f68e1fd1822ff48eed8a3fb52fe">iteWithStatus</a> operation.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7">More...</a><br /></td></tr>
<tr class="separator:acbac0f80deb727275f231b8d9040b2a7 inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a426773481ab705c0080f4ad1a90bbe inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a9a426773481ab705c0080f4ad1a90bbe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a9a426773481ab705c0080f4ad1a90bbe">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a></td></tr>
<tr class="memdesc:a9a426773481ab705c0080f4ad1a90bbe inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a9a426773481ab705c0080f4ad1a90bbe inherit pub_types_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ff56829f2b8dc8a4527293d7e08fa4d" id="r_a3ff56829f2b8dc8a4527293d7e08fa4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a3ff56829f2b8dc8a4527293d7e08fa4d">create</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) const override</td></tr>
<tr class="memdesc:a3ff56829f2b8dc8a4527293d7e08fa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual allocating constructor.  <br /></td></tr>
<tr class="separator:a3ff56829f2b8dc8a4527293d7e08fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69623fa863d77d7da49c29aaa6889a9" id="r_aa69623fa863d77d7da49c29aaa6889a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aa69623fa863d77d7da49c29aaa6889a9">create</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;state, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) const override</td></tr>
<tr class="memdesc:aa69623fa863d77d7da49c29aaa6889a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual allocating constructor.  <br /></td></tr>
<tr class="separator:aa69623fa863d77d7da49c29aaa6889a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af261c1bf1aa409b356af5c50991126cf" id="r_af261c1bf1aa409b356af5c50991126cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#af261c1bf1aa409b356af5c50991126cf">readMemory</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> segreg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;dflt, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;cond) override</td></tr>
<tr class="memdesc:af261c1bf1aa409b356af5c50991126cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from memory.  <br /></td></tr>
<tr class="separator:af261c1bf1aa409b356af5c50991126cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c19f51e41012add2f3f10aef59c29b" id="r_a88c19f51e41012add2f3f10aef59c29b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a88c19f51e41012add2f3f10aef59c29b">writeMemory</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> segreg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;data, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;cond) override</td></tr>
<tr class="memdesc:a88c19f51e41012add2f3f10aef59c29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to memory.  <br /></td></tr>
<tr class="separator:a88c19f51e41012add2f3f10aef59c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672499bc4842510c1b2dd314b084ddcd" id="r_a672499bc4842510c1b2dd314b084ddcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a672499bc4842510c1b2dd314b084ddcd">indent</a> (int nlevels=1)</td></tr>
<tr class="memdesc:a672499bc4842510c1b2dd314b084ddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase indentation by <code>nlevels</code> levels.  <br /></td></tr>
<tr class="separator:a672499bc4842510c1b2dd314b084ddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5eb9328430f4526ac023ffe8701148" id="r_aac5eb9328430f4526ac023ffe8701148"><td class="memItemLeft" align="right" valign="top"><a id="aac5eb9328430f4526ac023ffe8701148" name="aac5eb9328430f4526ac023ffe8701148"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>prefix</b> () const</td></tr>
<tr class="memdesc:aac5eb9328430f4526ac023ffe8701148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return indentation string. <br /></td></tr>
<tr class="separator:aac5eb9328430f4526ac023ffe8701148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64288d641cc56a6a05361b589a7355cc" id="r_a64288d641cc56a6a05361b589a7355cc"><td class="memItemLeft" align="right" valign="top"><a id="a64288d641cc56a6a05361b589a7355cc" name="a64288d641cc56a6a05361b589a7355cc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a64288d641cc56a6a05361b589a7355cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to initial state. <br /></td></tr>
<tr class="separator:a64288d641cc56a6a05361b589a7355cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008d3469c5c0b6721dbbfb7999644af1" id="r_a008d3469c5c0b6721dbbfb7999644af1"><td class="memItemLeft" align="right" valign="top">virtual const RegisterDescriptors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a008d3469c5c0b6721dbbfb7999644af1">get_important_registers</a> ()</td></tr>
<tr class="memdesc:a008d3469c5c0b6721dbbfb7999644af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of registers that needs to be emitted to LLVM.  <br /></td></tr>
<tr class="separator:a008d3469c5c0b6721dbbfb7999644af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba06ef76e7fb2c6671a672c744ca990" id="r_a8ba06ef76e7fb2c6671a672c744ca990"><td class="memItemLeft" align="right" valign="top">virtual RegisterDescriptors&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a8ba06ef76e7fb2c6671a672c744ca990">get_stored_registers</a> ()</td></tr>
<tr class="memdesc:a8ba06ef76e7fb2c6671a672c744ca990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of important registers that are stored.  <br /></td></tr>
<tr class="separator:a8ba06ef76e7fb2c6671a672c744ca990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bb2156f7ea994f8b02ba3efe1fd841" id="r_ac2bb2156f7ea994f8b02ba3efe1fd841"><td class="memItemLeft" align="right" valign="top"><a id="ac2bb2156f7ea994f8b02ba3efe1fd841" name="ac2bb2156f7ea994f8b02ba3efe1fd841"></a>
virtual RegisterDescriptors&#160;</td><td class="memItemRight" valign="bottom"><b>get_modified_registers</b> ()</td></tr>
<tr class="memdesc:ac2bb2156f7ea994f8b02ba3efe1fd841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of important registers that have been modified since the last call to <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a0e4f1e6425d5a27674c60dc65dc97754" title="Mark the current state as having been emitted.">make_current()</a>. <br /></td></tr>
<tr class="separator:ac2bb2156f7ea994f8b02ba3efe1fd841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3886bcd775d28f3753de25130a006bcf" id="r_a3886bcd775d28f3753de25130a006bcf"><td class="memItemLeft" align="right" valign="top"><a id="a3886bcd775d28f3753de25130a006bcf" name="a3886bcd775d28f3753de25130a006bcf"></a>
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_insn_pointer_register</b> ()</td></tr>
<tr class="memdesc:a3886bcd775d28f3753de25130a006bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the descriptor for the instruction pointer register. <br /></td></tr>
<tr class="separator:a3886bcd775d28f3753de25130a006bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b24b5905ccd4ecd88c9d31bf6ed8eb" id="r_a15b24b5905ccd4ecd88c9d31bf6ed8eb"><td class="memItemLeft" align="right" valign="top"><a id="a15b24b5905ccd4ecd88c9d31bf6ed8eb" name="a15b24b5905ccd4ecd88c9d31bf6ed8eb"></a>
virtual <a class="el" href="classSawyer_1_1SharedPointer.html">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_instruction_pointer</b> ()</td></tr>
<tr class="memdesc:a15b24b5905ccd4ecd88c9d31bf6ed8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the instruction pointer. <br /></td></tr>
<tr class="separator:a15b24b5905ccd4ecd88c9d31bf6ed8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc727b356b6f9a67e02e86af8e10345" id="r_a7dc727b356b6f9a67e02e86af8e10345"><td class="memItemLeft" align="right" valign="top">virtual const TreeNodes &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a7dc727b356b6f9a67e02e86af8e10345">get_memory_writes</a> ()</td></tr>
<tr class="memdesc:a7dc727b356b6f9a67e02e86af8e10345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of memory writes that have occured since the last call to <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a0e4f1e6425d5a27674c60dc65dc97754" title="Mark the current state as having been emitted.">make_current()</a>.  <br /></td></tr>
<tr class="separator:a7dc727b356b6f9a67e02e86af8e10345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4f1e6425d5a27674c60dc65dc97754" id="r_a0e4f1e6425d5a27674c60dc65dc97754"><td class="memItemLeft" align="right" valign="top"><a id="a0e4f1e6425d5a27674c60dc65dc97754" name="a0e4f1e6425d5a27674c60dc65dc97754"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>make_current</b> ()</td></tr>
<tr class="memdesc:a0e4f1e6425d5a27674c60dc65dc97754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current state as having been emitted. <br /></td></tr>
<tr class="separator:a0e4f1e6425d5a27674c60dc65dc97754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7420ada7fe8a03bba6faf9929cc1fcfc" id="r_a7420ada7fe8a03bba6faf9929cc1fcfc"><td class="memItemLeft" align="right" valign="top"><a id="a7420ada7fe8a03bba6faf9929cc1fcfc" name="a7420ada7fe8a03bba6faf9929cc1fcfc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>add_rewrite</b> (const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;from, const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;to)</td></tr>
<tr class="memdesc:a7420ada7fe8a03bba6faf9929cc1fcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rewrite. <br /></td></tr>
<tr class="separator:a7420ada7fe8a03bba6faf9929cc1fcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864052b291e4ffc8d60e2cb6869de202" id="r_a864052b291e4ffc8d60e2cb6869de202"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a864052b291e4ffc8d60e2cb6869de202">add_variable</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;)</td></tr>
<tr class="memdesc:a864052b291e4ffc8d60e2cb6869de202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an LLVM variable.  <br /></td></tr>
<tr class="separator:a864052b291e4ffc8d60e2cb6869de202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978adebe1f276a2f7910b81170d25160" id="r_a978adebe1f276a2f7910b81170d25160"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a978adebe1f276a2f7910b81170d25160">get_variable</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;)</td></tr>
<tr class="memdesc:a978adebe1f276a2f7910b81170d25160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LLVM name for a variable, including the sigil.  <br /></td></tr>
<tr class="separator:a978adebe1f276a2f7910b81170d25160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf193af4262b776516206eb9fcc47ee4" id="r_aaf193af4262b776516206eb9fcc47ee4"><td class="memItemLeft" align="right" valign="top"><a id="aaf193af4262b776516206eb9fcc47ee4" name="aaf193af4262b776516206eb9fcc47ee4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>emit_register_declarations</b> (std::ostream &amp;, const RegisterDescriptors &amp;)</td></tr>
<tr class="memdesc:aaf193af4262b776516206eb9fcc47ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output LLVM global register declarations for the specified registers. <br /></td></tr>
<tr class="separator:aaf193af4262b776516206eb9fcc47ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0fa705eccde8e94c2bbf7f212f3179" id="r_a0d0fa705eccde8e94c2bbf7f212f3179"><td class="memItemLeft" align="right" valign="top"><a id="a0d0fa705eccde8e94c2bbf7f212f3179" name="a0d0fa705eccde8e94c2bbf7f212f3179"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>emit_register_definitions</b> (std::ostream &amp;, const RegisterDescriptors &amp;)</td></tr>
<tr class="memdesc:a0d0fa705eccde8e94c2bbf7f212f3179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output LLVM global register definitions for the specified registers. <br /></td></tr>
<tr class="separator:a0d0fa705eccde8e94c2bbf7f212f3179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1300cd4f11e8eb06dc87b97b7a0015" id="r_a7d1300cd4f11e8eb06dc87b97b7a0015"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a7d1300cd4f11e8eb06dc87b97b7a0015">emit_prerequisites</a> (std::ostream &amp;, const RegisterDescriptors &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;)</td></tr>
<tr class="memdesc:a7d1300cd4f11e8eb06dc87b97b7a0015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output LLVM global variable reads that are needed to define the specified registers and pending memory writes.  <br /></td></tr>
<tr class="separator:a7d1300cd4f11e8eb06dc87b97b7a0015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cfd991fafcb17ebc33bdd06af6b4e3" id="r_a28cfd991fafcb17ebc33bdd06af6b4e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a28cfd991fafcb17ebc33bdd06af6b4e3">emit_next_eip</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *latest_insn)</td></tr>
<tr class="memdesc:a28cfd991fafcb17ebc33bdd06af6b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an LLVM branch instruction.  <br /></td></tr>
<tr class="separator:a28cfd991fafcb17ebc33bdd06af6b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc55645d5844790750cd4b273e87e71" id="r_a3bc55645d5844790750cd4b273e87e71"><td class="memItemLeft" align="right" valign="top"><a id="a3bc55645d5844790750cd4b273e87e71" name="a3bc55645d5844790750cd4b273e87e71"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>emit_memory_writes</b> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a3bc55645d5844790750cd4b273e87e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output changed memory state. <br /></td></tr>
<tr class="separator:a3bc55645d5844790750cd4b273e87e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba4fe87baa02a72044c90bd3187d17" id="r_a72ba4fe87baa02a72044c90bd3187d17"><td class="memItemLeft" align="right" valign="top"><a id="a72ba4fe87baa02a72044c90bd3187d17" name="a72ba4fe87baa02a72044c90bd3187d17"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>emit_changed_state</b> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a72ba4fe87baa02a72044c90bd3187d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output LLVM to bring the LLVM state up to date with respect to the ROSE state. <br /></td></tr>
<tr class="separator:a72ba4fe87baa02a72044c90bd3187d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6b8c3d207f9add0df1e26aab740dd6" id="r_a1c6b8c3d207f9add0df1e26aab740dd6"><td class="memItemLeft" align="right" valign="top"><a id="a1c6b8c3d207f9add0df1e26aab740dd6" name="a1c6b8c3d207f9add0df1e26aab740dd6"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>llvm_integer_type</b> (size_t nbits)</td></tr>
<tr class="memdesc:a1c6b8c3d207f9add0df1e26aab740dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the LLVM type name for an integer. <br /></td></tr>
<tr class="separator:a1c6b8c3d207f9add0df1e26aab740dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672c2a9a4ff9d252a69fd03b04cc77a0" id="r_a672c2a9a4ff9d252a69fd03b04cc77a0"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a672c2a9a4ff9d252a69fd03b04cc77a0">llvm_term</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a672c2a9a4ff9d252a69fd03b04cc77a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a ROSE variable or integer to an LLVM term.  <br /></td></tr>
<tr class="separator:a672c2a9a4ff9d252a69fd03b04cc77a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed02c2b6aed08808f8371b6cf1d657" id="r_a9aed02c2b6aed08808f8371b6cf1d657"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a9aed02c2b6aed08808f8371b6cf1d657">llvm_lvalue</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;)</td></tr>
<tr class="memdesc:a9aed02c2b6aed08808f8371b6cf1d657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a ROSE variable to an LLVM lvalue.  <br /></td></tr>
<tr class="separator:a9aed02c2b6aed08808f8371b6cf1d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cddf4d67a01a1f390b1946c2ca592e1" id="r_a9cddf4d67a01a1f390b1946c2ca592e1"><td class="memItemLeft" align="right" valign="top"><a id="a9cddf4d67a01a1f390b1946c2ca592e1" name="a9cddf4d67a01a1f390b1946c2ca592e1"></a>
virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_temporary</b> (size_t nbits)</td></tr>
<tr class="memdesc:a9cddf4d67a01a1f390b1946c2ca592e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a temporary variable. <br /></td></tr>
<tr class="separator:a9cddf4d67a01a1f390b1946c2ca592e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3601c313e20fb93a8334c143b50b0d" id="r_a0d3601c313e20fb93a8334c143b50b0d"><td class="memItemLeft" align="right" valign="top"><a id="a0d3601c313e20fb93a8334c143b50b0d" name="a0d3601c313e20fb93a8334c143b50b0d"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>next_label</b> ()</td></tr>
<tr class="memdesc:a0d3601c313e20fb93a8334c143b50b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the name for an LLVM label, excluding the "%" sigil. <br /></td></tr>
<tr class="separator:a0d3601c313e20fb93a8334c143b50b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9206375cb1b74694c201889c630b82" id="r_a9f9206375cb1b74694c201889c630b82"><td class="memItemLeft" align="right" valign="top"><a id="a9f9206375cb1b74694c201889c630b82" name="a9f9206375cb1b74694c201889c630b82"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>addr_label</b> (rose_addr_t)</td></tr>
<tr class="memdesc:a9f9206375cb1b74694c201889c630b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a label for a virtual address. <br /></td></tr>
<tr class="separator:a9f9206375cb1b74694c201889c630b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff623d9458e63c91595022be14a2bc" id="r_a53ff623d9458e63c91595022be14a2bc"><td class="memItemLeft" align="right" valign="top"><a id="a53ff623d9458e63c91595022be14a2bc" name="a53ff623d9458e63c91595022be14a2bc"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>function_label</b> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *)</td></tr>
<tr class="memdesc:a53ff623d9458e63c91595022be14a2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a label for a function. <br /></td></tr>
<tr class="separator:a53ff623d9458e63c91595022be14a2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ef83f2d4fb594ed5dbece42711c3c07" id="r_a3ef83f2d4fb594ed5dbece42711c3c07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a3ef83f2d4fb594ed5dbece42711c3c07">llvmVersion</a> () const</td></tr>
<tr class="memdesc:a3ef83f2d4fb594ed5dbece42711c3c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: LLVM version.  <br /></td></tr>
<tr class="separator:a3ef83f2d4fb594ed5dbece42711c3c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e5b9f9c09be0696ecd08b68684dbf8" id="r_a25e5b9f9c09be0696ecd08b68684dbf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a25e5b9f9c09be0696ecd08b68684dbf8">llvmVersion</a> (int v)</td></tr>
<tr class="memdesc:a25e5b9f9c09be0696ecd08b68684dbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: LLVM version.  <br /></td></tr>
<tr class="separator:a25e5b9f9c09be0696ecd08b68684dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02b9f1a78d65ad0e7c18b63effcd9209" id="r_a02b9f1a78d65ad0e7c18b63effcd9209"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209">emit_expression</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">SValuePtr</a> &amp;)</td></tr>
<tr class="memdesc:a02b9f1a78d65ad0e7c18b63effcd9209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit LLVM statements for an expression.  <br /></td></tr>
<tr class="separator:a02b9f1a78d65ad0e7c18b63effcd9209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbdf089da8572fdc7317a6f1df889bd" id="r_a3fbdf089da8572fdc7317a6f1df889bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a3fbdf089da8572fdc7317a6f1df889bd">emit_expression</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a3fbdf089da8572fdc7317a6f1df889bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit LLVM statements for an expression.  <br /></td></tr>
<tr class="separator:a3fbdf089da8572fdc7317a6f1df889bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0f5fc6e1557e2909851e1a10c86b2c" id="r_afc0f5fc6e1557e2909851e1a10c86b2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#afc0f5fc6e1557e2909851e1a10c86b2c">emit_expression</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;)</td></tr>
<tr class="memdesc:afc0f5fc6e1557e2909851e1a10c86b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit LLVM statements for an expression.  <br /></td></tr>
<tr class="separator:afc0f5fc6e1557e2909851e1a10c86b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a492b4a9b6738dc6b1d0b96061eab3a27 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a492b4a9b6738dc6b1d0b96061eab3a27"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a492b4a9b6738dc6b1d0b96061eab3a27">boolean_</a> (bool b) override</td></tr>
<tr class="memdesc:a492b4a9b6738dc6b1d0b96061eab3a27 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Boolean value.  <br /></td></tr>
<tr class="separator:a492b4a9b6738dc6b1d0b96061eab3a27 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65382370d8d08b97a5efe7e182b586c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a65382370d8d08b97a5efe7e182b586c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a65382370d8d08b97a5efe7e182b586c9">number_</a> (size_t nbits, uint64_t value) override</td></tr>
<tr class="memdesc:a65382370d8d08b97a5efe7e182b586c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number of the specified bit width.  <br /></td></tr>
<tr class="separator:a65382370d8d08b97a5efe7e182b586c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427e04270c96895409196138dd688846 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a427e04270c96895409196138dd688846"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueExpr</b> (const <a class="el" href="classSawyer_1_1SharedPointer.html">ExprPtr</a> &amp;expr, const InsnSet &amp;defs=InsnSet())</td></tr>
<tr class="separator:a427e04270c96895409196138dd688846 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bc141f8f7bd3b4a9204310adbc809b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a16bc141f8f7bd3b4a9204310adbc809b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a16bc141f8f7bd3b4a9204310adbc809b">getset_omit_cur_insn</a> (bool b)</td></tr>
<tr class="separator:a16bc141f8f7bd3b4a9204310adbc809b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc66c59351021da13d4743cea1dc10a4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_abc66c59351021da13d4743cea1dc10a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#abc66c59351021da13d4743cea1dc10a4">substitute</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a> &amp;from, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a> &amp;to)</td></tr>
<tr class="memdesc:abc66c59351021da13d4743cea1dc10a4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute all occurrences of <code>from</code> with <code>to</code> in the current state.  <br /></td></tr>
<tr class="separator:abc66c59351021da13d4743cea1dc10a4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ecf971caa0dfa0712dc862768d128a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a75ecf971caa0dfa0712dc862768d128a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a75ecf971caa0dfa0712dc862768d128a">filterResult</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;)</td></tr>
<tr class="memdesc:a75ecf971caa0dfa0712dc862768d128a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters results from RISC operators.  <br /></td></tr>
<tr class="separator:a75ecf971caa0dfa0712dc862768d128a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff88dff482643b05e5dd0f2cac532a9a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aff88dff482643b05e5dd0f2cac532a9a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">SymbolicExpression::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aff88dff482643b05e5dd0f2cac532a9a">sgTypeToSymbolicType</a> (<a class="el" href="classSgAsmType.html">SgAsmType</a> *)</td></tr>
<tr class="memdesc:aff88dff482643b05e5dd0f2cac532a9a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classSgAsmType.html" title="Base class for binary types.">SgAsmType</a> to a symbolic type.  <br /></td></tr>
<tr class="separator:aff88dff482643b05e5dd0f2cac532a9a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841ff95a2aeb0fbb97a8aca024580848 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a841ff95a2aeb0fbb97a8aca024580848"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a841ff95a2aeb0fbb97a8aca024580848">interrupt</a> (int majr, int minr) override</td></tr>
<tr class="memdesc:a841ff95a2aeb0fbb97a8aca024580848 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally raise an interrupt.  <br /></td></tr>
<tr class="separator:a841ff95a2aeb0fbb97a8aca024580848 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab91e5747e77d1ba50e815c3161c03f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aeab91e5747e77d1ba50e815c3161c03f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aeab91e5747e77d1ba50e815c3161c03f">and_</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:aeab91e5747e77d1ba50e815c3161c03f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bit-wise AND of two values.  <br /></td></tr>
<tr class="separator:aeab91e5747e77d1ba50e815c3161c03f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc71d1e14117498bc69d5626233b8cc6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_afc71d1e14117498bc69d5626233b8cc6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#afc71d1e14117498bc69d5626233b8cc6">or_</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:afc71d1e14117498bc69d5626233b8cc6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bit-wise OR of two values.  <br /></td></tr>
<tr class="separator:afc71d1e14117498bc69d5626233b8cc6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15a85ddb8cff4baea1fa28a16730152 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ad15a85ddb8cff4baea1fa28a16730152"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ad15a85ddb8cff4baea1fa28a16730152">xor_</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:ad15a85ddb8cff4baea1fa28a16730152 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes bit-wise XOR of two values.  <br /></td></tr>
<tr class="separator:ad15a85ddb8cff4baea1fa28a16730152 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323b6ceebd2cbc40ea34f5d0262a4b99 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a323b6ceebd2cbc40ea34f5d0262a4b99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a323b6ceebd2cbc40ea34f5d0262a4b99">invert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:a323b6ceebd2cbc40ea34f5d0262a4b99 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">One's complement.  <br /></td></tr>
<tr class="separator:a323b6ceebd2cbc40ea34f5d0262a4b99 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8b02e89fd8bfa3cb157afb0a8403d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ade8b02e89fd8bfa3cb157afb0a8403d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ade8b02e89fd8bfa3cb157afb0a8403d5">extract</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, size_t begin_bit, size_t end_bit) override</td></tr>
<tr class="memdesc:ade8b02e89fd8bfa3cb157afb0a8403d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts bits from a value.  <br /></td></tr>
<tr class="separator:ade8b02e89fd8bfa3cb157afb0a8403d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70967d385ba9527a9daed1ab4e6b205 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ad70967d385ba9527a9daed1ab4e6b205"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ad70967d385ba9527a9daed1ab4e6b205">concat</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:ad70967d385ba9527a9daed1ab4e6b205 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the bits of two values.  <br /></td></tr>
<tr class="separator:ad70967d385ba9527a9daed1ab4e6b205 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97d36aea61ecfc57eeb4c511caf011 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aab97d36aea61ecfc57eeb4c511caf011"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aab97d36aea61ecfc57eeb4c511caf011">leastSignificantSetBit</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:aab97d36aea61ecfc57eeb4c511caf011 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns position of least significant set bit; zero when no bits are set.  <br /></td></tr>
<tr class="separator:aab97d36aea61ecfc57eeb4c511caf011 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac06e5c5725e4b2ce3e45fe42d5e6ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a6ac06e5c5725e4b2ce3e45fe42d5e6ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a6ac06e5c5725e4b2ce3e45fe42d5e6ae">mostSignificantSetBit</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:a6ac06e5c5725e4b2ce3e45fe42d5e6ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns position of most significant set bit; zero when no bits are set.  <br /></td></tr>
<tr class="separator:a6ac06e5c5725e4b2ce3e45fe42d5e6ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1878f5b0908acf7e01e2b11a744fde inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a5c1878f5b0908acf7e01e2b11a744fde"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a5c1878f5b0908acf7e01e2b11a744fde">rotateLeft</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sa_) override</td></tr>
<tr class="memdesc:a5c1878f5b0908acf7e01e2b11a744fde inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits to the left.  <br /></td></tr>
<tr class="separator:a5c1878f5b0908acf7e01e2b11a744fde inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488c0d676e2010590c1f22d36506c65c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a488c0d676e2010590c1f22d36506c65c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a488c0d676e2010590c1f22d36506c65c">rotateRight</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sa_) override</td></tr>
<tr class="memdesc:a488c0d676e2010590c1f22d36506c65c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits to the right.  <br /></td></tr>
<tr class="separator:a488c0d676e2010590c1f22d36506c65c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55911487a44518b050d7e133b6c138 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_adc55911487a44518b050d7e133b6c138"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#adc55911487a44518b050d7e133b6c138">shiftLeft</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sa_) override</td></tr>
<tr class="memdesc:adc55911487a44518b050d7e133b6c138 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns arg shifted left.  <br /></td></tr>
<tr class="separator:adc55911487a44518b050d7e133b6c138 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a75333e5990178b3efb6e7b33043aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a51a75333e5990178b3efb6e7b33043aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a51a75333e5990178b3efb6e7b33043aa">shiftRight</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sa_) override</td></tr>
<tr class="memdesc:a51a75333e5990178b3efb6e7b33043aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns arg shifted right logically (no sign bit).  <br /></td></tr>
<tr class="separator:a51a75333e5990178b3efb6e7b33043aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b008972d60fcabe52abd37e178afaaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a6b008972d60fcabe52abd37e178afaaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a6b008972d60fcabe52abd37e178afaaa">shiftRightArithmetic</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sa_) override</td></tr>
<tr class="memdesc:a6b008972d60fcabe52abd37e178afaaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns arg shifted right arithmetically (with sign bit).  <br /></td></tr>
<tr class="separator:a6b008972d60fcabe52abd37e178afaaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6e5901c18ff7e4d0857492c72a5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a9a6e5901c18ff7e4d0857492c72a5780"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a9a6e5901c18ff7e4d0857492c72a5780">equalToZero</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:a9a6e5901c18ff7e4d0857492c72a5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a value is equal to zero.  <br /></td></tr>
<tr class="separator:a9a6e5901c18ff7e4d0857492c72a5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d1ca09044a0793e84fc6ccd7f87421 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aa7d1ca09044a0793e84fc6ccd7f87421"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aa7d1ca09044a0793e84fc6ccd7f87421">iteWithStatus</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;sel_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#acbac0f80deb727275f231b8d9040b2a7">IteStatus</a> &amp;) override</td></tr>
<tr class="memdesc:aa7d1ca09044a0793e84fc6ccd7f87421 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">If-then-else with status.  <br /></td></tr>
<tr class="separator:aa7d1ca09044a0793e84fc6ccd7f87421 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53953bd27256ec5994fe13fa4c77101 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ab53953bd27256ec5994fe13fa4c77101"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ab53953bd27256ec5994fe13fa4c77101">unsignedExtend</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, size_t new_width) override</td></tr>
<tr class="memdesc:ab53953bd27256ec5994fe13fa4c77101 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend (or shrink) operand <code>a</code> so it is <code>nbits</code> wide by adding or removing high-order bits.  <br /></td></tr>
<tr class="separator:ab53953bd27256ec5994fe13fa4c77101 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4177253b1c5abcc0d8f640ab79fdbfa8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a4177253b1c5abcc0d8f640ab79fdbfa8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a4177253b1c5abcc0d8f640ab79fdbfa8">signExtend</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, size_t new_width) override</td></tr>
<tr class="memdesc:a4177253b1c5abcc0d8f640ab79fdbfa8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign extends a value.  <br /></td></tr>
<tr class="separator:a4177253b1c5abcc0d8f640ab79fdbfa8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3d91609369e4636097f3f23fd381e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ac1c3d91609369e4636097f3f23fd381e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:ac1c3d91609369e4636097f3f23fd381e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two integers of equal size.  <br /></td></tr>
<tr class="separator:ac1c3d91609369e4636097f3f23fd381e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf99e90bf03833705537da75b133a696 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aaf99e90bf03833705537da75b133a696"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aaf99e90bf03833705537da75b133a696">addWithCarries</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;c_, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;carry_out) override</td></tr>
<tr class="memdesc:aaf99e90bf03833705537da75b133a696 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two values of equal size and a carry bit.  <br /></td></tr>
<tr class="separator:aaf99e90bf03833705537da75b133a696 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd6f7bcd3c64b8e8df2a12ce8e061dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_accd6f7bcd3c64b8e8df2a12ce8e061dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#accd6f7bcd3c64b8e8df2a12ce8e061dc">negate</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:accd6f7bcd3c64b8e8df2a12ce8e061dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two's complement.  <br /></td></tr>
<tr class="separator:accd6f7bcd3c64b8e8df2a12ce8e061dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d91e01c1571b0a44c1361e97392159 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a38d91e01c1571b0a44c1361e97392159"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a38d91e01c1571b0a44c1361e97392159">signedDivide</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:a38d91e01c1571b0a44c1361e97392159 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides two signed values.  <br /></td></tr>
<tr class="separator:a38d91e01c1571b0a44c1361e97392159 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e546838a24c2fc0e4421cfc9ce22a06 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a2e546838a24c2fc0e4421cfc9ce22a06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a2e546838a24c2fc0e4421cfc9ce22a06">signedModulo</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:a2e546838a24c2fc0e4421cfc9ce22a06 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modulo with signed values.  <br /></td></tr>
<tr class="separator:a2e546838a24c2fc0e4421cfc9ce22a06 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a0db3494ec156dc03fb6dba4a7541 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_af71a0db3494ec156dc03fb6dba4a7541"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#af71a0db3494ec156dc03fb6dba4a7541">signedMultiply</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:af71a0db3494ec156dc03fb6dba4a7541 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two signed values.  <br /></td></tr>
<tr class="separator:af71a0db3494ec156dc03fb6dba4a7541 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ee50d772cc367a8ec6056156815c51 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a92ee50d772cc367a8ec6056156815c51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a92ee50d772cc367a8ec6056156815c51">unsignedDivide</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:a92ee50d772cc367a8ec6056156815c51 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides two unsigned values.  <br /></td></tr>
<tr class="separator:a92ee50d772cc367a8ec6056156815c51 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6fd2be6168fcbf327bbdcf1d02d9e8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a0f6fd2be6168fcbf327bbdcf1d02d9e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a0f6fd2be6168fcbf327bbdcf1d02d9e8">unsignedModulo</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:a0f6fd2be6168fcbf327bbdcf1d02d9e8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modulo with unsigned values.  <br /></td></tr>
<tr class="separator:a0f6fd2be6168fcbf327bbdcf1d02d9e8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfcd8d70022d560e4a9791d9a403155 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a8dfcd8d70022d560e4a9791d9a403155"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a8dfcd8d70022d560e4a9791d9a403155">unsignedMultiply</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;b_) override</td></tr>
<tr class="memdesc:a8dfcd8d70022d560e4a9791d9a403155 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned values.  <br /></td></tr>
<tr class="separator:a8dfcd8d70022d560e4a9791d9a403155 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829fc372db7143344abdb1a18171fd1c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a829fc372db7143344abdb1a18171fd1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a829fc372db7143344abdb1a18171fd1c">fpConvert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *aType, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *retType) override</td></tr>
<tr class="memdesc:a829fc372db7143344abdb1a18171fd1c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from one floating-point type to another.  <br /></td></tr>
<tr class="separator:a829fc372db7143344abdb1a18171fd1c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97934f7c0beb06c1f54c9c8ad2cdbd92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a97934f7c0beb06c1f54c9c8ad2cdbd92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a97934f7c0beb06c1f54c9c8ad2cdbd92">reinterpret</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;, <a class="el" href="classSgAsmType.html">SgAsmType</a> *) override</td></tr>
<tr class="memdesc:a97934f7c0beb06c1f54c9c8ad2cdbd92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret an expression as a different type.  <br /></td></tr>
<tr class="separator:a97934f7c0beb06c1f54c9c8ad2cdbd92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c03a2675bcda79e4ec993ba855cbbc4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a4c03a2675bcda79e4ec993ba855cbbc4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a4c03a2675bcda79e4ec993ba855cbbc4">readRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;dflt) override</td></tr>
<tr class="memdesc:a4c03a2675bcda79e4ec993ba855cbbc4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from a register.  <br /></td></tr>
<tr class="separator:a4c03a2675bcda79e4ec993ba855cbbc4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f46f1ec5e167ff25ca2e0a4b669c200 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a4f46f1ec5e167ff25ca2e0a4b669c200"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a4f46f1ec5e167ff25ca2e0a4b669c200">peekRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;dflt) override</td></tr>
<tr class="memdesc:a4f46f1ec5e167ff25ca2e0a4b669c200 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a register value without side effects.  <br /></td></tr>
<tr class="separator:a4f46f1ec5e167ff25ca2e0a4b669c200 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd6d564f4d472f71bc01fbbcab0ee4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7ecd6d564f4d472f71bc01fbbcab0ee4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a7ecd6d564f4d472f71bc01fbbcab0ee4">writeRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;a_) override</td></tr>
<tr class="memdesc:a7ecd6d564f4d472f71bc01fbbcab0ee4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to a register.  <br /></td></tr>
<tr class="separator:a7ecd6d564f4d472f71bc01fbbcab0ee4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6b0182d6522556f0de74bcaa83ad45 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a5a6b0182d6522556f0de74bcaa83ad45"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a5a6b0182d6522556f0de74bcaa83ad45">peekMemory</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> segreg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;dflt) override</td></tr>
<tr class="memdesc:a5a6b0182d6522556f0de74bcaa83ad45 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read memory without side effects.  <br /></td></tr>
<tr class="separator:a5a6b0182d6522556f0de74bcaa83ad45 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afdddae6f19b26d13a6d1182fd6e206 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a8afdddae6f19b26d13a6d1182fd6e206"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>readOrPeekMemory</b> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> segreg, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;dflt, AllowSideEffects::Flag)</td></tr>
<tr class="separator:a8afdddae6f19b26d13a6d1182fd6e206 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e16ac2e23015c90e22e00e62e8573 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a056e16ac2e23015c90e22e00e62e8573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a056e16ac2e23015c90e22e00e62e8573">computingDefiners</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae08ad578f4f00fb39d6557e6a40c40dd">DefinersMode</a> m)</td></tr>
<tr class="memdesc:a056e16ac2e23015c90e22e00e62e8573 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track which instructions define a semantic value.  <br /></td></tr>
<tr class="separator:a056e16ac2e23015c90e22e00e62e8573 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe700018796663f58bebca99d28319d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_abe700018796663f58bebca99d28319d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae08ad578f4f00fb39d6557e6a40c40dd">DefinersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#abe700018796663f58bebca99d28319d2">computingDefiners</a> () const</td></tr>
<tr class="memdesc:abe700018796663f58bebca99d28319d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track which instructions define a semantic value.  <br /></td></tr>
<tr class="separator:abe700018796663f58bebca99d28319d2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d002756fc7e4c519f71e052d202928 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a23d002756fc7e4c519f71e052d202928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a23d002756fc7e4c519f71e052d202928">computingMemoryWriters</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a> m)</td></tr>
<tr class="memdesc:a23d002756fc7e4c519f71e052d202928 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track which instructions write to each memory location.  <br /></td></tr>
<tr class="separator:a23d002756fc7e4c519f71e052d202928 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab087fb4bbb3d38f8ea03ee0e94a71b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_abab087fb4bbb3d38f8ea03ee0e94a71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#abab087fb4bbb3d38f8ea03ee0e94a71b">computingMemoryWriters</a> () const</td></tr>
<tr class="memdesc:abab087fb4bbb3d38f8ea03ee0e94a71b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track which instructions write to each memory location.  <br /></td></tr>
<tr class="separator:abab087fb4bbb3d38f8ea03ee0e94a71b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df358c3750b8eb29451117a0c1f6ca3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7df358c3750b8eb29451117a0c1f6ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a7df358c3750b8eb29451117a0c1f6ca3">computingRegisterWriters</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a> m)</td></tr>
<tr class="memdesc:a7df358c3750b8eb29451117a0c1f6ca3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track latest writer to each register.  <br /></td></tr>
<tr class="separator:a7df358c3750b8eb29451117a0c1f6ca3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff02a8a70e8688f16f9ed03ecc9382d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a4ff02a8a70e8688f16f9ed03ecc9382d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a4ff02a8a70e8688f16f9ed03ecc9382d">computingRegisterWriters</a> () const</td></tr>
<tr class="memdesc:a4ff02a8a70e8688f16f9ed03ecc9382d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Track latest writer to each register.  <br /></td></tr>
<tr class="separator:a4ff02a8a70e8688f16f9ed03ecc9382d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876a1abf646d436af442bd62c434ca6f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a876a1abf646d436af442bd62c434ca6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a876a1abf646d436af442bd62c434ca6f">trimThreshold</a> (uint64_t n)</td></tr>
<tr class="memdesc:a876a1abf646d436af442bd62c434ca6f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Maximum size of expressions.  <br /></td></tr>
<tr class="separator:a876a1abf646d436af442bd62c434ca6f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60e6c687ddac82c94565ce154751249 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ae60e6c687ddac82c94565ce154751249"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ae60e6c687ddac82c94565ce154751249">trimThreshold</a> () const</td></tr>
<tr class="memdesc:ae60e6c687ddac82c94565ce154751249 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Maximum size of expressions.  <br /></td></tr>
<tr class="separator:ae60e6c687ddac82c94565ce154751249 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9e982820acfb2903c5ef4c2adbe1fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a2d9e982820acfb2903c5ef4c2adbe1fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a2d9e982820acfb2903c5ef4c2adbe1fd">nTrimmed</a> () const</td></tr>
<tr class="memdesc:a2d9e982820acfb2903c5ef4c2adbe1fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of symbolic expressions trimmed.  <br /></td></tr>
<tr class="separator:a2d9e982820acfb2903c5ef4c2adbe1fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d17bf7103d0ff5467b9da9d6b11c47c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7d17bf7103d0ff5467b9da9d6b11c47c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a7d17bf7103d0ff5467b9da9d6b11c47c">nTrimmed</a> (size_t n)</td></tr>
<tr class="memdesc:a7d17bf7103d0ff5467b9da9d6b11c47c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of symbolic expressions trimmed.  <br /></td></tr>
<tr class="separator:a7d17bf7103d0ff5467b9da9d6b11c47c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb56ed0f981f4c98e452cb833338a636 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_adb56ed0f981f4c98e452cb833338a636"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#adb56ed0f981f4c98e452cb833338a636">reinterpretMemoryReads</a> () const</td></tr>
<tr class="memdesc:adb56ed0f981f4c98e452cb833338a636 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reinterpret data as unsigned integers when reading from memory or registers.  <br /></td></tr>
<tr class="separator:adb56ed0f981f4c98e452cb833338a636 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e694d3adc15cd93aecc1fbd0be1390a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7e694d3adc15cd93aecc1fbd0be1390a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a7e694d3adc15cd93aecc1fbd0be1390a">reinterpretMemoryReads</a> (bool b)</td></tr>
<tr class="memdesc:a7e694d3adc15cd93aecc1fbd0be1390a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reinterpret data as unsigned integers when reading from memory or registers.  <br /></td></tr>
<tr class="separator:a7e694d3adc15cd93aecc1fbd0be1390a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b732929ccd006ba59e746590cdec23 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_aa9b732929ccd006ba59e746590cdec23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#aa9b732929ccd006ba59e746590cdec23">reinterpretRegisterReads</a> () const</td></tr>
<tr class="memdesc:aa9b732929ccd006ba59e746590cdec23 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reinterpret data as unsigned integers when reading from memory or registers.  <br /></td></tr>
<tr class="separator:aa9b732929ccd006ba59e746590cdec23 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75446ac335db2e546e3f6d0a84328df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ac75446ac335db2e546e3f6d0a84328df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac75446ac335db2e546e3f6d0a84328df">reinterpretRegisterReads</a> (bool b)</td></tr>
<tr class="memdesc:ac75446ac335db2e546e3f6d0a84328df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Reinterpret data as unsigned integers when reading from memory or registers.  <br /></td></tr>
<tr class="separator:ac75446ac335db2e546e3f6d0a84328df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a7c5e09435a745f38ec86be09db43dc12 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a7c5e09435a745f38ec86be09db43dc12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a> () const</td></tr>
<tr class="memdesc:a7c5e09435a745f38ec86be09db43dc12 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Prototypical semantic value.  <br /></td></tr>
<tr class="separator:a7c5e09435a745f38ec86be09db43dc12 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f064a1e99ad4ae1642dc496d7573c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a875f064a1e99ad4ae1642dc496d7573c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a875f064a1e99ad4ae1642dc496d7573c">hash</a> (<a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;)</td></tr>
<tr class="memdesc:a875f064a1e99ad4ae1642dc496d7573c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hash of current state.  <br /></td></tr>
<tr class="separator:a875f064a1e99ad4ae1642dc496d7573c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95092e2c28435893e6786a6deb6a75aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a95092e2c28435893e6786a6deb6a75aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a95092e2c28435893e6786a6deb6a75aa">startInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a95092e2c28435893e6786a6deb6a75aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the beginning of every instruction.  <br /></td></tr>
<tr class="separator:a95092e2c28435893e6786a6deb6a75aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605075b85b67c1b9b729c0446acb334 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a7605075b85b67c1b9b729c0446acb334"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7605075b85b67c1b9b729c0446acb334">finishInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a7605075b85b67c1b9b729c0446acb334 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the end of every instruction.  <br /></td></tr>
<tr class="separator:a7605075b85b67c1b9b729c0446acb334 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1006835b3be274a2cb0d70702f2ef191 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a1006835b3be274a2cb0d70702f2ef191"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a1006835b3be274a2cb0d70702f2ef191">comment</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a1006835b3be274a2cb0d70702f2ef191 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a line comment into debugging streams.  <br /></td></tr>
<tr class="separator:a1006835b3be274a2cb0d70702f2ef191 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229f65685bb4a158f6279023a60f72cf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a229f65685bb4a158f6279023a60f72cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a229f65685bb4a158f6279023a60f72cf">bottom_</a> (size_t nbits)</td></tr>
<tr class="memdesc:a229f65685bb4a158f6279023a60f72cf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a data-flow bottom value.  <br /></td></tr>
<tr class="separator:a229f65685bb4a158f6279023a60f72cf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789ec9521537bf50f0d68b9391da5cc7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a789ec9521537bf50f0d68b9391da5cc7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a789ec9521537bf50f0d68b9391da5cc7">filterCallTarget</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a)</td></tr>
<tr class="memdesc:a789ec9521537bf50f0d68b9391da5cc7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked to filter call targets.  <br /></td></tr>
<tr class="separator:a789ec9521537bf50f0d68b9391da5cc7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ca11f2453f0981d09fca211414bf49 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a86ca11f2453f0981d09fca211414bf49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a86ca11f2453f0981d09fca211414bf49">filterReturnTarget</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a)</td></tr>
<tr class="memdesc:a86ca11f2453f0981d09fca211414bf49 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked to filter return targets.  <br /></td></tr>
<tr class="separator:a86ca11f2453f0981d09fca211414bf49 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2b8330b3eaa8adc7dfec1c04107e05 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_aff2b8330b3eaa8adc7dfec1c04107e05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aff2b8330b3eaa8adc7dfec1c04107e05">filterIndirectJumpTarget</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a)</td></tr>
<tr class="memdesc:aff2b8330b3eaa8adc7dfec1c04107e05 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked to filter indirect jumps.  <br /></td></tr>
<tr class="separator:aff2b8330b3eaa8adc7dfec1c04107e05 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac696d8ff35958ba4419a77774ca3b47b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac696d8ff35958ba4419a77774ca3b47b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac696d8ff35958ba4419a77774ca3b47b">hlt</a> ()</td></tr>
<tr class="memdesc:ac696d8ff35958ba4419a77774ca3b47b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked for the x86 HLT instruction.  <br /></td></tr>
<tr class="separator:ac696d8ff35958ba4419a77774ca3b47b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1313a4a048d92be82c4dcfc229e6c47a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a1313a4a048d92be82c4dcfc229e6c47a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a1313a4a048d92be82c4dcfc229e6c47a">cpuid</a> ()</td></tr>
<tr class="memdesc:a1313a4a048d92be82c4dcfc229e6c47a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked for the x86 CPUID instruction.  <br /></td></tr>
<tr class="separator:a1313a4a048d92be82c4dcfc229e6c47a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b4d9d2e0508126c6f4a844171f9d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a9d7b4d9d2e0508126c6f4a844171f9d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a9d7b4d9d2e0508126c6f4a844171f9d5">rdtsc</a> ()</td></tr>
<tr class="memdesc:a9d7b4d9d2e0508126c6f4a844171f9d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked for the x86 RDTSC instruction.  <br /></td></tr>
<tr class="separator:a9d7b4d9d2e0508126c6f4a844171f9d5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05f4432cb89a8bd9e4cb6508135507a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ad05f4432cb89a8bd9e4cb6508135507a"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ad05f4432cb89a8bd9e4cb6508135507a">split</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, size_t splitPoint)</td></tr>
<tr class="memdesc:ad05f4432cb89a8bd9e4cb6508135507a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a value into two narrower values.  <br /></td></tr>
<tr class="separator:ad05f4432cb89a8bd9e4cb6508135507a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1488866517e9098166e2f422026e45e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a1488866517e9098166e2f422026e45e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a1488866517e9098166e2f422026e45e4">countLeadingZeros</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a)</td></tr>
<tr class="memdesc:a1488866517e9098166e2f422026e45e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading zero bits.  <br /></td></tr>
<tr class="separator:a1488866517e9098166e2f422026e45e4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e96898a9202fc9ebcedfe694785df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_af78e96898a9202fc9ebcedfe694785df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#af78e96898a9202fc9ebcedfe694785df">countLeadingOnes</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a)</td></tr>
<tr class="memdesc:af78e96898a9202fc9ebcedfe694785df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count leading one bits.  <br /></td></tr>
<tr class="separator:af78e96898a9202fc9ebcedfe694785df inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b2eb747df9ac4c05d609115da4e360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a73b2eb747df9ac4c05d609115da4e360"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a73b2eb747df9ac4c05d609115da4e360">reverseElmts</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, size_t elmtNBits)</td></tr>
<tr class="memdesc:a73b2eb747df9ac4c05d609115da4e360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse parts of a value.  <br /></td></tr>
<tr class="separator:a73b2eb747df9ac4c05d609115da4e360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2b18f1dcb9016ef8eecafebec8f018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a7b2b18f1dcb9016ef8eecafebec8f018"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7b2b18f1dcb9016ef8eecafebec8f018">ite</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;cond, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b) final</td></tr>
<tr class="memdesc:a7b2b18f1dcb9016ef8eecafebec8f018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">If-then-else.  <br /></td></tr>
<tr class="separator:a7b2b18f1dcb9016ef8eecafebec8f018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829b1e77aa53e324fa79d860f0a50124 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a829b1e77aa53e324fa79d860f0a50124"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a829b1e77aa53e324fa79d860f0a50124">addCarry</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;carryOut, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;overflowed)</td></tr>
<tr class="memdesc:a829b1e77aa53e324fa79d860f0a50124 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two integers of equal size and carry.  <br /></td></tr>
<tr class="separator:a829b1e77aa53e324fa79d860f0a50124 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ab95ef72d38e81b002a57715d9b305 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a05ab95ef72d38e81b002a57715d9b305"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a05ab95ef72d38e81b002a57715d9b305">subtract</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;minuend, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;subtrahend)</td></tr>
<tr class="memdesc:a05ab95ef72d38e81b002a57715d9b305 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one value from another.  <br /></td></tr>
<tr class="separator:a05ab95ef72d38e81b002a57715d9b305 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24049850479376faba8fc9fd4592e946 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a24049850479376faba8fc9fd4592e946"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a24049850479376faba8fc9fd4592e946">subtractCarry</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;minuend, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;subtrahend, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;carryOut, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;overflowed)</td></tr>
<tr class="memdesc:a24049850479376faba8fc9fd4592e946 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one value from another and carry.  <br /></td></tr>
<tr class="separator:a24049850479376faba8fc9fd4592e946 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6fbf3868b9a58ba6d6a99dc01da757 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a7b6fbf3868b9a58ba6d6a99dc01da757"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7b6fbf3868b9a58ba6d6a99dc01da757">interrupt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;majr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;minr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;raise)</td></tr>
<tr class="memdesc:a7b6fbf3868b9a58ba6d6a99dc01da757 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked for instructions that cause an interrupt.  <br /></td></tr>
<tr class="separator:a7b6fbf3868b9a58ba6d6a99dc01da757 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad5bc546be21b2ad95c289c85c2073 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac4ad5bc546be21b2ad95c289c85c2073"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac4ad5bc546be21b2ad95c289c85c2073">raiseInterrupt</a> (unsigned majorNumber, unsigned minorNumber, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;raise)</td></tr>
<tr class="memdesc:ac4ad5bc546be21b2ad95c289c85c2073 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally raise an interrupt.  <br /></td></tr>
<tr class="separator:ac4ad5bc546be21b2ad95c289c85c2073 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c70cccc3350cef76096cca7efe3d8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ab97c70cccc3350cef76096cca7efe3d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ab97c70cccc3350cef76096cca7efe3d8">fpFromInteger</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;intValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:ab97c70cccc3350cef76096cca7efe3d8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a floating-point value from an integer value.  <br /></td></tr>
<tr class="separator:ab97c70cccc3350cef76096cca7efe3d8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266c826ab824942797b745586c899ca6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a266c826ab824942797b745586c899ca6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a266c826ab824942797b745586c899ca6">fpToInteger</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;dflt)</td></tr>
<tr class="memdesc:a266c826ab824942797b745586c899ca6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an integer value from a floating-point value.  <br /></td></tr>
<tr class="separator:a266c826ab824942797b745586c899ca6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c7365a245c857ab0961e7653641018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a45c7365a245c857ab0961e7653641018"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a45c7365a245c857ab0961e7653641018">fpIsNan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a45c7365a245c857ab0961e7653641018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a floating-point value is a special not-a-number bit pattern.  <br /></td></tr>
<tr class="separator:a45c7365a245c857ab0961e7653641018 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3658d410e4ed99fde8996f2bc13cea74 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a3658d410e4ed99fde8996f2bc13cea74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a3658d410e4ed99fde8996f2bc13cea74">fpIsDenormalized</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a3658d410e4ed99fde8996f2bc13cea74 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a floating-point value is denormalized.  <br /></td></tr>
<tr class="separator:a3658d410e4ed99fde8996f2bc13cea74 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3e78791766ae61f5bd63e4ec7217f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_aeed3e78791766ae61f5bd63e4ec7217f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aeed3e78791766ae61f5bd63e4ec7217f">fpIsZero</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:aeed3e78791766ae61f5bd63e4ec7217f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a floating-point value is equal to zero.  <br /></td></tr>
<tr class="separator:aeed3e78791766ae61f5bd63e4ec7217f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388b78b6af1b67139da4e1bdc8da3ad0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a388b78b6af1b67139da4e1bdc8da3ad0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a388b78b6af1b67139da4e1bdc8da3ad0">fpIsInfinity</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a388b78b6af1b67139da4e1bdc8da3ad0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a floating-point value is infinity.  <br /></td></tr>
<tr class="separator:a388b78b6af1b67139da4e1bdc8da3ad0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4705305d629bf0dfb63670831b6f9caf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a4705305d629bf0dfb63670831b6f9caf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a4705305d629bf0dfb63670831b6f9caf">fpSign</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a4705305d629bf0dfb63670831b6f9caf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign of floating-point value.  <br /></td></tr>
<tr class="separator:a4705305d629bf0dfb63670831b6f9caf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93296f368070ea3425f73aea2bdc4a3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ae93296f368070ea3425f73aea2bdc4a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ae93296f368070ea3425f73aea2bdc4a3">fpEffectiveExponent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;fpValue, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:ae93296f368070ea3425f73aea2bdc4a3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponent of floating-point value.  <br /></td></tr>
<tr class="separator:ae93296f368070ea3425f73aea2bdc4a3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3235086d4a8513b0920cd8b18cd2ef7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_aa3235086d4a8513b0920cd8b18cd2ef7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aa3235086d4a8513b0920cd8b18cd2ef7">fpAdd</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:aa3235086d4a8513b0920cd8b18cd2ef7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two floating-point values.  <br /></td></tr>
<tr class="separator:aa3235086d4a8513b0920cd8b18cd2ef7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010324f1f25cede2d5f3b19e8255f08 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac010324f1f25cede2d5f3b19e8255f08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac010324f1f25cede2d5f3b19e8255f08">fpSubtract</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:ac010324f1f25cede2d5f3b19e8255f08 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one floating-point value from another.  <br /></td></tr>
<tr class="separator:ac010324f1f25cede2d5f3b19e8255f08 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdff1ff536688d1a0a701a7d9b0ca37 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_abfdff1ff536688d1a0a701a7d9b0ca37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#abfdff1ff536688d1a0a701a7d9b0ca37">fpMultiply</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:abfdff1ff536688d1a0a701a7d9b0ca37 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two floating-point values.  <br /></td></tr>
<tr class="separator:abfdff1ff536688d1a0a701a7d9b0ca37 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407764575990d99299218b54dbd7f786 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a407764575990d99299218b54dbd7f786"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a407764575990d99299218b54dbd7f786">fpDivide</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a407764575990d99299218b54dbd7f786 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide one floating-point value by another.  <br /></td></tr>
<tr class="separator:a407764575990d99299218b54dbd7f786 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecddd74c8dce2e515e68930f56aeb4b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_aecddd74c8dce2e515e68930f56aeb4b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aecddd74c8dce2e515e68930f56aeb4b3">fpSquareRoot</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:aecddd74c8dce2e515e68930f56aeb4b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root.  <br /></td></tr>
<tr class="separator:aecddd74c8dce2e515e68930f56aeb4b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4143b3da42464e4b553180745e538b4b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a4143b3da42464e4b553180745e538b4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a4143b3da42464e4b553180745e538b4b">fpRoundTowardZero</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *fpType)</td></tr>
<tr class="memdesc:a4143b3da42464e4b553180745e538b4b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round toward zero.  <br /></td></tr>
<tr class="separator:a4143b3da42464e4b553180745e538b4b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38c585879e18a82e826743c6c9c95ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ab38c585879e18a82e826743c6c9c95ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ab38c585879e18a82e826743c6c9c95ae">convert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, <a class="el" href="classSgAsmType.html">SgAsmType</a> *srcType, <a class="el" href="classSgAsmType.html">SgAsmType</a> *dstType)</td></tr>
<tr class="memdesc:ab38c585879e18a82e826743c6c9c95ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert value from one type to another.  <br /></td></tr>
<tr class="separator:ab38c585879e18a82e826743c6c9c95ae inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79178527d1f5032c588ed95f32caf596 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a79178527d1f5032c588ed95f32caf596"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a> () const</td></tr>
<tr class="memdesc:a79178527d1f5032c588ed95f32caf596 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Satisfiability module theory (SMT) solver.  <br /></td></tr>
<tr class="separator:a79178527d1f5032c588ed95f32caf596 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6d6233979d76ee24a5d35fc69fdc2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ad6b6d6233979d76ee24a5d35fc69fdc2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ad6b6d6233979d76ee24a5d35fc69fdc2">solver</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;s)</td></tr>
<tr class="memdesc:ad6b6d6233979d76ee24a5d35fc69fdc2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Satisfiability module theory (SMT) solver.  <br /></td></tr>
<tr class="separator:ad6b6d6233979d76ee24a5d35fc69fdc2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac710b405ca3981e26adee36619a89b8e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac710b405ca3981e26adee36619a89b8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1HotPatch.html">HotPatch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac710b405ca3981e26adee36619a89b8e">hotPatch</a> () const</td></tr>
<tr class="memdesc:ac710b405ca3981e26adee36619a89b8e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Post-instruction hot patches.  <br /></td></tr>
<tr class="separator:ac710b405ca3981e26adee36619a89b8e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52989e34edce18ee7f06b948bae68a0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ad52989e34edce18ee7f06b948bae68a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1HotPatch.html">HotPatch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ad52989e34edce18ee7f06b948bae68a0">hotPatch</a> ()</td></tr>
<tr class="memdesc:ad52989e34edce18ee7f06b948bae68a0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Post-instruction hot patches.  <br /></td></tr>
<tr class="separator:ad52989e34edce18ee7f06b948bae68a0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405358f5eaece8e92b3c339833109c54 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a405358f5eaece8e92b3c339833109c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a405358f5eaece8e92b3c339833109c54">hotPatch</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1HotPatch.html">HotPatch</a> &amp;hp)</td></tr>
<tr class="memdesc:a405358f5eaece8e92b3c339833109c54 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Post-instruction hot patches.  <br /></td></tr>
<tr class="separator:a405358f5eaece8e92b3c339833109c54 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a0859028329bc37d6852a1f7776e2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac3a0859028329bc37d6852a1f7776e2f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac3a0859028329bc37d6852a1f7776e2f">currentState</a> () const</td></tr>
<tr class="memdesc:ac3a0859028329bc37d6852a1f7776e2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Current semantic state.  <br /></td></tr>
<tr class="separator:ac3a0859028329bc37d6852a1f7776e2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ce930aa16d365a64e1d46ccf0ddbd9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac0ce930aa16d365a64e1d46ccf0ddbd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac0ce930aa16d365a64e1d46ccf0ddbd9">currentState</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a> &amp;s)</td></tr>
<tr class="memdesc:ac0ce930aa16d365a64e1d46ccf0ddbd9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Current semantic state.  <br /></td></tr>
<tr class="separator:ac0ce930aa16d365a64e1d46ccf0ddbd9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5ca9604e6b98211bcd1da01ab1a897 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a2a5ca9604e6b98211bcd1da01ab1a897"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a2a5ca9604e6b98211bcd1da01ab1a897">initialState</a> () const</td></tr>
<tr class="memdesc:a2a5ca9604e6b98211bcd1da01ab1a897 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional lazily updated initial state.  <br /></td></tr>
<tr class="separator:a2a5ca9604e6b98211bcd1da01ab1a897 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9920b059f337861132fb0b0b7ae026 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_afc9920b059f337861132fb0b0b7ae026"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#afc9920b059f337861132fb0b0b7ae026">initialState</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a> &amp;s)</td></tr>
<tr class="memdesc:afc9920b059f337861132fb0b0b7ae026 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional lazily updated initial state.  <br /></td></tr>
<tr class="separator:afc9920b059f337861132fb0b0b7ae026 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe78f863602ef78e0dbe93119baadc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a9dbe78f863602ef78e0dbe93119baadc"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a9dbe78f863602ef78e0dbe93119baadc">name</a> () const</td></tr>
<tr class="memdesc:a9dbe78f863602ef78e0dbe93119baadc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name used for debugging.  <br /></td></tr>
<tr class="separator:a9dbe78f863602ef78e0dbe93119baadc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d79b2add31d647e7781fbdb4b9bd47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ae9d79b2add31d647e7781fbdb4b9bd47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ae9d79b2add31d647e7781fbdb4b9bd47">name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae9d79b2add31d647e7781fbdb4b9bd47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name used for debugging.  <br /></td></tr>
<tr class="separator:ae9d79b2add31d647e7781fbdb4b9bd47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d8e47058822eb9eea3aa3410609fcb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a59d8e47058822eb9eea3aa3410609fcb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;stream, const std::string prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:a59d8e47058822eb9eea3aa3410609fcb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multi-line output for this object. <br /></td></tr>
<tr class="separator:a59d8e47058822eb9eea3aa3410609fcb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9479c46653cc0212ab8d7913d49d9b1e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a9479c46653cc0212ab8d7913d49d9b1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a9479c46653cc0212ab8d7913d49d9b1e">print</a> (std::ostream &amp;stream, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;fmt) const</td></tr>
<tr class="memdesc:a9479c46653cc0212ab8d7913d49d9b1e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multi-line output for this object.  <br /></td></tr>
<tr class="separator:a9479c46653cc0212ab8d7913d49d9b1e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50b0547666a5077ab16177ea8636fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a3a50b0547666a5077ab16177ea8636fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a3a50b0547666a5077ab16177ea8636fd">with_format</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:a3a50b0547666a5077ab16177ea8636fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing RISC operators with formatting.  <br /></td></tr>
<tr class="separator:a3a50b0547666a5077ab16177ea8636fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab00bc0250e8b78fcdca242654ba7d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac9ab00bc0250e8b78fcdca242654ba7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac9ab00bc0250e8b78fcdca242654ba7d">operator+</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:ac9ab00bc0250e8b78fcdca242654ba7d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing RISC operators with formatting.  <br /></td></tr>
<tr class="separator:ac9ab00bc0250e8b78fcdca242654ba7d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e749fee5b94d6fb1ec578d6aefb6c1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a11e749fee5b94d6fb1ec578d6aefb6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a11e749fee5b94d6fb1ec578d6aefb6c1">operator+</a> (const std::string &amp;linePrefix)</td></tr>
<tr class="memdesc:a11e749fee5b94d6fb1ec578d6aefb6c1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing RISC operators with formatting.  <br /></td></tr>
<tr class="separator:a11e749fee5b94d6fb1ec578d6aefb6c1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7b0b6cc74f0f6f2a000cb9fe64ab09 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a3a7b0b6cc74f0f6f2a000cb9fe64ab09"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a3a7b0b6cc74f0f6f2a000cb9fe64ab09">nInsns</a> () const</td></tr>
<tr class="memdesc:a3a7b0b6cc74f0f6f2a000cb9fe64ab09 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of instructions processed.  <br /></td></tr>
<tr class="separator:a3a7b0b6cc74f0f6f2a000cb9fe64ab09 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5635ef1ebeb9b13c11cd6d40b5e7ab8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ab5635ef1ebeb9b13c11cd6d40b5e7ab8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ab5635ef1ebeb9b13c11cd6d40b5e7ab8">nInsns</a> (size_t n)</td></tr>
<tr class="memdesc:ab5635ef1ebeb9b13c11cd6d40b5e7ab8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of instructions processed.  <br /></td></tr>
<tr class="separator:ab5635ef1ebeb9b13c11cd6d40b5e7ab8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1cf7980a604a81efb96e4e8bae1d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a94a1cf7980a604a81efb96e4e8bae1d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a94a1cf7980a604a81efb96e4e8bae1d6">currentInstruction</a> () const</td></tr>
<tr class="memdesc:a94a1cf7980a604a81efb96e4e8bae1d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Current instruction.  <br /></td></tr>
<tr class="separator:a94a1cf7980a604a81efb96e4e8bae1d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad79fc5cfce8ef1718ecc3c45553589 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a7ad79fc5cfce8ef1718ecc3c45553589"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7ad79fc5cfce8ef1718ecc3c45553589">currentInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a7ad79fc5cfce8ef1718ecc3c45553589 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Current instruction.  <br /></td></tr>
<tr class="separator:a7ad79fc5cfce8ef1718ecc3c45553589 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef85e9818962390170f69e58096532af inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_aef85e9818962390170f69e58096532af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aef85e9818962390170f69e58096532af">isNoopRead</a> () const</td></tr>
<tr class="memdesc:aef85e9818962390170f69e58096532af inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: No-op read.  <br /></td></tr>
<tr class="separator:aef85e9818962390170f69e58096532af inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787efbff78a00e80eaf7f2c2b7580e7e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a787efbff78a00e80eaf7f2c2b7580e7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a787efbff78a00e80eaf7f2c2b7580e7e">isNoopRead</a> (bool b)</td></tr>
<tr class="memdesc:a787efbff78a00e80eaf7f2c2b7580e7e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: No-op read.  <br /></td></tr>
<tr class="separator:a787efbff78a00e80eaf7f2c2b7580e7e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69066ea4dfa212235366d12c7d6fa74a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a69066ea4dfa212235366d12c7d6fa74a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a69066ea4dfa212235366d12c7d6fa74a">undefined_</a> (size_t nbits)</td></tr>
<tr class="memdesc:a69066ea4dfa212235366d12c7d6fa74a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new undefined value.  <br /></td></tr>
<tr class="separator:a69066ea4dfa212235366d12c7d6fa74a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fdcc1d0b538127d0449aa517e7a39c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a67fdcc1d0b538127d0449aa517e7a39c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a67fdcc1d0b538127d0449aa517e7a39c">unspecified_</a> (size_t nbits)</td></tr>
<tr class="memdesc:a67fdcc1d0b538127d0449aa517e7a39c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new undefined value.  <br /></td></tr>
<tr class="separator:a67fdcc1d0b538127d0449aa517e7a39c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85388d490db71a30f45ecdac47b86842 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a85388d490db71a30f45ecdac47b86842"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a85388d490db71a30f45ecdac47b86842">concatLoHi</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;lowBits, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;highBits)</td></tr>
<tr class="memdesc:a85388d490db71a30f45ecdac47b86842 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for concatenation.  <br /></td></tr>
<tr class="separator:a85388d490db71a30f45ecdac47b86842 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198ce70854af5af2f875d97f0e1d4aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ad198ce70854af5af2f875d97f0e1d4aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ad198ce70854af5af2f875d97f0e1d4aa">concatHiLo</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;highBits, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;lowBits)</td></tr>
<tr class="memdesc:ad198ce70854af5af2f875d97f0e1d4aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for concatenation.  <br /></td></tr>
<tr class="separator:ad198ce70854af5af2f875d97f0e1d4aa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bc7d639ccd00cb75efe48b5aefa977 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ac3bc7d639ccd00cb75efe48b5aefa977"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac3bc7d639ccd00cb75efe48b5aefa977">isEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ac3bc7d639ccd00cb75efe48b5aefa977 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <br /></td></tr>
<tr class="separator:ac3bc7d639ccd00cb75efe48b5aefa977 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ba24ec6a27b4aefb8544cd52917b5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ae92ba24ec6a27b4aefb8544cd52917b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ae92ba24ec6a27b4aefb8544cd52917b5">isNotEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ae92ba24ec6a27b4aefb8544cd52917b5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <br /></td></tr>
<tr class="separator:ae92ba24ec6a27b4aefb8544cd52917b5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273cfe8806994c5417d711016c90a4f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a273cfe8806994c5417d711016c90a4f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a273cfe8806994c5417d711016c90a4f1">isUnsignedLessThan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a273cfe8806994c5417d711016c90a4f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for unsigned values.  <br /></td></tr>
<tr class="separator:a273cfe8806994c5417d711016c90a4f1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0983f0d9dbab5dd8a75b2fdbc4ee1b5c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a0983f0d9dbab5dd8a75b2fdbc4ee1b5c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a0983f0d9dbab5dd8a75b2fdbc4ee1b5c">isUnsignedLessThanOrEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a0983f0d9dbab5dd8a75b2fdbc4ee1b5c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for unsigned values.  <br /></td></tr>
<tr class="separator:a0983f0d9dbab5dd8a75b2fdbc4ee1b5c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae352eaefbd5a562af994445f134c46e0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ae352eaefbd5a562af994445f134c46e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ae352eaefbd5a562af994445f134c46e0">isUnsignedGreaterThan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ae352eaefbd5a562af994445f134c46e0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for unsigned values.  <br /></td></tr>
<tr class="separator:ae352eaefbd5a562af994445f134c46e0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99c50aaf9da86163e8b31583577fcd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_ad99c50aaf9da86163e8b31583577fcd4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ad99c50aaf9da86163e8b31583577fcd4">isUnsignedGreaterThanOrEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:ad99c50aaf9da86163e8b31583577fcd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for unsigned values.  <br /></td></tr>
<tr class="separator:ad99c50aaf9da86163e8b31583577fcd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac2d63288aec8f1405eaf069f361525 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a6ac2d63288aec8f1405eaf069f361525"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a6ac2d63288aec8f1405eaf069f361525">isSignedLessThan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a6ac2d63288aec8f1405eaf069f361525 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for signed values.  <br /></td></tr>
<tr class="separator:a6ac2d63288aec8f1405eaf069f361525 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c895e3a92a25ace2c8ddc2d793af3f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a47c895e3a92a25ace2c8ddc2d793af3f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a47c895e3a92a25ace2c8ddc2d793af3f">isSignedLessThanOrEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a47c895e3a92a25ace2c8ddc2d793af3f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for signed values.  <br /></td></tr>
<tr class="separator:a47c895e3a92a25ace2c8ddc2d793af3f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df29e3c1979db228500665d85346531 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a9df29e3c1979db228500665d85346531"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a9df29e3c1979db228500665d85346531">isSignedGreaterThan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a9df29e3c1979db228500665d85346531 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for signed values.  <br /></td></tr>
<tr class="separator:a9df29e3c1979db228500665d85346531 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77639218df9d9cf04bc20f0db5932654 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a77639218df9d9cf04bc20f0db5932654"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a77639218df9d9cf04bc20f0db5932654">isSignedGreaterThanOrEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;b)</td></tr>
<tr class="memdesc:a77639218df9d9cf04bc20f0db5932654 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison for signed values.  <br /></td></tr>
<tr class="separator:a77639218df9d9cf04bc20f0db5932654 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d80abf1c0a958a9ac82cdd3a5c3dd3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_af1d80abf1c0a958a9ac82cdd3a5c3dd3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#af1d80abf1c0a958a9ac82cdd3a5c3dd3">readRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg)</td></tr>
<tr class="memdesc:af1d80abf1c0a958a9ac82cdd3a5c3dd3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a value from a register.  <br /></td></tr>
<tr class="separator:af1d80abf1c0a958a9ac82cdd3a5c3dd3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d61a917ed3aecf4dcaec6c876552ee inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_af0d61a917ed3aecf4dcaec6c876552ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#af0d61a917ed3aecf4dcaec6c876552ee">peekRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg)</td></tr>
<tr class="memdesc:af0d61a917ed3aecf4dcaec6c876552ee inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a register value without side effects.  <br /></td></tr>
<tr class="separator:af0d61a917ed3aecf4dcaec6c876552ee inherit pub_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa410a0428f69de2e147734980b523e4e" id="r_aa410a0428f69de2e147734980b523e4e"><td class="memItemLeft" align="right" valign="top"><a id="aa410a0428f69de2e147734980b523e4e" name="aa410a0428f69de2e147734980b523e4e"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instanceFromRegisters</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:aa410a0428f69de2e147734980b523e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> object and configures it to use semantic values and states that are defaults for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html" title="A semantic domain to generate LLVM.">LlvmSemantics</a>. <br /></td></tr>
<tr class="separator:aa410a0428f69de2e147734980b523e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138947db93a42a1d1dada1fb4668d620" id="r_a138947db93a42a1d1dada1fb4668d620"><td class="memItemLeft" align="right" valign="top"><a id="a138947db93a42a1d1dada1fb4668d620" name="a138947db93a42a1d1dada1fb4668d620"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instanceFromProtoval</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a138947db93a42a1d1dada1fb4668d620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> object with specified prototypical values. <br /></td></tr>
<tr class="separator:a138947db93a42a1d1dada1fb4668d620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546d89d0f09a089f78f6f6368eb1a106" id="r_a546d89d0f09a089f78f6f6368eb1a106"><td class="memItemLeft" align="right" valign="top"><a id="a546d89d0f09a089f78f6f6368eb1a106" name="a546d89d0f09a089f78f6f6368eb1a106"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instanceFromState</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a546d89d0f09a089f78f6f6368eb1a106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> object with specified state. <br /></td></tr>
<tr class="separator:a546d89d0f09a089f78f6f6368eb1a106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e924e608633f62c9faaea89f122a7" id="r_a8e2e924e608633f62c9faaea89f122a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a8e2e924e608633f62c9faaea89f122a7">promote</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="memdesc:a8e2e924e608633f62c9faaea89f122a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-time promotion of a base <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> pointer to Llvm operators.  <br /></td></tr>
<tr class="separator:a8e2e924e608633f62c9faaea89f122a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memitem:af342bdcdb3f8fec0ab4a96fbaf09eff5 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_af342bdcdb3f8fec0ab4a96fbaf09eff5"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae3899d47205079ff24dcfba3210bd5cd">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instanceFromRegisters</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:af342bdcdb3f8fec0ab4a96fbaf09eff5 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain.">RiscOperators</a> object and configures it to use semantic values and states that are defaults for <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html" title="A fully symbolic semantic domain.">SymbolicSemantics</a>. <br /></td></tr>
<tr class="separator:af342bdcdb3f8fec0ab4a96fbaf09eff5 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045746d0569a5e870bd3091504fdc99c inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a045746d0569a5e870bd3091504fdc99c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae3899d47205079ff24dcfba3210bd5cd">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a045746d0569a5e870bd3091504fdc99c">instanceFromProtoval</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a045746d0569a5e870bd3091504fdc99c inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain.">RiscOperators</a> object with specified prototypical values.  <br /></td></tr>
<tr class="separator:a045746d0569a5e870bd3091504fdc99c inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eb994fc47940a3dbbca37d100e165e inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a84eb994fc47940a3dbbca37d100e165e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae3899d47205079ff24dcfba3210bd5cd">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a84eb994fc47940a3dbbca37d100e165e">instanceFromState</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a84eb994fc47940a3dbbca37d100e165e inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain.">RiscOperators</a> object with specified state.  <br /></td></tr>
<tr class="separator:a84eb994fc47940a3dbbca37d100e165e inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aefb4637f26dac0e78b83f379dce0e7 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7aefb4637f26dac0e78b83f379dce0e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae3899d47205079ff24dcfba3210bd5cd">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a7aefb4637f26dac0e78b83f379dce0e7">promote</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;)</td></tr>
<tr class="memdesc:a7aefb4637f26dac0e78b83f379dce0e7 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-time promotion of a base <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html" title="Defines RISC operators for the SymbolicSemantics domain.">RiscOperators</a> pointer to symbolic operators.  <br /></td></tr>
<tr class="separator:a7aefb4637f26dac0e78b83f379dce0e7 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a172006dccabe64bb482543ca0eb611 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a1a172006dccabe64bb482543ca0eb611"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgAsmFloatType.html">SgAsmFloatType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a1a172006dccabe64bb482543ca0eb611">sgIsIeee754</a> (<a class="el" href="classSgAsmType.html">SgAsmType</a> *)</td></tr>
<tr class="memdesc:a1a172006dccabe64bb482543ca0eb611 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a <a class="el" href="classSgAsmType.html" title="Base class for binary types.">SgAsmType</a> is an IEEE-754 floating-point type.  <br /></td></tr>
<tr class="separator:a1a172006dccabe64bb482543ca0eb611 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a13252e7a27d971f1eb25c3a5b3891bdd inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a13252e7a27d971f1eb25c3a5b3891bdd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a13252e7a27d971f1eb25c3a5b3891bdd">promote</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">RiscOperatorsPtr</a> &amp;x)</td></tr>
<tr class="separator:a13252e7a27d971f1eb25c3a5b3891bdd inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acde922c02ef2d543b0d13344b0f8151a" id="r_acde922c02ef2d543b0d13344b0f8151a"><td class="memItemLeft" align="right" valign="top"><a id="acde922c02ef2d543b0d13344b0f8151a" name="acde922c02ef2d543b0d13344b0f8151a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;)</td></tr>
<tr class="separator:acde922c02ef2d543b0d13344b0f8151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f4f2f8b087433c9c87c11e22562a3b" id="r_ad6f4f2f8b087433c9c87c11e22562a3b"><td class="memItemLeft" align="right" valign="top"><a id="ad6f4f2f8b087433c9c87c11e22562a3b" name="ad6f4f2f8b087433c9c87c11e22562a3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;)</td></tr>
<tr class="separator:ad6f4f2f8b087433c9c87c11e22562a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e17b383e97435b3bfff3506ca3cc28" id="r_a74e17b383e97435b3bfff3506ca3cc28"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a74e17b383e97435b3bfff3506ca3cc28">emit_assignment</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;rhs)</td></tr>
<tr class="memdesc:a74e17b383e97435b3bfff3506ca3cc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an assignment and add a rewrite rule.  <br /></td></tr>
<tr class="separator:a74e17b383e97435b3bfff3506ca3cc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2256fedc87f1861f2717fb090eb7ca61" id="r_a2256fedc87f1861f2717fb090eb7ca61"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a2256fedc87f1861f2717fb090eb7ca61">emit_zero_extend</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, size_t nbits)</td></tr>
<tr class="memdesc:a2256fedc87f1861f2717fb090eb7ca61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a2256fedc87f1861f2717fb090eb7ca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9a21a883f75b94549459446d9eaa51" id="r_a3f9a21a883f75b94549459446d9eaa51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a3f9a21a883f75b94549459446d9eaa51">emit_sign_extend</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, size_t nbits)</td></tr>
<tr class="memdesc:a3f9a21a883f75b94549459446d9eaa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a3f9a21a883f75b94549459446d9eaa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03abbd1349bc25c9deb3a5a44f75e95e" id="r_a03abbd1349bc25c9deb3a5a44f75e95e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a03abbd1349bc25c9deb3a5a44f75e95e">emit_truncate</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, size_t nbits)</td></tr>
<tr class="memdesc:a03abbd1349bc25c9deb3a5a44f75e95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a03abbd1349bc25c9deb3a5a44f75e95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae768725771cd6cb3f4b498ee1c32c232" id="r_ae768725771cd6cb3f4b498ee1c32c232"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ae768725771cd6cb3f4b498ee1c32c232">emit_unsigned_resize</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, size_t nbits)</td></tr>
<tr class="memdesc:ae768725771cd6cb3f4b498ee1c32c232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ae768725771cd6cb3f4b498ee1c32c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a81b7edef1e4a227940b3ce0a6412" id="r_aed8a81b7edef1e4a227940b3ce0a6412"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aed8a81b7edef1e4a227940b3ce0a6412">emit_binary</a> (std::ostream &amp;, const std::string &amp;llvm_op, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:aed8a81b7edef1e4a227940b3ce0a6412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aed8a81b7edef1e4a227940b3ce0a6412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae56246d365ee8031cb29359ec073139" id="r_aae56246d365ee8031cb29359ec073139"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aae56246d365ee8031cb29359ec073139">emit_signed_binary</a> (std::ostream &amp;, const std::string &amp;llvm_op, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:aae56246d365ee8031cb29359ec073139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aae56246d365ee8031cb29359ec073139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd81aaefd73da28e4d5c4d93320a888b" id="r_acd81aaefd73da28e4d5c4d93320a888b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#acd81aaefd73da28e4d5c4d93320a888b">emit_unsigned_binary</a> (std::ostream &amp;, const std::string &amp;llvm_op, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:acd81aaefd73da28e4d5c4d93320a888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:acd81aaefd73da28e4d5c4d93320a888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34024fc4ddcfaa13424ef9b7a784c015" id="r_a34024fc4ddcfaa13424ef9b7a784c015"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a34024fc4ddcfaa13424ef9b7a784c015">emit_logical_right_shift</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:a34024fc4ddcfaa13424ef9b7a784c015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a34024fc4ddcfaa13424ef9b7a784c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d3168a954bdb7675982e71a65402c" id="r_ab31d3168a954bdb7675982e71a65402c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ab31d3168a954bdb7675982e71a65402c">emit_logical_right_shift_ones</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:ab31d3168a954bdb7675982e71a65402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ab31d3168a954bdb7675982e71a65402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841367960792f2fbfebb9992f0a9fb11" id="r_a841367960792f2fbfebb9992f0a9fb11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a841367960792f2fbfebb9992f0a9fb11">emit_arithmetic_right_shift</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:a841367960792f2fbfebb9992f0a9fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a841367960792f2fbfebb9992f0a9fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c8965eed912642089eb16cbcbdff3d" id="r_a12c8965eed912642089eb16cbcbdff3d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a12c8965eed912642089eb16cbcbdff3d">emit_left_shift</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:a12c8965eed912642089eb16cbcbdff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a12c8965eed912642089eb16cbcbdff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2e228358c53313a5a4d699e6f43aea" id="r_add2e228358c53313a5a4d699e6f43aea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#add2e228358c53313a5a4d699e6f43aea">emit_left_shift_ones</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:add2e228358c53313a5a4d699e6f43aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:add2e228358c53313a5a4d699e6f43aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978aec8f6e3763de9d165626f9eb3c30" id="r_a978aec8f6e3763de9d165626f9eb3c30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a978aec8f6e3763de9d165626f9eb3c30">emit_lssb</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a978aec8f6e3763de9d165626f9eb3c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a978aec8f6e3763de9d165626f9eb3c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b7b046ad9b1cbd7944755ef08dd7a8" id="r_ad4b7b046ad9b1cbd7944755ef08dd7a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ad4b7b046ad9b1cbd7944755ef08dd7a8">emit_mssb</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:ad4b7b046ad9b1cbd7944755ef08dd7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ad4b7b046ad9b1cbd7944755ef08dd7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3c4e4f78c76340fe117f1e390a1a6" id="r_a30f3c4e4f78c76340fe117f1e390a1a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a30f3c4e4f78c76340fe117f1e390a1a6">emit_extract</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;from, size_t result_nbits)</td></tr>
<tr class="memdesc:a30f3c4e4f78c76340fe117f1e390a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a30f3c4e4f78c76340fe117f1e390a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e77c1dc2cc438e7274ef439b68056e" id="r_ab8e77c1dc2cc438e7274ef439b68056e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ab8e77c1dc2cc438e7274ef439b68056e">emit_invert</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value)</td></tr>
<tr class="memdesc:ab8e77c1dc2cc438e7274ef439b68056e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ab8e77c1dc2cc438e7274ef439b68056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ffca237356f17c8785dbea65d65852" id="r_a13ffca237356f17c8785dbea65d65852"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a13ffca237356f17c8785dbea65d65852">emit_left_associative</a> (std::ostream &amp;, const std::string &amp;llvm_op, const TreeNodes &amp;operands)</td></tr>
<tr class="memdesc:a13ffca237356f17c8785dbea65d65852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a13ffca237356f17c8785dbea65d65852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca200257e85f144b480c0bfb3131a778" id="r_aca200257e85f144b480c0bfb3131a778"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aca200257e85f144b480c0bfb3131a778">emit_concat</a> (std::ostream &amp;, TreeNodes operands)</td></tr>
<tr class="memdesc:aca200257e85f144b480c0bfb3131a778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aca200257e85f144b480c0bfb3131a778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e12bc201188a8fee8d65b5e844f824" id="r_a92e12bc201188a8fee8d65b5e844f824"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a92e12bc201188a8fee8d65b5e844f824">emit_signed_divide</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;numerator, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;denominator)</td></tr>
<tr class="memdesc:a92e12bc201188a8fee8d65b5e844f824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a92e12bc201188a8fee8d65b5e844f824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d281a1f997afff19f90b875c9d7e5f" id="r_af9d281a1f997afff19f90b875c9d7e5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#af9d281a1f997afff19f90b875c9d7e5f">emit_unsigned_divide</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;numerator, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;denominator)</td></tr>
<tr class="memdesc:af9d281a1f997afff19f90b875c9d7e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:af9d281a1f997afff19f90b875c9d7e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2053f44711033e6e9df7c2e0a5e24e" id="r_a9d2053f44711033e6e9df7c2e0a5e24e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a9d2053f44711033e6e9df7c2e0a5e24e">emit_signed_modulo</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;numerator, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;denominator)</td></tr>
<tr class="memdesc:a9d2053f44711033e6e9df7c2e0a5e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a9d2053f44711033e6e9df7c2e0a5e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab224c7bc6fe62a80e1e71a807411c7ad" id="r_ab224c7bc6fe62a80e1e71a807411c7ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ab224c7bc6fe62a80e1e71a807411c7ad">emit_unsigned_modulo</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;numerator, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;denominator)</td></tr>
<tr class="memdesc:ab224c7bc6fe62a80e1e71a807411c7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ab224c7bc6fe62a80e1e71a807411c7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e51762ed8898e40e20aef4bc020bcc" id="r_a24e51762ed8898e40e20aef4bc020bcc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a24e51762ed8898e40e20aef4bc020bcc">emit_signed_multiply</a> (std::ostream &amp;, const TreeNodes &amp;operands)</td></tr>
<tr class="memdesc:a24e51762ed8898e40e20aef4bc020bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a24e51762ed8898e40e20aef4bc020bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944bd10a118e30226b6669391488004c" id="r_a944bd10a118e30226b6669391488004c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a944bd10a118e30226b6669391488004c">emit_unsigned_multiply</a> (std::ostream &amp;, const TreeNodes &amp;operands)</td></tr>
<tr class="memdesc:a944bd10a118e30226b6669391488004c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a944bd10a118e30226b6669391488004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325c3bafc6833f227377c4cf914d48a" id="r_aa325c3bafc6833f227377c4cf914d48a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aa325c3bafc6833f227377c4cf914d48a">emit_rotate_left</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:aa325c3bafc6833f227377c4cf914d48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aa325c3bafc6833f227377c4cf914d48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d5253462417a831a75e52a027f8f83" id="r_ad0d5253462417a831a75e52a027f8f83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#ad0d5253462417a831a75e52a027f8f83">emit_rotate_right</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;amount)</td></tr>
<tr class="memdesc:ad0d5253462417a831a75e52a027f8f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:ad0d5253462417a831a75e52a027f8f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0e975eed49999adf21604732f50e8a" id="r_a2d0e975eed49999adf21604732f50e8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a2d0e975eed49999adf21604732f50e8a">emit_compare</a> (std::ostream &amp;, const std::string &amp;llvm_op, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a2d0e975eed49999adf21604732f50e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a2d0e975eed49999adf21604732f50e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f30be72cefc22930c5d3fcc8cce956" id="r_aa3f30be72cefc22930c5d3fcc8cce956"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aa3f30be72cefc22930c5d3fcc8cce956">emit_ite</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;cond, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;)</td></tr>
<tr class="memdesc:aa3f30be72cefc22930c5d3fcc8cce956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aa3f30be72cefc22930c5d3fcc8cce956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e40e2a7677bc84f9ac286a389fe523" id="r_a17e40e2a7677bc84f9ac286a389fe523"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a17e40e2a7677bc84f9ac286a389fe523">emit_memory_read</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;address, size_t nbits)</td></tr>
<tr class="memdesc:a17e40e2a7677bc84f9ac286a389fe523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a17e40e2a7677bc84f9ac286a389fe523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120cdb4301e184dcc844ea8ffcdea6bc" id="r_a120cdb4301e184dcc844ea8ffcdea6bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a120cdb4301e184dcc844ea8ffcdea6bc">emit_global_read</a> (std::ostream &amp;, const std::string &amp;varname, size_t nbits)</td></tr>
<tr class="memdesc:a120cdb4301e184dcc844ea8ffcdea6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:a120cdb4301e184dcc844ea8ffcdea6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cb13d26544a1571f6fdf64a5e2fe27" id="r_aa7cb13d26544a1571f6fdf64a5e2fe27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#aa7cb13d26544a1571f6fdf64a5e2fe27">emit_memory_write</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;address, const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;value)</td></tr>
<tr class="memdesc:aa7cb13d26544a1571f6fdf64a5e2fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an operation as LLVM instructions.  <br /></td></tr>
<tr class="separator:aa7cb13d26544a1571f6fdf64a5e2fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a2580ca693076adf64e2f491302ec76dc inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a2580ca693076adf64e2f491302ec76dc"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>)</td></tr>
<tr class="separator:a2580ca693076adf64e2f491302ec76dc inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e97e12b603be2337d2c0e9032772f1 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a04e97e12b603be2337d2c0e9032772f1"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;state, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>)</td></tr>
<tr class="separator:a04e97e12b603be2337d2c0e9032772f1 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a59f2fcc3c62661c58943e9221fb795 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a7a59f2fcc3c62661c58943e9221fb795"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueUndefined</b> (size_t nbits)</td></tr>
<tr class="separator:a7a59f2fcc3c62661c58943e9221fb795 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bb96bed70872152283b94a92f3112b inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ab4bb96bed70872152283b94a92f3112b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueBottom</b> (size_t nbits)</td></tr>
<tr class="separator:ab4bb96bed70872152283b94a92f3112b inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5c82ab220fd946777b6317b52b496 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a9cf5c82ab220fd946777b6317b52b496"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueUnspecified</b> (size_t nbits)</td></tr>
<tr class="separator:a9cf5c82ab220fd946777b6317b52b496 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eee6b79382c753a1cdc3b7fdd05b637 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a8eee6b79382c753a1cdc3b7fdd05b637"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueNumber</b> (size_t nbits, uint64_t value)</td></tr>
<tr class="separator:a8eee6b79382c753a1cdc3b7fdd05b637 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994fdc92365e9dc0cc12f8e348c1a582 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a994fdc92365e9dc0cc12f8e348c1a582"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#acc48f9fd1f86a6920ec0c00307941292">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>svalueBoolean</b> (bool b)</td></tr>
<tr class="separator:a994fdc92365e9dc0cc12f8e348c1a582 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a2ec18326f24605fc0cc9c1a42be08fc8 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a2ec18326f24605fc0cc9c1a42be08fc8"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a7c5e09435a745f38ec86be09db43dc12">protoval</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="separator:a2ec18326f24605fc0cc9c1a42be08fc8 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726331af1936a1f67d19402b3622dad4 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators" id="r_a726331af1936a1f67d19402b3622dad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>RiscOperators</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">StatePtr</a> &amp;state, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="separator:a726331af1936a1f67d19402b3622dad4 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a></td></tr>
<tr class="memitem:a74a5f153cba9a2d2e09e80a77a372f48 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a74a5f153cba9a2d2e09e80a77a372f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a74a5f153cba9a2d2e09e80a77a372f48">omit_cur_insn</a></td></tr>
<tr class="separator:a74a5f153cba9a2d2e09e80a77a372f48 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c9368bfda2ecf0af119533f8b66887 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a28c9368bfda2ecf0af119533f8b66887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#ae08ad578f4f00fb39d6557e6a40c40dd">DefinersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a28c9368bfda2ecf0af119533f8b66887">computingDefiners_</a></td></tr>
<tr class="separator:a28c9368bfda2ecf0af119533f8b66887 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc2298c5bcd43a7056234041d2278b inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a1fcc2298c5bcd43a7056234041d2278b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a1fcc2298c5bcd43a7056234041d2278b">computingMemoryWriters_</a></td></tr>
<tr class="separator:a1fcc2298c5bcd43a7056234041d2278b inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f16935aeabd223196e46635fa88e37 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ad7f16935aeabd223196e46635fa88e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html#a0db00b8a9ae31b8dedb83fc715ae243e">WritersMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ad7f16935aeabd223196e46635fa88e37">computingRegisterWriters_</a></td></tr>
<tr class="separator:ad7f16935aeabd223196e46635fa88e37 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752f32af3a9bf202f9a43e32fb28e40c inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a752f32af3a9bf202f9a43e32fb28e40c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a752f32af3a9bf202f9a43e32fb28e40c">trimThreshold_</a></td></tr>
<tr class="separator:a752f32af3a9bf202f9a43e32fb28e40c inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1963256d824183950042047b10526e inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_add1963256d824183950042047b10526e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#add1963256d824183950042047b10526e">reinterpretMemoryReads_</a></td></tr>
<tr class="separator:add1963256d824183950042047b10526e inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97f61dfb7488ea408b6f6b5a19fbe62 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_ac97f61dfb7488ea408b6f6b5a19fbe62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac97f61dfb7488ea408b6f6b5a19fbe62">reinterpretRegisterReads_</a></td></tr>
<tr class="separator:ac97f61dfb7488ea408b6f6b5a19fbe62 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80258cfa9dd5ab4bde2a4de12cb7703c inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators" id="r_a80258cfa9dd5ab4bde2a4de12cb7703c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a80258cfa9dd5ab4bde2a4de12cb7703c">nTrimmed_</a> = 0</td></tr>
<tr class="separator:a80258cfa9dd5ab4bde2a4de12cb7703c inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8c3c7ad1796cb535d699ee345187d766" name="a8c3c7ad1796cb535d699ee345187d766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3c7ad1796cb535d699ee345187d766">&#9670;&#160;</a></span>Super</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a8c3c7ad1796cb535d699ee345187d766">Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::Super</a> =  <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html">SymbolicSemantics::RiscOperators</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00045">45</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<a id="a63db9c25141b369719791207a828e40d" name="a63db9c25141b369719791207a828e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63db9c25141b369719791207a828e40d">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a63db9c25141b369719791207a828e40d">Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00048">48</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae493d841a6fcf508e31a971ee9be4a75" name="ae493d841a6fcf508e31a971ee9be4a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae493d841a6fcf508e31a971ee9be4a75">&#9670;&#160;</a></span>~RiscOperators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::~RiscOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ff56829f2b8dc8a4527293d7e08fa4d" name="a3ff56829f2b8dc8a4527293d7e08fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff56829f2b8dc8a4527293d7e08fa4d">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>protoval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual allocating constructor. </p>
<p>The <code>protoval</code> is a prototypical semantic value that is used as a factory to create additional values as necessary via its virtual constructors. The state upon which the RISC operations operate must be set by modifying the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac3a0859028329bc37d6852a1f7776e2f">currentState</a> property. An optional SMT solver may be specified (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>). </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a4d8342bfe9504a68d2f88294988cdd7b">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a>.</p>

</div>
</div>
<a id="aa69623fa863d77d7da49c29aaa6889a9" name="aa69623fa863d77d7da49c29aaa6889a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69623fa863d77d7da49c29aaa6889a9">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#aae5e1a00d709df3fc68381fdd5383db9">BaseSemantics::StatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual allocating constructor. </p>
<p>The supplied <code>state</code> is that upon which the RISC operations operate and is also used to define the prototypical semantic value. Other states can be supplied by setting <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#ac3a0859028329bc37d6852a1f7776e2f">currentState</a>. The prototypical semantic value is used as a factory to create additional values as necessary via its virtual constructors. An optional SMT solver may be specified (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a79178527d1f5032c588ed95f32caf596">solver</a>). </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a34b1ee46955085e65c5ae960abe3cfdf">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a>.</p>

</div>
</div>
<a id="a8e2e924e608633f62c9faaea89f122a7" name="a8e2e924e608633f62c9faaea89f122a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2e924e608633f62c9faaea89f122a7">&#9670;&#160;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics.html#a86e8584f4cef9b5e67914d4d4a4d948c">RiscOperatorsPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::promote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run-time promotion of a base <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> pointer to Llvm operators. </p>
<p>This is a checked-converstion&ndash;it will fail if <code>x</code> does not point to a <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">LlvmSemantics::RiscOperators</a> object. </p>

</div>
</div>
<a id="a3ef83f2d4fb594ed5dbece42711c3c07" name="a3ef83f2d4fb594ed5dbece42711c3c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef83f2d4fb594ed5dbece42711c3c07">&#9670;&#160;</a></span>llvmVersion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::llvmVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: LLVM version. </p>
<p>Different versions of LLVM have different assembly syntaxes which are not backward compatible, and this property which dialect is emitted. This property is set to a*x^2 + b*x + c where a, b, and c are the three-part LLVM version number "a.b.c" and x is 1000. The special value zero is reserved to mean that the version number is unknown. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00112">112</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<a id="a25e5b9f9c09be0696ecd08b68684dbf8" name="a25e5b9f9c09be0696ecd08b68684dbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e5b9f9c09be0696ecd08b68684dbf8">&#9670;&#160;</a></span>llvmVersion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::llvmVersion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: LLVM version. </p>
<p>Different versions of LLVM have different assembly syntaxes which are not backward compatible, and this property which dialect is emitted. This property is set to a*x^2 + b*x + c where a, b, and c are the three-part LLVM version number "a.b.c" and x is 1000. The special value zero is reserved to mean that the version number is unknown. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00113">113</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<a id="af261c1bf1aa409b356af5c50991126cf" name="af261c1bf1aa409b356af5c50991126cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af261c1bf1aa409b356af5c50991126cf">&#9670;&#160;</a></span>readMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::readMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>segreg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a value from memory. </p>
<p>The implementation (in subclasses) will typically delegate much of the work to the current state's <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html#a72ff9f2aa2976e4260bf568140d9d6fc">readMemory</a> method.</p>
<p>A MemoryState will implement storage for memory locations and might impose certain restrictions, such as "all memory
values must be eight bits". However, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#af261c1bf1aa409b356af5c50991126cf">readMemory</a> should not have these constraints so that it can be called from a variety of Dispatcher subclass (e.g., the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1DispatcherX86.html" title="Semantically evaluates Intel x86 instructions.">DispatcherX86</a> class assumes that <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#af261c1bf1aa409b356af5c50991126cf">readMemory</a> is capable of reading 32-bit values from little-endian memory). The designers of the MemoryState, State, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> should collaborate to decide which layer (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a>, State, or MemoryState) is reponsible for combining individual memory locations into larger values. A <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> object is passed along the chain of delegations for this purpose. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html">RiscOperators</a> might also contain other data that's important during the process, such as an SMT solver.</p>
<p>The <code>segreg</code> argument is an optional segment register. Most architectures have a flat virtual address space and will pass a default-constructed register descriptor whose is_valid() method returns false.</p>
<p>The <code>cond</code> argument is a Boolean value that indicates whether this is a true read operation. If <code>cond</code> can be proven to be false then the read is a no-op and returns an arbitrary value.</p>
<p>The <code>dflt</code> argument determines the size of the value to be read. This argument is also passed along to the lower layers so that they can, if they desire, use it to initialize memory that has never been read or written before. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a5fc6491e6d449f5adc36a21508002574">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a>.</p>

</div>
</div>
<a id="a88c19f51e41012add2f3f10aef59c29b" name="a88c19f51e41012add2f3f10aef59c29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c19f51e41012add2f3f10aef59c29b">&#9670;&#160;</a></span>writeMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::writeMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>segreg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a value to memory. </p>
<p>The implementation (in subclasses) will typically delegate much of the work to the current state's <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html#aa9bfd5c49e6ca9c239a8a75038f65ac1">writeMemory</a> method.</p>
<p>The <code>segreg</code> argument is an optional segment register. Most architectures have a flat virtual address space and will pass a default-constructed register descriptor whose is_valid() method returns false.</p>
<p>The <code>cond</code> argument is a Boolean value that indicates whether this is a true write operation. If <code>cond</code> can be proved to be false then writeMemory is a no-op. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#a986cd04ad143a3253d4b41a3ff406fe4">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators</a>.</p>

</div>
</div>
<a id="a672499bc4842510c1b2dd314b084ddcd" name="a672499bc4842510c1b2dd314b084ddcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672499bc4842510c1b2dd314b084ddcd">&#9670;&#160;</a></span>indent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::indent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase indentation by <code>nlevels</code> levels. </p>
<p>Indentation is decreased if nlevels is negative. Returns the new indentation level. It is permissible for the indentation to become negative, but prefix() always returns a non-negative amount of space. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00131">131</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<a id="a008d3469c5c0b6721dbbfb7999644af1" name="a008d3469c5c0b6721dbbfb7999644af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008d3469c5c0b6721dbbfb7999644af1">&#9670;&#160;</a></span>get_important_registers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const RegisterDescriptors &amp; Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::get_important_registers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of registers that needs to be emitted to LLVM. </p>
<p>Regardless of what registers are written (e.g., AX), return a list of registers that we're keeping track of in global variables (e.g., EAX). </p>

</div>
</div>
<a id="a8ba06ef76e7fb2c6671a672c744ca990" name="a8ba06ef76e7fb2c6671a672c744ca990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba06ef76e7fb2c6671a672c744ca990">&#9670;&#160;</a></span>get_stored_registers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RegisterDescriptors Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::get_stored_registers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of important registers that are stored. </p>
<p>This is a subset of the value returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a008d3469c5c0b6721dbbfb7999644af1" title="Return the list of registers that needs to be emitted to LLVM.">get_important_registers()</a>. </p>

</div>
</div>
<a id="a7dc727b356b6f9a67e02e86af8e10345" name="a7dc727b356b6f9a67e02e86af8e10345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc727b356b6f9a67e02e86af8e10345">&#9670;&#160;</a></span>get_memory_writes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const TreeNodes &amp; Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::get_memory_writes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of memory writes that have occured since the last call to <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a0e4f1e6425d5a27674c60dc65dc97754" title="Mark the current state as having been emitted.">make_current()</a>. </p>
<p>Each item in the list is an OP_WRITE symbolic expression, and the list is in the order the write occurred (oldest to most recent). The memory states are each unique and not used for anything in particular. </p>

<p class="definition">Definition at line <a class="el" href="LlvmSemantics_8h_source.html#l00179">179</a> of file <a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a>.</p>

</div>
</div>
<a id="a864052b291e4ffc8d60e2cb6869de202" name="a864052b291e4ffc8d60e2cb6869de202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864052b291e4ffc8d60e2cb6869de202">&#9670;&#160;</a></span>add_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::add_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an LLVM variable. </p>
<p>Returns the LLVM variable name including its sigil. If the variable doesn't exist yet then it's added to the list of known variables. </p>

</div>
</div>
<a id="a978adebe1f276a2f7910b81170d25160" name="a978adebe1f276a2f7910b81170d25160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978adebe1f276a2f7910b81170d25160">&#9670;&#160;</a></span>get_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the LLVM name for a variable, including the sigil. </p>
<p>If the specified ROSE variable has no corresponding LLVM definition, then the empty string is returned. </p>

</div>
</div>
<a id="a7d1300cd4f11e8eb06dc87b97b7a0015" name="a7d1300cd4f11e8eb06dc87b97b7a0015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1300cd4f11e8eb06dc87b97b7a0015">&#9670;&#160;</a></span>emit_prerequisites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_prerequisites </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RegisterDescriptors &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output LLVM global variable reads that are needed to define the specified registers and pending memory writes. </p>
<p>Since registers are stored in global variables and we routinely emit more than one register definition at a time, we need to first make sure that any global prerequisites for the definitions are saved in temporaries. This is to handle cases like the following, where the values of <code>eax</code> and <code>ebx</code> are swapped using <code>edx</code> as a temporary:</p>
<div class="fragment"><div class="line">mov edx, eax</div>
<div class="line">mov eax, ebx</div>
<div class="line">mov ebx, edx</div>
</div><!-- fragment --><p>If we emit all the register definitions at the end of these three x86 instructions, we should get LLVM output similar to the following:</p>
<div class="fragment"><div class="line">%1 = @eax</div>
<div class="line">%2 = @ebx</div>
<div class="line">@eax = %2</div>
<div class="line">@ebx = %1</div>
<div class="line">@edx = %1</div>
</div><!-- fragment --><p>The dictionary is used to convert register names (that appear in symbolic variable comments, like "eax_0") to register descriptors. If a register reference (like "eax_0") corresponds to a register that we're not interested in, then don't bother emitting a temporary variable for the register. </p>

</div>
</div>
<a id="a28cfd991fafcb17ebc33bdd06af6b4e3" name="a28cfd991fafcb17ebc33bdd06af6b4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cfd991fafcb17ebc33bdd06af6b4e3">&#9670;&#160;</a></span>emit_next_eip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_next_eip </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"><em>latest_insn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output an LLVM branch instruction. </p>
<p>The <code>latest_insn</code> is the most recent instruction that was transcoded, usually the last instruction of a basic block. </p>

</div>
</div>
<a id="a672c2a9a4ff9d252a69fd03b04cc77a0" name="a672c2a9a4ff9d252a69fd03b04cc77a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672c2a9a4ff9d252a69fd03b04cc77a0">&#9670;&#160;</a></span>llvm_term()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::llvm_term </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a ROSE variable or integer to an LLVM term. </p>
<p>A term must be a constant or a variable reference (rvalue). </p>

</div>
</div>
<a id="a9aed02c2b6aed08808f8371b6cf1d657" name="a9aed02c2b6aed08808f8371b6cf1d657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed02c2b6aed08808f8371b6cf1d657">&#9670;&#160;</a></span>llvm_lvalue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::llvm_lvalue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a ROSE variable to an LLVM lvalue. </p>
<p>The variable must not have been used as an lvalue previously since LLVM uses single static assignment (SSA) format. </p>

</div>
</div>
<a id="a02b9f1a78d65ad0e7c18b63effcd9209" name="a02b9f1a78d65ad0e7c18b63effcd9209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b9f1a78d65ad0e7c18b63effcd9209">&#9670;&#160;</a></span>emit_expression() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_expression </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit LLVM statements for an expression. </p>
<p>This method transcodes an expression to LLVM and returns an LLVM terminal node (a constant or variable). The terminal node is not part of the output. For instance, an expression like:</p>
<div class="fragment"><div class="line">(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a>[32] v1[32] v2[32] (<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#accd6f7bcd3c64b8e8df2a12ce8e061dc">negate</a>[32] v3[32]))</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators_html_ac1c3d91609369e4636097f3f23fd381e"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators::add</a></div><div class="ttdeci">virtual BaseSemantics::SValuePtr add(const BaseSemantics::SValuePtr &amp;a_, const BaseSemantics::SValuePtr &amp;b_) override</div><div class="ttdoc">Adds two integers of equal size.</div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators_html_accd6f7bcd3c64b8e8df2a12ce8e061dc"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#accd6f7bcd3c64b8e8df2a12ce8e061dc">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::RiscOperators::negate</a></div><div class="ttdeci">virtual BaseSemantics::SValuePtr negate(const BaseSemantics::SValuePtr &amp;a_) override</div><div class="ttdoc">Two's complement.</div></div>
</div><!-- fragment --><p>Would produce the following LLVM</p>
<div class="fragment"><div class="line">%4 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %1, i32 %2</div>
<div class="line">%5 = sub i32 0, i32 %3</div>
<div class="line">%6 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %4, i32 %5</div>
</div><!-- fragment --><p>and returns the symbolic variable "v6". </p>

</div>
</div>
<a id="a3fbdf089da8572fdc7317a6f1df889bd" name="a3fbdf089da8572fdc7317a6f1df889bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbdf089da8572fdc7317a6f1df889bd">&#9670;&#160;</a></span>emit_expression() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_expression </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit LLVM statements for an expression. </p>
<p>This method transcodes an expression to LLVM and returns an LLVM terminal node (a constant or variable). The terminal node is not part of the output. For instance, an expression like:</p>
<div class="fragment"><div class="line">(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a>[32] v1[32] v2[32] (<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#accd6f7bcd3c64b8e8df2a12ce8e061dc">negate</a>[32] v3[32]))</div>
</div><!-- fragment --><p>Would produce the following LLVM</p>
<div class="fragment"><div class="line">%4 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %1, i32 %2</div>
<div class="line">%5 = sub i32 0, i32 %3</div>
<div class="line">%6 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %4, i32 %5</div>
</div><!-- fragment --><p>and returns the symbolic variable "v6". </p>

</div>
</div>
<a id="afc0f5fc6e1557e2909851e1a10c86b2c" name="afc0f5fc6e1557e2909851e1a10c86b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0f5fc6e1557e2909851e1a10c86b2c">&#9670;&#160;</a></span>emit_expression() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_expression </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit LLVM statements for an expression. </p>
<p>This method transcodes an expression to LLVM and returns an LLVM terminal node (a constant or variable). The terminal node is not part of the output. For instance, an expression like:</p>
<div class="fragment"><div class="line">(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a>[32] v1[32] v2[32] (<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#accd6f7bcd3c64b8e8df2a12ce8e061dc">negate</a>[32] v3[32]))</div>
</div><!-- fragment --><p>Would produce the following LLVM</p>
<div class="fragment"><div class="line">%4 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %1, i32 %2</div>
<div class="line">%5 = sub i32 0, i32 %3</div>
<div class="line">%6 = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1RiscOperators.html#ac1c3d91609369e4636097f3f23fd381e">add</a> i32 %4, i32 %5</div>
</div><!-- fragment --><p>and returns the symbolic variable "v6". </p>

</div>
</div>
<a id="a74e17b383e97435b3bfff3506ca3cc28" name="a74e17b383e97435b3bfff3506ca3cc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e17b383e97435b3bfff3506ca3cc28">&#9670;&#160;</a></span>emit_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">LeafPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_assignment </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an assignment and add a rewrite rule. </p>
<p>The left hand side is a new LLVM temporary variable (which is returned). If <code>rhs</code> is an LLVM unamed local variable then <code>rhs</code> is returned. Otherwise, a rewrite rule is added so that future appearances of the right hand side will be replaced by the left hand side in calls to <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a>. </p>

</div>
</div>
<a id="a2256fedc87f1861f2717fb090eb7ca61" name="a2256fedc87f1861f2717fb090eb7ca61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256fedc87f1861f2717fb090eb7ca61">&#9670;&#160;</a></span>emit_zero_extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_zero_extend </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a3f9a21a883f75b94549459446d9eaa51" name="a3f9a21a883f75b94549459446d9eaa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9a21a883f75b94549459446d9eaa51">&#9670;&#160;</a></span>emit_sign_extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_sign_extend </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a03abbd1349bc25c9deb3a5a44f75e95e" name="a03abbd1349bc25c9deb3a5a44f75e95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03abbd1349bc25c9deb3a5a44f75e95e">&#9670;&#160;</a></span>emit_truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_truncate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ae768725771cd6cb3f4b498ee1c32c232" name="ae768725771cd6cb3f4b498ee1c32c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae768725771cd6cb3f4b498ee1c32c232">&#9670;&#160;</a></span>emit_unsigned_resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_unsigned_resize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aed8a81b7edef1e4a227940b3ce0a6412" name="aed8a81b7edef1e4a227940b3ce0a6412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8a81b7edef1e4a227940b3ce0a6412">&#9670;&#160;</a></span>emit_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_binary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aae56246d365ee8031cb29359ec073139" name="aae56246d365ee8031cb29359ec073139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae56246d365ee8031cb29359ec073139">&#9670;&#160;</a></span>emit_signed_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_signed_binary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="acd81aaefd73da28e4d5c4d93320a888b" name="acd81aaefd73da28e4d5c4d93320a888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd81aaefd73da28e4d5c4d93320a888b">&#9670;&#160;</a></span>emit_unsigned_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_unsigned_binary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a34024fc4ddcfaa13424ef9b7a784c015" name="a34024fc4ddcfaa13424ef9b7a784c015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34024fc4ddcfaa13424ef9b7a784c015">&#9670;&#160;</a></span>emit_logical_right_shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_logical_right_shift </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ab31d3168a954bdb7675982e71a65402c" name="ab31d3168a954bdb7675982e71a65402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31d3168a954bdb7675982e71a65402c">&#9670;&#160;</a></span>emit_logical_right_shift_ones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_logical_right_shift_ones </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a841367960792f2fbfebb9992f0a9fb11" name="a841367960792f2fbfebb9992f0a9fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841367960792f2fbfebb9992f0a9fb11">&#9670;&#160;</a></span>emit_arithmetic_right_shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_arithmetic_right_shift </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a12c8965eed912642089eb16cbcbdff3d" name="a12c8965eed912642089eb16cbcbdff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c8965eed912642089eb16cbcbdff3d">&#9670;&#160;</a></span>emit_left_shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_left_shift </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="add2e228358c53313a5a4d699e6f43aea" name="add2e228358c53313a5a4d699e6f43aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2e228358c53313a5a4d699e6f43aea">&#9670;&#160;</a></span>emit_left_shift_ones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_left_shift_ones </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a978aec8f6e3763de9d165626f9eb3c30" name="a978aec8f6e3763de9d165626f9eb3c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978aec8f6e3763de9d165626f9eb3c30">&#9670;&#160;</a></span>emit_lssb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_lssb </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ad4b7b046ad9b1cbd7944755ef08dd7a8" name="ad4b7b046ad9b1cbd7944755ef08dd7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b7b046ad9b1cbd7944755ef08dd7a8">&#9670;&#160;</a></span>emit_mssb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_mssb </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a30f3c4e4f78c76340fe117f1e390a1a6" name="a30f3c4e4f78c76340fe117f1e390a1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f3c4e4f78c76340fe117f1e390a1a6">&#9670;&#160;</a></span>emit_extract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_extract </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>result_nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ab8e77c1dc2cc438e7274ef439b68056e" name="ab8e77c1dc2cc438e7274ef439b68056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e77c1dc2cc438e7274ef439b68056e">&#9670;&#160;</a></span>emit_invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_invert </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a13ffca237356f17c8785dbea65d65852" name="a13ffca237356f17c8785dbea65d65852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ffca237356f17c8785dbea65d65852">&#9670;&#160;</a></span>emit_left_associative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_left_associative </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeNodes &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aca200257e85f144b480c0bfb3131a778" name="aca200257e85f144b480c0bfb3131a778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca200257e85f144b480c0bfb3131a778">&#9670;&#160;</a></span>emit_concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_concat </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeNodes&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a92e12bc201188a8fee8d65b5e844f824" name="a92e12bc201188a8fee8d65b5e844f824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e12bc201188a8fee8d65b5e844f824">&#9670;&#160;</a></span>emit_signed_divide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_signed_divide </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="af9d281a1f997afff19f90b875c9d7e5f" name="af9d281a1f997afff19f90b875c9d7e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d281a1f997afff19f90b875c9d7e5f">&#9670;&#160;</a></span>emit_unsigned_divide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_unsigned_divide </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a9d2053f44711033e6e9df7c2e0a5e24e" name="a9d2053f44711033e6e9df7c2e0a5e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2053f44711033e6e9df7c2e0a5e24e">&#9670;&#160;</a></span>emit_signed_modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_signed_modulo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ab224c7bc6fe62a80e1e71a807411c7ad" name="ab224c7bc6fe62a80e1e71a807411c7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab224c7bc6fe62a80e1e71a807411c7ad">&#9670;&#160;</a></span>emit_unsigned_modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_unsigned_modulo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a24e51762ed8898e40e20aef4bc020bcc" name="a24e51762ed8898e40e20aef4bc020bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e51762ed8898e40e20aef4bc020bcc">&#9670;&#160;</a></span>emit_signed_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_signed_multiply </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeNodes &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a944bd10a118e30226b6669391488004c" name="a944bd10a118e30226b6669391488004c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944bd10a118e30226b6669391488004c">&#9670;&#160;</a></span>emit_unsigned_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_unsigned_multiply </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeNodes &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aa325c3bafc6833f227377c4cf914d48a" name="aa325c3bafc6833f227377c4cf914d48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa325c3bafc6833f227377c4cf914d48a">&#9670;&#160;</a></span>emit_rotate_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_rotate_left </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="ad0d5253462417a831a75e52a027f8f83" name="ad0d5253462417a831a75e52a027f8f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d5253462417a831a75e52a027f8f83">&#9670;&#160;</a></span>emit_rotate_right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_rotate_right </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a2d0e975eed49999adf21604732f50e8a" name="a2d0e975eed49999adf21604732f50e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0e975eed49999adf21604732f50e8a">&#9670;&#160;</a></span>emit_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_compare </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aa3f30be72cefc22930c5d3fcc8cce956" name="aa3f30be72cefc22930c5d3fcc8cce956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f30be72cefc22930c5d3fcc8cce956">&#9670;&#160;</a></span>emit_ite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_ite </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a17e40e2a7677bc84f9ac286a389fe523" name="a17e40e2a7677bc84f9ac286a389fe523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e40e2a7677bc84f9ac286a389fe523">&#9670;&#160;</a></span>emit_memory_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_memory_read </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="a120cdb4301e184dcc844ea8ffcdea6bc" name="a120cdb4301e184dcc844ea8ffcdea6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120cdb4301e184dcc844ea8ffcdea6bc">&#9670;&#160;</a></span>emit_global_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_global_read </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<a id="aa7cb13d26544a1571f6fdf64a5e2fe27" name="aa7cb13d26544a1571f6fdf64a5e2fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cb13d26544a1571f6fdf64a5e2fe27">&#9670;&#160;</a></span>emit_memory_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::LlvmSemantics::RiscOperators::emit_memory_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ExpressionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an operation as LLVM instructions. </p>
<p>These "emit" methods take operands that are symbolic expressions and output LLVM instructions that implement the expression. The return value is either an LLVM term (variable or integer) or an expression. Expressions are only returned in cases where the operation is a no-op, such as for the symbolic expression "(add (negate v3))" where the "add" is a no-op that simply returns its only argument. Because these "emit" methods might return an expression, it is customary to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1LlvmSemantics_1_1RiscOperators.html#a02b9f1a78d65ad0e7c18b63effcd9209" title="Emit LLVM statements for an expression.">emit_expression()</a> on their return value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LlvmSemantics_8h_source.html">LlvmSemantics.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
