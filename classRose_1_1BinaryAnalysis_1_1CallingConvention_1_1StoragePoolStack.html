<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::CallingConvention::StoragePoolStack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html">CallingConvention</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html">StoragePoolStack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::CallingConvention::StoragePoolStack Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>A storage pool for stack-based argument locations. </p>
<p>This pool holds an ordered sequence of locations on the stack. Some of the stack properties come from the associated calling convention definition. </p>

<p class="definition">Definition at line <a class="el" href="StoragePool_8h_source.html#l00187">187</a> of file <a class="el" href="StoragePool_8h_source.html">StoragePool.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="StoragePool_8h_source.html">Rose/BinaryAnalysis/CallingConvention/StoragePool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::CallingConvention::StoragePoolStack:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_inherit__map" id="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_inherit__map">
<area shape="rect" title="A storage pool for stack&#45;based argument locations." alt="" coords="5,108,153,163"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html" title="Base class for pool of locations." alt="" coords="5,5,153,60"/>
<area shape="poly" title=" " alt="" coords="82,74,82,108,77,108,77,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::CallingConvention::StoragePoolStack:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_coll__map" id="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack_coll__map">
<area shape="rect" title="A storage pool for stack&#45;based argument locations." alt="" coords="5,108,153,163"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html" title="Base class for pool of locations." alt="" coords="5,5,153,60"/>
<area shape="poly" title=" " alt="" coords="82,74,82,108,77,108,77,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a97feb31133d3c7e59cea90c176ce8752" id="r_a97feb31133d3c7e59cea90c176ce8752"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a97feb31133d3c7e59cea90c176ce8752">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a8d893305475075739855a54bbf3bff26">StoragePoolStackPtr</a></td></tr>
<tr class="memdesc:a97feb31133d3c7e59cea90c176ce8752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a97feb31133d3c7e59cea90c176ce8752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa608f33cf1b4e78bccd77c8df6d1a5d2" id="r_aa608f33cf1b4e78bccd77c8df6d1a5d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#aa608f33cf1b4e78bccd77c8df6d1a5d2">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af89a06b052ad4b63bbdcb3f76e2840ea">StoragePoolStackConstPtr</a></td></tr>
<tr class="memdesc:aa608f33cf1b4e78bccd77c8df6d1a5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:aa608f33cf1b4e78bccd77c8df6d1a5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a></td></tr>
<tr class="memitem:ae088cc961c1cdb7b610ce456e586d962 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase" id="r_ae088cc961c1cdb7b610ce456e586d962"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#ae088cc961c1cdb7b610ce456e586d962">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af78c17c831b5837a3de3efbed5e86d01">StoragePoolBasePtr</a></td></tr>
<tr class="memdesc:ae088cc961c1cdb7b610ce456e586d962 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:ae088cc961c1cdb7b610ce456e586d962 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741ebc289eda3f5ae0aaf65539acd5c0 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase" id="r_a741ebc289eda3f5ae0aaf65539acd5c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#a741ebc289eda3f5ae0aaf65539acd5c0">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ab246ca65a642c7d402cb14815f52f3f6">StoragePoolBaseConstPtr</a></td></tr>
<tr class="memdesc:a741ebc289eda3f5ae0aaf65539acd5c0 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a741ebc289eda3f5ae0aaf65539acd5c0 inherit pub_types_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd50a06327ff5baa1fbb7420745835a7" id="r_abd50a06327ff5baa1fbb7420745835a7"><td class="memItemLeft" align="right" valign="top"><a id="abd50a06327ff5baa1fbb7420745835a7" name="abd50a06327ff5baa1fbb7420745835a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StoragePoolStack</b> (const std::string &amp;name, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#abeee506b5a4fe0e7e1a6419b487352b3">TypePredicateConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Rose::BinaryAnalysis::Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:abd50a06327ff5baa1fbb7420745835a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27cbbb598ea5bb496ec3bbf5de18d55" id="r_ad27cbbb598ea5bb496ec3bbf5de18d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af78c17c831b5837a3de3efbed5e86d01">StoragePoolBasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#ad27cbbb598ea5bb496ec3bbf5de18d55">copy</a> () const override</td></tr>
<tr class="memdesc:ad27cbbb598ea5bb496ec3bbf5de18d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ad27cbbb598ea5bb496ec3bbf5de18d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1f2a38860c3c2d9936ae93b8c8fb98" id="r_afc1f2a38860c3c2d9936ae93b8c8fb98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#afc1f2a38860c3c2d9936ae93b8c8fb98">consume</a> (<a class="el" href="classSgAsmType.html">SgAsmType</a> *) override</td></tr>
<tr class="memdesc:afc1f2a38860c3c2d9936ae93b8c8fb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume a storage location.  <br /></td></tr>
<tr class="separator:afc1f2a38860c3c2d9936ae93b8c8fb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f26e6f2d60fc65c4a7a77ce012f44" id="r_a389f26e6f2d60fc65c4a7a77ce012f44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a389f26e6f2d60fc65c4a7a77ce012f44">reset</a> () override</td></tr>
<tr class="memdesc:a389f26e6f2d60fc65c4a7a77ce012f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset allocation.  <br /></td></tr>
<tr class="separator:a389f26e6f2d60fc65c4a7a77ce012f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22f7e4bfcb6f385c29de5d7ba7722eae" id="r_a22f7e4bfcb6f385c29de5d7ba7722eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a22f7e4bfcb6f385c29de5d7ba7722eae">stackDirection</a> () const</td></tr>
<tr class="memdesc:a22f7e4bfcb6f385c29de5d7ba7722eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack direction.  <br /></td></tr>
<tr class="separator:a22f7e4bfcb6f385c29de5d7ba7722eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71754c6f4f223f8aa0fab638612c48bb" id="r_a71754c6f4f223f8aa0fab638612c48bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a71754c6f4f223f8aa0fab638612c48bb">stackDirection</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a>)</td></tr>
<tr class="memdesc:a71754c6f4f223f8aa0fab638612c48bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack direction.  <br /></td></tr>
<tr class="separator:a71754c6f4f223f8aa0fab638612c48bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02aebcb35ff1eb5ceea8d1b04882499e" id="r_a02aebcb35ff1eb5ceea8d1b04882499e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a02aebcb35ff1eb5ceea8d1b04882499e">initialOffset</a> () const</td></tr>
<tr class="memdesc:a02aebcb35ff1eb5ceea8d1b04882499e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Initial stack offset.  <br /></td></tr>
<tr class="separator:a02aebcb35ff1eb5ceea8d1b04882499e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e06ee34c1be121b34727512011f137" id="r_a69e06ee34c1be121b34727512011f137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a69e06ee34c1be121b34727512011f137">initialOffset</a> (int64_t)</td></tr>
<tr class="memdesc:a69e06ee34c1be121b34727512011f137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Initial stack offset.  <br /></td></tr>
<tr class="separator:a69e06ee34c1be121b34727512011f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad297f04eaf12ff59be86190e64e51a25" id="r_ad297f04eaf12ff59be86190e64e51a25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#ad297f04eaf12ff59be86190e64e51a25">minimumValueSize</a> () const</td></tr>
<tr class="memdesc:ad297f04eaf12ff59be86190e64e51a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Minimum value size.  <br /></td></tr>
<tr class="separator:ad297f04eaf12ff59be86190e64e51a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36839031d382db899a43c591813a3fa6" id="r_a36839031d382db899a43c591813a3fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a36839031d382db899a43c591813a3fa6">minimumValueSize</a> (size_t m)</td></tr>
<tr class="memdesc:a36839031d382db899a43c591813a3fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Minimum value size.  <br /></td></tr>
<tr class="separator:a36839031d382db899a43c591813a3fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a06f3441195b8c2c0327b4d2a5abce278" id="r_a06f3441195b8c2c0327b4d2a5abce278"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a06f3441195b8c2c0327b4d2a5abce278">valuePadding</a> () const</td></tr>
<tr class="memdesc:a06f3441195b8c2c0327b4d2a5abce278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Aligned value size.  <br /></td></tr>
<tr class="separator:a06f3441195b8c2c0327b4d2a5abce278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab306d9bd7ad60c0e7149375c66e341dd" id="r_ab306d9bd7ad60c0e7149375c66e341dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#ab306d9bd7ad60c0e7149375c66e341dd">valuePadding</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;)</td></tr>
<tr class="memdesc:ab306d9bd7ad60c0e7149375c66e341dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Aligned value size.  <br /></td></tr>
<tr class="separator:ab306d9bd7ad60c0e7149375c66e341dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8469bfed16b9677187f6dfef51ad42e7" id="r_a8469bfed16b9677187f6dfef51ad42e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a8469bfed16b9677187f6dfef51ad42e7">valueJustification</a> () const</td></tr>
<tr class="memdesc:a8469bfed16b9677187f6dfef51ad42e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Value justification within allocated storage.  <br /></td></tr>
<tr class="separator:a8469bfed16b9677187f6dfef51ad42e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66160d551695359274226721f711770f" id="r_a66160d551695359274226721f711770f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a66160d551695359274226721f711770f">valueJustification</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>)</td></tr>
<tr class="memdesc:a66160d551695359274226721f711770f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Value justification within allocated storage.  <br /></td></tr>
<tr class="separator:a66160d551695359274226721f711770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a281f1e574d56d19b435cde5fc1ed6323" id="r_a281f1e574d56d19b435cde5fc1ed6323"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a281f1e574d56d19b435cde5fc1ed6323">alignment</a> () const</td></tr>
<tr class="memdesc:a281f1e574d56d19b435cde5fc1ed6323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> of stack offsets.  <br /></td></tr>
<tr class="separator:a281f1e574d56d19b435cde5fc1ed6323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ec9dfe9b46bbc555e9eb05f9e13f0f" id="r_a00ec9dfe9b46bbc555e9eb05f9e13f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a00ec9dfe9b46bbc555e9eb05f9e13f0f">alignment</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;)</td></tr>
<tr class="memdesc:a00ec9dfe9b46bbc555e9eb05f9e13f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> of stack offsets.  <br /></td></tr>
<tr class="separator:a00ec9dfe9b46bbc555e9eb05f9e13f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7b8c5fd15de13f6915e18b3f34593dd7" id="r_a7b8c5fd15de13f6915e18b3f34593dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a7b8c5fd15de13f6915e18b3f34593dd7">baseRegister</a> () const</td></tr>
<tr class="memdesc:a7b8c5fd15de13f6915e18b3f34593dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Base register.  <br /></td></tr>
<tr class="separator:a7b8c5fd15de13f6915e18b3f34593dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0586517eebeddc16d3c26d1128a9016" id="r_ae0586517eebeddc16d3c26d1128a9016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#ae0586517eebeddc16d3c26d1128a9016">baseRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:ae0586517eebeddc16d3c26d1128a9016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Base register.  <br /></td></tr>
<tr class="separator:ae0586517eebeddc16d3c26d1128a9016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a></td></tr>
<tr class="memitem:a062560c3b1ce47ee02011442c07084fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase" id="r_a062560c3b1ce47ee02011442c07084fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#a062560c3b1ce47ee02011442c07084fe">canStore</a> (<a class="el" href="classSgAsmType.html">SgAsmType</a> *) const</td></tr>
<tr class="memdesc:a062560c3b1ce47ee02011442c07084fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether locations can store type.  <br /></td></tr>
<tr class="separator:a062560c3b1ce47ee02011442c07084fe inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab268cba08087ebb999ab84eb59fca2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase" id="r_aab268cba08087ebb999ab84eb59fca2f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#aab268cba08087ebb999ab84eb59fca2f">constantLocations</a> () const</td></tr>
<tr class="memdesc:aab268cba08087ebb999ab84eb59fca2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of constant storage locations.  <br /></td></tr>
<tr class="separator:aab268cba08087ebb999ab84eb59fca2f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a180ad6daa58ea8a9a8ed2a0fa00b1095" id="r_a180ad6daa58ea8a9a8ed2a0fa00b1095"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a97feb31133d3c7e59cea90c176ce8752">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a180ad6daa58ea8a9a8ed2a0fa00b1095">instance</a> (const std::string &amp;name, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#abeee506b5a4fe0e7e1a6419b487352b3">TypePredicateConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a180ad6daa58ea8a9a8ed2a0fa00b1095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a180ad6daa58ea8a9a8ed2a0fa00b1095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a></td></tr>
<tr class="memitem:ade288df0c766c1c5fef90349caa5d0b0 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase" id="r_ade288df0c766c1c5fef90349caa5d0b0"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>StoragePoolBase</b> (const std::string &amp;name, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#abeee506b5a4fe0e7e1a6419b487352b3">TypePredicateConstPtr</a> &amp;)</td></tr>
<tr class="separator:ade288df0c766c1c5fef90349caa5d0b0 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a97feb31133d3c7e59cea90c176ce8752" name="a97feb31133d3c7e59cea90c176ce8752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97feb31133d3c7e59cea90c176ce8752">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a97feb31133d3c7e59cea90c176ce8752">Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a8d893305475075739855a54bbf3bff26">StoragePoolStackPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="StoragePool_8h_source.html#l00192">192</a> of file <a class="el" href="StoragePool_8h_source.html">StoragePool.h</a>.</p>

</div>
</div>
<a id="aa608f33cf1b4e78bccd77c8df6d1a5d2" name="aa608f33cf1b4e78bccd77c8df6d1a5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa608f33cf1b4e78bccd77c8df6d1a5d2">&#9670;&#160;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#aa608f33cf1b4e78bccd77c8df6d1a5d2">Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::ConstPtr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af89a06b052ad4b63bbdcb3f76e2840ea">StoragePoolStackConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="StoragePool_8h_source.html#l00193">193</a> of file <a class="el" href="StoragePool_8h_source.html">StoragePool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a180ad6daa58ea8a9a8ed2a0fa00b1095" name="a180ad6daa58ea8a9a8ed2a0fa00b1095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180ad6daa58ea8a9a8ed2a0fa00b1095">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#a97feb31133d3c7e59cea90c176ce8752">Ptr</a> Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#abeee506b5a4fe0e7e1a6419b487352b3">TypePredicateConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Construct a new storage pool for allocating arguments on the stack. </p>

</div>
</div>
<a id="a22f7e4bfcb6f385c29de5d7ba7722eae" name="a22f7e4bfcb6f385c29de5d7ba7722eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f7e4bfcb6f385c29de5d7ba7722eae">&#9670;&#160;</a></span>stackDirection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a> Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::stackDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack direction. </p>
<p>Determines whether the stack grows up or down when an item is pushed onto the stack. Downward-growing stacks are the usual convention, which means that a value is pushed onto the stack by placing it at the next lower stack address(es) in memory. </p>

</div>
</div>
<a id="a71754c6f4f223f8aa0fab638612c48bb" name="a71754c6f4f223f8aa0fab638612c48bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71754c6f4f223f8aa0fab638612c48bb">&#9670;&#160;</a></span>stackDirection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::stackDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack direction. </p>
<p>Determines whether the stack grows up or down when an item is pushed onto the stack. Downward-growing stacks are the usual convention, which means that a value is pushed onto the stack by placing it at the next lower stack address(es) in memory. </p>

</div>
</div>
<a id="a02aebcb35ff1eb5ceea8d1b04882499e" name="a02aebcb35ff1eb5ceea8d1b04882499e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aebcb35ff1eb5ceea8d1b04882499e">&#9670;&#160;</a></span>initialOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::initialOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Initial stack offset. </p>
<p>Offset from the stack pointer to the first storage location. </p>

</div>
</div>
<a id="a69e06ee34c1be121b34727512011f137" name="a69e06ee34c1be121b34727512011f137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e06ee34c1be121b34727512011f137">&#9670;&#160;</a></span>initialOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::initialOffset </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Initial stack offset. </p>
<p>Offset from the stack pointer to the first storage location. </p>

</div>
</div>
<a id="ad297f04eaf12ff59be86190e64e51a25" name="ad297f04eaf12ff59be86190e64e51a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad297f04eaf12ff59be86190e64e51a25">&#9670;&#160;</a></span>minimumValueSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::minimumValueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Minimum value size. </p>
<p>When allocating space for a value of size <code>n</code> bytes, this pool will allocate at least <code>m</code> bytes. </p>

</div>
</div>
<a id="a36839031d382db899a43c591813a3fa6" name="a36839031d382db899a43c591813a3fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36839031d382db899a43c591813a3fa6">&#9670;&#160;</a></span>minimumValueSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::minimumValueSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Minimum value size. </p>
<p>When allocating space for a value of size <code>n</code> bytes, this pool will allocate at least <code>m</code> bytes. </p>

</div>
</div>
<a id="a06f3441195b8c2c0327b4d2a5abce278" name="a06f3441195b8c2c0327b4d2a5abce278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3441195b8c2c0327b4d2a5abce278">&#9670;&#160;</a></span>valuePadding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp; Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::valuePadding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Aligned value size. </p>
<p>When allocating space for a value of size <code>n</code> bytes, this pool will pad the size to make it a multiple of <code>m</code> bytes. </p>

</div>
</div>
<a id="ab306d9bd7ad60c0e7149375c66e341dd" name="ab306d9bd7ad60c0e7149375c66e341dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab306d9bd7ad60c0e7149375c66e341dd">&#9670;&#160;</a></span>valuePadding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::valuePadding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Aligned value size. </p>
<p>When allocating space for a value of size <code>n</code> bytes, this pool will pad the size to make it a multiple of <code>m</code> bytes. </p>

</div>
</div>
<a id="a8469bfed16b9677187f6dfef51ad42e7" name="a8469bfed16b9677187f6dfef51ad42e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8469bfed16b9677187f6dfef51ad42e7">&#9670;&#160;</a></span>valueJustification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::valueJustification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Value justification within allocated storage. </p>
<p>When allocating space for a value of of size <code>n</code> bytes in an allocation region of size <code>m</code> bytes where <code>m</code> is greater than <code>n</code>, this property determines whether the value is stored in the lowest-address bytes of the region (<code>ORDER_LSB</code>) or the highest bytes of the region (<code>ORDER_MSB</code>) </p>

</div>
</div>
<a id="a66160d551695359274226721f711770f" name="a66160d551695359274226721f711770f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66160d551695359274226721f711770f">&#9670;&#160;</a></span>valueJustification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::valueJustification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Value justification within allocated storage. </p>
<p>When allocating space for a value of of size <code>n</code> bytes in an allocation region of size <code>m</code> bytes where <code>m</code> is greater than <code>n</code>, this property determines whether the value is stored in the lowest-address bytes of the region (<code>ORDER_LSB</code>) or the highest bytes of the region (<code>ORDER_MSB</code>) </p>

</div>
</div>
<a id="a281f1e574d56d19b435cde5fc1ed6323" name="a281f1e574d56d19b435cde5fc1ed6323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281f1e574d56d19b435cde5fc1ed6323">&#9670;&#160;</a></span>alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp; Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::alignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> of stack offsets. </p>
<p>After determining the padded size of the stack area that stores the value, the address on the stack is calculated as an offset from the stack pointer. The offset is then aligned according to this property. </p>

</div>
</div>
<a id="a00ec9dfe9b46bbc555e9eb05f9e13f0f" name="a00ec9dfe9b46bbc555e9eb05f9e13f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ec9dfe9b46bbc555e9eb05f9e13f0f">&#9670;&#160;</a></span>alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> of stack offsets. </p>
<p>After determining the padded size of the stack area that stores the value, the address on the stack is calculated as an offset from the stack pointer. The offset is then aligned according to this property. </p>

</div>
</div>
<a id="a7b8c5fd15de13f6915e18b3f34593dd7" name="a7b8c5fd15de13f6915e18b3f34593dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8c5fd15de13f6915e18b3f34593dd7">&#9670;&#160;</a></span>baseRegister() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::baseRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Base register. </p>
<p>This is the register that points to the top of the stack. The constructor initializes this with the stack pointer register obtained from the architecture description, but it can be overridden. </p>

</div>
</div>
<a id="ae0586517eebeddc16d3c26d1128a9016" name="ae0586517eebeddc16d3c26d1128a9016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0586517eebeddc16d3c26d1128a9016">&#9670;&#160;</a></span>baseRegister() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::baseRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Base register. </p>
<p>This is the register that points to the top of the stack. The constructor initializes this with the stack pointer register obtained from the architecture description, but it can be overridden. </p>

</div>
</div>
<a id="ad27cbbb598ea5bb496ec3bbf5de18d55" name="ad27cbbb598ea5bb496ec3bbf5de18d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27cbbb598ea5bb496ec3bbf5de18d55">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af78c17c831b5837a3de3efbed5e86d01">StoragePoolBasePtr</a> Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Makes a new copy of this pool. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#a5c1f0da622328028f449fae11f7f9a30">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a>.</p>

</div>
</div>
<a id="afc1f2a38860c3c2d9936ae93b8c8fb98" name="afc1f2a38860c3c2d9936ae93b8c8fb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1f2a38860c3c2d9936ae93b8c8fb98">&#9670;&#160;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmType.html">SgAsmType</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consume a storage location. </p>
<p>Given an argument type, return a location(s) if possible and remove that location from this pool. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#af2a82bcc647a9840874724ff851a3605">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a>.</p>

</div>
</div>
<a id="a389f26e6f2d60fc65c4a7a77ce012f44" name="a389f26e6f2d60fc65c4a7a77ce012f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389f26e6f2d60fc65c4a7a77ce012f44">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::StoragePoolStack::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset allocation. </p>
<p>Resets this storage pool back to its initial state. For instance, if the storage pool contains a list of three explicit locations and some or all of them have been taken by <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolStack.html#afc1f2a38860c3c2d9936ae93b8c8fb98">consume</a>, then calling this function will make all three available again. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1StoragePoolBase.html#a89ea9c9c7f9a59111c791f446c3432d9">Rose::BinaryAnalysis::CallingConvention::StoragePoolBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="StoragePool_8h_source.html">StoragePool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
