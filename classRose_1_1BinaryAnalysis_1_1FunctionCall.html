<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::FunctionCall Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">FunctionCall</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1FunctionCall-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::FunctionCall Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Binary function call analysis. </p>
<p>This class serves mostly to organize the functions that operate on function calls, but also provides a container for various settings that influence the function call analyses, such as vertex and edge filters.</p>
<p><a class="el" href="classFunction.html">Function</a> call graphs can be computed over any subtree of the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, although one usually does so over an entire binary interpretation (<a class="el" href="classSgAsmInterpretation.html" title="Represents an interpretation of a binary container.">SgAsmInterpretation</a>). The vertex and edge filters can restrict which functions and call edges are considered by the various methods of this class. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00021">21</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="FunctionCall_8h_source.html">Rose/BinaryAnalysis/FunctionCall.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::FunctionCall:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1FunctionCall__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1FunctionCall_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1FunctionCall_coll__map" id="aRose_1_1BinaryAnalysis_1_1FunctionCall_coll__map">
<area shape="rect" title="Binary function call analysis." alt="" coords="304,37,452,77"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html" title="Filter for vertices." alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="196,34,304,46,304,52,196,39"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html" title="Filter for edges." alt="" coords="9,69,179,109"/>
<area shape="poly" title=" " alt="" coords="193,75,303,63,304,68,194,81"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for edges.  <a href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for vertices.  <a href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:accf1caa8493b25dce524e99c107e5998" id="r_accf1caa8493b25dce524e99c107e5998"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list&lt; boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt; boost::vertex_name_t, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998">Graph</a></td></tr>
<tr class="memdesc:accf1caa8493b25dce524e99c107e5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default function call graph type.  <br /></td></tr>
<tr class="separator:accf1caa8493b25dce524e99c107e5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b79bb8b5b8bf6e7f66f132b83d4a535" id="r_a2b79bb8b5b8bf6e7f66f132b83d4a535"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:a2b79bb8b5b8bf6e7f66f132b83d4a535"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a2b79bb8b5b8bf6e7f66f132b83d4a535">cache_vertex_descriptors</a> (const FunctionCallGraph &amp;)</td></tr>
<tr class="memdesc:a2b79bb8b5b8bf6e7f66f132b83d4a535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache vertex descriptors in <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a2b79bb8b5b8bf6e7f66f132b83d4a535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2b5bca2c2da7dae69c3732569a333c65" id="r_a2b5bca2c2da7dae69c3732569a333c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a2b5bca2c2da7dae69c3732569a333c65">set_vertex_filter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>
<tr class="memdesc:a2b5bca2c2da7dae69c3732569a333c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the vertex filter.  <br /></td></tr>
<tr class="separator:a2b5bca2c2da7dae69c3732569a333c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada039443703126d6406ec94bfa382927" id="r_ada039443703126d6406ec94bfa382927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#ada039443703126d6406ec94bfa382927">get_vertex_filter</a> () const</td></tr>
<tr class="memdesc:ada039443703126d6406ec94bfa382927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the vertex filter.  <br /></td></tr>
<tr class="separator:ada039443703126d6406ec94bfa382927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d804c3abcafc84a6e5acaeb957eac01" id="r_a3d804c3abcafc84a6e5acaeb957eac01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a3d804c3abcafc84a6e5acaeb957eac01">set_edge_filter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>
<tr class="memdesc:a3d804c3abcafc84a6e5acaeb957eac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the edge filter.  <br /></td></tr>
<tr class="separator:a3d804c3abcafc84a6e5acaeb957eac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5cfcafb0d8fd618b2ef6f628f329f4" id="r_a5e5cfcafb0d8fd618b2ef6f628f329f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a5e5cfcafb0d8fd618b2ef6f628f329f4">get_edge_filter</a> () const</td></tr>
<tr class="memdesc:a5e5cfcafb0d8fd618b2ef6f628f329f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the edge filter.  <br /></td></tr>
<tr class="separator:a5e5cfcafb0d8fd618b2ef6f628f329f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5555905b7313d4752e61bf93a0376b64" id="r_a5555905b7313d4752e61bf93a0376b64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a5555905b7313d4752e61bf93a0376b64">is_vertex_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *func, <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>
<tr class="memdesc:a5555905b7313d4752e61bf93a0376b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a vertex is filtered out.  <br /></td></tr>
<tr class="separator:a5555905b7313d4752e61bf93a0376b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2f3174db53847501c57215ae98bf18" id="r_afe2f3174db53847501c57215ae98bf18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#afe2f3174db53847501c57215ae98bf18">is_vertex_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *func)</td></tr>
<tr class="memdesc:afe2f3174db53847501c57215ae98bf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a vertex is filtered out.  <br /></td></tr>
<tr class="separator:afe2f3174db53847501c57215ae98bf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0fd8da2d2e3ba509eb00113d8715a9db" id="r_a0fd8da2d2e3ba509eb00113d8715a9db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a0fd8da2d2e3ba509eb00113d8715a9db">is_edge_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *dst, <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>
<tr class="memdesc:a0fd8da2d2e3ba509eb00113d8715a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an edge is filtered out.  <br /></td></tr>
<tr class="separator:a0fd8da2d2e3ba509eb00113d8715a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8b2d4aa5778471679bb2b34b1c959e" id="r_aee8b2d4aa5778471679bb2b34b1c959e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#aee8b2d4aa5778471679bb2b34b1c959e">is_edge_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *dst)</td></tr>
<tr class="memdesc:aee8b2d4aa5778471679bb2b34b1c959e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an edge is filtered out.  <br /></td></tr>
<tr class="separator:aee8b2d4aa5778471679bb2b34b1c959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a51fb41efd554d3f6c3dbe401f43bf7b8" id="r_a51fb41efd554d3f6c3dbe401f43bf7b8"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph , class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a51fb41efd554d3f6c3dbe401f43bf7b8"><td class="memTemplItemLeft" align="right" valign="top">FunctionCallGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a51fb41efd554d3f6c3dbe401f43bf7b8">build_cg_from_cfg</a> (const ControlFlowGraph &amp;)</td></tr>
<tr class="memdesc:a51fb41efd554d3f6c3dbe401f43bf7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a function call graph from a control flow graph.  <br /></td></tr>
<tr class="separator:a51fb41efd554d3f6c3dbe401f43bf7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41af2cacea187ae89de3dec1543439" id="r_a1f41af2cacea187ae89de3dec1543439"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph , class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:a1f41af2cacea187ae89de3dec1543439"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a1f41af2cacea187ae89de3dec1543439">build_cg_from_cfg</a> (const ControlFlowGraph &amp;cfg, FunctionCallGraph &amp;cg)</td></tr>
<tr class="memdesc:a1f41af2cacea187ae89de3dec1543439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a function call graph from a control flow graph.  <br /></td></tr>
<tr class="separator:a1f41af2cacea187ae89de3dec1543439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93ab7f9364fdb2e82747bab90a5bd9b4" id="r_a93ab7f9364fdb2e82747bab90a5bd9b4"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:a93ab7f9364fdb2e82747bab90a5bd9b4"><td class="memTemplItemLeft" align="right" valign="top">FunctionCallGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a93ab7f9364fdb2e82747bab90a5bd9b4">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a93ab7f9364fdb2e82747bab90a5bd9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a function call graph from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a93ab7f9364fdb2e82747bab90a5bd9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f52f028befb01a9c04b3ab7d3e0a0d" id="r_ab1f52f028befb01a9c04b3ab7d3e0a0d"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:ab1f52f028befb01a9c04b3ab7d3e0a0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#ab1f52f028befb01a9c04b3ab7d3e0a0d">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, FunctionCallGraph &amp;cg)</td></tr>
<tr class="memdesc:ab1f52f028befb01a9c04b3ab7d3e0a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a function call graph from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:ab1f52f028befb01a9c04b3ab7d3e0a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b013c79bf99372835b13c1845ca9ec0" id="r_a0b013c79bf99372835b13c1845ca9ec0"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:a0b013c79bf99372835b13c1845ca9ec0"><td class="memTemplItemLeft" align="right" valign="top">FunctionCallGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a0b013c79bf99372835b13c1845ca9ec0">copy</a> (const FunctionCallGraph &amp;src)</td></tr>
<tr class="memdesc:a0b013c79bf99372835b13c1845ca9ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a graph while filtering.  <br /></td></tr>
<tr class="separator:a0b013c79bf99372835b13c1845ca9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285812b5ed1134a3764a83c2409aba0e" id="r_a285812b5ed1134a3764a83c2409aba0e"><td class="memTemplParams" colspan="2">template&lt;class FunctionCallGraph &gt; </td></tr>
<tr class="memitem:a285812b5ed1134a3764a83c2409aba0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a285812b5ed1134a3764a83c2409aba0e">copy</a> (const FunctionCallGraph &amp;src, FunctionCallGraph &amp;dst)</td></tr>
<tr class="memdesc:a285812b5ed1134a3764a83c2409aba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a graph while filtering.  <br /></td></tr>
<tr class="separator:a285812b5ed1134a3764a83c2409aba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af9adb8aeb43fad3d77a7fc7821e7da16" id="r_af9adb8aeb43fad3d77a7fc7821e7da16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#af9adb8aeb43fad3d77a7fc7821e7da16">vertex_filter</a></td></tr>
<tr class="separator:af9adb8aeb43fad3d77a7fc7821e7da16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e344a28c60467ba8a952ab9ffb7c3e" id="r_a15e344a28c60467ba8a952ab9ffb7c3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a15e344a28c60467ba8a952ab9ffb7c3e">edge_filter</a></td></tr>
<tr class="separator:a15e344a28c60467ba8a952ab9ffb7c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="accf1caa8493b25dce524e99c107e5998" name="accf1caa8493b25dce524e99c107e5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf1caa8493b25dce524e99c107e5998">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>*&gt; &gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998">Rose::BinaryAnalysis::FunctionCall::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default function call graph type. </p>
<p>A function call graph is simply a Boost graph whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> nodes in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> (via the boost::vertex_name property). The graph edges represent function calls from one <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> to another. Since this graph is a Boost graph, it is endowed with all the features of a Boost graph and can be the operand of the various Boost graph algorithms. See build_cg() for specifics about what is included in such a graph.</p>
<p>Another way to represent function calls is to adapt a global control flow graph (Rose::BinaryAnalysis::ControlFlowGraph) to include only the edges (and their incident vertices) that flow from one function to another. The advantage of using a control flow graph to represent function call information is that each call site will be included in the function call graph due to the fact that the control flow graph vertices are blocks (<a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>) rather than functions (<a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a>).</p>
<p>It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself&ndash;change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor <a class="code hl_struct" href="structVertex.html">Vertex</a>;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor <a class="code hl_struct" href="structEdge.html">Edge</a>;</div>
<div class="ttc" id="astructEdge_html"><div class="ttname"><a href="structEdge.html">Edge</a></div><div class="ttdef"><b>Definition</b> <a href="SgGraphTemplate_8h_source.html#l00012">SgGraphTemplate.h:12</a></div></div>
<div class="ttc" id="astructVertex_html"><div class="ttname"><a href="structVertex.html">Vertex</a></div><div class="ttdef"><b>Definition</b> <a href="SgGraphTemplate_8h_source.html#l00007">SgGraphTemplate.h:7</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00056">56</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea8697be4be96d2460f8cb436453c620" name="aea8697be4be96d2460f8cb436453c620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8697be4be96d2460f8cb436453c620">&#9670;&#160;</a></span>FunctionCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::FunctionCall::FunctionCall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00024">24</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2b5bca2c2da7dae69c3732569a333c65" name="a2b5bca2c2da7dae69c3732569a333c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5bca2c2da7dae69c3732569a333c65">&#9670;&#160;</a></span>set_vertex_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::set_vertex_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the vertex filter. </p>
<p>When building a function call graph, the vertex filter is invoked on each function which is about to be added as a vertex. If the filter returns false then that function is not added to the graph. A null filter accepts all vertices. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00091">91</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<a id="ada039443703126d6406ec94bfa382927" name="ada039443703126d6406ec94bfa382927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada039443703126d6406ec94bfa382927">&#9670;&#160;</a></span>get_vertex_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> * Rose::BinaryAnalysis::FunctionCall::get_vertex_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the vertex filter. </p>
<p>When building a function call graph, the vertex filter is invoked on each function which is about to be added as a vertex. If the filter returns false then that function is not added to the graph. A null filter accepts all vertices. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00092">92</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<a id="a3d804c3abcafc84a6e5acaeb957eac01" name="a3d804c3abcafc84a6e5acaeb957eac01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d804c3abcafc84a6e5acaeb957eac01">&#9670;&#160;</a></span>set_edge_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::set_edge_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the edge filter. </p>
<p>When building a function call graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00101">101</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<a id="a5e5cfcafb0d8fd618b2ef6f628f329f4" name="a5e5cfcafb0d8fd618b2ef6f628f329f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5cfcafb0d8fd618b2ef6f628f329f4">&#9670;&#160;</a></span>get_edge_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> * Rose::BinaryAnalysis::FunctionCall::get_edge_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the edge filter. </p>
<p>When building a function call graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00102">102</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<a id="a5555905b7313d4752e61bf93a0376b64" name="a5555905b7313d4752e61bf93a0376b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5555905b7313d4752e61bf93a0376b64">&#9670;&#160;</a></span>is_vertex_filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::FunctionCall::is_vertex_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a vertex is filtered out. </p>
<p>Returns true if the vertex would be filtered out by being rejected by the current vertex filter. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00110">110</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCall_8h_source.html#l00306">build_cg_from_ast()</a>, <a class="el" href="FunctionCall_8h_source.html#l00250">build_cg_from_cfg()</a>, <a class="el" href="FunctionCall_8h_source.html#l00238">cache_vertex_descriptors()</a>, <a class="el" href="FunctionCall_8h_source.html#l00386">copy()</a>, and <a class="el" href="FunctionCall_8h_source.html#l00113">is_vertex_filtered()</a>.</p>

</div>
</div>
<a id="afe2f3174db53847501c57215ae98bf18" name="afe2f3174db53847501c57215ae98bf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2f3174db53847501c57215ae98bf18">&#9670;&#160;</a></span>is_vertex_filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::FunctionCall::is_vertex_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a vertex is filtered out. </p>
<p>Returns true if the vertex would be filtered out by being rejected by the current vertex filter. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00113">113</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="FunctionCall_8h_source.html#l00110">is_vertex_filtered()</a>.</p>

</div>
</div>
<a id="a0fd8da2d2e3ba509eb00113d8715a9db" name="a0fd8da2d2e3ba509eb00113d8715a9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd8da2d2e3ba509eb00113d8715a9db">&#9670;&#160;</a></span>is_edge_filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::FunctionCall::is_edge_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an edge is filtered out. </p>
<p>Returns true if the edge would be filtered out by being rejected by the current edge filter. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00123">123</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCall_8h_source.html#l00306">build_cg_from_ast()</a>, <a class="el" href="FunctionCall_8h_source.html#l00250">build_cg_from_cfg()</a>, <a class="el" href="FunctionCall_8h_source.html#l00386">copy()</a>, and <a class="el" href="FunctionCall_8h_source.html#l00126">is_edge_filtered()</a>.</p>

</div>
</div>
<a id="aee8b2d4aa5778471679bb2b34b1c959e" name="aee8b2d4aa5778471679bb2b34b1c959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8b2d4aa5778471679bb2b34b1c959e">&#9670;&#160;</a></span>is_edge_filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::FunctionCall::is_edge_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an edge is filtered out. </p>
<p>Returns true if the edge would be filtered out by being rejected by the current edge filter. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00126">126</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="FunctionCall_8h_source.html#l00123">is_edge_filtered()</a>.</p>

</div>
</div>
<a id="a2b79bb8b5b8bf6e7f66f132b83d4a535" name="a2b79bb8b5b8bf6e7f66f132b83d4a535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b79bb8b5b8bf6e7f66f132b83d4a535">&#9670;&#160;</a></span>cache_vertex_descriptors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::cache_vertex_descriptors </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>cg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache vertex descriptors in <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>The vertices of a function call graph are of type <a class="el" href="structVertex.html">Vertex</a>, and point at the functions (<a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a>) of the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. Although most graph algorithms will only need to map <a class="el" href="structVertex.html">Vertex</a> to <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a>, the inverse mapping is also sometimes useful. That mapping can be stored into an std::map via graph traversal, or stored in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> itself attached to each <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a>. Using an std::map requires an O(log N) lookup each time we need to get the vertex descriptor for a function, while storing the vertex descriptor in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> requires O(1) lookup time.</p>
<p>The vertex descriptors are available via SgAsmFunction::get_cached_vertex(). Other graph types (e.g., dominance graphs) might also use the same cache line. The cached vertex is stored as a size_t, which is the same underlying type for function call graph vertices.</p>
<p>The current vertex filter determines which function nodes are modified. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00238">238</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, and <a class="el" href="FunctionCall_8h_source.html#l00110">is_vertex_filtered()</a>.</p>

</div>
</div>
<a id="a51fb41efd554d3f6c3dbe401f43bf7b8" name="a51fb41efd554d3f6c3dbe401f43bf7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fb41efd554d3f6c3dbe401f43bf7b8">&#9670;&#160;</a></span>build_cg_from_cfg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph , class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph Rose::BinaryAnalysis::FunctionCall::build_cg_from_cfg </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a function call graph from a control flow graph. </p>
<p>Given a control flow graph (CFG) spanning multiple functions, create a function call graph (CG) by collapsing vertices in the CFG that belong to a common function. Any resulting self-loop edges will be removed unless the target of the corresponding edge in the CFG was the function entry block (i.e., intra-function CFG edges whose target is the function's entry block are assumed to be recursive calls, while all other intra-function CFG edges are omitted from the CG).</p>
<p>The current vertex and edge filters are used to restrict which functions and calls make it into the graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00297">297</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="FunctionCall_8h_source.html#l00297">build_cg_from_cfg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCall_8h_source.html#l00297">build_cg_from_cfg()</a>.</p>

</div>
</div>
<a id="a1f41af2cacea187ae89de3dec1543439" name="a1f41af2cacea187ae89de3dec1543439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f41af2cacea187ae89de3dec1543439">&#9670;&#160;</a></span>build_cg_from_cfg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph , class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::build_cg_from_cfg </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>cg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a function call graph from a control flow graph. </p>
<p>Given a control flow graph (CFG) spanning multiple functions, create a function call graph (CG) by collapsing vertices in the CFG that belong to a common function. Any resulting self-loop edges will be removed unless the target of the corresponding edge in the CFG was the function entry block (i.e., intra-function CFG edges whose target is the function's entry block are assumed to be recursive calls, while all other intra-function CFG edges are omitted from the CG).</p>
<p>The current vertex and edge filters are used to restrict which functions and calls make it into the graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00250">250</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmBlock.html#ac45ed2064a3235234b651183ac632a70">SgAsmBlock::get_enclosingFunction()</a>, <a class="el" href="classSgAsmFunction.html#a85374a810087387df27743e02e84705c">SgAsmFunction::get_entryBlock()</a>, <a class="el" href="FunctionCall_8h_source.html#l00123">is_edge_filtered()</a>, <a class="el" href="FunctionCall_8h_source.html#l00110">is_vertex_filtered()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00567">Rose::BinaryAnalysis::put_ast_node()</a>.</p>

</div>
</div>
<a id="a93ab7f9364fdb2e82747bab90a5bd9b4" name="a93ab7f9364fdb2e82747bab90a5bd9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab7f9364fdb2e82747bab90a5bd9b4">&#9670;&#160;</a></span>build_cg_from_ast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph Rose::BinaryAnalysis::FunctionCall::build_cg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a function call graph from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Given an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, traverse the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> beginning at <code>root</code> and build a function call graph (CG). The function call graph will contain only <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> vertices that are in the specified subtree and which are not filtered out by the current vertex filter. Edges also must pass the edge filter to be included in the graph.</p>
<p>The following two methods of constructing a CG should result in identical graphs (although vertex and edge order may be different):</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998">FunctionCall::Graph</a> CG;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#acf06837ba4e61a78fce3704d367643d3">ControlFlow::Graph</a>  CFG;</div>
<div class="line"><a class="code hl_class" href="classSgAsmNode.html">SgAsmNode</a> *node = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 1</span></div>
<div class="line">CG cg1 = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a93ab7f9364fdb2e82747bab90a5bd9b4">build_cg_from_ast</a>(node);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 2</span></div>
<div class="line">CFG cfg = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">ControlFlow</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296">build_block_cfg_from_ast</a>&lt;CFG&gt;(node);</div>
<div class="line">CG cg2 = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a51fb41efd554d3f6c3dbe401f43bf7b8">build_cg_from_cfg</a>&lt;CG&gt;(cfg);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1ControlFlow_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">Rose::BinaryAnalysis::ControlFlow</a></div><div class="ttdoc">Binary control flow analysis.</div><div class="ttdef"><b>Definition</b> <a href="ControlFlow_8h_source.html#l00135">ControlFlow.h:135</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1ControlFlow_html_a9328c747abd4d9a9054cca11a6634296"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296">Rose::BinaryAnalysis::ControlFlow::build_block_cfg_from_ast</a></div><div class="ttdeci">ControlFlowGraph build_block_cfg_from_ast(SgNode *root)</div><div class="ttdoc">Builds a control flow graph for part of an AST.</div><div class="ttdef"><b>Definition</b> <a href="ControlFlow_8h_source.html#l00988">ControlFlow.h:988</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1ControlFlow_html_acf06837ba4e61a78fce3704d367643d3"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#acf06837ba4e61a78fce3704d367643d3">Rose::BinaryAnalysis::ControlFlow::Graph</a></div><div class="ttdeci">BlockGraph Graph</div><div class="ttdoc">Default control flow graph.</div><div class="ttdef"><b>Definition</b> <a href="ControlFlow_8h_source.html#l00190">ControlFlow.h:190</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1FunctionCall_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">Rose::BinaryAnalysis::FunctionCall</a></div><div class="ttdoc">Binary function call analysis.</div><div class="ttdef"><b>Definition</b> <a href="FunctionCall_8h_source.html#l00021">FunctionCall.h:21</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1FunctionCall_html_a51fb41efd554d3f6c3dbe401f43bf7b8"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a51fb41efd554d3f6c3dbe401f43bf7b8">Rose::BinaryAnalysis::FunctionCall::build_cg_from_cfg</a></div><div class="ttdeci">FunctionCallGraph build_cg_from_cfg(const ControlFlowGraph &amp;)</div><div class="ttdoc">Build a function call graph from a control flow graph.</div><div class="ttdef"><b>Definition</b> <a href="FunctionCall_8h_source.html#l00297">FunctionCall.h:297</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1FunctionCall_html_a93ab7f9364fdb2e82747bab90a5bd9b4"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a93ab7f9364fdb2e82747bab90a5bd9b4">Rose::BinaryAnalysis::FunctionCall::build_cg_from_ast</a></div><div class="ttdeci">FunctionCallGraph build_cg_from_ast(SgNode *root)</div><div class="ttdoc">Build a function call graph from an AST.</div><div class="ttdef"><b>Definition</b> <a href="FunctionCall_8h_source.html#l00377">FunctionCall.h:377</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1FunctionCall_html_accf1caa8493b25dce524e99c107e5998"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998">Rose::BinaryAnalysis::FunctionCall::Graph</a></div><div class="ttdeci">boost::adjacency_list&lt; boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt; boost::vertex_name_t, SgAsmFunction * &gt; &gt; Graph</div><div class="ttdoc">The default function call graph type.</div><div class="ttdef"><b>Definition</b> <a href="FunctionCall_8h_source.html#l00056">FunctionCall.h:56</a></div></div>
<div class="ttc" id="aclassSgAsmNode_html"><div class="ttname"><a href="classSgAsmNode.html">SgAsmNode</a></div><div class="ttdoc">Base class for all binary analysis IR nodes.</div><div class="ttdef"><b>Definition</b> <a href="binaryInstruction_8C_source.html#l44097">binaryInstruction.C:44097</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a></div><div class="ttdoc">Binary analysis.</div><div class="ttdef"><b>Definition</b> <a href="BinaryTutorial_8dox_source.html#l00004">BinaryTutorial.dox:4</a></div></div>
</div><!-- fragment --><p>In general, building the function call graph directly from the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will be faster than first building the control flow graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00377">377</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="FunctionCall_8h_source.html#l00377">build_cg_from_ast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCall_8h_source.html#l00377">build_cg_from_ast()</a>.</p>

</div>
</div>
<a id="ab1f52f028befb01a9c04b3ab7d3e0a0d" name="ab1f52f028befb01a9c04b3ab7d3e0a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f52f028befb01a9c04b3ab7d3e0a0d">&#9670;&#160;</a></span>build_cg_from_ast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::build_cg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>cg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a function call graph from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Given an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, traverse the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> beginning at <code>root</code> and build a function call graph (CG). The function call graph will contain only <a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> vertices that are in the specified subtree and which are not filtered out by the current vertex filter. Edges also must pass the edge filter to be included in the graph.</p>
<p>The following two methods of constructing a CG should result in identical graphs (although vertex and edge order may be different):</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998">FunctionCall::Graph</a> CG;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#acf06837ba4e61a78fce3704d367643d3">ControlFlow::Graph</a>  CFG;</div>
<div class="line"><a class="code hl_class" href="classSgAsmNode.html">SgAsmNode</a> *node = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 1</span></div>
<div class="line">CG cg1 = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a93ab7f9364fdb2e82747bab90a5bd9b4">build_cg_from_ast</a>(node);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method 2</span></div>
<div class="line">CFG cfg = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">ControlFlow</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296">build_block_cfg_from_ast</a>&lt;CFG&gt;(node);</div>
<div class="line">CG cg2 = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#a51fb41efd554d3f6c3dbe401f43bf7b8">build_cg_from_cfg</a>&lt;CG&gt;(cfg);</div>
</div><!-- fragment --><p>In general, building the function call graph directly from the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will be faster than first building the control flow graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00306">306</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="classSgAsmStatement.html#ac0959f1b0d967f7aff9032c2a4e2ab92">SgAsmStatement::get_address()</a>, <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmBlock.html#ac45ed2064a3235234b651183ac632a70">SgAsmBlock::get_enclosingFunction()</a>, <a class="el" href="classSgAsmFunction.html#a18b23b19d6538da747ea71ecd94262ae">SgAsmFunction::get_entryVa()</a>, <a class="el" href="classSgAsmBlock.html#a31ca54ec6ee0dfff832a935fe08e3d80">SgAsmBlock::get_successors()</a>, <a class="el" href="FunctionCall_8h_source.html#l00123">is_edge_filtered()</a>, <a class="el" href="FunctionCall_8h_source.html#l00110">is_vertex_filtered()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00567">Rose::BinaryAnalysis::put_ast_node()</a>.</p>

</div>
</div>
<a id="a0b013c79bf99372835b13c1845ca9ec0" name="a0b013c79bf99372835b13c1845ca9ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b013c79bf99372835b13c1845ca9ec0">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph Rose::BinaryAnalysis::FunctionCall::copy </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a graph while filtering. </p>
<p>Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).</p>
<p>If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00416">416</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="FunctionCall_8h_source.html#l00416">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCall_8h_source.html#l00416">copy()</a>.</p>

</div>
</div>
<a id="a285812b5ed1134a3764a83c2409aba0e" name="a285812b5ed1134a3764a83c2409aba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285812b5ed1134a3764a83c2409aba0e">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::FunctionCall::copy </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a graph while filtering. </p>
<p>Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).</p>
<p>If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00386">386</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="FunctionCall_8h_source.html#l00123">is_edge_filtered()</a>, <a class="el" href="FunctionCall_8h_source.html#l00110">is_vertex_filtered()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00567">Rose::BinaryAnalysis::put_ast_node()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af9adb8aeb43fad3d77a7fc7821e7da16" name="af9adb8aeb43fad3d77a7fc7821e7da16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9adb8aeb43fad3d77a7fc7821e7da16">&#9670;&#160;</a></span>vertex_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a>* Rose::BinaryAnalysis::FunctionCall::vertex_filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00132">132</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<a id="a15e344a28c60467ba8a952ab9ffb7c3e" name="a15e344a28c60467ba8a952ab9ffb7c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e344a28c60467ba8a952ab9ffb7c3e">&#9670;&#160;</a></span>edge_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a>* Rose::BinaryAnalysis::FunctionCall::edge_filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FunctionCall_8h_source.html#l00133">133</a> of file <a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
