<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::StackDelta::Analysis Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1StackDelta.html">StackDelta</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::StackDelta::Analysis Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Stack delta anzalyzer. </p>
<p>Local variables within a function are generally found at constant offsets from a stack frame located on the stack. Some architectures have a stack frame pointer register that points to the current frame, but even on these architectures the register can sometimes be used for other purposes. If there is no frame pointer register, then the stack frame still exists and can be found at a constant offset from the stack pointer's initial value (at the start of the function).</p>
<p>This class performs a data-flow analysis to attempt to assign stack deltas to each instruction: one delta at the start of the instruction and one delta after the instruction executes. A stack delta is the difference between the current top-of-stack and the original top-of-stack.</p>
<p>If a stack delta is known at a particular instruction, then it can be used to find the original stack pointer by subtracting it from the current stack pointer. For example, if a function's first instruction is x86 "PUSH EAX" then the pre-instruction delta is zero and the post-instruction delta will be -4 due to the "push" decrementing ESP by four. After the "push", subtracting -4 from the current ESP value will give you the original ESP, from which you can find the frame. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00055">55</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="StackDelta_8h_source.html">Rose/BinaryAnalysis/StackDelta.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a82c36e90f59af4d164106220cb54188b" id="r_a82c36e90f59af4d164106220cb54188b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; rose_addr_t, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a82c36e90f59af4d164106220cb54188b">DeltasPerAddress</a></td></tr>
<tr class="separator:a82c36e90f59af4d164106220cb54188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fad00b701ddee683e707ba2130bcfd" id="r_a83fad00b701ddee683e707ba2130bcfd"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a83fad00b701ddee683e707ba2130bcfd">SValuePair</a></td></tr>
<tr class="separator:a83fad00b701ddee683e707ba2130bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9596e0e8a6870c7371ce8ef5c6a4e60" id="r_ab9596e0e8a6870c7371ce8ef5c6a4e60"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; rose_addr_t, SValuePair &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#ab9596e0e8a6870c7371ce8ef5c6a4e60">SValuePairPerAddress</a></td></tr>
<tr class="separator:ab9596e0e8a6870c7371ce8ef5c6a4e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c2fe021d66511e50b733355422c961" id="r_ae4c2fe021d66511e50b733355422c961"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#ae4c2fe021d66511e50b733355422c961">Analysis</a> ()</td></tr>
<tr class="memdesc:ae4c2fe021d66511e50b733355422c961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae4c2fe021d66511e50b733355422c961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef4b07af4122e188a4eb4fb0ec0dda5" id="r_adef4b07af4122e188a4eb4fb0ec0dda5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#adef4b07af4122e188a4eb4fb0ec0dda5">Analysis</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a> &amp;d)</td></tr>
<tr class="memdesc:adef4b07af4122e188a4eb4fb0ec0dda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an analyzer using a specified disassembler.  <br /></td></tr>
<tr class="separator:adef4b07af4122e188a4eb4fb0ec0dda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c968995c36d8508924f508b37ced3" id="r_a926c968995c36d8508924f508b37ced3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a926c968995c36d8508924f508b37ced3">Analysis</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a9bb90bedfdb964747abdb1da655922ea">cpu</a>)</td></tr>
<tr class="memdesc:a926c968995c36d8508924f508b37ced3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an analysis using a specified dispatcher.  <br /></td></tr>
<tr class="separator:a926c968995c36d8508924f508b37ced3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea3ec17b0400b12e841150f37f7fde2" id="r_a1ea3ec17b0400b12e841150f37f7fde2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a1ea3ec17b0400b12e841150f37f7fde2">analyzeFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html">Partitioner2::DataFlow::InterproceduralPredicate</a> &amp;)</td></tr>
<tr class="memdesc:a1ea3ec17b0400b12e841150f37f7fde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze one function.  <br /></td></tr>
<tr class="separator:a1ea3ec17b0400b12e841150f37f7fde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef93ac3ab37b9dad70e3e610ea377d8" id="r_aaef93ac3ab37b9dad70e3e610ea377d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#aaef93ac3ab37b9dad70e3e610ea377d8">hasResults</a> () const</td></tr>
<tr class="memdesc:aaef93ac3ab37b9dad70e3e610ea377d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a function has been analyzed.  <br /></td></tr>
<tr class="separator:aaef93ac3ab37b9dad70e3e610ea377d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b95ba3a619a985b4cba78d5cd96f98" id="r_af1b95ba3a619a985b4cba78d5cd96f98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#af1b95ba3a619a985b4cba78d5cd96f98">didConverge</a> () const</td></tr>
<tr class="memdesc:af1b95ba3a619a985b4cba78d5cd96f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the analysis results are valid.  <br /></td></tr>
<tr class="separator:af1b95ba3a619a985b4cba78d5cd96f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5d5a6e15483e413a03017c39fc4c4" id="r_ad4a5d5a6e15483e413a03017c39fc4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#ad4a5d5a6e15483e413a03017c39fc4c4">clearResults</a> ()</td></tr>
<tr class="memdesc:ad4a5d5a6e15483e413a03017c39fc4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear analysis results.  <br /></td></tr>
<tr class="separator:ad4a5d5a6e15483e413a03017c39fc4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae20dfe85b86fdac24e798d19d5f6f9" id="r_a9ae20dfe85b86fdac24e798d19d5f6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a9ae20dfe85b86fdac24e798d19d5f6f9">clearStackPointers</a> ()</td></tr>
<tr class="memdesc:a9ae20dfe85b86fdac24e798d19d5f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stack pointers, not deltas.  <br /></td></tr>
<tr class="separator:a9ae20dfe85b86fdac24e798d19d5f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23117ccc7a1c5f86ce869cd43df70ff7" id="r_a23117ccc7a1c5f86ce869cd43df70ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a23117ccc7a1c5f86ce869cd43df70ff7">clearStackDeltas</a> ()</td></tr>
<tr class="memdesc:a23117ccc7a1c5f86ce869cd43df70ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stack deltas, not pointers.  <br /></td></tr>
<tr class="separator:a23117ccc7a1c5f86ce869cd43df70ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb1d10725dac03615040d67419bbad1" id="r_a7eb1d10725dac03615040d67419bbad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a7eb1d10725dac03615040d67419bbad1">clearNonResults</a> ()</td></tr>
<tr class="memdesc:a7eb1d10725dac03615040d67419bbad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears everything but results.  <br /></td></tr>
<tr class="separator:a7eb1d10725dac03615040d67419bbad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38388fb9b1e04e806191fac89ed05eac" id="r_a38388fb9b1e04e806191fac89ed05eac"><td class="memItemLeft" align="right" valign="top">SValuePair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a38388fb9b1e04e806191fac89ed05eac">functionStackPointers</a> () const</td></tr>
<tr class="memdesc:a38388fb9b1e04e806191fac89ed05eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial and final stack pointers for an analyzed function.  <br /></td></tr>
<tr class="separator:a38388fb9b1e04e806191fac89ed05eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e184378dc651e4e089ce9343f487" id="r_a5954e184378dc651e4e089ce9343f487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a5954e184378dc651e4e089ce9343f487">functionStackDelta</a> () const</td></tr>
<tr class="memdesc:a5954e184378dc651e4e089ce9343f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for an analyzed function.  <br /></td></tr>
<tr class="separator:a5954e184378dc651e4e089ce9343f487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aedc20ea48a3d30a1cc51cffe263ee3" id="r_a5aedc20ea48a3d30a1cc51cffe263ee3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a5aedc20ea48a3d30a1cc51cffe263ee3">functionStackDeltaConcrete</a> () const</td></tr>
<tr class="memdesc:a5aedc20ea48a3d30a1cc51cffe263ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete stack delta for an analyzed function.  <br /></td></tr>
<tr class="separator:a5aedc20ea48a3d30a1cc51cffe263ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc61dc2a5834aabf2910cce901c337cb" id="r_acc61dc2a5834aabf2910cce901c337cb"><td class="memItemLeft" align="right" valign="top">SValuePair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#acc61dc2a5834aabf2910cce901c337cb">basicBlockStackPointers</a> (rose_addr_t basicBlockAddress) const</td></tr>
<tr class="memdesc:acc61dc2a5834aabf2910cce901c337cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial and final stack pointers for a basic block.  <br /></td></tr>
<tr class="separator:acc61dc2a5834aabf2910cce901c337cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d666d65ededc32bfb72d512f9b877b6" id="r_a6d666d65ededc32bfb72d512f9b877b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a6d666d65ededc32bfb72d512f9b877b6">basicBlockStackDelta</a> (rose_addr_t basicBlockAddress) const</td></tr>
<tr class="memdesc:a6d666d65ededc32bfb72d512f9b877b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for an analyzed basic block.  <br /></td></tr>
<tr class="separator:a6d666d65ededc32bfb72d512f9b877b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937886253f2dafae3339a3cfb06ddb73" id="r_a937886253f2dafae3339a3cfb06ddb73"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a937886253f2dafae3339a3cfb06ddb73">basicBlockStackDeltaConcrete</a> (rose_addr_t basicBlockAddress) const</td></tr>
<tr class="memdesc:a937886253f2dafae3339a3cfb06ddb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete stack delta for an analyzed basic block.  <br /></td></tr>
<tr class="separator:a937886253f2dafae3339a3cfb06ddb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d0f21b077d4ba41197933b36ef34cd" id="r_a11d0f21b077d4ba41197933b36ef34cd"><td class="memItemLeft" align="right" valign="top">SValuePair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a11d0f21b077d4ba41197933b36ef34cd">instructionStackPointers</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a11d0f21b077d4ba41197933b36ef34cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial and final stack ponters for an analyzed instruction.  <br /></td></tr>
<tr class="separator:a11d0f21b077d4ba41197933b36ef34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b9067edde97e2e47a78976d755592a" id="r_a23b9067edde97e2e47a78976d755592a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a23b9067edde97e2e47a78976d755592a">instructionStackDelta</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a23b9067edde97e2e47a78976d755592a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for an instruction.  <br /></td></tr>
<tr class="separator:a23b9067edde97e2e47a78976d755592a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6e6c4b3f1e12d151b76fe89a7bf13c" id="r_a3d6e6c4b3f1e12d151b76fe89a7bf13c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a3d6e6c4b3f1e12d151b76fe89a7bf13c">instructionStackDeltaConcrete</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a3d6e6c4b3f1e12d151b76fe89a7bf13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete stack delta for an instruction.  <br /></td></tr>
<tr class="separator:a3d6e6c4b3f1e12d151b76fe89a7bf13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f160a33642f01adcd2fb3fdecd72de9" id="r_a4f160a33642f01adcd2fb3fdecd72de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a4f160a33642f01adcd2fb3fdecd72de9">saveAnalysisResults</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *) const</td></tr>
<tr class="memdesc:a4f160a33642f01adcd2fb3fdecd72de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> with analysis results.  <br /></td></tr>
<tr class="separator:a4f160a33642f01adcd2fb3fdecd72de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb90bedfdb964747abdb1da655922ea" id="r_a9bb90bedfdb964747abdb1da655922ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a9bb90bedfdb964747abdb1da655922ea">cpu</a> () const</td></tr>
<tr class="memdesc:a9bb90bedfdb964747abdb1da655922ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual CPU used for analysis.  <br /></td></tr>
<tr class="separator:a9bb90bedfdb964747abdb1da655922ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479faee7b652360e32a5f4915f751d80" id="r_a479faee7b652360e32a5f4915f751d80"><td class="memItemLeft" align="right" valign="top"><a id="a479faee7b652360e32a5f4915f751d80" name="a479faee7b652360e32a5f4915f751d80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a479faee7b652360e32a5f4915f751d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print multi-line value to specified stream. <br /></td></tr>
<tr class="separator:a479faee7b652360e32a5f4915f751d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861fa403899832997c57e23a7586562b" id="r_a861fa403899832997c57e23a7586562b"><td class="memItemLeft" align="right" valign="top"><a id="a861fa403899832997c57e23a7586562b" name="a861fa403899832997c57e23a7586562b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjustInstruction</b> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;spIn, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;spOut, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;delta)</td></tr>
<tr class="separator:a861fa403899832997c57e23a7586562b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2e44dfd2133673ba93b3526da9ced922" id="r_a2e44dfd2133673ba93b3526da9ced922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a2e44dfd2133673ba93b3526da9ced922">initialConcreteStackPointer</a> () const</td></tr>
<tr class="memdesc:a2e44dfd2133673ba93b3526da9ced922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Initial value to use for stack pointers.  <br /></td></tr>
<tr class="separator:a2e44dfd2133673ba93b3526da9ced922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e821815b3a79a4eaaa284410b72bfb2" id="r_a4e821815b3a79a4eaaa284410b72bfb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a4e821815b3a79a4eaaa284410b72bfb2">initialConcreteStackPointer</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a4e821815b3a79a4eaaa284410b72bfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Initial value to use for stack pointers.  <br /></td></tr>
<tr class="separator:a4e821815b3a79a4eaaa284410b72bfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af098237d90e540ad97bcdc3578e99a70" id="r_af098237d90e540ad97bcdc3578e99a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#af098237d90e540ad97bcdc3578e99a70">basicBlockInputStackDeltaWrtFunction</a> (rose_addr_t basicBlockAddress) const</td></tr>
<tr class="memdesc:af098237d90e540ad97bcdc3578e99a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for block w.r.t.  <br /></td></tr>
<tr class="separator:af098237d90e540ad97bcdc3578e99a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a570c9c1d7f91d7215e6871487bfb1f" id="r_a5a570c9c1d7f91d7215e6871487bfb1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a5a570c9c1d7f91d7215e6871487bfb1f">basicBlockOutputStackDeltaWrtFunction</a> (rose_addr_t basicBlockAddress) const</td></tr>
<tr class="memdesc:a5a570c9c1d7f91d7215e6871487bfb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for block w.r.t.  <br /></td></tr>
<tr class="separator:a5a570c9c1d7f91d7215e6871487bfb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a025472a38be1507d2e90e97f88977268" id="r_a025472a38be1507d2e90e97f88977268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a025472a38be1507d2e90e97f88977268">instructionInputStackDeltaWrtFunction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a025472a38be1507d2e90e97f88977268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for instruction w.r.t.  <br /></td></tr>
<tr class="separator:a025472a38be1507d2e90e97f88977268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798accaa2609260b35e04ad133f82352" id="r_a798accaa2609260b35e04ad133f82352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a798accaa2609260b35e04ad133f82352">instructionOutputStackDeltaWrtFunction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a798accaa2609260b35e04ad133f82352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta for instruction w.r.t.  <br /></td></tr>
<tr class="separator:a798accaa2609260b35e04ad133f82352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4fb8a4ce0683159379d19468a33fb614" id="r_a4fb8a4ce0683159379d19468a33fb614"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a4fb8a4ce0683159379d19468a33fb614">clearAstStackDeltas</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>
<tr class="memdesc:a4fb8a4ce0683159379d19468a33fb614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> stack deltas.  <br /></td></tr>
<tr class="separator:a4fb8a4ce0683159379d19468a33fb614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822dcf3927c575ffa7527dcc7989eb96" id="r_a822dcf3927c575ffa7527dcc7989eb96"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a822dcf3927c575ffa7527dcc7989eb96">toInt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;)</td></tr>
<tr class="memdesc:a822dcf3927c575ffa7527dcc7989eb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a symbolic value to an integer.  <br /></td></tr>
<tr class="separator:a822dcf3927c575ffa7527dcc7989eb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a82c36e90f59af4d164106220cb54188b" name="a82c36e90f59af4d164106220cb54188b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c36e90f59af4d164106220cb54188b">&#9670;&#160;</a></span>DeltasPerAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;rose_addr_t, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&gt; <a class="el" href="classSawyer_1_1Container_1_1Map.html">Rose::BinaryAnalysis::StackDelta::Analysis::DeltasPerAddress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00057">57</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a83fad00b701ddee683e707ba2130bcfd" name="a83fad00b701ddee683e707ba2130bcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fad00b701ddee683e707ba2130bcfd">&#9670;&#160;</a></span>SValuePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&gt; Rose::BinaryAnalysis::StackDelta::Analysis::SValuePair</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00059">59</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="ab9596e0e8a6870c7371ce8ef5c6a4e60" name="ab9596e0e8a6870c7371ce8ef5c6a4e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9596e0e8a6870c7371ce8ef5c6a4e60">&#9670;&#160;</a></span>SValuePairPerAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;rose_addr_t, SValuePair&gt; <a class="el" href="classSawyer_1_1Container_1_1Map.html">Rose::BinaryAnalysis::StackDelta::Analysis::SValuePairPerAddress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00060">60</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c2fe021d66511e50b733355422c961" name="ae4c2fe021d66511e50b733355422c961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c2fe021d66511e50b733355422c961">&#9670;&#160;</a></span>Analysis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::StackDelta::Analysis::Analysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an analyzer that is not suitable for analysis since it doesn't know anything about the architecture it would be analyzing. This is mostly for use in situations where an analyzer must be constructed as a member of another class's default constructor, in containers that initialize their contents with a default constructor, etc. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00134">134</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="adef4b07af4122e188a4eb4fb0ec0dda5" name="adef4b07af4122e188a4eb4fb0ec0dda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef4b07af4122e188a4eb4fb0ec0dda5">&#9670;&#160;</a></span>Analysis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::StackDelta::Analysis::Analysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an analyzer using a specified disassembler. </p>
<p>This constructor chooses a symbolic domain and a dispatcher appropriate for the disassembler's architecture. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00140">140</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a926c968995c36d8508924f508b37ced3" name="a926c968995c36d8508924f508b37ced3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926c968995c36d8508924f508b37ced3">&#9670;&#160;</a></span>Analysis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::StackDelta::Analysis::Analysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an analysis using a specified dispatcher. </p>
<p>This constructor uses the supplied dispatcher and associated semantic domain. For best results, the semantic domain should be a symbolic domain that uses <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RegisterStateGeneric.html">RegisterStateGeneric</a>. The memory state can be the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics.html">InstructionSemantics::NullSemantics</a> memory state to speed up dataflow converging when the stack pointer is known to not be saved/restored (which is usually the case), and is what the analysis uses when no state is specified. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00152">152</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e44dfd2133673ba93b3526da9ced922" name="a2e44dfd2133673ba93b3526da9ced922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e44dfd2133673ba93b3526da9ced922">&#9670;&#160;</a></span>initialConcreteStackPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::StackDelta::Analysis::initialConcreteStackPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Initial value to use for stack pointers. </p>
<p>A concrete value can be specified for the initial stack pointer, in which case many arithmetic operations on the stack pointer are constant folded, which leads to more data-flow solutions. The default is to not initialize the stack pointer at the start of the analysis. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00162">162</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a4e821815b3a79a4eaaa284410b72bfb2" name="a4e821815b3a79a4eaaa284410b72bfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e821815b3a79a4eaaa284410b72bfb2">&#9670;&#160;</a></span>initialConcreteStackPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::initialConcreteStackPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Initial value to use for stack pointers. </p>
<p>A concrete value can be specified for the initial stack pointer, in which case many arithmetic operations on the stack pointer are constant folded, which leads to more data-flow solutions. The default is to not initialize the stack pointer at the start of the analysis. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00163">163</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a1ea3ec17b0400b12e841150f37f7fde2" name="a1ea3ec17b0400b12e841150f37f7fde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea3ec17b0400b12e841150f37f7fde2">&#9670;&#160;</a></span>analyzeFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::analyzeFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow_1_1InterproceduralPredicate.html">Partitioner2::DataFlow::InterproceduralPredicate</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze one function. </p>
<p>This analysis method uses <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a> data structures which are generally faster than using the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. The specified function need not be attached to the partitioner. Results of the analysis are stored in this analysis object to be queried after the analysis completes. </p>

</div>
</div>
<a id="aaef93ac3ab37b9dad70e3e610ea377d8" name="aaef93ac3ab37b9dad70e3e610ea377d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef93ac3ab37b9dad70e3e610ea377d8">&#9670;&#160;</a></span>hasResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::StackDelta::Analysis::hasResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a function has been analyzed. </p>
<p>Returns true if this analysis object holds results from analyzing a function. The results might be only approximations depending on whether <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#af1b95ba3a619a985b4cba78d5cd96f98">didConverge</a> also returns true. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00179">179</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="af1b95ba3a619a985b4cba78d5cd96f98" name="af1b95ba3a619a985b4cba78d5cd96f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b95ba3a619a985b4cba78d5cd96f98">&#9670;&#160;</a></span>didConverge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::StackDelta::Analysis::didConverge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the analysis results are valid. </p>
<p>Returns true if <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#aaef93ac3ab37b9dad70e3e610ea377d8">hasResults</a> is true and the analysis converged to a solution. If the analysis did not converge then the other results are only approximations. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00185">185</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="ad4a5d5a6e15483e413a03017c39fc4c4" name="ad4a5d5a6e15483e413a03017c39fc4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a5d5a6e15483e413a03017c39fc4c4">&#9670;&#160;</a></span>clearResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::clearResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear analysis results. </p>
<p>Resets the analysis results so it looks like this analyzer is initialized but has not run yet. When this method returns, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#aaef93ac3ab37b9dad70e3e610ea377d8">hasResults</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#af1b95ba3a619a985b4cba78d5cd96f98">didConverge</a> will both return false. </p>

</div>
</div>
<a id="a9ae20dfe85b86fdac24e798d19d5f6f9" name="a9ae20dfe85b86fdac24e798d19d5f6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae20dfe85b86fdac24e798d19d5f6f9">&#9670;&#160;</a></span>clearStackPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::clearStackPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear stack pointers, not deltas. </p>
<p>Clears the stack pointer results but not the stack deltas. </p>

</div>
</div>
<a id="a23117ccc7a1c5f86ce869cd43df70ff7" name="a23117ccc7a1c5f86ce869cd43df70ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23117ccc7a1c5f86ce869cd43df70ff7">&#9670;&#160;</a></span>clearStackDeltas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::clearStackDeltas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear stack deltas, not pointers. </p>
<p>Clears the stack delta results but not the stack pointers. </p>

</div>
</div>
<a id="a7eb1d10725dac03615040d67419bbad1" name="a7eb1d10725dac03615040d67419bbad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb1d10725dac03615040d67419bbad1">&#9670;&#160;</a></span>clearNonResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::clearNonResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears everything but results. </p>
<p>This resets the virtual CPU to the null pointer, possibly freeing some memory if the CPU isn't being used for other things. Once the CPU is removed it's no longer possible to do more analysis. </p>

</div>
</div>
<a id="a38388fb9b1e04e806191fac89ed05eac" name="a38388fb9b1e04e806191fac89ed05eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38388fb9b1e04e806191fac89ed05eac">&#9670;&#160;</a></span>functionStackPointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SValuePair Rose::BinaryAnalysis::StackDelta::Analysis::functionStackPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial and final stack pointers for an analyzed function. </p>
<p>These are the initial and final stack pointers for the function as determined by the data-flow analysis. Returns null pointers if the data-flow did not reach the initial and/or final vertices of the function's control flow graph. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00213">213</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a5954e184378dc651e4e089ce9343f487" name="a5954e184378dc651e4e089ce9343f487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5954e184378dc651e4e089ce9343f487">&#9670;&#160;</a></span>functionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::functionStackDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack delta for an analyzed function. </p>
<p>Returns the net effect that an analyzed function has on the stack pointer. If the data-flow did not complete then returns a null pointer. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a5aedc20ea48a3d30a1cc51cffe263ee3">functionStackDeltaConcrete</a>. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00219">219</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a5aedc20ea48a3d30a1cc51cffe263ee3" name="a5aedc20ea48a3d30a1cc51cffe263ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aedc20ea48a3d30a1cc51cffe263ee3">&#9670;&#160;</a></span>functionStackDeltaConcrete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Rose::BinaryAnalysis::StackDelta::Analysis::functionStackDeltaConcrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concrete stack delta for an analyzed function. </p>
<p>Returns a concrete stack delta for a function if known, otherwise the <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a> constant is returned. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a5954e184378dc651e4e089ce9343f487">functionStackDelta</a>. </p>

</div>
</div>
<a id="acc61dc2a5834aabf2910cce901c337cb" name="acc61dc2a5834aabf2910cce901c337cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc61dc2a5834aabf2910cce901c337cb">&#9670;&#160;</a></span>basicBlockStackPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SValuePair Rose::BinaryAnalysis::StackDelta::Analysis::basicBlockStackPointers </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>basicBlockAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial and final stack pointers for a basic block. </p>
<p>Returns the incoming and outgoing stack pointers for each basic block as determined by a data-flow analysis. If the data-flow did not reach the beginning and/or end of the basic block then null pointers are returned. </p>

</div>
</div>
<a id="a6d666d65ededc32bfb72d512f9b877b6" name="a6d666d65ededc32bfb72d512f9b877b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d666d65ededc32bfb72d512f9b877b6">&#9670;&#160;</a></span>basicBlockStackDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::basicBlockStackDelta </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>basicBlockAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for an analyzed basic block. </p>
<p>Returns the net effect that an analyzed basic block has on the stack pointer. If the data-flow did not reach this basic block then returns a null pointer. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a937886253f2dafae3339a3cfb06ddb73">basicBlockStackDeltaConcrete</a>. </p>

</div>
</div>
<a id="af098237d90e540ad97bcdc3578e99a70" name="af098237d90e540ad97bcdc3578e99a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af098237d90e540ad97bcdc3578e99a70">&#9670;&#160;</a></span>basicBlockInputStackDeltaWrtFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::basicBlockInputStackDeltaWrtFunction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>basicBlockAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for block w.r.t. </p>
<p>function.</p>
<p>Returns the incoming or outgoing stack delta for a basic block with respect to the beginning of the function. Returns a null pointer if the data-flow did not reach the beginning or end of this block. </p>

</div>
</div>
<a id="a5a570c9c1d7f91d7215e6871487bfb1f" name="a5a570c9c1d7f91d7215e6871487bfb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a570c9c1d7f91d7215e6871487bfb1f">&#9670;&#160;</a></span>basicBlockOutputStackDeltaWrtFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::basicBlockOutputStackDeltaWrtFunction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>basicBlockAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for block w.r.t. </p>
<p>function.</p>
<p>Returns the incoming or outgoing stack delta for a basic block with respect to the beginning of the function. Returns a null pointer if the data-flow did not reach the beginning or end of this block. </p>

</div>
</div>
<a id="a937886253f2dafae3339a3cfb06ddb73" name="a937886253f2dafae3339a3cfb06ddb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937886253f2dafae3339a3cfb06ddb73">&#9670;&#160;</a></span>basicBlockStackDeltaConcrete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Rose::BinaryAnalysis::StackDelta::Analysis::basicBlockStackDeltaConcrete </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>basicBlockAddress</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concrete stack delta for an analyzed basic block. </p>
<p>Returns the concrete stack delta for a basic block if known, otherwise returns the <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a> constant. </p>

</div>
</div>
<a id="a11d0f21b077d4ba41197933b36ef34cd" name="a11d0f21b077d4ba41197933b36ef34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d0f21b077d4ba41197933b36ef34cd">&#9670;&#160;</a></span>instructionStackPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SValuePair Rose::BinaryAnalysis::StackDelta::Analysis::instructionStackPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial and final stack ponters for an analyzed instruction. </p>
<p>These are the initial and final stack pointers for the instruction as determined by data-flow analysis. Returns null pointers if the data-flow did not reach the beginning and/or end of the instruction. </p>

</div>
</div>
<a id="a23b9067edde97e2e47a78976d755592a" name="a23b9067edde97e2e47a78976d755592a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b9067edde97e2e47a78976d755592a">&#9670;&#160;</a></span>instructionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::instructionStackDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for an instruction. </p>
<p>Returns the stack delta for a single instruction if known, otherwise a null pointer. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a3d6e6c4b3f1e12d151b76fe89a7bf13c">instructionStackDeltaConcrete</a>. The stack delta for an instruction is the difference between the stack pointer after the instruction executes and the stack pointer before the instruction executes. </p>

</div>
</div>
<a id="a025472a38be1507d2e90e97f88977268" name="a025472a38be1507d2e90e97f88977268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025472a38be1507d2e90e97f88977268">&#9670;&#160;</a></span>instructionInputStackDeltaWrtFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::instructionInputStackDeltaWrtFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for instruction w.r.t. </p>
<p>function.</p>
<p>Returns the incoming or outgoing stack delta for an instruction with respect to the beginning of the function. Returns a null pointer if the data-flow did not reach the beginning or end of the instruction. </p>

</div>
</div>
<a id="a798accaa2609260b35e04ad133f82352" name="a798accaa2609260b35e04ad133f82352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798accaa2609260b35e04ad133f82352">&#9670;&#160;</a></span>instructionOutputStackDeltaWrtFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::instructionOutputStackDeltaWrtFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta for instruction w.r.t. </p>
<p>function.</p>
<p>Returns the incoming or outgoing stack delta for an instruction with respect to the beginning of the function. Returns a null pointer if the data-flow did not reach the beginning or end of the instruction. </p>

</div>
</div>
<a id="a3d6e6c4b3f1e12d151b76fe89a7bf13c" name="a3d6e6c4b3f1e12d151b76fe89a7bf13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6e6c4b3f1e12d151b76fe89a7bf13c">&#9670;&#160;</a></span>instructionStackDeltaConcrete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Rose::BinaryAnalysis::StackDelta::Analysis::instructionStackDeltaConcrete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concrete stack delta for an instruction. </p>
<p>Returns the concrete stack delta for an instruction if known, otherwise returns the <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a> constants. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html#a23b9067edde97e2e47a78976d755592a">instructionStackDelta</a>. </p>

</div>
</div>
<a id="a4f160a33642f01adcd2fb3fdecd72de9" name="a4f160a33642f01adcd2fb3fdecd72de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f160a33642f01adcd2fb3fdecd72de9">&#9670;&#160;</a></span>saveAnalysisResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::StackDelta::Analysis::saveAnalysisResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> with analysis results. </p>
<p>The analysis results are copied into the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, Instructions in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> that belong to the function but were not present during the analysis have their stack deltas set to <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a>. Only the specified function, its basic blocks, and their instructions are affected. </p>

</div>
</div>
<a id="a4fb8a4ce0683159379d19468a33fb614" name="a4fb8a4ce0683159379d19468a33fb614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb8a4ce0683159379d19468a33fb614">&#9670;&#160;</a></span>clearAstStackDeltas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::StackDelta::Analysis::clearAstStackDeltas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> stack deltas. </p>
<p>Clear all stack deltas stored in the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> by setting them to <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a>. </p>

</div>
</div>
<a id="a9bb90bedfdb964747abdb1da655922ea" name="a9bb90bedfdb964747abdb1da655922ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb90bedfdb964747abdb1da655922ea">&#9670;&#160;</a></span>cpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> Rose::BinaryAnalysis::StackDelta::Analysis::cpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual CPU used for analysis. </p>
<p>Returns the dispatcher set by the constructor or the latest analysis. If no dispatcher is set in the constructor then the analysis itself may set one. </p>

<p class="definition">Definition at line <a class="el" href="StackDelta_8h_source.html#l00300">300</a> of file <a class="el" href="StackDelta_8h_source.html">StackDelta.h</a>.</p>

</div>
</div>
<a id="a822dcf3927c575ffa7527dcc7989eb96" name="a822dcf3927c575ffa7527dcc7989eb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822dcf3927c575ffa7527dcc7989eb96">&#9670;&#160;</a></span>toInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t Rose::BinaryAnalysis::StackDelta::Analysis::toInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a symbolic value to an integer. </p>
<p>Converts the specified symbolic value to a 64-bit signed stack delta. If the symbolic value is a null pointer or is not an integer, or is wider than 64 bits, then the <a class="el" href="classSgAsmInstruction.html#a6fb91f8c348c2912b78a55ee6b8d4a39">SgAsmInstruction::INVALID_STACK_DELTA</a> constant is returned. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="StackDelta_8h_source.html">StackDelta.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
