<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: OmpSupport Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">OmpSupport Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Types and functions to support OpenMP. </p>
<p>OpenMP specific data types and functions are put into this namespace</p>
<p>Translation (directive lowering) support for OpenMP 3.0 C/C++</p>
<p>Like other OpenMP related work within ROSE, all things go to the <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace to avoid conflicts Liao, 8/10/2009 </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One attribute object stores all information within an OpenMP pragma (directive and clauses)  <a href="classOmpSupport_1_1OmpAttribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1OmpAttributeList.html">OmpAttributeList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1SgVarRefExpVisitor.html">SgVarRefExpVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1translationDriver.html">translationDriver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A driver to traverse AST trees and invoke individual translators for OpenMP constructs, (not in use) Postorder is preferred.  <a href="classOmpSupport_1_1translationDriver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a517aeb9b0b29041f7d14636b9b643afb" id="r_a517aeb9b0b29041f7d14636b9b643afb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a517aeb9b0b29041f7d14636b9b643afb">VariableSymbolMap_t</a></td></tr>
<tr class="separator:a517aeb9b0b29041f7d14636b9b643afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9407f163895e6aef1aaac5155fb25ac9" id="r_a9407f163895e6aef1aaac5155fb25ac9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>omp_construct_enum</b> { <br />
&#160;&#160;<b>e_unknown</b> = 0
, <br />
&#160;&#160;<b>e_parallel</b>
, <br />
&#160;&#160;<b>e_for</b>
, <br />
&#160;&#160;<b>e_for_simd</b>
, <br />
&#160;&#160;<b>e_do</b>
, <br />
&#160;&#160;<b>e_workshare</b>
, <br />
&#160;&#160;<b>e_sections</b>
, <br />
&#160;&#160;<b>e_section</b>
, <br />
&#160;&#160;<b>e_single</b>
, <br />
&#160;&#160;<b>e_master</b>
, <br />
&#160;&#160;<b>e_critical</b>
, <br />
&#160;&#160;<b>e_barrier</b>
, <br />
&#160;&#160;<b>e_atomic</b>
, <br />
&#160;&#160;<b>e_flush</b>
, <br />
&#160;&#160;<b>e_target</b>
, <br />
&#160;&#160;<b>e_target_declare</b>
, <br />
&#160;&#160;<b>e_target_data</b>
, <br />
&#160;&#160;<b>e_target_update</b>
, <br />
&#160;&#160;<b>e_map</b>
, <br />
&#160;&#160;<b>e_device</b>
, <br />
&#160;&#160;<b>e_begin</b>
, <br />
&#160;&#160;<b>e_end</b>
, <br />
&#160;&#160;<b>e_threadprivate</b>
, <br />
&#160;&#160;<b>e_parallel_for</b>
, <br />
&#160;&#160;<b>e_parallel_for_simd</b>
, <br />
&#160;&#160;<b>e_parallel_do</b>
, <br />
&#160;&#160;<b>e_parallel_sections</b>
, <br />
&#160;&#160;<b>e_parallel_workshare</b>
, <br />
&#160;&#160;<b>e_task</b>
, <br />
&#160;&#160;<b>e_taskwait</b>
, <br />
&#160;&#160;<b>e_ordered_directive</b>
, <br />
&#160;&#160;<b>e_end_critical</b>
, <br />
&#160;&#160;<b>e_end_do</b>
, <br />
&#160;&#160;<b>e_end_master</b>
, <br />
&#160;&#160;<b>e_end_ordered</b>
, <br />
&#160;&#160;<b>e_end_parallel_do</b>
, <br />
&#160;&#160;<b>e_end_parallel_sections</b>
, <br />
&#160;&#160;<b>e_end_parallel_workshare</b>
, <br />
&#160;&#160;<b>e_end_parallel</b>
, <br />
&#160;&#160;<b>e_end_sections</b>
, <br />
&#160;&#160;<b>e_end_single</b>
, <br />
&#160;&#160;<b>e_end_task</b>
, <br />
&#160;&#160;<b>e_end_workshare</b>
, <br />
&#160;&#160;<b>e_default</b>
, <br />
&#160;&#160;<b>e_shared</b>
, <br />
&#160;&#160;<b>e_private</b>
, <br />
&#160;&#160;<b>e_firstprivate</b>
, <br />
&#160;&#160;<b>e_lastprivate</b>
, <br />
&#160;&#160;<b>e_copyin</b>
, <br />
&#160;&#160;<b>e_copyprivate</b>
, <br />
&#160;&#160;<b>e_proc_bind</b>
, <br />
&#160;&#160;<b>e_if</b>
, <br />
&#160;&#160;<b>e_num_threads</b>
, <br />
&#160;&#160;<b>e_nowait</b>
, <br />
&#160;&#160;<b>e_ordered_clause</b>
, <br />
&#160;&#160;<b>e_reduction</b>
, <br />
&#160;&#160;<b>e_schedule</b>
, <br />
&#160;&#160;<b>e_collapse</b>
, <br />
&#160;&#160;<b>e_untied</b>
, <br />
&#160;&#160;<b>e_mergeable</b>
, <br />
&#160;&#160;<b>e_final</b>
, <br />
&#160;&#160;<b>e_priority</b>
, <br />
&#160;&#160;<b>e_atomic_clause</b>
, <br />
&#160;&#160;<b>e_inbranch</b>
, <br />
&#160;&#160;<b>e_notinbranch</b>
, <br />
&#160;&#160;<b>e_depend</b>
, <br />
&#160;&#160;<b>e_default_none</b>
, <br />
&#160;&#160;<b>e_default_shared</b>
, <br />
&#160;&#160;<b>e_default_private</b>
, <br />
&#160;&#160;<b>e_default_firstprivate</b>
, <br />
&#160;&#160;<b>e_proc_bind_master</b>
, <br />
&#160;&#160;<b>e_proc_bind_close</b>
, <br />
&#160;&#160;<b>e_proc_bind_spread</b>
, <br />
&#160;&#160;<b>e_atomic_read</b>
, <br />
&#160;&#160;<b>e_atomic_write</b>
, <br />
&#160;&#160;<b>e_atomic_update</b>
, <br />
&#160;&#160;<b>e_atomic_capture</b>
, <br />
&#160;&#160;<b>e_reduction_plus</b>
, <br />
&#160;&#160;<b>e_reduction_mul</b>
, <br />
&#160;&#160;<b>e_reduction_minus</b>
, <br />
&#160;&#160;<b>e_reduction_bitand</b>
, <br />
&#160;&#160;<b>e_reduction_bitor</b>
, <br />
&#160;&#160;<b>e_reduction_bitxor</b>
, <br />
&#160;&#160;<b>e_reduction_logand</b>
, <br />
&#160;&#160;<b>e_reduction_logor</b>
, <br />
&#160;&#160;<b>e_reduction_and</b>
, <br />
&#160;&#160;<b>e_reduction_or</b>
, <br />
&#160;&#160;<b>e_reduction_eqv</b>
, <br />
&#160;&#160;<b>e_reduction_neqv</b>
, <br />
&#160;&#160;<b>e_reduction_max</b>
, <br />
&#160;&#160;<b>e_reduction_min</b>
, <br />
&#160;&#160;<b>e_reduction_iand</b>
, <br />
&#160;&#160;<b>e_reduction_ior</b>
, <br />
&#160;&#160;<b>e_reduction_ieor</b>
, <br />
&#160;&#160;<b>e_schedule_none</b>
, <br />
&#160;&#160;<b>e_schedule_static</b>
, <br />
&#160;&#160;<b>e_schedule_dynamic</b>
, <br />
&#160;&#160;<b>e_schedule_guided</b>
, <br />
&#160;&#160;<b>e_schedule_auto</b>
, <br />
&#160;&#160;<b>e_schedule_runtime</b>
, <br />
&#160;&#160;<b>e_map_alloc</b>
, <br />
&#160;&#160;<b>e_map_to</b>
, <br />
&#160;&#160;<b>e_map_from</b>
, <br />
&#160;&#160;<b>e_map_tofrom</b>
, <br />
&#160;&#160;<b>e_dist_data</b>
, <br />
&#160;&#160;<b>e_duplicate</b>
, <br />
&#160;&#160;<b>e_block</b>
, <br />
&#160;&#160;<b>e_cyclic</b>
, <br />
&#160;&#160;<b>e_simd</b>
, <br />
&#160;&#160;<b>e_declare_simd</b>
, <br />
&#160;&#160;<b>e_safelen</b>
, <br />
&#160;&#160;<b>e_simdlen</b>
, <br />
&#160;&#160;<b>e_uniform</b>
, <br />
&#160;&#160;<b>e_aligned</b>
, <br />
&#160;&#160;<b>e_linear</b>
, <br />
&#160;&#160;<b>e_depend_in</b>
, <br />
&#160;&#160;<b>e_depend_out</b>
, <br />
&#160;&#160;<b>e_depend_inout</b>
, <br />
&#160;&#160;<b>e_not_omp</b>
<br />
 }</td></tr>
<tr class="separator:a9407f163895e6aef1aaac5155fb25ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc7f08fd77ecfd382fe54fd641dc10" id="r_abffc7f08fd77ecfd382fe54fd641dc10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">omp_rtl_enum</a> { <br />
&#160;&#160;<b>e_gomp</b>
, <br />
&#160;&#160;<b>e_omni</b>
, <br />
&#160;&#160;<b>e_last_rtl</b>
<br />
 }</td></tr>
<tr class="memdesc:abffc7f08fd77ecfd382fe54fd641dc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of target runtime libraries (not yet in use)  <a href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">More...</a><br /></td></tr>
<tr class="separator:abffc7f08fd77ecfd382fe54fd641dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af61ca3e72cc3ce57c0a429fa3bb4a8fd" id="r_af61ca3e72cc3ce57c0a429fa3bb4a8fd"><td class="memItemLeft" align="right" valign="top"><a id="af61ca3e72cc3ce57c0a429fa3bb4a8fd" name="af61ca3e72cc3ce57c0a429fa3bb4a8fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>processOpenMP</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *sageFilePtr)</td></tr>
<tr class="separator:af61ca3e72cc3ce57c0a429fa3bb4a8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e4359fa76afb6e296b55180d4b3f82" id="r_a25e4359fa76afb6e296b55180d4b3f82"><td class="memItemLeft" align="right" valign="top"><a id="a25e4359fa76afb6e296b55180d4b3f82" name="a25e4359fa76afb6e296b55180d4b3f82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>postParsingProcessing</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *sageFilePtr)</td></tr>
<tr class="separator:a25e4359fa76afb6e296b55180d4b3f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd54e60feb0dcc01a470ef9bf0b514e1" id="r_abd54e60feb0dcc01a470ef9bf0b514e1"><td class="memItemLeft" align="right" valign="top"><a id="abd54e60feb0dcc01a470ef9bf0b514e1" name="abd54e60feb0dcc01a470ef9bf0b514e1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:abd54e60feb0dcc01a470ef9bf0b514e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output omp_construct_enum to a string: <br /></td></tr>
<tr class="separator:abd54e60feb0dcc01a470ef9bf0b514e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0de366aa8cc20c9055fd8878c357b" id="r_aebf0de366aa8cc20c9055fd8878c357b"><td class="memItemLeft" align="right" valign="top"><a id="aebf0de366aa8cc20c9055fd8878c357b" name="aebf0de366aa8cc20c9055fd8878c357b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFortranEndDirective</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:aebf0de366aa8cc20c9055fd8878c357b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the construct is a Fortran END ... directive. <br /></td></tr>
<tr class="separator:aebf0de366aa8cc20c9055fd8878c357b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911371ad3052111b489a9e727d83cbe0" id="r_a911371ad3052111b489a9e727d83cbe0"><td class="memItemLeft" align="right" valign="top"><a id="a911371ad3052111b489a9e727d83cbe0" name="a911371ad3052111b489a9e727d83cbe0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFortranBeginDirective</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a911371ad3052111b489a9e727d83cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the construct is a Fortran directive which can (optionally) have a corresponding END directive. <br /></td></tr>
<tr class="separator:a911371ad3052111b489a9e727d83cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a3e721998855c128409cca54c023f" id="r_a122a3e721998855c128409cca54c023f"><td class="memItemLeft" align="right" valign="top"><a id="a122a3e721998855c128409cca54c023f" name="a122a3e721998855c128409cca54c023f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDirective</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a122a3e721998855c128409cca54c023f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a directive. <br /></td></tr>
<tr class="separator:a122a3e721998855c128409cca54c023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9c316424f6f34cd6ba79344217fee7" id="r_a1e9c316424f6f34cd6ba79344217fee7"><td class="memItemLeft" align="right" valign="top"><a id="a1e9c316424f6f34cd6ba79344217fee7" name="a1e9c316424f6f34cd6ba79344217fee7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDirectiveWithBody</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:a1e9c316424f6f34cd6ba79344217fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP directive has a structured body. <br /></td></tr>
<tr class="separator:a1e9c316424f6f34cd6ba79344217fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5216695c28a37e6d3af469aeadb41" id="r_afca5216695c28a37e6d3af469aeadb41"><td class="memItemLeft" align="right" valign="top"><a id="afca5216695c28a37e6d3af469aeadb41" name="afca5216695c28a37e6d3af469aeadb41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isClause</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:afca5216695c28a37e6d3af469aeadb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a clause. <br /></td></tr>
<tr class="separator:afca5216695c28a37e6d3af469aeadb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d2faaeee9244a3d3d6bc3c5eddc3fc" id="r_ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="memItemLeft" align="right" valign="top"><a id="ad6d2faaeee9244a3d3d6bc3c5eddc3fc" name="ad6d2faaeee9244a3d3d6bc3c5eddc3fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReductionOperator</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a reduction operator. <br /></td></tr>
<tr class="separator:ad6d2faaeee9244a3d3d6bc3c5eddc3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad910f83affb025c0efc9cc2536dfb81" id="r_aad910f83affb025c0efc9cc2536dfb81"><td class="memItemLeft" align="right" valign="top"><a id="aad910f83affb025c0efc9cc2536dfb81" name="aad910f83affb025c0efc9cc2536dfb81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDependenceType</b> (omp_construct_enum omp_type)</td></tr>
<tr class="memdesc:aad910f83affb025c0efc9cc2536dfb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP construct is a dependence type for omp task depend. <br /></td></tr>
<tr class="separator:aad910f83affb025c0efc9cc2536dfb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2dc3d90879693e6e3a6fa1decbf975" id="r_acd2dc3d90879693e6e3a6fa1decbf975"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API <a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#acd2dc3d90879693e6e3a6fa1decbf975">buildOmpAttribute</a> (enum omp_construct_enum directive_type, <a class="el" href="classSgNode.html">SgNode</a> *context_node, bool useDefined)</td></tr>
<tr class="memdesc:acd2dc3d90879693e6e3a6fa1decbf975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some utility functions to manipulate <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a>.  <br /></td></tr>
<tr class="separator:acd2dc3d90879693e6e3a6fa1decbf975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d6a42c522d2fb52a6f02f7e34a8d8" id="r_a9c5d6a42c522d2fb52a6f02f7e34a8d8"><td class="memItemLeft" align="right" valign="top"><a id="a9c5d6a42c522d2fb52a6f02f7e34a8d8" name="a9c5d6a42c522d2fb52a6f02f7e34a8d8"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>addOmpAttribute</b> (<a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *ompattribute, <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a9c5d6a42c522d2fb52a6f02f7e34a8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> to a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>. <br /></td></tr>
<tr class="separator:a9c5d6a42c522d2fb52a6f02f7e34a8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535831afa8fb3526d7af82e6f21f7921" id="r_a535831afa8fb3526d7af82e6f21f7921"><td class="memItemLeft" align="right" valign="top"><a id="a535831afa8fb3526d7af82e6f21f7921" name="a535831afa8fb3526d7af82e6f21f7921"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>removeOmpAttribute</b> (<a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *ompattribute, <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a535831afa8fb3526d7af82e6f21f7921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> from a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>. <br /></td></tr>
<tr class="separator:a535831afa8fb3526d7af82e6f21f7921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb12d15e4675067c07064c6e49d9f58e" id="r_acb12d15e4675067c07064c6e49d9f58e"><td class="memItemLeft" align="right" valign="top"><a id="acb12d15e4675067c07064c6e49d9f58e" name="acb12d15e4675067c07064c6e49d9f58e"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEquivalentOmpAttribute</b> (<a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *a1, <a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *a2)</td></tr>
<tr class="memdesc:acb12d15e4675067c07064c6e49d9f58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two OmpAttributes are semantically equivalent to each other. <br /></td></tr>
<tr class="separator:acb12d15e4675067c07064c6e49d9f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eb061c691a3e758b4c619dcc225910" id="r_ae3eb061c691a3e758b4c619dcc225910"><td class="memItemLeft" align="right" valign="top"><a id="ae3eb061c691a3e758b4c619dcc225910" name="ae3eb061c691a3e758b4c619dcc225910"></a>
ROSE_DLL_API <a class="el" href="classOmpSupport_1_1OmpAttributeList.html">OmpAttributeList</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getOmpAttributeList</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ae3eb061c691a3e758b4c619dcc225910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> from a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>, return NULL if not found. <br /></td></tr>
<tr class="separator:ae3eb061c691a3e758b4c619dcc225910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27087717b90c874ead82c6cef2d5af7c" id="r_a27087717b90c874ead82c6cef2d5af7c"><td class="memItemLeft" align="right" valign="top"><a id="a27087717b90c874ead82c6cef2d5af7c" name="a27087717b90c874ead82c6cef2d5af7c"></a>
<a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getOmpAttribute</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a27087717b90c874ead82c6cef2d5af7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> from a <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>, return NULL if not found. <br /></td></tr>
<tr class="separator:a27087717b90c874ead82c6cef2d5af7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692df25655b27a76b3ceab034fdba996" id="r_a692df25655b27a76b3ceab034fdba996"><td class="memItemLeft" align="right" valign="top"><a id="a692df25655b27a76b3ceab034fdba996" name="a692df25655b27a76b3ceab034fdba996"></a>
omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>getOmpConstructEnum</b> (<a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *decl)</td></tr>
<tr class="memdesc:a692df25655b27a76b3ceab034fdba996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get omp enum from an OpenMP pragma attached with <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a>. <br /></td></tr>
<tr class="separator:a692df25655b27a76b3ceab034fdba996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b65048d08aaa335bb5ea9857dc0690f" id="r_a7b65048d08aaa335bb5ea9857dc0690f"><td class="memItemLeft" align="right" valign="top"><a id="a7b65048d08aaa335bb5ea9857dc0690f" name="a7b65048d08aaa335bb5ea9857dc0690f"></a>
omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>getBeginOmpConstructEnum</b> (omp_construct_enum end_enum)</td></tr>
<tr class="memdesc:a7b65048d08aaa335bb5ea9857dc0690f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding begin construct enum from an end construct enum. <br /></td></tr>
<tr class="separator:a7b65048d08aaa335bb5ea9857dc0690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf03860e846b87b282b05164d75f614" id="r_afdf03860e846b87b282b05164d75f614"><td class="memItemLeft" align="right" valign="top"><a id="afdf03860e846b87b282b05164d75f614" name="afdf03860e846b87b282b05164d75f614"></a>
omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>getEndOmpConstructEnum</b> (omp_construct_enum begin_enum)</td></tr>
<tr class="memdesc:afdf03860e846b87b282b05164d75f614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding end construct enum from a begin construct enum. <br /></td></tr>
<tr class="separator:afdf03860e846b87b282b05164d75f614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe5f0cf52e5423628ec47ac0f6e8635" id="r_aabe5f0cf52e5423628ec47ac0f6e8635"><td class="memItemLeft" align="right" valign="top"><a id="aabe5f0cf52e5423628ec47ac0f6e8635" name="aabe5f0cf52e5423628ec47ac0f6e8635"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>generatePragmaFromOmpAttribute</b> (<a class="el" href="classSgNode.html">SgNode</a> *sg_node)</td></tr>
<tr class="memdesc:aabe5f0cf52e5423628ec47ac0f6e8635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pragma declaration from <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> attached to a statement. <br /></td></tr>
<tr class="separator:aabe5f0cf52e5423628ec47ac0f6e8635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bab26b59d96811ad36a87fb9f8591e" id="r_a64bab26b59d96811ad36a87fb9f8591e"><td class="memItemLeft" align="right" valign="top"><a id="a64bab26b59d96811ad36a87fb9f8591e" name="a64bab26b59d96811ad36a87fb9f8591e"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generateDiffTextFromOmpAttribute</b> (<a class="el" href="classSgNode.html">SgNode</a> *sg_node)</td></tr>
<tr class="memdesc:a64bab26b59d96811ad36a87fb9f8591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate diff text from <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a> attached to a statement. <br /></td></tr>
<tr class="separator:a64bab26b59d96811ad36a87fb9f8591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501a3bda788701ed37519c2e0f56a2f" id="r_a7501a3bda788701ed37519c2e0f56a2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a7501a3bda788701ed37519c2e0f56a2f">patchUpSharedVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:a7501a3bda788701ed37519c2e0f56a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">makeDataSharingExplicit() can call some of existing functions for some work in <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace by Hongyi 07/16/2012 TODO: add a function within the <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST.  <br /></td></tr>
<tr class="separator:a7501a3bda788701ed37519c2e0f56a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109c3a085942e285df4d6a9b8d470f90" id="r_a109c3a085942e285df4d6a9b8d470f90"><td class="memItemLeft" align="right" valign="top"><a id="a109c3a085942e285df4d6a9b8d470f90" name="a109c3a085942e285df4d6a9b8d470f90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>makeDataSharingExplicit</b> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="separator:a109c3a085942e285df4d6a9b8d470f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949516f6dba7524ecfe19cb4bacafbe8" id="r_a949516f6dba7524ecfe19cb4bacafbe8"><td class="memItemLeft" align="right" valign="top"><a id="a949516f6dba7524ecfe19cb4bacafbe8" name="a949516f6dba7524ecfe19cb4bacafbe8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commandLineProcessing</b> (std::vector&lt; std::string &gt; &amp;argvList)</td></tr>
<tr class="separator:a949516f6dba7524ecfe19cb4bacafbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad14255713b507fc965732164024806" id="r_a9ad14255713b507fc965732164024806"><td class="memItemLeft" align="right" valign="top"><a id="a9ad14255713b507fc965732164024806" name="a9ad14255713b507fc965732164024806"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lower_omp</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a9ad14255713b507fc965732164024806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top level interface to translate OpenMP directives. <br /></td></tr>
<tr class="separator:a9ad14255713b507fc965732164024806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e85da767f2a26695fdcd9d70c4adf3" id="r_a98e85da767f2a26695fdcd9d70c4adf3"><td class="memItemLeft" align="right" valign="top"><a id="a98e85da767f2a26695fdcd9d70c4adf3" name="a98e85da767f2a26695fdcd9d70c4adf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertRTLHeaders</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a98e85da767f2a26695fdcd9d70c4adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert #include "xxx.h", the interface of a runtime library to the compiler. <br /></td></tr>
<tr class="separator:a98e85da767f2a26695fdcd9d70c4adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404b0f71c1b780fec510bbd850fbcda1" id="r_a404b0f71c1b780fec510bbd850fbcda1"><td class="memItemLeft" align="right" valign="top"><a id="a404b0f71c1b780fec510bbd850fbcda1" name="a404b0f71c1b780fec510bbd850fbcda1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertRTLinitAndCleanCode</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="memdesc:a404b0f71c1b780fec510bbd850fbcda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert runtime init and terminate routines to main() entry. <br /></td></tr>
<tr class="separator:a404b0f71c1b780fec510bbd850fbcda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ffb2ef7945e03c853c136acd6071c" id="r_a877ffb2ef7945e03c853c136acd6071c"><td class="memItemLeft" align="right" valign="top"><a id="a877ffb2ef7945e03c853c136acd6071c" name="a877ffb2ef7945e03c853c136acd6071c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertAcceleratorInit</b> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>
<tr class="separator:a877ffb2ef7945e03c853c136acd6071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b151fb4117c4b6b8b0e774d6c358006" id="r_a2b151fb4117c4b6b8b0e774d6c358006"><td class="memItemLeft" align="right" valign="top"><a id="a2b151fb4117c4b6b8b0e774d6c358006" name="a2b151fb4117c4b6b8b0e774d6c358006"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpParallel</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2b151fb4117c4b6b8b0e774d6c358006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp parallel. <br /></td></tr>
<tr class="separator:a2b151fb4117c4b6b8b0e774d6c358006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa460279915813087b3109bad38558f4b" id="r_aa460279915813087b3109bad38558f4b"><td class="memItemLeft" align="right" valign="top"><a id="aa460279915813087b3109bad38558f4b" name="aa460279915813087b3109bad38558f4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTargetParallel</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:aa460279915813087b3109bad38558f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp parallel under "omp target". <br /></td></tr>
<tr class="separator:aa460279915813087b3109bad38558f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547b91648d9a4437b6f6b410687aeda8" id="r_a547b91648d9a4437b6f6b410687aeda8"><td class="memItemLeft" align="right" valign="top"><a id="a547b91648d9a4437b6f6b410687aeda8" name="a547b91648d9a4437b6f6b410687aeda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpSections</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a547b91648d9a4437b6f6b410687aeda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp sections. <br /></td></tr>
<tr class="separator:a547b91648d9a4437b6f6b410687aeda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae015c3c4d380f148944d2cb9f2a8a305" id="r_ae015c3c4d380f148944d2cb9f2a8a305"><td class="memItemLeft" align="right" valign="top"><a id="ae015c3c4d380f148944d2cb9f2a8a305" name="ae015c3c4d380f148944d2cb9f2a8a305"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTask</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ae015c3c4d380f148944d2cb9f2a8a305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp task. <br /></td></tr>
<tr class="separator:ae015c3c4d380f148944d2cb9f2a8a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834de54bb3fee4a3f75e5aa7b7e60d4" id="r_a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="memItemLeft" align="right" valign="top"><a id="a8834de54bb3fee4a3f75e5aa7b7e60d4" name="a8834de54bb3fee4a3f75e5aa7b7e60d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpLoop</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops. <br /></td></tr>
<tr class="separator:a8834de54bb3fee4a3f75e5aa7b7e60d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f29754e2a97ffae8e21dbd2a30942" id="r_a6f7f29754e2a97ffae8e21dbd2a30942"><td class="memItemLeft" align="right" valign="top"><a id="a6f7f29754e2a97ffae8e21dbd2a30942" name="a6f7f29754e2a97ffae8e21dbd2a30942"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTargetLoop</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a6f7f29754e2a97ffae8e21dbd2a30942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops affected by the "omp target" directive, using naive 1-to-1 mapping Liao 1/28/2013. <br /></td></tr>
<tr class="separator:a6f7f29754e2a97ffae8e21dbd2a30942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570eb492119157e48576da8fe539c0da" id="r_a570eb492119157e48576da8fe539c0da"><td class="memItemLeft" align="right" valign="top"><a id="a570eb492119157e48576da8fe539c0da" name="a570eb492119157e48576da8fe539c0da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTargetLoop_RoundRobin</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a570eb492119157e48576da8fe539c0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp for or omp do loops affected by the "omp target" directive, using a round robin-scheduler Liao 7/10/2014. <br /></td></tr>
<tr class="separator:a570eb492119157e48576da8fe539c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c59562231bb9a568ee6ef65bd6cc3ec" id="r_a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a1c59562231bb9a568ee6ef65bd6cc3ec">transOmpTarget</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate Fortran omp do.  <br /></td></tr>
<tr class="separator:a1c59562231bb9a568ee6ef65bd6cc3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3995a5c314ed5d9bd06a39220208f711" id="r_a3995a5c314ed5d9bd06a39220208f711"><td class="memItemLeft" align="right" valign="top"><a id="a3995a5c314ed5d9bd06a39220208f711" name="a3995a5c314ed5d9bd06a39220208f711"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTargetData</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a3995a5c314ed5d9bd06a39220208f711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate "omp target data". <br /></td></tr>
<tr class="separator:a3995a5c314ed5d9bd06a39220208f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0cefae7b38c9b035dbbd2f5a417e80" id="r_a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="memItemLeft" align="right" valign="top"><a id="a2d0cefae7b38c9b035dbbd2f5a417e80" name="a2d0cefae7b38c9b035dbbd2f5a417e80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpBarrier</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp barrier. <br /></td></tr>
<tr class="separator:a2d0cefae7b38c9b035dbbd2f5a417e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c" id="r_adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="memItemLeft" align="right" valign="top"><a id="adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c" name="adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpFlush</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp flush. <br /></td></tr>
<tr class="separator:adfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd2daf13f11b87b823d673fa512f07" id="r_a88cd2daf13f11b87b823d673fa512f07"><td class="memItemLeft" align="right" valign="top"><a id="a88cd2daf13f11b87b823d673fa512f07" name="a88cd2daf13f11b87b823d673fa512f07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpTaskwait</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a88cd2daf13f11b87b823d673fa512f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp taskwait. <br /></td></tr>
<tr class="separator:a88cd2daf13f11b87b823d673fa512f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e377cd0e5da19d049a0d335419ba96" id="r_a91e377cd0e5da19d049a0d335419ba96"><td class="memItemLeft" align="right" valign="top"><a id="a91e377cd0e5da19d049a0d335419ba96" name="a91e377cd0e5da19d049a0d335419ba96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpThreadprivate</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a91e377cd0e5da19d049a0d335419ba96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp threadprivate. <br /></td></tr>
<tr class="separator:a91e377cd0e5da19d049a0d335419ba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d605f2c191dfe399343fd2af91d019" id="r_a92d605f2c191dfe399343fd2af91d019"><td class="memItemLeft" align="right" valign="top"><a id="a92d605f2c191dfe399343fd2af91d019" name="a92d605f2c191dfe399343fd2af91d019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpOrdered</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a92d605f2c191dfe399343fd2af91d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the ordered directive (not the ordered clause) <br /></td></tr>
<tr class="separator:a92d605f2c191dfe399343fd2af91d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce2fb3d01361a12fada8d678b2e1008" id="r_a2ce2fb3d01361a12fada8d678b2e1008"><td class="memItemLeft" align="right" valign="top"><a id="a2ce2fb3d01361a12fada8d678b2e1008" name="a2ce2fb3d01361a12fada8d678b2e1008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpAtomic</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a2ce2fb3d01361a12fada8d678b2e1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp atomic. <br /></td></tr>
<tr class="separator:a2ce2fb3d01361a12fada8d678b2e1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101582626c5f4d0f5e38481522bbf1ad" id="r_a101582626c5f4d0f5e38481522bbf1ad"><td class="memItemLeft" align="right" valign="top"><a id="a101582626c5f4d0f5e38481522bbf1ad" name="a101582626c5f4d0f5e38481522bbf1ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpCritical</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a101582626c5f4d0f5e38481522bbf1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp critical. <br /></td></tr>
<tr class="separator:a101582626c5f4d0f5e38481522bbf1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f911ebe755bc85aa73b25324bda24a8" id="r_a3f911ebe755bc85aa73b25324bda24a8"><td class="memItemLeft" align="right" valign="top"><a id="a3f911ebe755bc85aa73b25324bda24a8" name="a3f911ebe755bc85aa73b25324bda24a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpMaster</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:a3f911ebe755bc85aa73b25324bda24a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp master. <br /></td></tr>
<tr class="separator:a3f911ebe755bc85aa73b25324bda24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5784dbc40c3d9f01093ae944cf5208a" id="r_ab5784dbc40c3d9f01093ae944cf5208a"><td class="memItemLeft" align="right" valign="top"><a id="ab5784dbc40c3d9f01093ae944cf5208a" name="ab5784dbc40c3d9f01093ae944cf5208a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpSingle</b> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>
<tr class="memdesc:ab5784dbc40c3d9f01093ae944cf5208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate omp single. <br /></td></tr>
<tr class="separator:ab5784dbc40c3d9f01093ae944cf5208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9d02e5219e6c011336fc3a0bde5446" id="r_a6d9d02e5219e6c011336fc3a0bde5446"><td class="memItemLeft" align="right" valign="top"><a id="a6d9d02e5219e6c011336fc3a0bde5446" name="a6d9d02e5219e6c011336fc3a0bde5446"></a>
<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>generateOutlinedTask</b> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::string &amp;wrapper_name, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;syms)</td></tr>
<tr class="memdesc:a6d9d02e5219e6c011336fc3a0bde5446"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to generate implicit or explicit task for either omp parallel or omp task. <br /></td></tr>
<tr class="separator:a6d9d02e5219e6c011336fc3a0bde5446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e21e091b97082edbd005ebc254b5b9" id="r_a98e21e091b97082edbd005ebc254b5b9"><td class="memItemLeft" align="right" valign="top"><a id="a98e21e091b97082edbd005ebc254b5b9" name="a98e21e091b97082edbd005ebc254b5b9"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>transOmpVariables</b> (<a class="el" href="classSgStatement.html">SgStatement</a> *ompStmt, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *bb1, <a class="el" href="classSgExpression.html">SgExpression</a> *orig_loop_upper=NULL, bool withinAcceleratorModel=false)</td></tr>
<tr class="memdesc:a98e21e091b97082edbd005ebc254b5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate OpenMP variables associated with an OpenMP pragma, such as private, firstprivate, lastprivate, reduction, etc. bb1 is the translation generated code block in which the variable handling statements will be inserted. Original loop upper bound is needed for implementing lastprivate (check if it is the last iteration). withinAcceleratorModel means if we only translate private() variables, used to support accelerator model. <br /></td></tr>
<tr class="separator:a98e21e091b97082edbd005ebc254b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532bd0e22697f90845101221fa0ae33d" id="r_a532bd0e22697f90845101221fa0ae33d"><td class="memItemLeft" align="right" valign="top"><a id="a532bd0e22697f90845101221fa0ae33d" name="a532bd0e22697f90845101221fa0ae33d"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><b>collectAllClauseVariables</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt)</td></tr>
<tr class="memdesc:a532bd0e22697f90845101221fa0ae33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all variables from OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:a532bd0e22697f90845101221fa0ae33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa87b7282c34089df291faf5b54fea6" id="r_a4aa87b7282c34089df291faf5b54fea6"><td class="memItemLeft" align="right" valign="top"><a id="a4aa87b7282c34089df291faf5b54fea6" name="a4aa87b7282c34089df291faf5b54fea6"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><b>collectClauseVariables</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a4aa87b7282c34089df291faf5b54fea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect variables from a particular type of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:a4aa87b7282c34089df291faf5b54fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8f8d3eaff57e69b86818d344c11f23" id="r_adc8f8d3eaff57e69b86818d344c11f23"><td class="memItemLeft" align="right" valign="top"><a id="adc8f8d3eaff57e69b86818d344c11f23" name="adc8f8d3eaff57e69b86818d344c11f23"></a>
ROSE_DLL_API SgInitializedNamePtrList&#160;</td><td class="memItemRight" valign="bottom"><b>collectClauseVariables</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:adc8f8d3eaff57e69b86818d344c11f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect variables from given types of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:adc8f8d3eaff57e69b86818d344c11f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad223a6aa660e0e1068bf6b9a3c876" id="r_ad4ad223a6aa660e0e1068bf6b9a3c876"><td class="memItemLeft" align="right" valign="top"><a id="ad4ad223a6aa660e0e1068bf6b9a3c876" name="ad4ad223a6aa660e0e1068bf6b9a3c876"></a>
ROSE_DLL_API <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getClauseExpression</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:ad4ad223a6aa660e0e1068bf6b9a3c876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect expression from given types of OpenMP clauses associated with an omp statement: private, reduction, etc. <br /></td></tr>
<tr class="separator:ad4ad223a6aa660e0e1068bf6b9a3c876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d34f9f3f6e5108ee1553a1ffc9dea8" id="r_a84d34f9f3f6e5108ee1553a1ffc9dea8"><td class="memItemLeft" align="right" valign="top"><a id="a84d34f9f3f6e5108ee1553a1ffc9dea8" name="a84d34f9f3f6e5108ee1553a1ffc9dea8"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInClauseVariableList</b> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a84d34f9f3f6e5108ee1553a1ffc9dea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in a variable list of a given clause type. <br /></td></tr>
<tr class="separator:a84d34f9f3f6e5108ee1553a1ffc9dea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea34d841e22f58188bced0094095202" id="r_a1ea34d841e22f58188bced0094095202"><td class="memItemLeft" align="right" valign="top"><a id="a1ea34d841e22f58188bced0094095202" name="a1ea34d841e22f58188bced0094095202"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInClauseVariableList</b> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>
<tr class="memdesc:a1ea34d841e22f58188bced0094095202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in variable lists of given clause types. <br /></td></tr>
<tr class="separator:a1ea34d841e22f58188bced0094095202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ac93c429bcb6007e9be3b443f987c5" id="r_a97ac93c429bcb6007e9be3b443f987c5"><td class="memItemLeft" align="right" valign="top"><a id="a97ac93c429bcb6007e9be3b443f987c5" name="a97ac93c429bcb6007e9be3b443f987c5"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>replaceVariableReferences</b> (<a class="el" href="classSgNode.html">SgNode</a> *root, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *oldVar, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *newVar)</td></tr>
<tr class="memdesc:a97ac93c429bcb6007e9be3b443f987c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace references to oldVar within root with references to newVar, return the number of references replaced. <br /></td></tr>
<tr class="separator:a97ac93c429bcb6007e9be3b443f987c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33ecf538a49b48239039fd4e51f3b8" id="r_a8b33ecf538a49b48239039fd4e51f3b8"><td class="memItemLeft" align="right" valign="top"><a id="a8b33ecf538a49b48239039fd4e51f3b8" name="a8b33ecf538a49b48239039fd4e51f3b8"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>replaceVariableReferences</b> (<a class="el" href="classSgNode.html">SgNode</a> *root, VariableSymbolMap_t varRemap)</td></tr>
<tr class="memdesc:a8b33ecf538a49b48239039fd4e51f3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace variable references within root based on a map from old symbols to new symbols. <br /></td></tr>
<tr class="separator:a8b33ecf538a49b48239039fd4e51f3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dfe9c59c91efe7149787d3bac59ac1" id="r_ab6dfe9c59c91efe7149787d3bac59ac1"><td class="memItemLeft" align="right" valign="top"><a id="ab6dfe9c59c91efe7149787d3bac59ac1" name="ab6dfe9c59c91efe7149787d3bac59ac1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>replaceVariablesWithPointerDereference</b> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;vars)</td></tr>
<tr class="memdesc:ab6dfe9c59c91efe7149787d3bac59ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all variable references in a set by pointers to the variable. <br /></td></tr>
<tr class="separator:ab6dfe9c59c91efe7149787d3bac59ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace68b6e025d8036aa1ad583475c87203" id="r_ace68b6e025d8036aa1ad583475c87203"><td class="memItemLeft" align="right" valign="top"><a id="ace68b6e025d8036aa1ad583475c87203" name="ace68b6e025d8036aa1ad583475c87203"></a>
ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><b>addClauseVariable</b> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:ace68b6e025d8036aa1ad583475c87203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a variable into a non-reduction clause of an OpenMP statement, create the clause transparently if it does not exist. <br /></td></tr>
<tr class="separator:ace68b6e025d8036aa1ad583475c87203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c1e6218564ada90bc6d36653f24228" id="r_a27c1e6218564ada90bc6d36653f24228"><td class="memItemLeft" align="right" valign="top"><a id="a27c1e6218564ada90bc6d36653f24228" name="a27c1e6218564ada90bc6d36653f24228"></a>
ROSE_DLL_API <a class="el" href="classSgOmpVariablesClause.html">SgOmpVariablesClause</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildOmpVariableClause</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a27c1e6218564ada90bc6d36653f24228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a non-reduction variable clause for a given OpenMP directive. It directly returns the clause if the clause already exists. <br /></td></tr>
<tr class="separator:a27c1e6218564ada90bc6d36653f24228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c025469512b17de16ad88f08fb4d400" id="r_a9c025469512b17de16ad88f08fb4d400"><td class="memItemLeft" align="right" valign="top"><a id="a9c025469512b17de16ad88f08fb4d400" name="a9c025469512b17de16ad88f08fb4d400"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>removeClause</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a9c025469512b17de16ad88f08fb4d400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one or more clauses of type vt. <br /></td></tr>
<tr class="separator:a9c025469512b17de16ad88f08fb4d400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aebb4d7ee834417cf4500c61e3922cf" id="r_a8aebb4d7ee834417cf4500c61e3922cf"><td class="memItemLeft" align="right" valign="top"><a id="a8aebb4d7ee834417cf4500c61e3922cf" name="a8aebb4d7ee834417cf4500c61e3922cf"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasClause</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a8aebb4d7ee834417cf4500c61e3922cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an OpenMP statement has a clause of type vt. <br /></td></tr>
<tr class="separator:a8aebb4d7ee834417cf4500c61e3922cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842c0d0b8933c5a7cebb5f295fd379c1" id="r_a842c0d0b8933c5a7cebb5f295fd379c1"><td class="memItemLeft" align="right" valign="top"><a id="a842c0d0b8933c5a7cebb5f295fd379c1" name="a842c0d0b8933c5a7cebb5f295fd379c1"></a>
ROSE_DLL_API Rose_STL_Container&lt; <a class="el" href="classSgOmpClause.html">SgOmpClause</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getClause</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantT &amp;vt)</td></tr>
<tr class="memdesc:a842c0d0b8933c5a7cebb5f295fd379c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OpenMP clauses from an eligible OpenMP statement. <br /></td></tr>
<tr class="separator:a842c0d0b8933c5a7cebb5f295fd379c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc11c254f98d95ebc7ed4464b518ed1" id="r_a6fc11c254f98d95ebc7ed4464b518ed1"><td class="memItemLeft" align="right" valign="top"><a id="a6fc11c254f98d95ebc7ed4464b518ed1" name="a6fc11c254f98d95ebc7ed4464b518ed1"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>useStaticSchedule</b> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *omp_loop)</td></tr>
<tr class="memdesc:a6fc11c254f98d95ebc7ed4464b518ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an omp for/do loop use static schedule or not, including: default schedule, or schedule(static[,chunk_size]) <br /></td></tr>
<tr class="separator:a6fc11c254f98d95ebc7ed4464b518ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a254043e365d2ddcb08da63e94e9822" id="r_a1a254043e365d2ddcb08da63e94e9822"><td class="memItemLeft" align="right" valign="top"><a id="a1a254043e365d2ddcb08da63e94e9822" name="a1a254043e365d2ddcb08da63e94e9822"></a>
ROSE_DLL_API SgOmpClause::omp_reduction_operator_enum&#160;</td><td class="memItemRight" valign="bottom"><b>getReductionOperationType</b> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *init_name, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt)</td></tr>
<tr class="memdesc:a1a254043e365d2ddcb08da63e94e9822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reduction variable's reduction operation type. <br /></td></tr>
<tr class="separator:a1a254043e365d2ddcb08da63e94e9822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28505cc599d1cb7e6afb9f1a9c152aed" id="r_a28505cc599d1cb7e6afb9f1a9c152aed"><td class="memItemLeft" align="right" valign="top"><a id="a28505cc599d1cb7e6afb9f1a9c152aed" name="a28505cc599d1cb7e6afb9f1a9c152aed"></a>
ROSE_DLL_API <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createInitialValueExp</b> (SgOmpClause::omp_reduction_operator_enum r_operator)</td></tr>
<tr class="memdesc:a28505cc599d1cb7e6afb9f1a9c152aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an initial value according to reduction operator type. <br /></td></tr>
<tr class="separator:a28505cc599d1cb7e6afb9f1a9c152aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0bd3d3d27d4f23dcd8340bcf07a5b6" id="r_a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="memItemLeft" align="right" valign="top"><a id="a8e0bd3d3d27d4f23dcd8340bcf07a5b6" name="a8e0bd3d3d27d4f23dcd8340bcf07a5b6"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generateGOMPLoopStartFuncName</b> (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate GOMP loop schedule start function's name. <br /></td></tr>
<tr class="separator:a8e0bd3d3d27d4f23dcd8340bcf07a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed9f1f738216fef339027c347c6e615" id="r_aeed9f1f738216fef339027c347c6e615"><td class="memItemLeft" align="right" valign="top"><a id="aeed9f1f738216fef339027c347c6e615" name="aeed9f1f738216fef339027c347c6e615"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generateGOMPLoopNextFuncName</b> (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:aeed9f1f738216fef339027c347c6e615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate GOMP loop schedule next function's name. <br /></td></tr>
<tr class="separator:aeed9f1f738216fef339027c347c6e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad381a8a9a107462e74e55a621babb28d" id="r_ad381a8a9a107462e74e55a621babb28d"><td class="memItemLeft" align="right" valign="top"><a id="ad381a8a9a107462e74e55a621babb28d" name="ad381a8a9a107462e74e55a621babb28d"></a>
ROSE_DLL_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (SgOmpClause::omp_schedule_kind_enum s_kind)</td></tr>
<tr class="memdesc:ad381a8a9a107462e74e55a621babb28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a schedule kind enum value to a small case string. <br /></td></tr>
<tr class="separator:ad381a8a9a107462e74e55a621babb28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2040f5469b59cd3baaabf7c1c7450" id="r_a3bb2040f5469b59cd3baaabf7c1c7450"><td class="memItemLeft" align="right" valign="top"><a id="a3bb2040f5469b59cd3baaabf7c1c7450" name="a3bb2040f5469b59cd3baaabf7c1c7450"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>patchUpPrivateVariables</b> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:a3bb2040f5469b59cd3baaabf7c1c7450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up private variables for omp for of entire file. The reason is that loop indices should be private by default and this function will make this explicit. <br /></td></tr>
<tr class="separator:a3bb2040f5469b59cd3baaabf7c1c7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3863e39e286bc6846a4619c0b6806e7" id="r_ac3863e39e286bc6846a4619c0b6806e7"><td class="memItemLeft" align="right" valign="top"><a id="ac3863e39e286bc6846a4619c0b6806e7" name="ac3863e39e286bc6846a4619c0b6806e7"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>patchUpPrivateVariables</b> (<a class="el" href="classSgStatement.html">SgStatement</a> *omp_loop)</td></tr>
<tr class="memdesc:ac3863e39e286bc6846a4619c0b6806e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up private variables for omp for. The reason is that loop indices should be private by default and this function will make this explicit. <br /></td></tr>
<tr class="separator:ac3863e39e286bc6846a4619c0b6806e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadab3d7eb05453e29a85178f1df5694a" id="r_aadab3d7eb05453e29a85178f1df5694a"><td class="memItemLeft" align="right" valign="top"><a id="aadab3d7eb05453e29a85178f1df5694a" name="aadab3d7eb05453e29a85178f1df5694a"></a>
ROSE_DLL_API int&#160;</td><td class="memItemRight" valign="bottom"><b>patchUpFirstprivateVariables</b> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>
<tr class="memdesc:aadab3d7eb05453e29a85178f1df5694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch up firstprivate variables for omp task. The reason is that the specification 3.0 defines rules for implicitly determined data-sharing attributes and this function will make the firstprivate variable of omp task explicit. <br /></td></tr>
<tr class="separator:aadab3d7eb05453e29a85178f1df5694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af016b6de6543aebaeef2858a661d0f5b" id="r_af016b6de6543aebaeef2858a661d0f5b"><td class="memItemLeft" align="right" valign="top"><a id="af016b6de6543aebaeef2858a661d0f5b" name="af016b6de6543aebaeef2858a661d0f5b"></a>
std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>collectThreadprivateVariables</b> ()</td></tr>
<tr class="memdesc:af016b6de6543aebaeef2858a661d0f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect threadprivate variables within the current project, return a set to avoid duplicated elements. No input parameters are needed since it finds match from memory pools. <br /></td></tr>
<tr class="separator:af016b6de6543aebaeef2858a661d0f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7b746b4c144b4ab3292deb223decc7" id="r_acc7b746b4c144b4ab3292deb223decc7"><td class="memItemLeft" align="right" valign="top"><a id="acc7b746b4c144b4ab3292deb223decc7" name="acc7b746b4c144b4ab3292deb223decc7"></a>
<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildAndInsertDeclarationForOmp</b> (const std::string &amp;name, <a class="el" href="classSgType.html">SgType</a> *type, <a class="el" href="classSgInitializer.html">SgInitializer</a> *varInit, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *orig_scope)</td></tr>
<tr class="memdesc:acc7b746b4c144b4ab3292deb223decc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling when trying to build and insert a variable declaration into a BB within Fortran OpenMP code. <br /></td></tr>
<tr class="separator:acc7b746b4c144b4ab3292deb223decc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05277c52618809f1bb654698d37e376c" id="r_a05277c52618809f1bb654698d37e376c"><td class="memItemLeft" align="right" valign="top"><a id="a05277c52618809f1bb654698d37e376c" name="a05277c52618809f1bb654698d37e376c"></a>
<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getEnclosingRegionOrFuncDefinition</b> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>
<tr class="memdesc:a05277c52618809f1bb654698d37e376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an enclosing parallel region or function definition's body. <br /></td></tr>
<tr class="separator:a05277c52618809f1bb654698d37e376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59136522fa2c557521a2db41c0910d7" id="r_ab59136522fa2c557521a2db41c0910d7"><td class="memItemLeft" align="right" valign="top"><a id="ab59136522fa2c557521a2db41c0910d7" name="ab59136522fa2c557521a2db41c0910d7"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInClauseVariableList</b> (<a class="el" href="classSgOmpClause.html">SgOmpClause</a> *cls, <a class="el" href="classSgSymbol.html">SgSymbol</a> *var)</td></tr>
<tr class="memdesc:ab59136522fa2c557521a2db41c0910d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is in the clause's variable list. <br /></td></tr>
<tr class="separator:ab59136522fa2c557521a2db41c0910d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b17ab1689d8b4ef4cab3d36521b3ac" id="r_a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="memItemLeft" align="right" valign="top"><a id="a37b17ab1689d8b4ef4cab3d36521b3ac" name="a37b17ab1689d8b4ef4cab3d36521b3ac"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isThreadprivate</b> (<a class="el" href="classSgSymbol.html">SgSymbol</a> *var)</td></tr>
<tr class="memdesc:a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable is a threadprivate variable. It will search for all threadprivate directives to find the answer. <br /></td></tr>
<tr class="separator:a37b17ab1689d8b4ef4cab3d36521b3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed087b63b4c940da7d59a9f148d2f5" id="r_a7eed087b63b4c940da7d59a9f148d2f5"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#a7eed087b63b4c940da7d59a9f148d2f5">getDataSharingAttribute</a> (<a class="el" href="classSgSymbol.html">SgSymbol</a> *var, <a class="el" href="classSgNode.html">SgNode</a> *anchor_node)</td></tr>
<tr class="memdesc:a7eed087b63b4c940da7d59a9f148d2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data sharing attribute type of a variable, specified as a symbol and an anchor node (Must be the inner most node associated with the variable reference, e.g.  <br /></td></tr>
<tr class="separator:a7eed087b63b4c940da7d59a9f148d2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51968a9d4386f3819161dca44b76542" id="r_af51968a9d4386f3819161dca44b76542"><td class="memItemLeft" align="right" valign="top"><a id="af51968a9d4386f3819161dca44b76542" name="af51968a9d4386f3819161dca44b76542"></a>
ROSE_DLL_API omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>getDataSharingAttribute</b> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *varRef)</td></tr>
<tr class="memdesc:af51968a9d4386f3819161dca44b76542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the OpenMP data sharing attribute type of a variable reference. <br /></td></tr>
<tr class="separator:af51968a9d4386f3819161dca44b76542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca716508b2b743aab5240e4acea9f68" id="r_afca716508b2b743aab5240e4acea9f68"><td class="memItemLeft" align="right" valign="top"><a id="afca716508b2b743aab5240e4acea9f68" name="afca716508b2b743aab5240e4acea9f68"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSharedAccess</b> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *varRef)</td></tr>
<tr class="memdesc:afca716508b2b743aab5240e4acea9f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a variable access is a shared access , assuming it is already within an OpenMP region. <br /></td></tr>
<tr class="separator:afca716508b2b743aab5240e4acea9f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fa7a7c146b001c2563c3254ebb78f7" id="r_a54fa7a7c146b001c2563c3254ebb78f7"><td class="memItemLeft" align="right" valign="top"><a id="a54fa7a7c146b001c2563c3254ebb78f7" name="a54fa7a7c146b001c2563c3254ebb78f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractMapClauses</b> (Rose_STL_Container&lt; <a class="el" href="classSgOmpClause.html">SgOmpClause</a> * &gt; map_clauses, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classSgExpression.html">SgExpression</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;array_dimensions, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; SgOmpClause::omp_map_dist_data_enum, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;dist_data_policies, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_alloc_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_to_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_from_clause, <a class="el" href="classSgOmpMapClause.html">SgOmpMapClause</a> **map_tofrom_clause)</td></tr>
<tr class="memdesc:a54fa7a7c146b001c2563c3254ebb78f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract map clause information. <br /></td></tr>
<tr class="separator:a54fa7a7c146b001c2563c3254ebb78f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406e9cfadde32b60ea49cd622f88d45a" id="r_a406e9cfadde32b60ea49cd622f88d45a"><td class="memItemLeft" align="right" valign="top"><a id="a406e9cfadde32b60ea49cd622f88d45a" name="a406e9cfadde32b60ea49cd622f88d45a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>categorizeMapClauseVariables</b> (const SgInitializedNamePtrList &amp;all_vars, std::map&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classSgExpression.html">SgExpression</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt; &gt; &amp;array_dimensions, std::set&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt; &amp;array_syms, std::set&lt; <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt; &amp;atom_syms)</td></tr>
<tr class="memdesc:a406e9cfadde32b60ea49cd622f88d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categorize mapped variables. <br /></td></tr>
<tr class="separator:a406e9cfadde32b60ea49cd622f88d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6e37a76fc52e19725e0509e53317996" id="r_ad6e37a76fc52e19725e0509e53317996"><td class="memItemLeft" align="right" valign="top"><a id="ad6e37a76fc52e19725e0509e53317996" name="ad6e37a76fc52e19725e0509e53317996"></a>
omp_construct_enum&#160;</td><td class="memItemRight" valign="bottom"><b>cur_omp_directive</b></td></tr>
<tr class="separator:ad6e37a76fc52e19725e0509e53317996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc5bb0fb5164f3d976892bc0ca079a2" id="r_a2cc5bb0fb5164f3d976892bc0ca079a2"><td class="memItemLeft" align="right" valign="top"><a id="a2cc5bb0fb5164f3d976892bc0ca079a2" name="a2cc5bb0fb5164f3d976892bc0ca079a2"></a>
std::list&lt; <a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>omp_comment_list</b></td></tr>
<tr class="separator:a2cc5bb0fb5164f3d976892bc0ca079a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2297a3748cc91d4ba10b8d66dab3d384" id="r_a2297a3748cc91d4ba10b8d66dab3d384"><td class="memItemLeft" align="right" valign="top"><a id="a2297a3748cc91d4ba10b8d66dab3d384" name="a2297a3748cc91d4ba10b8d66dab3d384"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>enable_accelerator</b></td></tr>
<tr class="separator:a2297a3748cc91d4ba10b8d66dab3d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db8c05a30482833a0682ca3354ccdf" id="r_a30db8c05a30482833a0682ca3354ccdf"><td class="memItemLeft" align="right" valign="top"><a id="a30db8c05a30482833a0682ca3354ccdf" name="a30db8c05a30482833a0682ca3354ccdf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useDDE</b></td></tr>
<tr class="separator:a30db8c05a30482833a0682ca3354ccdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e89533a4c04bd31d7393781274f68e" id="r_af8e89533a4c04bd31d7393781274f68e"><td class="memItemLeft" align="right" valign="top"><a id="af8e89533a4c04bd31d7393781274f68e" name="af8e89533a4c04bd31d7393781274f68e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>nCounter</b></td></tr>
<tr class="separator:af8e89533a4c04bd31d7393781274f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43438c01722b3b4802ce8d082a636759" id="r_a43438c01722b3b4802ce8d082a636759"><td class="memItemLeft" align="right" valign="top"><a id="a43438c01722b3b4802ce8d082a636759" name="a43438c01722b3b4802ce8d082a636759"></a>
<a class="el" href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">omp_rtl_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtl_type</b></td></tr>
<tr class="separator:a43438c01722b3b4802ce8d082a636759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a517aeb9b0b29041f7d14636b9b643afb" name="a517aeb9b0b29041f7d14636b9b643afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517aeb9b0b29041f7d14636b9b643afb">&#9670;&#160;</a></span>VariableSymbolMap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&gt; OmpSupport::VariableSymbolMap_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="omp__lowering_8h_source.html#l00046">46</a> of file <a class="el" href="omp__lowering_8h_source.html">omp_lowering.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9407f163895e6aef1aaac5155fb25ac9" name="a9407f163895e6aef1aaac5155fb25ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9407f163895e6aef1aaac5155fb25ac9">&#9670;&#160;</a></span>omp_construct_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum OmpSupport::omp_construct_enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OmpAttribute_8h_source.html#l00031">31</a> of file <a class="el" href="OmpAttribute_8h_source.html">OmpAttribute.h</a>.</p>

</div>
</div>
<a id="abffc7f08fd77ecfd382fe54fd641dc10" name="abffc7f08fd77ecfd382fe54fd641dc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc7f08fd77ecfd382fe54fd641dc10">&#9670;&#160;</a></span>omp_rtl_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOmpSupport.html#abffc7f08fd77ecfd382fe54fd641dc10">OmpSupport::omp_rtl_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of target runtime libraries (not yet in use) </p>

<p class="definition">Definition at line <a class="el" href="omp__lowering_8h_source.html#l00037">37</a> of file <a class="el" href="omp__lowering_8h_source.html">omp_lowering.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd2dc3d90879693e6e3a6fa1decbf975" name="acd2dc3d90879693e6e3a6fa1decbf975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2dc3d90879693e6e3a6fa1decbf975">&#9670;&#160;</a></span>buildOmpAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="classOmpSupport_1_1OmpAttribute.html">OmpAttribute</a> * OmpSupport::buildOmpAttribute </td>
          <td>(</td>
          <td class="paramtype">enum omp_construct_enum&#160;</td>
          <td class="paramname"><em>directive_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>context_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useDefined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some utility functions to manipulate <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a>. </p>
<p>A builder for <a class="el" href="classOmpSupport_1_1OmpAttribute.html" title="One attribute object stores all information within an OpenMP pragma (directive and clauses)">OmpAttribute</a>, useDefined indicates if the directive is added by programmer or not (by autoParallelization) </p>

</div>
</div>
<a id="a7501a3bda788701ed37519c2e0f56a2f" name="a7501a3bda788701ed37519c2e0f56a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7501a3bda788701ed37519c2e0f56a2f">&#9670;&#160;</a></span>patchUpSharedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OmpSupport::patchUpSharedVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFile.html">SgFile</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>makeDataSharingExplicit() can call some of existing functions for some work in <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace by Hongyi 07/16/2012 TODO: add a function within the <a class="el" href="namespaceOmpSupport.html" title="Types and functions to support OpenMP.">OmpSupport</a> namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST. </p>
<p>ROSE has dedicated AST nodes for OpenMP directives and the associated clauses, such as private, shared, reduction. </p>

</div>
</div>
<a id="a1c59562231bb9a568ee6ef65bd6cc3ec" name="a1c59562231bb9a568ee6ef65bd6cc3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c59562231bb9a568ee6ef65bd6cc3ec">&#9670;&#160;</a></span>transOmpTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OmpSupport::transOmpTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate Fortran omp do. </p>
<p>Translate "omp target" </p>

</div>
</div>
<a id="a7eed087b63b4c940da7d59a9f148d2f5" name="a7eed087b63b4c940da7d59a9f148d2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eed087b63b4c940da7d59a9f148d2f5">&#9670;&#160;</a></span>getDataSharingAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API omp_construct_enum OmpSupport::getDataSharingAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSymbol.html">SgSymbol</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>anchor_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the data sharing attribute type of a variable, specified as a symbol and an anchor node (Must be the inner most node associated with the variable reference, e.g. </p>
<p>a <a class="el" href="classSgVarRefExp.html" title="This class represents the variable refernece in expressions.">SgVarRefExp</a>, <a class="el" href="classSgVariableDeclaration.html" title="This class represents the concept of a C or C++ variable declaration.">SgVariableDeclaration</a>, etc) Possible returned values include: e_shared, e_private, e_firstprivate, e_lastprivate, e_reduction, e_threadprivate, e_copyin, and e_copyprivate. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:07 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
