<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::AddressUsageMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::AddressUsageMap Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Address usage map. </p>
<p>Keeps track of which instructions and data span each virtual address. The AUM that's part of the partitioner is never modified directly by the user, and represents the instructions and basic blocks that are in the control flow graph as well as any data blocks they own. </p>

<p class="definition">Definition at line <a class="el" href="AddressUsageMap_8h_source.html#l00371">371</a> of file <a class="el" href="AddressUsageMap_8h_source.html">AddressUsageMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AddressUsageMap_8h_source.html">Rose/BinaryAnalysis/Partitioner2/AddressUsageMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca6be5362dbc1bad3d7b35c976f8a500" id="r_aca6be5362dbc1bad3d7b35c976f8a500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#aca6be5362dbc1bad3d7b35c976f8a500">isEmpty</a> () const</td></tr>
<tr class="memdesc:aca6be5362dbc1bad3d7b35c976f8a500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a map is empty.  <br /></td></tr>
<tr class="separator:aca6be5362dbc1bad3d7b35c976f8a500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342bd7c71b3de797bc181551e1d98d81" id="r_a342bd7c71b3de797bc181551e1d98d81"><td class="memItemLeft" align="right" valign="top"><a id="a342bd7c71b3de797bc181551e1d98d81" name="a342bd7c71b3de797bc181551e1d98d81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a342bd7c71b3de797bc181551e1d98d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset map to initial empty state. <br /></td></tr>
<tr class="separator:a342bd7c71b3de797bc181551e1d98d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe746c0c45ff5b356404831cb2a50fba" id="r_afe746c0c45ff5b356404831cb2a50fba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#afe746c0c45ff5b356404831cb2a50fba">size</a> () const</td></tr>
<tr class="memdesc:afe746c0c45ff5b356404831cb2a50fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of addresses represented by the map.  <br /></td></tr>
<tr class="separator:afe746c0c45ff5b356404831cb2a50fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583c8c9c821943595f34701f20146ec" id="r_aa583c8c9c821943595f34701f20146ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#aa583c8c9c821943595f34701f20146ec">hull</a> () const</td></tr>
<tr class="memdesc:aa583c8c9c821943595f34701f20146ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum and maximum used addresses.  <br /></td></tr>
<tr class="separator:aa583c8c9c821943595f34701f20146ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b56038c1899f7d0c9c054a56c4730" id="r_a551b56038c1899f7d0c9c054a56c4730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a551b56038c1899f7d0c9c054a56c4730">extent</a> () const</td></tr>
<tr class="memdesc:a551b56038c1899f7d0c9c054a56c4730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses represented.  <br /></td></tr>
<tr class="separator:a551b56038c1899f7d0c9c054a56c4730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb3d870b716b07ed1345174aff2249" id="r_a16bb3d870b716b07ed1345174aff2249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a16bb3d870b716b07ed1345174aff2249">exists</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:a16bb3d870b716b07ed1345174aff2249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to determine whether an address is used.  <br /></td></tr>
<tr class="separator:a16bb3d870b716b07ed1345174aff2249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e84e0df29869ff17c27618875acaf1" id="r_ad1e84e0df29869ff17c27618875acaf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ad1e84e0df29869ff17c27618875acaf1">nextUnused</a> (rose_addr_t minVa) const</td></tr>
<tr class="memdesc:ad1e84e0df29869ff17c27618875acaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next unused address interval.  <br /></td></tr>
<tr class="separator:ad1e84e0df29869ff17c27618875acaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a7a2956b099936ff3292ec5de42e06" id="r_ae8a7a2956b099936ff3292ec5de42e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ae8a7a2956b099936ff3292ec5de42e06">insertInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:ae8a7a2956b099936ff3292ec5de42e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the instruction along with an owning basic block.  <br /></td></tr>
<tr class="separator:ae8a7a2956b099936ff3292ec5de42e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd147c6aa9b87110d01e9ebee815bb9" id="r_a0fd147c6aa9b87110d01e9ebee815bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a0fd147c6aa9b87110d01e9ebee815bb9">insertDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a0fd147c6aa9b87110d01e9ebee815bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the data block.  <br /></td></tr>
<tr class="separator:a0fd147c6aa9b87110d01e9ebee815bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b2321f80754602f078b08c6f59ada0" id="r_a03b2321f80754602f078b08c6f59ada0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a03b2321f80754602f078b08c6f59ada0">eraseInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a03b2321f80754602f078b08c6f59ada0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified instruction/basic block pair.  <br /></td></tr>
<tr class="separator:a03b2321f80754602f078b08c6f59ada0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356322e37d7b6e1d4a4292c4c71b1232" id="r_a356322e37d7b6e1d4a4292c4c71b1232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a356322e37d7b6e1d4a4292c4c71b1232">eraseDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a356322e37d7b6e1d4a4292c4c71b1232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified data block.  <br /></td></tr>
<tr class="separator:a356322e37d7b6e1d4a4292c4c71b1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24082b068b5ec2ee605a8624ad7883e" id="r_af24082b068b5ec2ee605a8624ad7883e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#af24082b068b5ec2ee605a8624ad7883e">leastUnmapped</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:af24082b068b5ec2ee605a8624ad7883e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the least unmapped address with specified lower limit.  <br /></td></tr>
<tr class="separator:af24082b068b5ec2ee605a8624ad7883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d44a0d7a1586df8982d62ac6ca605c" id="r_ad3d44a0d7a1586df8982d62ac6ca605c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ad3d44a0d7a1586df8982d62ac6ca605c">print</a> (std::ostream &amp;, const std::string &amp;prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:ad3d44a0d7a1586df8982d62ac6ca605c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of this AUM to a stream.  <br /></td></tr>
<tr class="separator:ad3d44a0d7a1586df8982d62ac6ca605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e7b20c3d73cf8645341f258937c63b" id="r_a80e7b20c3d73cf8645341f258937c63b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a80e7b20c3d73cf8645341f258937c63b">checkConsistency</a> () const</td></tr>
<tr class="memdesc:a80e7b20c3d73cf8645341f258937c63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check invariants.  <br /></td></tr>
<tr class="separator:a80e7b20c3d73cf8645341f258937c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23ca843b9a624e05d0a51289c3b3bf94" id="r_a23ca843b9a624e05d0a51289c3b3bf94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a23ca843b9a624e05d0a51289c3b3bf94">anyExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a23ca843b9a624e05d0a51289c3b3bf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to determine whether any of the specified addresses are used.  <br /></td></tr>
<tr class="separator:a23ca843b9a624e05d0a51289c3b3bf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e69288af4d8b549e0beace18e0ece6" id="r_a32e69288af4d8b549e0beace18e0ece6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a32e69288af4d8b549e0beace18e0ece6">anyExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;) const</td></tr>
<tr class="memdesc:a32e69288af4d8b549e0beace18e0ece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to determine whether any of the specified addresses are used.  <br /></td></tr>
<tr class="separator:a32e69288af4d8b549e0beace18e0ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac374f1cbbfc3b9804a9c6cb8fc3f074f" id="r_ac374f1cbbfc3b9804a9c6cb8fc3f074f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ac374f1cbbfc3b9804a9c6cb8fc3f074f">unusedExtent</a> (size_t nBits) const</td></tr>
<tr class="memdesc:ac374f1cbbfc3b9804a9c6cb8fc3f074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses not represented.  <br /></td></tr>
<tr class="separator:ac374f1cbbfc3b9804a9c6cb8fc3f074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1d8b45284a0cad0476c08a20eca8c8" id="r_a9f1d8b45284a0cad0476c08a20eca8c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a9f1d8b45284a0cad0476c08a20eca8c8">unusedExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a9f1d8b45284a0cad0476c08a20eca8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses not represented.  <br /></td></tr>
<tr class="separator:a9f1d8b45284a0cad0476c08a20eca8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c95f51594a8c9b76a5efc280acfbed" id="r_a02c95f51594a8c9b76a5efc280acfbed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a02c95f51594a8c9b76a5efc280acfbed">unusedExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;) const</td></tr>
<tr class="memdesc:a02c95f51594a8c9b76a5efc280acfbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses not represented.  <br /></td></tr>
<tr class="separator:a02c95f51594a8c9b76a5efc280acfbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:add0ddc34f5d79b8f0912ec1cc2ab48fe" id="r_add0ddc34f5d79b8f0912ec1cc2ab48fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#add0ddc34f5d79b8f0912ec1cc2ab48fe">instructionExists</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:add0ddc34f5d79b8f0912ec1cc2ab48fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instruction or an equivalent exists.  <br /></td></tr>
<tr class="separator:add0ddc34f5d79b8f0912ec1cc2ab48fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa770f50e46d3db46a119fdaf0b8961d1" id="r_aa770f50e46d3db46a119fdaf0b8961d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#aa770f50e46d3db46a119fdaf0b8961d1">instructionExists</a> (rose_addr_t va) const</td></tr>
<tr class="memdesc:aa770f50e46d3db46a119fdaf0b8961d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instruction or an equivalent exists.  <br /></td></tr>
<tr class="separator:aa770f50e46d3db46a119fdaf0b8961d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad2171f82b7d9a6b821978a3ec7231699" id="r_ad2171f82b7d9a6b821978a3ec7231699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ad2171f82b7d9a6b821978a3ec7231699">basicBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ad2171f82b7d9a6b821978a3ec7231699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a basic block exists.  <br /></td></tr>
<tr class="separator:ad2171f82b7d9a6b821978a3ec7231699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b93e544af0414bbde53c9f73db95909" id="r_a5b93e544af0414bbde53c9f73db95909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a5b93e544af0414bbde53c9f73db95909">basicBlockExists</a> (rose_addr_t startOfBlock) const</td></tr>
<tr class="memdesc:a5b93e544af0414bbde53c9f73db95909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a basic block exists.  <br /></td></tr>
<tr class="separator:a5b93e544af0414bbde53c9f73db95909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a096b86ea1c9a55d039e84a80b19ffbed" id="r_a096b86ea1c9a55d039e84a80b19ffbed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a096b86ea1c9a55d039e84a80b19ffbed">dataBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a096b86ea1c9a55d039e84a80b19ffbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a data block exists.  <br /></td></tr>
<tr class="separator:a096b86ea1c9a55d039e84a80b19ffbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014d45a62e594a723ddec8f8f007501" id="r_a0014d45a62e594a723ddec8f8f007501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a0014d45a62e594a723ddec8f8f007501">dataBlockExists</a> (rose_addr_t va, rose_addr_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#afe746c0c45ff5b356404831cb2a50fba">size</a>) const</td></tr>
<tr class="memdesc:a0014d45a62e594a723ddec8f8f007501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a data block exists.  <br /></td></tr>
<tr class="separator:a0014d45a62e594a723ddec8f8f007501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab92a93fd87cd8a2ce873b70a59c8960d" id="r_ab92a93fd87cd8a2ce873b70a59c8960d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ab92a93fd87cd8a2ce873b70a59c8960d">findInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:ab92a93fd87cd8a2ce873b70a59c8960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified instruction, or equivalent.  <br /></td></tr>
<tr class="separator:ab92a93fd87cd8a2ce873b70a59c8960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515458819be08635d3e4f444fdbb601b" id="r_a515458819be08635d3e4f444fdbb601b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a515458819be08635d3e4f444fdbb601b">findInstruction</a> (rose_addr_t va) const</td></tr>
<tr class="memdesc:a515458819be08635d3e4f444fdbb601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified instruction, or equivalent.  <br /></td></tr>
<tr class="separator:a515458819be08635d3e4f444fdbb601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad97e19dd69bfdb9fed43e192abf85de1" id="r_ad97e19dd69bfdb9fed43e192abf85de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ad97e19dd69bfdb9fed43e192abf85de1">findBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ad97e19dd69bfdb9fed43e192abf85de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified basic block, or equivalent.  <br /></td></tr>
<tr class="separator:ad97e19dd69bfdb9fed43e192abf85de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93434e9b13cf794c2db28eb395c5dd40" id="r_a93434e9b13cf794c2db28eb395c5dd40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a93434e9b13cf794c2db28eb395c5dd40">findBasicBlock</a> (rose_addr_t va) const</td></tr>
<tr class="memdesc:a93434e9b13cf794c2db28eb395c5dd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified basic block, or equivalent.  <br /></td></tr>
<tr class="separator:a93434e9b13cf794c2db28eb395c5dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb294e0f4b759a68c46aa6824fc91d80" id="r_afb294e0f4b759a68c46aa6824fc91d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#afb294e0f4b759a68c46aa6824fc91d80">findDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:afb294e0f4b759a68c46aa6824fc91d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified data block, or equivalent.  <br /></td></tr>
<tr class="separator:afb294e0f4b759a68c46aa6824fc91d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036a3352284bdb6dfd966925ab428384" id="r_a036a3352284bdb6dfd966925ab428384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a036a3352284bdb6dfd966925ab428384">findDataBlock</a> (rose_addr_t va, rose_addr_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#afe746c0c45ff5b356404831cb2a50fba">size</a>) const</td></tr>
<tr class="memdesc:a036a3352284bdb6dfd966925ab428384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified data block, or equivalent.  <br /></td></tr>
<tr class="separator:a036a3352284bdb6dfd966925ab428384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54afc1e6c988f82b68396a77fe4f4f85" id="r_a54afc1e6c988f82b68396a77fe4f4f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a54afc1e6c988f82b68396a77fe4f4f85">spanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a54afc1e6c988f82b68396a77fe4f4f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find address users that span the entire interval.  <br /></td></tr>
<tr class="separator:a54afc1e6c988f82b68396a77fe4f4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aae655048152a59566b64b3ce8f045c" id="r_a0aae655048152a59566b64b3ce8f045c"><td class="memTemplParams" colspan="2">template&lt;class UserPredicate &gt; </td></tr>
<tr class="memitem:a0aae655048152a59566b64b3ce8f045c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a0aae655048152a59566b64b3ce8f045c">spanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;interval, UserPredicate userPredicate) const</td></tr>
<tr class="memdesc:a0aae655048152a59566b64b3ce8f045c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find address users that span the entire interval.  <br /></td></tr>
<tr class="separator:a0aae655048152a59566b64b3ce8f045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad71e8e7dc436ccc39ce7dab075134f51" id="r_ad71e8e7dc436ccc39ce7dab075134f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#ad71e8e7dc436ccc39ce7dab075134f51">overlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:ad71e8e7dc436ccc39ce7dab075134f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Users that overlap the interval.  <br /></td></tr>
<tr class="separator:ad71e8e7dc436ccc39ce7dab075134f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d62551c81cf0df7357261e6443ff26" id="r_aa5d62551c81cf0df7357261e6443ff26"><td class="memTemplParams" colspan="2">template&lt;class UserPredicate &gt; </td></tr>
<tr class="memitem:aa5d62551c81cf0df7357261e6443ff26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#aa5d62551c81cf0df7357261e6443ff26">overlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;interval, UserPredicate userPredicate) const</td></tr>
<tr class="memdesc:aa5d62551c81cf0df7357261e6443ff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Users that overlap the interval.  <br /></td></tr>
<tr class="separator:aa5d62551c81cf0df7357261e6443ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c995c751faf8ceeaef57542f296254d" id="r_a4c995c751faf8ceeaef57542f296254d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html#a4c995c751faf8ceeaef57542f296254d">containedIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a4c995c751faf8ceeaef57542f296254d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Users that are fully contained in the interval.  <br /></td></tr>
<tr class="separator:a4c995c751faf8ceeaef57542f296254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aca6be5362dbc1bad3d7b35c976f8a500" name="aca6be5362dbc1bad3d7b35c976f8a500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6be5362dbc1bad3d7b35c976f8a500">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a map is empty. </p>
<p>Returns true if the map contains no instructions or data, false if it contains at least one instruction or at least one data block. </p>

</div>
</div>
<a id="afe746c0c45ff5b356404831cb2a50fba" name="afe746c0c45ff5b356404831cb2a50fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe746c0c45ff5b356404831cb2a50fba">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of addresses represented by the map. </p>
<p>Returns the number of addresses that have at least one user. This is a constant-time operation. </p>

</div>
</div>
<a id="aa583c8c9c821943595f34701f20146ec" name="aa583c8c9c821943595f34701f20146ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa583c8c9c821943595f34701f20146ec">&#9670;&#160;</a></span>hull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::hull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum and maximum used addresses. </p>
<p>Returns minimum and maximum addresses that exist in this address usage map. If the map is empty then the returned interval is empty, containing neither a minimum nor maximum address. </p>

</div>
</div>
<a id="a551b56038c1899f7d0c9c054a56c4730" name="a551b56038c1899f7d0c9c054a56c4730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b56038c1899f7d0c9c054a56c4730">&#9670;&#160;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::extent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses represented. </p>
<p>Returns the set of addresses that are represented. </p>

</div>
</div>
<a id="a16bb3d870b716b07ed1345174aff2249" name="a16bb3d870b716b07ed1345174aff2249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb3d870b716b07ed1345174aff2249">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::exists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate to determine whether an address is used. </p>
<p>Returns true if the specified address belongs to any instruction, basic block, or data block. This is a O(log N) operation where N is the number of contiguous intervals in this address usage map. It may be slightly faster than some of the other methods since it doesn't need to construct a non-POD return value. </p>

</div>
</div>
<a id="a23ca843b9a624e05d0a51289c3b3bf94" name="a23ca843b9a624e05d0a51289c3b3bf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ca843b9a624e05d0a51289c3b3bf94">&#9670;&#160;</a></span>anyExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::anyExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate to determine whether any of the specified addresses are used. </p>
<p>Returns true if any address in the specified set or interval belongs to any instruction, basic block, or data block. This may be slightly faster than some of the other predicates because it doesn't need to construct a non-POD return value. </p>

</div>
</div>
<a id="a32e69288af4d8b549e0beace18e0ece6" name="a32e69288af4d8b549e0beace18e0ece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e69288af4d8b549e0beace18e0ece6">&#9670;&#160;</a></span>anyExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::anyExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate to determine whether any of the specified addresses are used. </p>
<p>Returns true if any address in the specified set or interval belongs to any instruction, basic block, or data block. This may be slightly faster than some of the other predicates because it doesn't need to construct a non-POD return value. </p>

</div>
</div>
<a id="ac374f1cbbfc3b9804a9c6cb8fc3f074f" name="ac374f1cbbfc3b9804a9c6cb8fc3f074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac374f1cbbfc3b9804a9c6cb8fc3f074f">&#9670;&#160;</a></span>unusedExtent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::unusedExtent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses not represented. </p>
<p>Returns the set of addresses that are not represented. The nBits argument is the number of bits in the virtual address space, usually 32 or 64, and must be between 1 and 64, inclusive. Alternatively, an interval or interval set can be supplied to limit the return value. </p>

</div>
</div>
<a id="a9f1d8b45284a0cad0476c08a20eca8c8" name="a9f1d8b45284a0cad0476c08a20eca8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1d8b45284a0cad0476c08a20eca8c8">&#9670;&#160;</a></span>unusedExtent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::unusedExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses not represented. </p>
<p>Returns the set of addresses that are not represented. The nBits argument is the number of bits in the virtual address space, usually 32 or 64, and must be between 1 and 64, inclusive. Alternatively, an interval or interval set can be supplied to limit the return value. </p>

</div>
</div>
<a id="a02c95f51594a8c9b76a5efc280acfbed" name="a02c95f51594a8c9b76a5efc280acfbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c95f51594a8c9b76a5efc280acfbed">&#9670;&#160;</a></span>unusedExtent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::unusedExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses not represented. </p>
<p>Returns the set of addresses that are not represented. The nBits argument is the number of bits in the virtual address space, usually 32 or 64, and must be between 1 and 64, inclusive. Alternatively, an interval or interval set can be supplied to limit the return value. </p>

</div>
</div>
<a id="ad1e84e0df29869ff17c27618875acaf1" name="ad1e84e0df29869ff17c27618875acaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e84e0df29869ff17c27618875acaf1">&#9670;&#160;</a></span>nextUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::nextUnused </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>minVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next unused address interval. </p>
<p>Returns the next address interval that begins at or after the specified address and which does not correspond to any instruction, basic block, data block, or function. The largest such interval is returned, but it will not contain any values less than <code>minVa</code>. Returns an empty interval if no such interval exists. </p>

</div>
</div>
<a id="add0ddc34f5d79b8f0912ec1cc2ab48fe" name="add0ddc34f5d79b8f0912ec1cc2ab48fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0ddc34f5d79b8f0912ec1cc2ab48fe">&#9670;&#160;</a></span>instructionExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::instructionExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified instruction or an equivalent exists. </p>
<p>Returns the instruction or equivalent that exists, otherwise null. </p>

</div>
</div>
<a id="aa770f50e46d3db46a119fdaf0b8961d1" name="aa770f50e46d3db46a119fdaf0b8961d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa770f50e46d3db46a119fdaf0b8961d1">&#9670;&#160;</a></span>instructionExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::instructionExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the specified instruction or an equivalent exists. </p>
<p>Returns the instruction or equivalent that exists, otherwise null. </p>

</div>
</div>
<a id="ad2171f82b7d9a6b821978a3ec7231699" name="ad2171f82b7d9a6b821978a3ec7231699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2171f82b7d9a6b821978a3ec7231699">&#9670;&#160;</a></span>basicBlockExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::basicBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a basic block exists. </p>
<p>If the specified basic block's starting address exists in this AUM and is the starting instruction of this basic block or an equivalent then returns a pointer to the existing basic block, otherwise the null pointer is returned. A basic block exists only when it has at least one instruction; this is contrary to the CFG, where a basic block can be represented by a placeholder with no instructions. </p>

</div>
</div>
<a id="a5b93e544af0414bbde53c9f73db95909" name="a5b93e544af0414bbde53c9f73db95909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b93e544af0414bbde53c9f73db95909">&#9670;&#160;</a></span>basicBlockExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::basicBlockExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startOfBlock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a basic block exists. </p>
<p>If the specified basic block's starting address exists in this AUM and is the starting instruction of this basic block or an equivalent then returns a pointer to the existing basic block, otherwise the null pointer is returned. A basic block exists only when it has at least one instruction; this is contrary to the CFG, where a basic block can be represented by a placeholder with no instructions. </p>

</div>
</div>
<a id="a096b86ea1c9a55d039e84a80b19ffbed" name="a096b86ea1c9a55d039e84a80b19ffbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096b86ea1c9a55d039e84a80b19ffbed">&#9670;&#160;</a></span>dataBlockExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::dataBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a data block exists. </p>
<p>If the specified data block or an equivalent exists in the map then a pointer to the exsiting data block is returned, otherwise a null pointer is returned. </p>

</div>
</div>
<a id="a0014d45a62e594a723ddec8f8f007501" name="a0014d45a62e594a723ddec8f8f007501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0014d45a62e594a723ddec8f8f007501">&#9670;&#160;</a></span>dataBlockExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::dataBlockExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a data block exists. </p>
<p>If the specified data block or an equivalent exists in the map then a pointer to the exsiting data block is returned, otherwise a null pointer is returned. </p>

</div>
</div>
<a id="ab92a93fd87cd8a2ce873b70a59c8960d" name="ab92a93fd87cd8a2ce873b70a59c8960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92a93fd87cd8a2ce873b70a59c8960d">&#9670;&#160;</a></span>findInstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified instruction, or equivalent. </p>
<p>If the specified instruction or an equivalent instruction exists in this object, then its record is returned, otherwise an empty record is returned. The instruction can be indicated by either an <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> object or a starting address. </p>

</div>
</div>
<a id="a515458819be08635d3e4f444fdbb601b" name="a515458819be08635d3e4f444fdbb601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515458819be08635d3e4f444fdbb601b">&#9670;&#160;</a></span>findInstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findInstruction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified instruction, or equivalent. </p>
<p>If the specified instruction or an equivalent instruction exists in this object, then its record is returned, otherwise an empty record is returned. The instruction can be indicated by either an <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> object or a starting address. </p>

</div>
</div>
<a id="ad97e19dd69bfdb9fed43e192abf85de1" name="ad97e19dd69bfdb9fed43e192abf85de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e19dd69bfdb9fed43e192abf85de1">&#9670;&#160;</a></span>findBasicBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified basic block, or equivalent. </p>
<p>If the specified basic block or an equivalent basic block (based on starting address) is present in this list, then return its record, otherwise return an empty record. This looks up the basic block by looking for its first instruction, therefore returns a record only if the first instruction is present. The basic block can be specified by either a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a> object or a starting address. </p>

</div>
</div>
<a id="a93434e9b13cf794c2db28eb395c5dd40" name="a93434e9b13cf794c2db28eb395c5dd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93434e9b13cf794c2db28eb395c5dd40">&#9670;&#160;</a></span>findBasicBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified basic block, or equivalent. </p>
<p>If the specified basic block or an equivalent basic block (based on starting address) is present in this list, then return its record, otherwise return an empty record. This looks up the basic block by looking for its first instruction, therefore returns a record only if the first instruction is present. The basic block can be specified by either a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a> object or a starting address. </p>

</div>
</div>
<a id="afb294e0f4b759a68c46aa6824fc91d80" name="afb294e0f4b759a68c46aa6824fc91d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb294e0f4b759a68c46aa6824fc91d80">&#9670;&#160;</a></span>findDataBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified data block, or equivalent. </p>
<p>If the specified data block or an equivalent data block exists in this object, then its record is returned, otherwise an empty record is returned. The data block can be specified by either a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a> object or a starting address and size. </p>

</div>
</div>
<a id="a036a3352284bdb6dfd966925ab428384" name="a036a3352284bdb6dfd966925ab428384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036a3352284bdb6dfd966925ab428384">&#9670;&#160;</a></span>findDataBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::findDataBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> record for the specified data block, or equivalent. </p>
<p>If the specified data block or an equivalent data block exists in this object, then its record is returned, otherwise an empty record is returned. The data block can be specified by either a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataBlock.html">DataBlock</a> object or a starting address and size. </p>

</div>
</div>
<a id="ae8a7a2956b099936ff3292ec5de42e06" name="ae8a7a2956b099936ff3292ec5de42e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a7a2956b099936ff3292ec5de42e06">&#9670;&#160;</a></span>insertInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::insertInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the instruction along with an owning basic block. </p>
<p>Inserts the specified instruction and its owning basic block if the information is not already present in this AUM. Returns the relavent address user information since this method might substitute existing equivalent instruction and owner. </p>

</div>
</div>
<a id="a0fd147c6aa9b87110d01e9ebee815bb9" name="a0fd147c6aa9b87110d01e9ebee815bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd147c6aa9b87110d01e9ebee815bb9">&#9670;&#160;</a></span>insertDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::insertDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the data block. </p>
<p>Inserts the specified data block if an equivalent data block is not already present. Returns the relevant address user information since this method might substitute an existing equivalent data block. </p>

</div>
</div>
<a id="a03b2321f80754602f078b08c6f59ada0" name="a03b2321f80754602f078b08c6f59ada0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b2321f80754602f078b08c6f59ada0">&#9670;&#160;</a></span>eraseInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::eraseInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified instruction/basic block pair. </p>
<p>If the specified instruction or equivalent is found in this AUM then the specified basic block is removed as one of its owners. If this leaves the instruction with no owning basic blocks, then the instruction itself is also removed. Returns the affected instruction. </p>

</div>
</div>
<a id="a356322e37d7b6e1d4a4292c4c71b1232" name="a356322e37d7b6e1d4a4292c4c71b1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356322e37d7b6e1d4a4292c4c71b1232">&#9670;&#160;</a></span>eraseDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::eraseDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the specified data block. </p>
<p>Removes the specified data block or an equivalent from this AUM. Returns the data block that was erased. </p>

</div>
</div>
<a id="a54afc1e6c988f82b68396a77fe4f4f85" name="a54afc1e6c988f82b68396a77fe4f4f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54afc1e6c988f82b68396a77fe4f4f85">&#9670;&#160;</a></span>spanning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::spanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find address users that span the entire interval. </p>
<p>The return value is a vector of address users (instructions and/or data blocks) sorted by starting address where each user starts at or before the beginning of the interval and ends at or after the end of the interval. The specified predicate is used to select which users are inserted into the result and should be a functor that takes an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> as an argument and returns true to select that user for inclusion in the result. </p>

</div>
</div>
<a id="a0aae655048152a59566b64b3ce8f045c" name="a0aae655048152a59566b64b3ce8f045c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aae655048152a59566b64b3ce8f045c">&#9670;&#160;</a></span>spanning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::spanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserPredicate&#160;</td>
          <td class="paramname"><em>userPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find address users that span the entire interval. </p>
<p>The return value is a vector of address users (instructions and/or data blocks) sorted by starting address where each user starts at or before the beginning of the interval and ends at or after the end of the interval. The specified predicate is used to select which users are inserted into the result and should be a functor that takes an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> as an argument and returns true to select that user for inclusion in the result. </p>

<p class="definition">Definition at line <a class="el" href="AddressUsageMap_8h_source.html#l00549">549</a> of file <a class="el" href="AddressUsageMap_8h_source.html">AddressUsageMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::findAll()</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html#a6833490ce80bf95e09ae5d6c799fbe69">Rose::BinaryAnalysis::Partitioner2::AddressUsers::intersection()</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html#a0f7ac0a824c30ad966a03aa9af7d5ed8">Rose::BinaryAnalysis::Partitioner2::AddressUsers::isEmpty()</a>, and <a class="el" href="AddressUsageMap_8h_source.html#l00292">Rose::BinaryAnalysis::Partitioner2::AddressUsers::select()</a>.</p>

</div>
</div>
<a id="ad71e8e7dc436ccc39ce7dab075134f51" name="ad71e8e7dc436ccc39ce7dab075134f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71e8e7dc436ccc39ce7dab075134f51">&#9670;&#160;</a></span>overlapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::overlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Users that overlap the interval. </p>
<p>The return value is a vector of address users (instructions and/or data blocks) sorted by starting address where each user overlaps with the interval. That is, at least one byte of the instruction or data block came from the specified interval of byte addresses. The specified predicate is used to select which users are inserted into the result and should be a functor that takes an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> as an argument and returns true to select that user for inclusion in the result. </p>

</div>
</div>
<a id="aa5d62551c81cf0df7357261e6443ff26" name="aa5d62551c81cf0df7357261e6443ff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d62551c81cf0df7357261e6443ff26">&#9670;&#160;</a></span>overlapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::overlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserPredicate&#160;</td>
          <td class="paramname"><em>userPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Users that overlap the interval. </p>
<p>The return value is a vector of address users (instructions and/or data blocks) sorted by starting address where each user overlaps with the interval. That is, at least one byte of the instruction or data block came from the specified interval of byte addresses. The specified predicate is used to select which users are inserted into the result and should be a functor that takes an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> as an argument and returns true to select that user for inclusion in the result. </p>

<p class="definition">Definition at line <a class="el" href="AddressUsageMap_8h_source.html#l00574">574</a> of file <a class="el" href="AddressUsageMap_8h_source.html">AddressUsageMap.h</a>.</p>

<p class="reference">References <a class="el" href="IntervalMap_8h_source.html#l00413">Sawyer::Container::IntervalMap&lt; I, T, Policy &gt;::findAll()</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html#a4ee0904943aca55a25b22d09e251d0c5">Rose::BinaryAnalysis::Partitioner2::AddressUsers::insert()</a>.</p>

</div>
</div>
<a id="a4c995c751faf8ceeaef57542f296254d" name="a4c995c751faf8ceeaef57542f296254d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c995c751faf8ceeaef57542f296254d">&#9670;&#160;</a></span>containedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsers.html">AddressUsers</a> Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::containedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Users that are fully contained in the interval. </p>
<p>The return value is a vector of address users (instructions and/or data blocks) sorted by starting address where each user is fully contained within the specified interval. That is, each user starts at or after the beginning of the interval and ends at or before the end of the interval. The specified predicate is used to select which users are inserted into the result and should be a functor that takes an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html" title="Address usage item.">AddressUser</a> as an argument and returns true to select that user for inclusion in the result. </p>

</div>
</div>
<a id="af24082b068b5ec2ee605a8624ad7883e" name="af24082b068b5ec2ee605a8624ad7883e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24082b068b5ec2ee605a8624ad7883e">&#9670;&#160;</a></span>leastUnmapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::leastUnmapped </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the least unmapped address with specified lower limit. </p>
<p>Returns the smallest unmapped address that is greater than or equal to <code>startVa</code>. If no such address exists then nothing is returned. </p>

</div>
</div>
<a id="ad3d44a0d7a1586df8982d62ac6ca605c" name="ad3d44a0d7a1586df8982d62ac6ca605c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d44a0d7a1586df8982d62ac6ca605c">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of this AUM to a stream. </p>
<p>The output contains one entry per line and the last line is terminated with a linefeed. </p>

</div>
</div>
<a id="a80e7b20c3d73cf8645341f258937c63b" name="a80e7b20c3d73cf8645341f258937c63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e7b20c3d73cf8645341f258937c63b">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::AddressUsageMap::checkConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check invariants. </p>
<p>Aborts if invariants are not satisified. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AddressUsageMap_8h_source.html">AddressUsageMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
