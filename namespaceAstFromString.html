<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: AstFromString Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">AstFromString Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Parser building blocks for creating simple recursive descent parsers generating AST from strings. </p>
<p>Liao 4/13/2011 An experimental SgStatement* SageBuilder::buildStatementFromString(string&amp;, SgScopeStatement* scope) is provided. 10/2015</p>
<p>Support creating simple recursive descent parsers of source code annotations</p>
<p>The namespace, <a class="el" href="namespaceAstFromString.html" title="Parser building blocks for creating simple recursive descent parsers generating AST from strings.">AstFromString</a>, collects a set of helper functions (or parser building blocks) that operate on an input string to create simple recursive descent parsers for source code annotations(C/C++ pragmas or Fortran comments). </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Character check , without side effect on the current position</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>utility functions for checking characters, without changing the current position of the input string being parsed. </p>
</div></td></tr>
<tr class="memitem:ada0d171a30f169d5620272c66d3d5c8c" id="r_ada0d171a30f169d5620272c66d3d5c8c"><td class="memItemLeft" align="right" valign="top"><a id="ada0d171a30f169d5620272c66d3d5c8c" name="ada0d171a30f169d5620272c66d3d5c8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_is_digit</b> ()</td></tr>
<tr class="memdesc:ada0d171a30f169d5620272c66d3d5c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current character is a digit. The current position of the input string remains unchanged either way. <br /></td></tr>
<tr class="separator:ada0d171a30f169d5620272c66d3d5c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c0b5acd1cd30df98bb570357c845ea" id="r_a72c0b5acd1cd30df98bb570357c845ea"><td class="memItemLeft" align="right" valign="top"><a id="a72c0b5acd1cd30df98bb570357c845ea" name="a72c0b5acd1cd30df98bb570357c845ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_is_identifier_char</b> ()</td></tr>
<tr class="memdesc:a72c0b5acd1cd30df98bb570357c845ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current character is a legal identifier character, including letters, digits, '_' and '$' (For fortran). No side effect on the current position. <br /></td></tr>
<tr class="separator:a72c0b5acd1cd30df98bb570357c845ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05677585e184ef8a881a8565a26ffb28" id="r_a05677585e184ef8a881a8565a26ffb28"><td class="memItemLeft" align="right" valign="top"><a id="a05677585e184ef8a881a8565a26ffb28" name="a05677585e184ef8a881a8565a26ffb28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_is_letter</b> ()</td></tr>
<tr class="memdesc:a05677585e184ef8a881a8565a26ffb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current character is a letter. No side effect on the current position of the input string. <br /></td></tr>
<tr class="separator:a05677585e184ef8a881a8565a26ffb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b24b41cef8d03a45ca8a079c8b2350" id="r_a11b24b41cef8d03a45ca8a079c8b2350"><td class="memItemLeft" align="right" valign="top"><a id="a11b24b41cef8d03a45ca8a079c8b2350" name="a11b24b41cef8d03a45ca8a079c8b2350"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_is_lower_letter</b> ()</td></tr>
<tr class="memdesc:a11b24b41cef8d03a45ca8a079c8b2350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current character is a lower case letter. <br /></td></tr>
<tr class="separator:a11b24b41cef8d03a45ca8a079c8b2350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad82524f84140c3e4d595a9e9fb5a132" id="r_aad82524f84140c3e4d595a9e9fb5a132"><td class="memItemLeft" align="right" valign="top"><a id="aad82524f84140c3e4d595a9e9fb5a132" name="aad82524f84140c3e4d595a9e9fb5a132"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_is_upper_letter</b> ()</td></tr>
<tr class="memdesc:aad82524f84140c3e4d595a9e9fb5a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current character is a upper case letter. <br /></td></tr>
<tr class="separator:aad82524f84140c3e4d595a9e9fb5a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Match with side effects (set c_parsed_node and advance the current position of character) if successful. Return false and have no side effects if the match fails.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>utility functions for matching string, whitespace, identifiers, const etc. Successful match will advance the current position. entry point, declarations, types Follow the order of <a href="http://www.antlr.org/grammar/1153358328744/C.g">http://www.antlr.org/grammar/1153358328744/C.g</a> </p>
</div></td></tr>
<tr class="memitem:a8e29d0d0e7d11398fbc2dfdbe5e95a3c" id="r_a8e29d0d0e7d11398fbc2dfdbe5e95a3c"><td class="memItemLeft" align="right" valign="top"><a id="a8e29d0d0e7d11398fbc2dfdbe5e95a3c" name="a8e29d0d0e7d11398fbc2dfdbe5e95a3c"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_char</b> (char c)</td></tr>
<tr class="memdesc:a8e29d0d0e7d11398fbc2dfdbe5e95a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">match a char, advance one position if successful. <br /></td></tr>
<tr class="separator:a8e29d0d0e7d11398fbc2dfdbe5e95a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e88c8fc182d4043da2c2f49f4e1f75f" id="r_a1e88c8fc182d4043da2c2f49f4e1f75f"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#a1e88c8fc182d4043da2c2f49f4e1f75f">afs_match_substr</a> (const char *substr, bool checkTrail=true)</td></tr>
<tr class="memdesc:a1e88c8fc182d4043da2c2f49f4e1f75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a sub string: a given sub c string from the input c string, again skip heading space/tabs if any.  <br /></td></tr>
<tr class="separator:a1e88c8fc182d4043da2c2f49f4e1f75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530782211ee5c81f32ce7db884a04467" id="r_a530782211ee5c81f32ce7db884a04467"><td class="memItemLeft" align="right" valign="top"><a id="a530782211ee5c81f32ce7db884a04467" name="a530782211ee5c81f32ce7db884a04467"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_skip_whitespace</b> ()</td></tr>
<tr class="memdesc:a530782211ee5c81f32ce7db884a04467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and skip whitespace. <br /></td></tr>
<tr class="separator:a530782211ee5c81f32ce7db884a04467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99b13fafd28cedbac3a0efeef9fcab" id="r_a9e99b13fafd28cedbac3a0efeef9fcab"><td class="memItemLeft" align="right" valign="top"><a id="a9e99b13fafd28cedbac3a0efeef9fcab" name="a9e99b13fafd28cedbac3a0efeef9fcab"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_identifier</b> ()</td></tr>
<tr class="memdesc:a9e99b13fafd28cedbac3a0efeef9fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match identifier, move to the next character if successful. The identifier could be a name of a type, function, variable, or label. The resolved identifier (type , variable name, function reference expression, or label name) is stored into c_parsed_node. <br /></td></tr>
<tr class="separator:a9e99b13fafd28cedbac3a0efeef9fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4058f8d7e211177e2e628605bc45d71" id="r_ab4058f8d7e211177e2e628605bc45d71"><td class="memItemLeft" align="right" valign="top"><a id="ab4058f8d7e211177e2e628605bc45d71" name="ab4058f8d7e211177e2e628605bc45d71"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_integer_const</b> (int *result)</td></tr>
<tr class="memdesc:ab4058f8d7e211177e2e628605bc45d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an integer constant, store it into result. <br /></td></tr>
<tr class="separator:ab4058f8d7e211177e2e628605bc45d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e904914c0f884224caffaac71aed92" id="r_ae3e904914c0f884224caffaac71aed92"><td class="memItemLeft" align="right" valign="top"><a id="ae3e904914c0f884224caffaac71aed92" name="ae3e904914c0f884224caffaac71aed92"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_double_const</b> (double *result)</td></tr>
<tr class="memdesc:ae3e904914c0f884224caffaac71aed92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an double constant, store it into result. <br /></td></tr>
<tr class="separator:ae3e904914c0f884224caffaac71aed92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c76f5e57e03bc6aba0a2b18916c4fd" id="r_a24c76f5e57e03bc6aba0a2b18916c4fd"><td class="memItemLeft" align="right" valign="top"><a id="a24c76f5e57e03bc6aba0a2b18916c4fd" name="a24c76f5e57e03bc6aba0a2b18916c4fd"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_translation_unit</b> ()</td></tr>
<tr class="memdesc:a24c76f5e57e03bc6aba0a2b18916c4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a translation unit. Not yet implemented. <br /></td></tr>
<tr class="separator:a24c76f5e57e03bc6aba0a2b18916c4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059846d56888bc0f8acbc0f8e8fa8df2" id="r_a059846d56888bc0f8acbc0f8e8fa8df2"><td class="memItemLeft" align="right" valign="top"><a id="a059846d56888bc0f8acbc0f8e8fa8df2" name="a059846d56888bc0f8acbc0f8e8fa8df2"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_external_declaration</b> ()</td></tr>
<tr class="memdesc:a059846d56888bc0f8acbc0f8e8fa8df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an external declaration. Not yet implemented. <br /></td></tr>
<tr class="separator:a059846d56888bc0f8acbc0f8e8fa8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05f5bbc17d0013edda8a49c4d29fae0" id="r_ae05f5bbc17d0013edda8a49c4d29fae0"><td class="memItemLeft" align="right" valign="top"><a id="ae05f5bbc17d0013edda8a49c4d29fae0" name="ae05f5bbc17d0013edda8a49c4d29fae0"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_function_definition</b> ()</td></tr>
<tr class="memdesc:ae05f5bbc17d0013edda8a49c4d29fae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a function definition. Not yet implemented. <br /></td></tr>
<tr class="separator:ae05f5bbc17d0013edda8a49c4d29fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae491485f86289feb92b584f5b1497347" id="r_ae491485f86289feb92b584f5b1497347"><td class="memItemLeft" align="right" valign="top"><a id="ae491485f86289feb92b584f5b1497347" name="ae491485f86289feb92b584f5b1497347"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_declaration</b> ()</td></tr>
<tr class="memdesc:ae491485f86289feb92b584f5b1497347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a declaration. Only the simplest int i=9; style declaration is supported for now. <br /></td></tr>
<tr class="separator:ae491485f86289feb92b584f5b1497347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919be5304d03a13e7ee7226c4e5d6c28" id="r_a919be5304d03a13e7ee7226c4e5d6c28"><td class="memItemLeft" align="right" valign="top"><a id="a919be5304d03a13e7ee7226c4e5d6c28" name="a919be5304d03a13e7ee7226c4e5d6c28"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_declaration_specifiers</b> (<a class="el" href="classSgType.html">SgType</a> **tt)</td></tr>
<tr class="memdesc:a919be5304d03a13e7ee7226c4e5d6c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match declaration specifiers, store the matched type into *tt. <br /></td></tr>
<tr class="separator:a919be5304d03a13e7ee7226c4e5d6c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b690bc1027eab8c220b8b3209dd4678" id="r_a5b690bc1027eab8c220b8b3209dd4678"><td class="memItemLeft" align="right" valign="top"><a id="a5b690bc1027eab8c220b8b3209dd4678" name="a5b690bc1027eab8c220b8b3209dd4678"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_init_declarator_list</b> ()</td></tr>
<tr class="memdesc:a5b690bc1027eab8c220b8b3209dd4678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an init declarator list. Not yet implemented. <br /></td></tr>
<tr class="separator:a5b690bc1027eab8c220b8b3209dd4678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9caed7be42daf11a88f49feb914d59" id="r_aeb9caed7be42daf11a88f49feb914d59"><td class="memItemLeft" align="right" valign="top"><a id="aeb9caed7be42daf11a88f49feb914d59" name="aeb9caed7be42daf11a88f49feb914d59"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_init_declarator</b> (<a class="el" href="classSgType.html">SgType</a> *orig_type, <a class="el" href="classSgType.html">SgType</a> **mod_type, <a class="el" href="classSgName.html">SgName</a> **sname, <a class="el" href="classSgExpression.html">SgExpression</a> **initializer)</td></tr>
<tr class="memdesc:aeb9caed7be42daf11a88f49feb914d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match init declarator. Store created mod_type, name, and initializer. Original type is needed as input to generate the modifier type. <br /></td></tr>
<tr class="separator:aeb9caed7be42daf11a88f49feb914d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44d5360a04314811c2a4b3f831388b" id="r_a5d44d5360a04314811c2a4b3f831388b"><td class="memItemLeft" align="right" valign="top"><a id="a5d44d5360a04314811c2a4b3f831388b" name="a5d44d5360a04314811c2a4b3f831388b"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_storage_class_specifier</b> ()</td></tr>
<tr class="memdesc:a5d44d5360a04314811c2a4b3f831388b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a storage class specifier. Not yet implemented. <br /></td></tr>
<tr class="separator:a5d44d5360a04314811c2a4b3f831388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e426325ec77fb5195998c00bfca6f70" id="r_a1e426325ec77fb5195998c00bfca6f70"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#a1e426325ec77fb5195998c00bfca6f70">afs_match_type_specifier</a> (bool checkTrail=true)</td></tr>
<tr class="separator:a1e426325ec77fb5195998c00bfca6f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7563b597c06ad0908c34ae886de57b37" id="r_a7563b597c06ad0908c34ae886de57b37"><td class="memItemLeft" align="right" valign="top"><a id="a7563b597c06ad0908c34ae886de57b37" name="a7563b597c06ad0908c34ae886de57b37"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_specifier_qualifier_list</b> (std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:a7563b597c06ad0908c34ae886de57b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a list of specifiers and qualifiers : : ( type_qualifier | type_specifier )+. <br /></td></tr>
<tr class="separator:a7563b597c06ad0908c34ae886de57b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed52a9b114253792dd46980a8b191c1" id="r_a7ed52a9b114253792dd46980a8b191c1"><td class="memItemLeft" align="right" valign="top"><a id="a7ed52a9b114253792dd46980a8b191c1" name="a7ed52a9b114253792dd46980a8b191c1"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_type_qualifier</b> ()</td></tr>
<tr class="memdesc:a7ed52a9b114253792dd46980a8b191c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a type qualifier : 'const' | 'volatile'. <br /></td></tr>
<tr class="separator:a7ed52a9b114253792dd46980a8b191c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2458e8de86ce3b18fb8126d28137e8f" id="r_af2458e8de86ce3b18fb8126d28137e8f"><td class="memItemLeft" align="right" valign="top"><a id="af2458e8de86ce3b18fb8126d28137e8f" name="af2458e8de86ce3b18fb8126d28137e8f"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_declarator</b> (<a class="el" href="classSgType.html">SgType</a> *orig_type, <a class="el" href="classSgType.html">SgType</a> **modified_type)</td></tr>
<tr class="memdesc:af2458e8de86ce3b18fb8126d28137e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a declarator. <br /></td></tr>
<tr class="separator:af2458e8de86ce3b18fb8126d28137e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35528a0f8e9476c33828f0919440650" id="r_aa35528a0f8e9476c33828f0919440650"><td class="memItemLeft" align="right" valign="top"><a id="aa35528a0f8e9476c33828f0919440650" name="aa35528a0f8e9476c33828f0919440650"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_direct_declarator</b> ()</td></tr>
<tr class="memdesc:aa35528a0f8e9476c33828f0919440650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a direct declarator. <br /></td></tr>
<tr class="separator:aa35528a0f8e9476c33828f0919440650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ca141292626df0d2cdd8805a68a36" id="r_a290ca141292626df0d2cdd8805a68a36"><td class="memItemLeft" align="right" valign="top"><a id="a290ca141292626df0d2cdd8805a68a36" name="a290ca141292626df0d2cdd8805a68a36"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_pointer</b> (<a class="el" href="classSgType.html">SgType</a> *orig_type)</td></tr>
<tr class="memdesc:a290ca141292626df0d2cdd8805a68a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer constructs like * type. <br /></td></tr>
<tr class="separator:a290ca141292626df0d2cdd8805a68a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9412cdf7a4edac166c46e7ee517ca7" id="r_a6b9412cdf7a4edac166c46e7ee517ca7"><td class="memItemLeft" align="right" valign="top"><a id="a6b9412cdf7a4edac166c46e7ee517ca7" name="a6b9412cdf7a4edac166c46e7ee517ca7"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_type_name</b> ()</td></tr>
<tr class="memdesc:a6b9412cdf7a4edac166c46e7ee517ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a type name : specifier_qualifier_list abstract_declarator? <br /></td></tr>
<tr class="separator:a6b9412cdf7a4edac166c46e7ee517ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6990d5812ceb12a2abdc67c23cd3a0fd" id="r_a6990d5812ceb12a2abdc67c23cd3a0fd"><td class="memItemLeft" align="right" valign="top"><a id="a6990d5812ceb12a2abdc67c23cd3a0fd" name="a6990d5812ceb12a2abdc67c23cd3a0fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_initializer</b> ()</td></tr>
<tr class="memdesc:a6990d5812ceb12a2abdc67c23cd3a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">match a char, advance one position if successful. <br /></td></tr>
<tr class="separator:a6990d5812ceb12a2abdc67c23cd3a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>utility functions for parsing expressions and generate AST pieces for them. Successful match will advance the current position. The function names and grammars largely follow the conventions used in <a href="http://www.antlr.org/grammar/1153358328744/C.g">http://www.antlr.org/grammar/1153358328744/C.g</a>. For example in the grammar shown, | means or, * means 0 or more repetition of the previous term , ? means 0 or 1 occurrence of the previous term. + means 1 or more occurrence. </p>
</div></td></tr>
<tr class="memitem:aa0ab2c6bcfccb09ecdb216122a961e42" id="r_aa0ab2c6bcfccb09ecdb216122a961e42"><td class="memItemLeft" align="right" valign="top"><a id="aa0ab2c6bcfccb09ecdb216122a961e42" name="aa0ab2c6bcfccb09ecdb216122a961e42"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_argument_expression_list</b> ()</td></tr>
<tr class="memdesc:aa0ab2c6bcfccb09ecdb216122a961e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grammar: argument_expression_list : assignment_expression (',' assignment_expression)* one assignment_expression, followed by optionally arbitrary numbers of (',' assignment_expression), store <a class="el" href="classSgExprListExp.html" title="This class represents the concept of a C and C++ expression list.">SgExprListExp</a> to c_parsed_node. <br /></td></tr>
<tr class="separator:aa0ab2c6bcfccb09ecdb216122a961e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5441785c1ce00c2db0432a4cb2b93a2" id="r_ab5441785c1ce00c2db0432a4cb2b93a2"><td class="memItemLeft" align="right" valign="top"><a id="ab5441785c1ce00c2db0432a4cb2b93a2" name="ab5441785c1ce00c2db0432a4cb2b93a2"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_additive_expression</b> ()</td></tr>
<tr class="memdesc:ab5441785c1ce00c2db0432a4cb2b93a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grammar: additive_expression : (multiplicative_expression) ('+' multiplicative_expression | '-' multiplicative_expression)*. <br /></td></tr>
<tr class="separator:ab5441785c1ce00c2db0432a4cb2b93a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f80c41c1d593e1ac6de44a30178ef83" id="r_a1f80c41c1d593e1ac6de44a30178ef83"><td class="memItemLeft" align="right" valign="top"><a id="a1f80c41c1d593e1ac6de44a30178ef83" name="a1f80c41c1d593e1ac6de44a30178ef83"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_multiplicative_expression</b> ()</td></tr>
<tr class="memdesc:a1f80c41c1d593e1ac6de44a30178ef83"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplicative_expression : (cast_expression) ('*' cast_expression | '/' cast_expression | '' cast_expression)* <br /></td></tr>
<tr class="separator:a1f80c41c1d593e1ac6de44a30178ef83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0592cf5777d93b61ee59f0ee436940" id="r_acb0592cf5777d93b61ee59f0ee436940"><td class="memItemLeft" align="right" valign="top"><a id="acb0592cf5777d93b61ee59f0ee436940" name="acb0592cf5777d93b61ee59f0ee436940"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_cast_expression</b> ()</td></tr>
<tr class="memdesc:acb0592cf5777d93b61ee59f0ee436940"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast_expression : '(' type_name ')' cast_expression | unary_expression <br /></td></tr>
<tr class="separator:acb0592cf5777d93b61ee59f0ee436940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ede7a592e19d94278abf7e568d50a5a" id="r_a3ede7a592e19d94278abf7e568d50a5a"><td class="memItemLeft" align="right" valign="top"><a id="a3ede7a592e19d94278abf7e568d50a5a" name="a3ede7a592e19d94278abf7e568d50a5a"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_unary_expression</b> ()</td></tr>
<tr class="memdesc:a3ede7a592e19d94278abf7e568d50a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator cast_expression | SIZEOF unary_expression | SIZEOF '(' type_name ')' <br /></td></tr>
<tr class="separator:a3ede7a592e19d94278abf7e568d50a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109a26d3112677087df302c260733c89" id="r_a109a26d3112677087df302c260733c89"><td class="memItemLeft" align="right" valign="top"><a id="a109a26d3112677087df302c260733c89" name="a109a26d3112677087df302c260733c89"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_postfix_expression</b> ()</td></tr>
<tr class="memdesc:a109a26d3112677087df302c260733c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">postfix_expression : primary_expression ( '[' expression ']' | '(' ')' | '(' argument_expression_list ')' | '.' IDENTIFIER | '-&gt;' IDENTIFIER | '++' | '&ndash;' )* <br /></td></tr>
<tr class="separator:a109a26d3112677087df302c260733c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8dbf260e19c1400cc3caedcb0cf7a" id="r_a2ff8dbf260e19c1400cc3caedcb0cf7a"><td class="memItemLeft" align="right" valign="top"><a id="a2ff8dbf260e19c1400cc3caedcb0cf7a" name="a2ff8dbf260e19c1400cc3caedcb0cf7a"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_primary_expression</b> ()</td></tr>
<tr class="memdesc:a2ff8dbf260e19c1400cc3caedcb0cf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">primary_expression : IDENTIFIER | constant | '(' expression ')' <br /></td></tr>
<tr class="separator:a2ff8dbf260e19c1400cc3caedcb0cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afb3737f249d298c8190a05bbf4b3af" id="r_a3afb3737f249d298c8190a05bbf4b3af"><td class="memItemLeft" align="right" valign="top"><a id="a3afb3737f249d298c8190a05bbf4b3af" name="a3afb3737f249d298c8190a05bbf4b3af"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_constant</b> ()</td></tr>
<tr class="memdesc:a3afb3737f249d298c8190a05bbf4b3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only integer constant is supported for now. Full grammar is constant : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL. <br /></td></tr>
<tr class="separator:a3afb3737f249d298c8190a05bbf4b3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8dbbf161995515372163f5e7d09f9c" id="r_a8e8dbbf161995515372163f5e7d09f9c"><td class="memItemLeft" align="right" valign="top"><a id="a8e8dbbf161995515372163f5e7d09f9c" name="a8e8dbbf161995515372163f5e7d09f9c"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_expression</b> ()</td></tr>
<tr class="memdesc:a8e8dbbf161995515372163f5e7d09f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">expression : assignment_expression (',' assignment_expression)*. Match one or more assignment_expression <br /></td></tr>
<tr class="separator:a8e8dbbf161995515372163f5e7d09f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d5c77b55ee801fc05105babc288af9" id="r_aa8d5c77b55ee801fc05105babc288af9"><td class="memItemLeft" align="right" valign="top"><a id="aa8d5c77b55ee801fc05105babc288af9" name="aa8d5c77b55ee801fc05105babc288af9"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_constant_expression</b> ()</td></tr>
<tr class="memdesc:aa8d5c77b55ee801fc05105babc288af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant_expression : conditional_expression <br /></td></tr>
<tr class="separator:aa8d5c77b55ee801fc05105babc288af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a429ac8628066d6ed3091c4f1582bee" id="r_a3a429ac8628066d6ed3091c4f1582bee"><td class="memItemLeft" align="right" valign="top"><a id="a3a429ac8628066d6ed3091c4f1582bee" name="a3a429ac8628066d6ed3091c4f1582bee"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_assignment_expression</b> ()</td></tr>
<tr class="memdesc:a3a429ac8628066d6ed3091c4f1582bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment_expression : lvalue assignment_operator assignment_expression | conditional_expression <br /></td></tr>
<tr class="separator:a3a429ac8628066d6ed3091c4f1582bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5208cd6d0a46d28d22097b59d34f7ef" id="r_ae5208cd6d0a46d28d22097b59d34f7ef"><td class="memItemLeft" align="right" valign="top"><a id="ae5208cd6d0a46d28d22097b59d34f7ef" name="ae5208cd6d0a46d28d22097b59d34f7ef"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_lvalue</b> ()</td></tr>
<tr class="memdesc:ae5208cd6d0a46d28d22097b59d34f7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">lvalue: unary_expression <br /></td></tr>
<tr class="separator:ae5208cd6d0a46d28d22097b59d34f7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bca9b9c5afc2803a80dddaa72f083a" id="r_a71bca9b9c5afc2803a80dddaa72f083a"><td class="memItemLeft" align="right" valign="top"><a id="a71bca9b9c5afc2803a80dddaa72f083a" name="a71bca9b9c5afc2803a80dddaa72f083a"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_conditional_expression</b> ()</td></tr>
<tr class="memdesc:a71bca9b9c5afc2803a80dddaa72f083a"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditional_expression : logical_or_expression ('?' expression ':' conditional_expression)? '?' means 0 or 1 occurrence <br /></td></tr>
<tr class="separator:a71bca9b9c5afc2803a80dddaa72f083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c6551a134bfb1839db3a3d1607b52b" id="r_a40c6551a134bfb1839db3a3d1607b52b"><td class="memItemLeft" align="right" valign="top"><a id="a40c6551a134bfb1839db3a3d1607b52b" name="a40c6551a134bfb1839db3a3d1607b52b"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_logical_or_expression</b> ()</td></tr>
<tr class="memdesc:a40c6551a134bfb1839db3a3d1607b52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">logical_or_expression : logical_and_expression ('||' logical_and_expression)* <br /></td></tr>
<tr class="separator:a40c6551a134bfb1839db3a3d1607b52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea9b7b6a3129e95eaaf5b44768debd7" id="r_adea9b7b6a3129e95eaaf5b44768debd7"><td class="memItemLeft" align="right" valign="top"><a id="adea9b7b6a3129e95eaaf5b44768debd7" name="adea9b7b6a3129e95eaaf5b44768debd7"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_logical_and_expression</b> ()</td></tr>
<tr class="memdesc:adea9b7b6a3129e95eaaf5b44768debd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">logical_and_expression : inclusive_or_expression ('&amp;&amp;' inclusive_or_expression)* <br /></td></tr>
<tr class="separator:adea9b7b6a3129e95eaaf5b44768debd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffcd96393312fbc2a7663928737f4d4" id="r_adffcd96393312fbc2a7663928737f4d4"><td class="memItemLeft" align="right" valign="top"><a id="adffcd96393312fbc2a7663928737f4d4" name="adffcd96393312fbc2a7663928737f4d4"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_inclusive_or_expression</b> ()</td></tr>
<tr class="memdesc:adffcd96393312fbc2a7663928737f4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">inclusive_or_expression : exclusive_or_expression ('|' exclusive_or_expression)* <br /></td></tr>
<tr class="separator:adffcd96393312fbc2a7663928737f4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa965fb64b1521485ccafb9401aa9ab3e" id="r_aa965fb64b1521485ccafb9401aa9ab3e"><td class="memItemLeft" align="right" valign="top"><a id="aa965fb64b1521485ccafb9401aa9ab3e" name="aa965fb64b1521485ccafb9401aa9ab3e"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_exclusive_or_expression</b> ()</td></tr>
<tr class="memdesc:aa965fb64b1521485ccafb9401aa9ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">exclusive_or_expression : and_expression ('^' and_expression)* <br /></td></tr>
<tr class="separator:aa965fb64b1521485ccafb9401aa9ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7336a0afad9d959c9e649c3d998c0112" id="r_a7336a0afad9d959c9e649c3d998c0112"><td class="memItemLeft" align="right" valign="top"><a id="a7336a0afad9d959c9e649c3d998c0112" name="a7336a0afad9d959c9e649c3d998c0112"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_and_expression</b> ()</td></tr>
<tr class="memdesc:a7336a0afad9d959c9e649c3d998c0112"><td class="mdescLeft">&#160;</td><td class="mdescRight">and_expression : equality_expression ('&amp;' equality_expression)* <br /></td></tr>
<tr class="separator:a7336a0afad9d959c9e649c3d998c0112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888d0687dd4f40440820a63455110e18" id="r_a888d0687dd4f40440820a63455110e18"><td class="memItemLeft" align="right" valign="top"><a id="a888d0687dd4f40440820a63455110e18" name="a888d0687dd4f40440820a63455110e18"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_equality_expression</b> ()</td></tr>
<tr class="memdesc:a888d0687dd4f40440820a63455110e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality_expression : relational_expression (('=='|'!=') relational_expression)* <br /></td></tr>
<tr class="separator:a888d0687dd4f40440820a63455110e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0b53c59c8e46bcc5633d4558b45f83" id="r_a5e0b53c59c8e46bcc5633d4558b45f83"><td class="memItemLeft" align="right" valign="top"><a id="a5e0b53c59c8e46bcc5633d4558b45f83" name="a5e0b53c59c8e46bcc5633d4558b45f83"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_relational_expression</b> ()</td></tr>
<tr class="memdesc:a5e0b53c59c8e46bcc5633d4558b45f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">relational_expression : shift_expression (('&lt;'|'&gt;'|'&lt;='|'&gt;=') shift_expression)* <br /></td></tr>
<tr class="separator:a5e0b53c59c8e46bcc5633d4558b45f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061220ba80565ba5377f024272909232" id="r_a061220ba80565ba5377f024272909232"><td class="memItemLeft" align="right" valign="top"><a id="a061220ba80565ba5377f024272909232" name="a061220ba80565ba5377f024272909232"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_shift_expression</b> ()</td></tr>
<tr class="memdesc:a061220ba80565ba5377f024272909232"><td class="mdescLeft">&#160;</td><td class="mdescRight">shift_expression : additive_expression (('&lt;&lt;'|'&gt;&gt;') additive_expression)* <br /></td></tr>
<tr class="separator:a061220ba80565ba5377f024272909232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Statement</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>utility functions to parse a few statements. Successful match will advance the current position. INCOMPLETE now, Don't use them yet! </p>
</div></td></tr>
<tr class="memitem:ab864cb2da0859dbd31f1e116975f1411" id="r_ab864cb2da0859dbd31f1e116975f1411"><td class="memItemLeft" align="right" valign="top"><a id="ab864cb2da0859dbd31f1e116975f1411" name="ab864cb2da0859dbd31f1e116975f1411"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_statement</b> ()</td></tr>
<tr class="memdesc:ab864cb2da0859dbd31f1e116975f1411"><td class="mdescLeft">&#160;</td><td class="mdescRight">match any statement, not complete yet. Don't use it yet . : labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement <br /></td></tr>
<tr class="separator:ab864cb2da0859dbd31f1e116975f1411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bef0efe21f0e45004f60b0b29f83b" id="r_ad04bef0efe21f0e45004f60b0b29f83b"><td class="memItemLeft" align="right" valign="top"><a id="ad04bef0efe21f0e45004f60b0b29f83b" name="ad04bef0efe21f0e45004f60b0b29f83b"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_labeled_statement</b> ()</td></tr>
<tr class="memdesc:ad04bef0efe21f0e45004f60b0b29f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match labeled statement : IDENTIFIER ':' statement | 'case' constant_expression ':' statement | 'default' ':' statement. <br /></td></tr>
<tr class="separator:ad04bef0efe21f0e45004f60b0b29f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eae32e1043797136d714129aa1a0a3" id="r_a47eae32e1043797136d714129aa1a0a3"><td class="memItemLeft" align="right" valign="top"><a id="a47eae32e1043797136d714129aa1a0a3" name="a47eae32e1043797136d714129aa1a0a3"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_compound_statement</b> ()</td></tr>
<tr class="memdesc:a47eae32e1043797136d714129aa1a0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not yet implemented. Match compound statement: '{' declaration* statement_list? '}'. <br /></td></tr>
<tr class="separator:a47eae32e1043797136d714129aa1a0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640e7247b0d9113d9988553b34c0f77f" id="r_a640e7247b0d9113d9988553b34c0f77f"><td class="memItemLeft" align="right" valign="top"><a id="a640e7247b0d9113d9988553b34c0f77f" name="a640e7247b0d9113d9988553b34c0f77f"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_expression_statement</b> ()</td></tr>
<tr class="memdesc:a640e7247b0d9113d9988553b34c0f77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match expression statement: : ';' | expression ';'. <br /></td></tr>
<tr class="separator:a640e7247b0d9113d9988553b34c0f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2b8bde944d1b51d75877ad06329c20" id="r_a0c2b8bde944d1b51d75877ad06329c20"><td class="memItemLeft" align="right" valign="top"><a id="a0c2b8bde944d1b51d75877ad06329c20" name="a0c2b8bde944d1b51d75877ad06329c20"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_selection_statement</b> ()</td></tr>
<tr class="memdesc:a0c2b8bde944d1b51d75877ad06329c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match selection statement: IF '(' expression ')' statement | IF '(' expression ')' statement ELSE statement | SWITCH '(' expression ')' statement. <br /></td></tr>
<tr class="separator:a0c2b8bde944d1b51d75877ad06329c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acee0f1a401275ee5f0918a5d14422b" id="r_a4acee0f1a401275ee5f0918a5d14422b"><td class="memItemLeft" align="right" valign="top"><a id="a4acee0f1a401275ee5f0918a5d14422b" name="a4acee0f1a401275ee5f0918a5d14422b"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_iteration_statement</b> ()</td></tr>
<tr class="memdesc:a4acee0f1a401275ee5f0918a5d14422b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an iteration statement: : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression_statement expression_statement expression? ')' statement. <br /></td></tr>
<tr class="separator:a4acee0f1a401275ee5f0918a5d14422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7db85258562842be279a7bfcbfae9" id="r_a5ab7db85258562842be279a7bfcbfae9"><td class="memItemLeft" align="right" valign="top"><a id="a5ab7db85258562842be279a7bfcbfae9" name="a5ab7db85258562842be279a7bfcbfae9"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>afs_match_jump_statement</b> ()</td></tr>
<tr class="memdesc:a5ab7db85258562842be279a7bfcbfae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a jump statement : 'goto' IDENTIFIER ';' | 'continue' ';' | 'break' ';' | 'return' ';' | 'return' expression ';'. <br /></td></tr>
<tr class="separator:a5ab7db85258562842be279a7bfcbfae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Namespace scope variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Semi-global variables </p>
</div></td></tr>
<tr class="memitem:a098fe28ea095acdcc1f6af0959a05685" id="r_a098fe28ea095acdcc1f6af0959a05685"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#a098fe28ea095acdcc1f6af0959a05685">c_char</a></td></tr>
<tr class="memdesc:a098fe28ea095acdcc1f6af0959a05685"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace scope char* to avoid passing and returning a target c string for every and each function current characters being scanned, what is pointed is const, the pointer itself is not const.  <br /></td></tr>
<tr class="separator:a098fe28ea095acdcc1f6af0959a05685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1149181523ff77c2cd1f5e1689f7ea4c" id="r_a1149181523ff77c2cd1f5e1689f7ea4c"><td class="memItemLeft" align="right" valign="top"><a id="a1149181523ff77c2cd1f5e1689f7ea4c" name="a1149181523ff77c2cd1f5e1689f7ea4c"></a>
ROSE_DLL_API <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>c_sgnode</b></td></tr>
<tr class="memdesc:a1149181523ff77c2cd1f5e1689f7ea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">current anchor <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> associated with parsing. It will serve as a start point to find enclosing scopes for resolving identifiers/symbols <br /></td></tr>
<tr class="separator:a1149181523ff77c2cd1f5e1689f7ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f4d7938d3ddce6b3a81b7ff8f31399" id="r_a95f4d7938d3ddce6b3a81b7ff8f31399"><td class="memItemLeft" align="right" valign="top"><a id="a95f4d7938d3ddce6b3a81b7ff8f31399" name="a95f4d7938d3ddce6b3a81b7ff8f31399"></a>
ROSE_DLL_API <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>c_parsed_node</b></td></tr>
<tr class="memdesc:a95f4d7938d3ddce6b3a81b7ff8f31399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the AST substree (expression, statement) generated from a helper function. <br /></td></tr>
<tr class="separator:a95f4d7938d3ddce6b3a81b7ff8f31399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e88c8fc182d4043da2c2f49f4e1f75f" name="a1e88c8fc182d4043da2c2f49f4e1f75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e88c8fc182d4043da2c2f49f4e1f75f">&#9670;&#160;</a></span>afs_match_substr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool AstFromString::afs_match_substr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkTrail</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a sub string: a given sub c string from the input c string, again skip heading space/tabs if any. </p>
<p>checkTrail: Check the immediate following character after the match, it must be one of whitespace, end of str, newline, tab, (, ), or '!', etc. It is set to true by default, used to ensure the matched substr is a full identifier/keywords. Note: If try to match non-identifier, such as operators +=, etc), please set checkTrail to false!! But Fortran OpenMP allows blanks/tabs to be ignored between certain pair of keywords: e.g: end critical == endcritical , parallel do == paralleldo to match the 'end' and 'parallel', we have to skip trail checking. return values:</p><ul>
<li>true: find a match, the current char is pointed to the next char after the substr</li>
<li>false: no match, the current char is intact </li>
</ul>

</div>
</div>
<a id="a1e426325ec77fb5195998c00bfca6f70" name="a1e426325ec77fb5195998c00bfca6f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e426325ec77fb5195998c00bfca6f70">&#9670;&#160;</a></span>afs_match_type_specifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API bool AstFromString::afs_match_type_specifier </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkTrail</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match a type specifier : 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | struct_or_union_specifier | enum_specifier | type_id. The recognized type is stored in c_parsed_node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">checkTrail</td><td>if false it authorizes any character to follow the type. Used to parse fragments of C (as a comma separated list of types) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a098fe28ea095acdcc1f6af0959a05685" name="a098fe28ea095acdcc1f6af0959a05685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098fe28ea095acdcc1f6af0959a05685">&#9670;&#160;</a></span>c_char</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API const char* AstFromString::c_char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A namespace scope char* to avoid passing and returning a target c string for every and each function current characters being scanned, what is pointed is const, the pointer itself is not const. </p>
<p><br  />
 </p>

<p class="reference">Referenced by <a class="el" href="sageBuilder_8C_source.html#l18895">SageBuilder::buildStatementFromString()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:07 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
