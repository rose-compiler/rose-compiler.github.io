<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::BitVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1BitVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::BitVector Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Bit vectors. </p>
<p>This class implements bit vectors with run-time sizes and a rich set of operations that can be restricted to a contiguous subset of bits. The primary goal of this class is not to provide the utmost performance, but rather a rich, easy-to-use interface. For example,</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> bv(128);                                  <span class="comment">// a 128-bit vector with all bits cleared</span></div>
<div class="line">bv.set(<a class="code hl_typedef" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>(6,27));                             <span class="comment">// set (make true) bits 6 through 27, inclusive</span></div>
<div class="line">bv.fromHex(<a class="code hl_function" href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f">BitRange::baseSize</a>(32,64), <span class="stringliteral">&quot;deadbeef&quot;</span>);  <span class="comment">// initialize 64 bits beginning at bit 32</span></div>
<div class="line"><span class="keywordtype">bool</span> carry = bv.add(<a class="code hl_typedef" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>(5,8), <a class="code hl_typedef" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>(5,8));  <span class="comment">// double the integer represented by bits 5 through 8</span></div>
<div class="line">std::cout &lt;&lt;bv.toBinary(<a class="code hl_typedef" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>(5,8)) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;      <span class="comment">// print bits 5-8 as a binary string</span></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1BitVector_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a></div><div class="ttdoc">Bit vectors.</div><div class="ttdef"><b>Definition</b> <a href="BitVector_8h_source.html#l00069">BitVector.h:69</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1BitVector_html_ad0d02ed250ef2712b681970b37b1bb61"><div class="ttname"><a href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">Sawyer::Container::BitVector::BitRange</a></div><div class="ttdeci">BitVectorSupport::BitRange BitRange</div><div class="ttdoc">Describes an inclusive interval of bit indices.</div><div class="ttdef"><b>Definition</b> <a href="BitVector_8h_source.html#l00072">BitVector.h:72</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Interval_html_a136b9afce8c48871c21c58dc9ecdc48f"><div class="ttname"><a href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f">Sawyer::Container::Interval&lt; size_t &gt;::baseSize</a></div><div class="ttdeci">static Interval baseSize(size_t lo, size_t size)</div><div class="ttdoc">Construct an interval from one endpoint and a size.</div><div class="ttdef"><b>Definition</b> <a href="Interval_8h_source.html#l00173">Interval.h:173</a></div></div>
</div><!-- fragment --><p>In general, each method has a number of overloaded varieties: if a BitRange is not specified it generally means the entire bit vector; if a second bit vector is not specified for binary operations it generally means use this vector for both operands. Non-const operations modify <code>this</code> vector in place, and most of them also return a reference so that they can be easily chained:</p>
<div class="fragment"><div class="line">bv.clear().set(<a class="code hl_typedef" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>(24,31));                    <span class="comment">// clear all bits, then set bits 24-31</span></div>
</div><!-- fragment --><p>When performing an operation that has two operands, the operands are generally permitted to both refer to the same vector, and the range arguments are permitted to overlap in that vector. When this occurs, the semantics are as if a temporary copy was made, then the operation was performed on the temporary copy, then the result was written back to the destination.</p>
<p><a class="el" href="classSawyer_1_1Container_1_1BitVector.html" title="Bit vectors.">BitVector</a> objects manage their own data, but if one needs to operate on an array that is already allocated then the function templates in the <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html">BitVectorSupport</a> name space can be used. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00069">69</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="BitVector_8h_source.html">Sawyer/BitVector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0381629ea9a527d239916f0efd7168c9" id="r_a0381629ea9a527d239916f0efd7168c9"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Word</a></td></tr>
<tr class="memdesc:a0381629ea9a527d239916f0efd7168c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage type.  <br /></td></tr>
<tr class="separator:a0381629ea9a527d239916f0efd7168c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d02ed250ef2712b681970b37b1bb61" id="r_ad0d02ed250ef2712b681970b37b1bb61"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitVectorSupport::BitRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a></td></tr>
<tr class="memdesc:ad0d02ed250ef2712b681970b37b1bb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an inclusive interval of bit indices.  <br /></td></tr>
<tr class="separator:ad0d02ed250ef2712b681970b37b1bb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ace0972d3cec4c55a5b2106a92301ed" id="r_a0ace0972d3cec4c55a5b2106a92301ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0ace0972d3cec4c55a5b2106a92301ed">BitVector</a> ()</td></tr>
<tr class="memdesc:a0ace0972d3cec4c55a5b2106a92301ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct an empty vector.  <br /></td></tr>
<tr class="separator:a0ace0972d3cec4c55a5b2106a92301ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e95f965808f5077abc300d0afdd51" id="r_a9b8e95f965808f5077abc300d0afdd51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a9b8e95f965808f5077abc300d0afdd51">BitVector</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:a9b8e95f965808f5077abc300d0afdd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9b8e95f965808f5077abc300d0afdd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f2a07d84ef2c8d3c5acbeea8ee0e18" id="r_a67f2a07d84ef2c8d3c5acbeea8ee0e18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a67f2a07d84ef2c8d3c5acbeea8ee0e18">BitVector</a> (size_t nbits, bool newBits=false)</td></tr>
<tr class="memdesc:a67f2a07d84ef2c8d3c5acbeea8ee0e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of specified size.  <br /></td></tr>
<tr class="separator:a67f2a07d84ef2c8d3c5acbeea8ee0e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2a6ea93f6c711c9de69d88ff5ec987" id="r_abc2a6ea93f6c711c9de69d88ff5ec987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#abc2a6ea93f6c711c9de69d88ff5ec987">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:abc2a6ea93f6c711c9de69d88ff5ec987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:abc2a6ea93f6c711c9de69d88ff5ec987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8335826daf5ee30dab6bc9cba96bdfa" id="r_af8335826daf5ee30dab6bc9cba96bdfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#af8335826daf5ee30dab6bc9cba96bdfa">isEmpty</a> () const</td></tr>
<tr class="memdesc:af8335826daf5ee30dab6bc9cba96bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the vector is empty.  <br /></td></tr>
<tr class="separator:af8335826daf5ee30dab6bc9cba96bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f05ce7f5af5ee0e9869a84db392301" id="r_a49f05ce7f5af5ee0e9869a84db392301"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a49f05ce7f5af5ee0e9869a84db392301">size</a> () const</td></tr>
<tr class="memdesc:a49f05ce7f5af5ee0e9869a84db392301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of vector in bits.  <br /></td></tr>
<tr class="separator:a49f05ce7f5af5ee0e9869a84db392301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714048799b18f6129aaee008f8fb2627" id="r_a714048799b18f6129aaee008f8fb2627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a714048799b18f6129aaee008f8fb2627">resize</a> (size_t newSize, bool newBits=false)</td></tr>
<tr class="memdesc:a714048799b18f6129aaee008f8fb2627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change vector size.  <br /></td></tr>
<tr class="separator:a714048799b18f6129aaee008f8fb2627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd82b71d7ce2c95fb21d8aaedebb8f" id="r_a1cbd82b71d7ce2c95fb21d8aaedebb8f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1cbd82b71d7ce2c95fb21d8aaedebb8f">capacity</a> () const</td></tr>
<tr class="memdesc:a1cbd82b71d7ce2c95fb21d8aaedebb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size before reallocation.  <br /></td></tr>
<tr class="separator:a1cbd82b71d7ce2c95fb21d8aaedebb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd958a91e697da6ae26aa3cc91b2ba9" id="r_a6cd958a91e697da6ae26aa3cc91b2ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a6cd958a91e697da6ae26aa3cc91b2ba9">hull</a> () const</td></tr>
<tr class="memdesc:a6cd958a91e697da6ae26aa3cc91b2ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> representing the entire vector.  <br /></td></tr>
<tr class="separator:a6cd958a91e697da6ae26aa3cc91b2ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b2c635fc6d9f089c5f8336b2ece893" id="r_a80b2c635fc6d9f089c5f8336b2ece893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80b2c635fc6d9f089c5f8336b2ece893">get</a> (size_t idx) const</td></tr>
<tr class="memdesc:a80b2c635fc6d9f089c5f8336b2ece893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve one bit.  <br /></td></tr>
<tr class="separator:a80b2c635fc6d9f089c5f8336b2ece893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0980597d500db192bbabcb60429b6b32" id="r_a0980597d500db192bbabcb60429b6b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a0980597d500db192bbabcb60429b6b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign zero to some bits.  <br /></td></tr>
<tr class="separator:a0980597d500db192bbabcb60429b6b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7819e37d0b36f7805388f2883bb89628" id="r_a7819e37d0b36f7805388f2883bb89628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7819e37d0b36f7805388f2883bb89628">clear</a> ()</td></tr>
<tr class="memdesc:a7819e37d0b36f7805388f2883bb89628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign zero to all bits.  <br /></td></tr>
<tr class="separator:a7819e37d0b36f7805388f2883bb89628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a1d3ad781210d44368f4a2536b0f00" id="r_a80a1d3ad781210d44368f4a2536b0f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a80a1d3ad781210d44368f4a2536b0f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign true to some bits.  <br /></td></tr>
<tr class="separator:a80a1d3ad781210d44368f4a2536b0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61456be73a9e4deeb05d7957dfdb369c" id="r_a61456be73a9e4deeb05d7957dfdb369c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a61456be73a9e4deeb05d7957dfdb369c">set</a> ()</td></tr>
<tr class="memdesc:a61456be73a9e4deeb05d7957dfdb369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign true to all bits.  <br /></td></tr>
<tr class="separator:a61456be73a9e4deeb05d7957dfdb369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bf0d5cf5b1df24d6c7106964e817f4" id="r_a79bf0d5cf5b1df24d6c7106964e817f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a79bf0d5cf5b1df24d6c7106964e817f4">setValue</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, bool value)</td></tr>
<tr class="memdesc:a79bf0d5cf5b1df24d6c7106964e817f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign true/false to some bits.  <br /></td></tr>
<tr class="separator:a79bf0d5cf5b1df24d6c7106964e817f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8380210716c085004adb77e785000d9" id="r_aa8380210716c085004adb77e785000d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa8380210716c085004adb77e785000d9">setValue</a> (bool value)</td></tr>
<tr class="memdesc:aa8380210716c085004adb77e785000d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign true/false to all bits.  <br /></td></tr>
<tr class="separator:aa8380210716c085004adb77e785000d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae020499e74716a481e10acc5b12d75d2" id="r_ae020499e74716a481e10acc5b12d75d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ae020499e74716a481e10acc5b12d75d2">copy</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;to, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;from)</td></tr>
<tr class="memdesc:ae020499e74716a481e10acc5b12d75d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy some bits.  <br /></td></tr>
<tr class="separator:ae020499e74716a481e10acc5b12d75d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36178a0b193130fdfdc4cbbdd74fd124" id="r_a36178a0b193130fdfdc4cbbdd74fd124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a36178a0b193130fdfdc4cbbdd74fd124">copy</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;to, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;from)</td></tr>
<tr class="memdesc:a36178a0b193130fdfdc4cbbdd74fd124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy some bits.  <br /></td></tr>
<tr class="separator:a36178a0b193130fdfdc4cbbdd74fd124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c7d435b045a3d62328752b02303af" id="r_a583c7d435b045a3d62328752b02303af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a583c7d435b045a3d62328752b02303af">swap</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a583c7d435b045a3d62328752b02303af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap some bits.  <br /></td></tr>
<tr class="separator:a583c7d435b045a3d62328752b02303af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead49c379759a7a63bada0d41f2d57aa" id="r_aead49c379759a7a63bada0d41f2d57aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aead49c379759a7a63bada0d41f2d57aa">swap</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:aead49c379759a7a63bada0d41f2d57aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap some bits.  <br /></td></tr>
<tr class="separator:aead49c379759a7a63bada0d41f2d57aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6f1a123ba6df173b13778849316d0" id="r_af4b6f1a123ba6df173b13778849316d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#af4b6f1a123ba6df173b13778849316d0">equalTo</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:af4b6f1a123ba6df173b13778849316d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two ranges are equal.  <br /></td></tr>
<tr class="separator:af4b6f1a123ba6df173b13778849316d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28925c27e64e2b1ade881763045312c7" id="r_a28925c27e64e2b1ade881763045312c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a28925c27e64e2b1ade881763045312c7">equalTo</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a28925c27e64e2b1ade881763045312c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the bits of two ranges are equal.  <br /></td></tr>
<tr class="separator:a28925c27e64e2b1ade881763045312c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfed3d4d52afa6dbadde6723e072879" id="r_a7bfed3d4d52afa6dbadde6723e072879"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7bfed3d4d52afa6dbadde6723e072879">equalTo</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:a7bfed3d4d52afa6dbadde6723e072879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the bits of one vector are equal to the bits of the other.  <br /></td></tr>
<tr class="separator:a7bfed3d4d52afa6dbadde6723e072879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53036b9231a66110d4cec2e356b04389" id="r_a53036b9231a66110d4cec2e356b04389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a53036b9231a66110d4cec2e356b04389">leastSignificantSetBit</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a53036b9231a66110d4cec2e356b04389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the least significant set bit.  <br /></td></tr>
<tr class="separator:a53036b9231a66110d4cec2e356b04389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46793b2a3bb72eb91412c7518527a6b" id="r_ac46793b2a3bb72eb91412c7518527a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ac46793b2a3bb72eb91412c7518527a6b">leastSignificantSetBit</a> () const</td></tr>
<tr class="memdesc:ac46793b2a3bb72eb91412c7518527a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the least significant set bit.  <br /></td></tr>
<tr class="separator:ac46793b2a3bb72eb91412c7518527a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a1eb5f442810516f5f99bb0ae8d9d" id="r_a1a0a1eb5f442810516f5f99bb0ae8d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1a0a1eb5f442810516f5f99bb0ae8d9d">leastSignificantClearBit</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a1a0a1eb5f442810516f5f99bb0ae8d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the least significant clear bit.  <br /></td></tr>
<tr class="separator:a1a0a1eb5f442810516f5f99bb0ae8d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3994e3f76b2a5a470f1464666845a4" id="r_a5f3994e3f76b2a5a470f1464666845a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a5f3994e3f76b2a5a470f1464666845a4">leastSignificantClearBit</a> () const</td></tr>
<tr class="memdesc:a5f3994e3f76b2a5a470f1464666845a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the least significant clear bit.  <br /></td></tr>
<tr class="separator:a5f3994e3f76b2a5a470f1464666845a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6a06fb217e86247e57e1c39f849a6b" id="r_a1e6a06fb217e86247e57e1c39f849a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1e6a06fb217e86247e57e1c39f849a6b">mostSignificantSetBit</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a1e6a06fb217e86247e57e1c39f849a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the most significant set bit.  <br /></td></tr>
<tr class="separator:a1e6a06fb217e86247e57e1c39f849a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da55a7c778f124d5fdc84a284b9036" id="r_a09da55a7c778f124d5fdc84a284b9036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a09da55a7c778f124d5fdc84a284b9036">mostSignificantSetBit</a> () const</td></tr>
<tr class="memdesc:a09da55a7c778f124d5fdc84a284b9036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the most significant set bit.  <br /></td></tr>
<tr class="separator:a09da55a7c778f124d5fdc84a284b9036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af514bc9ef1002590da3739e023f364c7" id="r_af514bc9ef1002590da3739e023f364c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#af514bc9ef1002590da3739e023f364c7">mostSignificantClearBit</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:af514bc9ef1002590da3739e023f364c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the most significant clear bit.  <br /></td></tr>
<tr class="separator:af514bc9ef1002590da3739e023f364c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab064e9fcfbe409df184018199d685b65" id="r_ab064e9fcfbe409df184018199d685b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ab064e9fcfbe409df184018199d685b65">mostSignificantClearBit</a> () const</td></tr>
<tr class="memdesc:ab064e9fcfbe409df184018199d685b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the most significant clear bit.  <br /></td></tr>
<tr class="separator:ab064e9fcfbe409df184018199d685b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336fe1195eca05b15f7053bf3fc51e5" id="r_ad336fe1195eca05b15f7053bf3fc51e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad336fe1195eca05b15f7053bf3fc51e5">isAllSet</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:ad336fe1195eca05b15f7053bf3fc51e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are set.  <br /></td></tr>
<tr class="separator:ad336fe1195eca05b15f7053bf3fc51e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d0555e81447c9c34e87a04e69d604c" id="r_a04d0555e81447c9c34e87a04e69d604c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a04d0555e81447c9c34e87a04e69d604c">isAllSet</a> () const</td></tr>
<tr class="memdesc:a04d0555e81447c9c34e87a04e69d604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are set.  <br /></td></tr>
<tr class="separator:a04d0555e81447c9c34e87a04e69d604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181cbb8cf30a0da90e7f59523346c64d" id="r_a181cbb8cf30a0da90e7f59523346c64d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a181cbb8cf30a0da90e7f59523346c64d">isAllClear</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a181cbb8cf30a0da90e7f59523346c64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are clear.  <br /></td></tr>
<tr class="separator:a181cbb8cf30a0da90e7f59523346c64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109be965d9669dd08314709049442308" id="r_a109be965d9669dd08314709049442308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a109be965d9669dd08314709049442308">isAllClear</a> () const</td></tr>
<tr class="memdesc:a109be965d9669dd08314709049442308"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all bits are clear.  <br /></td></tr>
<tr class="separator:a109be965d9669dd08314709049442308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5be5afa5176b7fb00267f9442cb18a" id="r_ade5be5afa5176b7fb00267f9442cb18a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ade5be5afa5176b7fb00267f9442cb18a">nSet</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:ade5be5afa5176b7fb00267f9442cb18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of set bits.  <br /></td></tr>
<tr class="separator:ade5be5afa5176b7fb00267f9442cb18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39cd6df295bdd530451cfa7be5902dc" id="r_ac39cd6df295bdd530451cfa7be5902dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ac39cd6df295bdd530451cfa7be5902dc">nSet</a> () const</td></tr>
<tr class="memdesc:ac39cd6df295bdd530451cfa7be5902dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of set bits.  <br /></td></tr>
<tr class="separator:ac39cd6df295bdd530451cfa7be5902dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1bdd8fbd8a0ac8ed712ccbe28116a5" id="r_aef1bdd8fbd8a0ac8ed712ccbe28116a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aef1bdd8fbd8a0ac8ed712ccbe28116a5">nClear</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:aef1bdd8fbd8a0ac8ed712ccbe28116a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of clear bits.  <br /></td></tr>
<tr class="separator:aef1bdd8fbd8a0ac8ed712ccbe28116a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abbce4dbbafd07ddd11f7b5db604355" id="r_a4abbce4dbbafd07ddd11f7b5db604355"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a4abbce4dbbafd07ddd11f7b5db604355">nClear</a> () const</td></tr>
<tr class="memdesc:a4abbce4dbbafd07ddd11f7b5db604355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of clear bits.  <br /></td></tr>
<tr class="separator:a4abbce4dbbafd07ddd11f7b5db604355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ff2458cf147b294782d2fd98a47d44" id="r_a67ff2458cf147b294782d2fd98a47d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a67ff2458cf147b294782d2fd98a47d44">mostSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a67ff2458cf147b294782d2fd98a47d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find most significant difference.  <br /></td></tr>
<tr class="separator:a67ff2458cf147b294782d2fd98a47d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abdeb49aa4a53c30052ad21b9bd82ff" id="r_a9abdeb49aa4a53c30052ad21b9bd82ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a9abdeb49aa4a53c30052ad21b9bd82ff">mostSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a9abdeb49aa4a53c30052ad21b9bd82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find most significant difference.  <br /></td></tr>
<tr class="separator:a9abdeb49aa4a53c30052ad21b9bd82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0ede72b5194893bdf7e37d38401c3f" id="r_a0f0ede72b5194893bdf7e37d38401c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0f0ede72b5194893bdf7e37d38401c3f">mostSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:a0f0ede72b5194893bdf7e37d38401c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find most significant difference.  <br /></td></tr>
<tr class="separator:a0f0ede72b5194893bdf7e37d38401c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59fd100ec69f48a55bd96ed8f83d93e" id="r_ae59fd100ec69f48a55bd96ed8f83d93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ae59fd100ec69f48a55bd96ed8f83d93e">leastSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:ae59fd100ec69f48a55bd96ed8f83d93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find least significant difference.  <br /></td></tr>
<tr class="separator:ae59fd100ec69f48a55bd96ed8f83d93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d5a51ea6bb3bd6add0de488ff716bc" id="r_a88d5a51ea6bb3bd6add0de488ff716bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a88d5a51ea6bb3bd6add0de488ff716bc">leastSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a88d5a51ea6bb3bd6add0de488ff716bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find least significant difference.  <br /></td></tr>
<tr class="separator:a88d5a51ea6bb3bd6add0de488ff716bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59dab3531a35d7289e68bc910fda371" id="r_ac59dab3531a35d7289e68bc910fda371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ac59dab3531a35d7289e68bc910fda371">leastSignificantDifference</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:ac59dab3531a35d7289e68bc910fda371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find least significant difference.  <br /></td></tr>
<tr class="separator:ac59dab3531a35d7289e68bc910fda371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb12c7ef3b96723eaccdd99152f7374e" id="r_aeb12c7ef3b96723eaccdd99152f7374e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aeb12c7ef3b96723eaccdd99152f7374e">shiftLeft</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:aeb12c7ef3b96723eaccdd99152f7374e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits left.  <br /></td></tr>
<tr class="separator:aeb12c7ef3b96723eaccdd99152f7374e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7b631db6561cae01f60691ad4476a8" id="r_adc7b631db6561cae01f60691ad4476a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#adc7b631db6561cae01f60691ad4476a8">shiftLeft</a> (size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:adc7b631db6561cae01f60691ad4476a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits left.  <br /></td></tr>
<tr class="separator:adc7b631db6561cae01f60691ad4476a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140f099df2da66d37dd12fafaf72dcd2" id="r_a140f099df2da66d37dd12fafaf72dcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a140f099df2da66d37dd12fafaf72dcd2">shiftRight</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:a140f099df2da66d37dd12fafaf72dcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right.  <br /></td></tr>
<tr class="separator:a140f099df2da66d37dd12fafaf72dcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a18d20c3c06c71b87e5bd3c970cfe71" id="r_a0a18d20c3c06c71b87e5bd3c970cfe71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0a18d20c3c06c71b87e5bd3c970cfe71">shiftRight</a> (size_t nShift, bool newBits=0)</td></tr>
<tr class="memdesc:a0a18d20c3c06c71b87e5bd3c970cfe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right.  <br /></td></tr>
<tr class="separator:a0a18d20c3c06c71b87e5bd3c970cfe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda2b3e05c1eb84009a3c21ab10c803b" id="r_acda2b3e05c1eb84009a3c21ab10c803b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#acda2b3e05c1eb84009a3c21ab10c803b">shiftRightArithmetic</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:acda2b3e05c1eb84009a3c21ab10c803b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right.  <br /></td></tr>
<tr class="separator:acda2b3e05c1eb84009a3c21ab10c803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690607194a260b5a515c40b7595addac" id="r_a690607194a260b5a515c40b7595addac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a690607194a260b5a515c40b7595addac">shiftRightArithmetic</a> (size_t nShift)</td></tr>
<tr class="memdesc:a690607194a260b5a515c40b7595addac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift bits right.  <br /></td></tr>
<tr class="separator:a690607194a260b5a515c40b7595addac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ec60dc574af9174051fea4c8ad4a9" id="r_a7e3ec60dc574af9174051fea4c8ad4a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7e3ec60dc574af9174051fea4c8ad4a9">rotateRight</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:a7e3ec60dc574af9174051fea4c8ad4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits right.  <br /></td></tr>
<tr class="separator:a7e3ec60dc574af9174051fea4c8ad4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733aa7cc9229323e2426a6321be2b813" id="r_a733aa7cc9229323e2426a6321be2b813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a733aa7cc9229323e2426a6321be2b813">rotateRight</a> (size_t nShift)</td></tr>
<tr class="memdesc:a733aa7cc9229323e2426a6321be2b813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits right.  <br /></td></tr>
<tr class="separator:a733aa7cc9229323e2426a6321be2b813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490beac89b7f12dd266a5059e4171ace" id="r_a490beac89b7f12dd266a5059e4171ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a490beac89b7f12dd266a5059e4171ace">rotateLeft</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, size_t nShift)</td></tr>
<tr class="memdesc:a490beac89b7f12dd266a5059e4171ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits left.  <br /></td></tr>
<tr class="separator:a490beac89b7f12dd266a5059e4171ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0787632027438de63cf1c7335c03455e" id="r_a0787632027438de63cf1c7335c03455e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0787632027438de63cf1c7335c03455e">rotateLeft</a> (size_t nShift)</td></tr>
<tr class="memdesc:a0787632027438de63cf1c7335c03455e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate bits left.  <br /></td></tr>
<tr class="separator:a0787632027438de63cf1c7335c03455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6f68f08471307cc33fe905ff8c9885" id="r_a1c6f68f08471307cc33fe905ff8c9885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1c6f68f08471307cc33fe905ff8c9885">negate</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:a1c6f68f08471307cc33fe905ff8c9885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates bits as integer.  <br /></td></tr>
<tr class="separator:a1c6f68f08471307cc33fe905ff8c9885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee6b5849173d4510648dfb7f6b5759" id="r_a3bee6b5849173d4510648dfb7f6b5759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3bee6b5849173d4510648dfb7f6b5759">negate</a> ()</td></tr>
<tr class="memdesc:a3bee6b5849173d4510648dfb7f6b5759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates bits as integer.  <br /></td></tr>
<tr class="separator:a3bee6b5849173d4510648dfb7f6b5759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e8dff6b39ae8302ab79e14dbba981" id="r_a0b8e8dff6b39ae8302ab79e14dbba981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0b8e8dff6b39ae8302ab79e14dbba981">increment</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:a0b8e8dff6b39ae8302ab79e14dbba981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment bits as integer.  <br /></td></tr>
<tr class="separator:a0b8e8dff6b39ae8302ab79e14dbba981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117b599387241c144ea353bc8dcc45fa" id="r_a117b599387241c144ea353bc8dcc45fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a117b599387241c144ea353bc8dcc45fa">increment</a> ()</td></tr>
<tr class="memdesc:a117b599387241c144ea353bc8dcc45fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment bits as integer.  <br /></td></tr>
<tr class="separator:a117b599387241c144ea353bc8dcc45fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add238864186bb80ffcb2dbb2e326a3" id="r_a7add238864186bb80ffcb2dbb2e326a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7add238864186bb80ffcb2dbb2e326a3">decrement</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1)</td></tr>
<tr class="memdesc:a7add238864186bb80ffcb2dbb2e326a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement bits as integer.  <br /></td></tr>
<tr class="separator:a7add238864186bb80ffcb2dbb2e326a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182e6fe271710ec91e7d18d6dc2fd30f" id="r_a182e6fe271710ec91e7d18d6dc2fd30f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a182e6fe271710ec91e7d18d6dc2fd30f">decrement</a> ()</td></tr>
<tr class="memdesc:a182e6fe271710ec91e7d18d6dc2fd30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement bits as integer.  <br /></td></tr>
<tr class="separator:a182e6fe271710ec91e7d18d6dc2fd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad227b36add661119094a305c657b56d2" id="r_ad227b36add661119094a305c657b56d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad227b36add661119094a305c657b56d2">add</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:ad227b36add661119094a305c657b56d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bits as integers.  <br /></td></tr>
<tr class="separator:ad227b36add661119094a305c657b56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c47d36d3799d8c60cf4d46b290e7f24" id="r_a5c47d36d3799d8c60cf4d46b290e7f24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a5c47d36d3799d8c60cf4d46b290e7f24">add</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a5c47d36d3799d8c60cf4d46b290e7f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bits as integers.  <br /></td></tr>
<tr class="separator:a5c47d36d3799d8c60cf4d46b290e7f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb237dc83e46c180388691861f8b4671" id="r_aeb237dc83e46c180388691861f8b4671"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aeb237dc83e46c180388691861f8b4671">add</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:aeb237dc83e46c180388691861f8b4671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bits as integers.  <br /></td></tr>
<tr class="separator:aeb237dc83e46c180388691861f8b4671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6330fd3a1a3fc89162aa89b980efcfd7" id="r_a6330fd3a1a3fc89162aa89b980efcfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a6330fd3a1a3fc89162aa89b980efcfd7">subtract</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a6330fd3a1a3fc89162aa89b980efcfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract bits as integers.  <br /></td></tr>
<tr class="separator:a6330fd3a1a3fc89162aa89b980efcfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1129a4ee284d2eecb2a8137ed0cd7d6" id="r_ae1129a4ee284d2eecb2a8137ed0cd7d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ae1129a4ee284d2eecb2a8137ed0cd7d6">subtract</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:ae1129a4ee284d2eecb2a8137ed0cd7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract bits as integers.  <br /></td></tr>
<tr class="separator:ae1129a4ee284d2eecb2a8137ed0cd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7a4bc2e937ba6156cdee10a4c083a7" id="r_a7f7a4bc2e937ba6156cdee10a4c083a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7f7a4bc2e937ba6156cdee10a4c083a7">subtract</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:a7f7a4bc2e937ba6156cdee10a4c083a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract bits as integers.  <br /></td></tr>
<tr class="separator:a7f7a4bc2e937ba6156cdee10a4c083a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d58fa62f0d6d80374a3d9d3df7154b" id="r_a44d58fa62f0d6d80374a3d9d3df7154b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a44d58fa62f0d6d80374a3d9d3df7154b">signExtend</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a44d58fa62f0d6d80374a3d9d3df7154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bits and sign extend.  <br /></td></tr>
<tr class="separator:a44d58fa62f0d6d80374a3d9d3df7154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86261dc840e385cd2be6daaf109a2287" id="r_a86261dc840e385cd2be6daaf109a2287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a86261dc840e385cd2be6daaf109a2287">signExtend</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a86261dc840e385cd2be6daaf109a2287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bits and sign extend.  <br /></td></tr>
<tr class="separator:a86261dc840e385cd2be6daaf109a2287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5e43e5ce97d5da496c5d5a7c35bdec" id="r_a3f5e43e5ce97d5da496c5d5a7c35bdec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3f5e43e5ce97d5da496c5d5a7c35bdec">signExtend</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:a3f5e43e5ce97d5da496c5d5a7c35bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy bits and sign extend.  <br /></td></tr>
<tr class="separator:a3f5e43e5ce97d5da496c5d5a7c35bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9294b32d004aebfdbb1a7bcf0ad38e" id="r_a5e9294b32d004aebfdbb1a7bcf0ad38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a5e9294b32d004aebfdbb1a7bcf0ad38e">multiply10</a> ()</td></tr>
<tr class="memdesc:a5e9294b32d004aebfdbb1a7bcf0ad38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by 10.  <br /></td></tr>
<tr class="separator:a5e9294b32d004aebfdbb1a7bcf0ad38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc7465f286ffa459338dfb11c7adc4f" id="r_a0dc7465f286ffa459338dfb11c7adc4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0dc7465f286ffa459338dfb11c7adc4f">multiply10</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a0dc7465f286ffa459338dfb11c7adc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply by 10.  <br /></td></tr>
<tr class="separator:a0dc7465f286ffa459338dfb11c7adc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0458442defdf8b2718edf162bf46b16" id="r_ab0458442defdf8b2718edf162bf46b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ab0458442defdf8b2718edf162bf46b16">multiply</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:ab0458442defdf8b2718edf162bf46b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two bit vectors.  <br /></td></tr>
<tr class="separator:ab0458442defdf8b2718edf162bf46b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240689423b2de539bd83328a2a36dcca" id="r_a240689423b2de539bd83328a2a36dcca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a240689423b2de539bd83328a2a36dcca">multiplySigned</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:a240689423b2de539bd83328a2a36dcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two signed integers.  <br /></td></tr>
<tr class="separator:a240689423b2de539bd83328a2a36dcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79639c80681c3f649e08079ff35b1637" id="r_a79639c80681c3f649e08079ff35b1637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a79639c80681c3f649e08079ff35b1637">invert</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range)</td></tr>
<tr class="memdesc:a79639c80681c3f649e08079ff35b1637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert bits.  <br /></td></tr>
<tr class="separator:a79639c80681c3f649e08079ff35b1637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8971e6f9cbf70e12fe65952830dea3a" id="r_af8971e6f9cbf70e12fe65952830dea3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#af8971e6f9cbf70e12fe65952830dea3a">invert</a> ()</td></tr>
<tr class="memdesc:af8971e6f9cbf70e12fe65952830dea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert bits.  <br /></td></tr>
<tr class="separator:af8971e6f9cbf70e12fe65952830dea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbddaaf873aab6ed2071cff72950d6ed" id="r_afbddaaf873aab6ed2071cff72950d6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#afbddaaf873aab6ed2071cff72950d6ed">bitwiseAnd</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:afbddaaf873aab6ed2071cff72950d6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise AND.  <br /></td></tr>
<tr class="separator:afbddaaf873aab6ed2071cff72950d6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c57ddd6b1522169e684080dd03d475f" id="r_a1c57ddd6b1522169e684080dd03d475f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1c57ddd6b1522169e684080dd03d475f">bitwiseAnd</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a1c57ddd6b1522169e684080dd03d475f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise AND.  <br /></td></tr>
<tr class="separator:a1c57ddd6b1522169e684080dd03d475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7fdf21a35a68f8a28b16698d4cc37c" id="r_a6f7fdf21a35a68f8a28b16698d4cc37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a6f7fdf21a35a68f8a28b16698d4cc37c">bitwiseAnd</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:a6f7fdf21a35a68f8a28b16698d4cc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise AND.  <br /></td></tr>
<tr class="separator:a6f7fdf21a35a68f8a28b16698d4cc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f0eb0b601d8deed4bc44e18de13a8d" id="r_a86f0eb0b601d8deed4bc44e18de13a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a86f0eb0b601d8deed4bc44e18de13a8d">bitwiseOr</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a86f0eb0b601d8deed4bc44e18de13a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise OR.  <br /></td></tr>
<tr class="separator:a86f0eb0b601d8deed4bc44e18de13a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8807bd882a430d12d8998b5631caa890" id="r_a8807bd882a430d12d8998b5631caa890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8807bd882a430d12d8998b5631caa890">bitwiseOr</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a8807bd882a430d12d8998b5631caa890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise OR.  <br /></td></tr>
<tr class="separator:a8807bd882a430d12d8998b5631caa890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47671e8d5dd237d71c2f9d865a164f8d" id="r_a47671e8d5dd237d71c2f9d865a164f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a47671e8d5dd237d71c2f9d865a164f8d">bitwiseOr</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:a47671e8d5dd237d71c2f9d865a164f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise OR.  <br /></td></tr>
<tr class="separator:a47671e8d5dd237d71c2f9d865a164f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76496f612e4a491de89e79f3614153a4" id="r_a76496f612e4a491de89e79f3614153a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a76496f612e4a491de89e79f3614153a4">bitwiseXor</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:a76496f612e4a491de89e79f3614153a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise XOR.  <br /></td></tr>
<tr class="separator:a76496f612e4a491de89e79f3614153a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e91d618fc95ccec420977dad82cb6" id="r_acd1e91d618fc95ccec420977dad82cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#acd1e91d618fc95ccec420977dad82cb6">bitwiseXor</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2)</td></tr>
<tr class="memdesc:acd1e91d618fc95ccec420977dad82cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise XOR.  <br /></td></tr>
<tr class="separator:acd1e91d618fc95ccec420977dad82cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae09af97e4709d43d42b324fd2b39e77" id="r_aae09af97e4709d43d42b324fd2b39e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aae09af97e4709d43d42b324fd2b39e77">bitwiseXor</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other)</td></tr>
<tr class="memdesc:aae09af97e4709d43d42b324fd2b39e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise XOR.  <br /></td></tr>
<tr class="separator:aae09af97e4709d43d42b324fd2b39e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3012f0488776cca578c5cb0fad346541" id="r_a3012f0488776cca578c5cb0fad346541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3012f0488776cca578c5cb0fad346541">isEqualToZero</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a3012f0488776cca578c5cb0fad346541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare to zero.  <br /></td></tr>
<tr class="separator:a3012f0488776cca578c5cb0fad346541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bb56406c26e008ec5960c485e8e8a5" id="r_aa7bb56406c26e008ec5960c485e8e8a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa7bb56406c26e008ec5960c485e8e8a5">isEqualToZero</a> () const</td></tr>
<tr class="memdesc:aa7bb56406c26e008ec5960c485e8e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare to zero.  <br /></td></tr>
<tr class="separator:aa7bb56406c26e008ec5960c485e8e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fc1666d8ef5d669b67dfcbc3303633" id="r_a90fc1666d8ef5d669b67dfcbc3303633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a90fc1666d8ef5d669b67dfcbc3303633">compare</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a90fc1666d8ef5d669b67dfcbc3303633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as integers.  <br /></td></tr>
<tr class="separator:a90fc1666d8ef5d669b67dfcbc3303633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f10771f342e38cd77e95a734376b80d" id="r_a8f10771f342e38cd77e95a734376b80d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8f10771f342e38cd77e95a734376b80d">compare</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a8f10771f342e38cd77e95a734376b80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as integers.  <br /></td></tr>
<tr class="separator:a8f10771f342e38cd77e95a734376b80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4603ab0e8dd9ab4cb295e094f4e84cf6" id="r_a4603ab0e8dd9ab4cb295e094f4e84cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a4603ab0e8dd9ab4cb295e094f4e84cf6">compare</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:a4603ab0e8dd9ab4cb295e094f4e84cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as integers.  <br /></td></tr>
<tr class="separator:a4603ab0e8dd9ab4cb295e094f4e84cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fba45b6b6a518841734bc14d1afb3" id="r_a691fba45b6b6a518841734bc14d1afb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a691fba45b6b6a518841734bc14d1afb3">compareSigned</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a691fba45b6b6a518841734bc14d1afb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as signed integers.  <br /></td></tr>
<tr class="separator:a691fba45b6b6a518841734bc14d1afb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d9d1e4fdf0b5404b9e64cff9a45403" id="r_a42d9d1e4fdf0b5404b9e64cff9a45403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a42d9d1e4fdf0b5404b9e64cff9a45403">compareSigned</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range1, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range2) const</td></tr>
<tr class="memdesc:a42d9d1e4fdf0b5404b9e64cff9a45403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as signed integers.  <br /></td></tr>
<tr class="separator:a42d9d1e4fdf0b5404b9e64cff9a45403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca98c42b8427dc519c3f8be083fed19" id="r_afca98c42b8427dc519c3f8be083fed19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#afca98c42b8427dc519c3f8be083fed19">compareSigned</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;other) const</td></tr>
<tr class="memdesc:afca98c42b8427dc519c3f8be083fed19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bits as signed integers.  <br /></td></tr>
<tr class="separator:afca98c42b8427dc519c3f8be083fed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2615057433c0ff469c0e7454cf58a1fc" id="r_a2615057433c0ff469c0e7454cf58a1fc"><td class="memItemLeft" align="right" valign="top">boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a2615057433c0ff469c0e7454cf58a1fc">toInteger</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a2615057433c0ff469c0e7454cf58a1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret bits as an unsigned integer.  <br /></td></tr>
<tr class="separator:a2615057433c0ff469c0e7454cf58a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa444e97765fed6bfdba4a49c8cf7922f" id="r_aa444e97765fed6bfdba4a49c8cf7922f"><td class="memItemLeft" align="right" valign="top">boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa444e97765fed6bfdba4a49c8cf7922f">toInteger</a> () const</td></tr>
<tr class="memdesc:aa444e97765fed6bfdba4a49c8cf7922f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret bits as an unsigned integer.  <br /></td></tr>
<tr class="separator:aa444e97765fed6bfdba4a49c8cf7922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ee12d53023c66fbec2bf0e616d1911" id="r_ab6ee12d53023c66fbec2bf0e616d1911"><td class="memItemLeft" align="right" valign="top">boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ab6ee12d53023c66fbec2bf0e616d1911">toSignedInteger</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:ab6ee12d53023c66fbec2bf0e616d1911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret bits as a signed integer.  <br /></td></tr>
<tr class="separator:ab6ee12d53023c66fbec2bf0e616d1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8ffe8c8bc61e949cb0d09fb20873f7" id="r_a5a8ffe8c8bc61e949cb0d09fb20873f7"><td class="memItemLeft" align="right" valign="top">boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a5a8ffe8c8bc61e949cb0d09fb20873f7">toSignedInteger</a> () const</td></tr>
<tr class="memdesc:a5a8ffe8c8bc61e949cb0d09fb20873f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret bits as a signed integer.  <br /></td></tr>
<tr class="separator:a5a8ffe8c8bc61e949cb0d09fb20873f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6c52521549bf68b18c873e2d966cfd" id="r_aba6c52521549bf68b18c873e2d966cfd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aba6c52521549bf68b18c873e2d966cfd">toHex</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:aba6c52521549bf68b18c873e2d966cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a hexadecimal string.  <br /></td></tr>
<tr class="separator:aba6c52521549bf68b18c873e2d966cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2980cc6a48c4230d49d52904b5a3d5a1" id="r_a2980cc6a48c4230d49d52904b5a3d5a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a2980cc6a48c4230d49d52904b5a3d5a1">toHex</a> () const</td></tr>
<tr class="memdesc:a2980cc6a48c4230d49d52904b5a3d5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a hexadecimal string.  <br /></td></tr>
<tr class="separator:a2980cc6a48c4230d49d52904b5a3d5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52256895bb5ef38b77f2c934e8985081" id="r_a52256895bb5ef38b77f2c934e8985081"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a52256895bb5ef38b77f2c934e8985081">toOctal</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a52256895bb5ef38b77f2c934e8985081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an octal string.  <br /></td></tr>
<tr class="separator:a52256895bb5ef38b77f2c934e8985081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f1645907e8529617502374aad1e24" id="r_a0f4f1645907e8529617502374aad1e24"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0f4f1645907e8529617502374aad1e24">toOctal</a> () const</td></tr>
<tr class="memdesc:a0f4f1645907e8529617502374aad1e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an octal string.  <br /></td></tr>
<tr class="separator:a0f4f1645907e8529617502374aad1e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f3412c5d67cf9f0918d9509be70ed6" id="r_a64f3412c5d67cf9f0918d9509be70ed6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a64f3412c5d67cf9f0918d9509be70ed6">toBinary</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a64f3412c5d67cf9f0918d9509be70ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a binary string.  <br /></td></tr>
<tr class="separator:a64f3412c5d67cf9f0918d9509be70ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bfe032526f900c40bbf24723ba96a6" id="r_ad1bfe032526f900c40bbf24723ba96a6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad1bfe032526f900c40bbf24723ba96a6">toBinary</a> () const</td></tr>
<tr class="memdesc:ad1bfe032526f900c40bbf24723ba96a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an binary string.  <br /></td></tr>
<tr class="separator:ad1bfe032526f900c40bbf24723ba96a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d943b31226c1b9de7eb40ff1a06f774" id="r_a3d943b31226c1b9de7eb40ff1a06f774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3d943b31226c1b9de7eb40ff1a06f774">fromInteger</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, boost::uint64_t value)</td></tr>
<tr class="memdesc:a3d943b31226c1b9de7eb40ff1a06f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from an integer.  <br /></td></tr>
<tr class="separator:a3d943b31226c1b9de7eb40ff1a06f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a01afa37f69796d1ef506a9326b6e" id="r_aa84a01afa37f69796d1ef506a9326b6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa84a01afa37f69796d1ef506a9326b6e">fromInteger</a> (boost::uint64_t value)</td></tr>
<tr class="memdesc:aa84a01afa37f69796d1ef506a9326b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from an integer.  <br /></td></tr>
<tr class="separator:aa84a01afa37f69796d1ef506a9326b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5387e3566bf3e55c40b9f0c982b7e52" id="r_aa5387e3566bf3e55c40b9f0c982b7e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa5387e3566bf3e55c40b9f0c982b7e52">fromDecimal</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:aa5387e3566bf3e55c40b9f0c982b7e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains bits from a decimal representation.  <br /></td></tr>
<tr class="separator:aa5387e3566bf3e55c40b9f0c982b7e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6382d86d3ba3cd42f0fff269d0fecd" id="r_afd6382d86d3ba3cd42f0fff269d0fecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#afd6382d86d3ba3cd42f0fff269d0fecd">fromDecimal</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:afd6382d86d3ba3cd42f0fff269d0fecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a decimal representation.  <br /></td></tr>
<tr class="separator:afd6382d86d3ba3cd42f0fff269d0fecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1f6849ce8000a9f7228104f464591e" id="r_a8c1f6849ce8000a9f7228104f464591e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8c1f6849ce8000a9f7228104f464591e">fromHex</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a8c1f6849ce8000a9f7228104f464591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a hexadecimal representation.  <br /></td></tr>
<tr class="separator:a8c1f6849ce8000a9f7228104f464591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff43127d36f97c7e2c7cf843ff1f88" id="r_a0bff43127d36f97c7e2c7cf843ff1f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0bff43127d36f97c7e2c7cf843ff1f88">fromHex</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a0bff43127d36f97c7e2c7cf843ff1f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a hexadecimal representation.  <br /></td></tr>
<tr class="separator:a0bff43127d36f97c7e2c7cf843ff1f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6abe52dc52264242ca79999561a8d7" id="r_a0e6abe52dc52264242ca79999561a8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0e6abe52dc52264242ca79999561a8d7">fromOctal</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a0e6abe52dc52264242ca79999561a8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from an octal representation.  <br /></td></tr>
<tr class="separator:a0e6abe52dc52264242ca79999561a8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6222dfa99ebe1fb47577045fa79b73" id="r_a1b6222dfa99ebe1fb47577045fa79b73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a1b6222dfa99ebe1fb47577045fa79b73">fromOctal</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a1b6222dfa99ebe1fb47577045fa79b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from an octal representation.  <br /></td></tr>
<tr class="separator:a1b6222dfa99ebe1fb47577045fa79b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b8a0fa11da896cd0020bdb9efd5c8" id="r_a8a9b8a0fa11da896cd0020bdb9efd5c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8a9b8a0fa11da896cd0020bdb9efd5c8">fromBinary</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, const std::string &amp;input)</td></tr>
<tr class="memdesc:a8a9b8a0fa11da896cd0020bdb9efd5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a binary representation.  <br /></td></tr>
<tr class="separator:a8a9b8a0fa11da896cd0020bdb9efd5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d8b0f5e4ab64ef5bb320ab532c2f9b" id="r_ac2d8b0f5e4ab64ef5bb320ab532c2f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ac2d8b0f5e4ab64ef5bb320ab532c2f9b">fromBinary</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:ac2d8b0f5e4ab64ef5bb320ab532c2f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a binary representation.  <br /></td></tr>
<tr class="separator:ac2d8b0f5e4ab64ef5bb320ab532c2f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aef9f4b51c24193972024d5db21bf51" id="r_a4aef9f4b51c24193972024d5db21bf51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a4aef9f4b51c24193972024d5db21bf51">checkRange</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a4aef9f4b51c24193972024d5db21bf51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Assert.html" title="Run-time logic assertions.">Assert</a> valid range.  <br /></td></tr>
<tr class="separator:a4aef9f4b51c24193972024d5db21bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf331c28cb21168e6e4fab44b446ea" id="r_a65bf331c28cb21168e6e4fab44b446ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a65bf331c28cb21168e6e4fab44b446ea">dataSize</a> () const</td></tr>
<tr class="memdesc:a65bf331c28cb21168e6e4fab44b446ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw data size.  <br /></td></tr>
<tr class="separator:a65bf331c28cb21168e6e4fab44b446ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e92229a96633b7b5a59f890b00b0dd2" id="r_a4e92229a96633b7b5a59f890b00b0dd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a4e92229a96633b7b5a59f890b00b0dd2">toBytes</a> () const</td></tr>
<tr class="memdesc:a4e92229a96633b7b5a59f890b00b0dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a vector of bytes.  <br /></td></tr>
<tr class="separator:a4e92229a96633b7b5a59f890b00b0dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e297c817dcaf28d237d927a2c1662ce" id="r_a7e297c817dcaf28d237d927a2c1662ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a7e297c817dcaf28d237d927a2c1662ce">toBytes</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range) const</td></tr>
<tr class="memdesc:a7e297c817dcaf28d237d927a2c1662ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a vector of bytes.  <br /></td></tr>
<tr class="separator:a7e297c817dcaf28d237d927a2c1662ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9e4074aa6f1e1d4b2ba75aa902fd772a" id="r_a9e4074aa6f1e1d4b2ba75aa902fd772a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a9e4074aa6f1e1d4b2ba75aa902fd772a">fromBytes</a> (const std::vector&lt; uint8_t &gt; &amp;input)</td></tr>
<tr class="memdesc:a9e4074aa6f1e1d4b2ba75aa902fd772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a byte vector.  <br /></td></tr>
<tr class="separator:a9e4074aa6f1e1d4b2ba75aa902fd772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52e0fffaa76392c6804ef5a5115b43d" id="r_af52e0fffaa76392c6804ef5a5115b43d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#af52e0fffaa76392c6804ef5a5115b43d">fromBytes</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;range, const std::vector&lt; uint8_t &gt; &amp;input)</td></tr>
<tr class="memdesc:af52e0fffaa76392c6804ef5a5115b43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain bits from a byte vector.  <br /></td></tr>
<tr class="separator:af52e0fffaa76392c6804ef5a5115b43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a78fa539344cebb182887eb009089ee20" id="r_a78fa539344cebb182887eb009089ee20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Word</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a78fa539344cebb182887eb009089ee20">data</a> ()</td></tr>
<tr class="memdesc:a78fa539344cebb182887eb009089ee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw data for vector.  <br /></td></tr>
<tr class="separator:a78fa539344cebb182887eb009089ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedf1b5b45390bdad1857d7b6dd06bb5" id="r_adedf1b5b45390bdad1857d7b6dd06bb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Word</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#adedf1b5b45390bdad1857d7b6dd06bb5">data</a> () const</td></tr>
<tr class="memdesc:adedf1b5b45390bdad1857d7b6dd06bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw data for vector.  <br /></td></tr>
<tr class="separator:adedf1b5b45390bdad1857d7b6dd06bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9aea292e884c332e080857bfc430ad82" id="r_a9aea292e884c332e080857bfc430ad82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a9aea292e884c332e080857bfc430ad82">parse</a> (std::string str)</td></tr>
<tr class="memdesc:a9aea292e884c332e080857bfc430ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit vector by reading a string.  <br /></td></tr>
<tr class="separator:a9aea292e884c332e080857bfc430ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740220b2578abfbaacd1dca3be0a781d" id="r_a740220b2578abfbaacd1dca3be0a781d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a740220b2578abfbaacd1dca3be0a781d">baseSize</a> (size_t base, size_t <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a49f05ce7f5af5ee0e9869a84db392301">size</a>)</td></tr>
<tr class="memdesc:a740220b2578abfbaacd1dca3be0a781d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit range from a starting offset and size.  <br /></td></tr>
<tr class="separator:a740220b2578abfbaacd1dca3be0a781d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b1366b4be5447c6e13929b09a7e2f" id="r_a575b1366b4be5447c6e13929b09a7e2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a575b1366b4be5447c6e13929b09a7e2f">hull</a> (size_t minOffset, size_t maxOffset)</td></tr>
<tr class="memdesc:a575b1366b4be5447c6e13929b09a7e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bit range from min and max positions.  <br /></td></tr>
<tr class="separator:a575b1366b4be5447c6e13929b09a7e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0381629ea9a527d239916f0efd7168c9" name="a0381629ea9a527d239916f0efd7168c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0381629ea9a527d239916f0efd7168c9">&#9670;&#160;</a></span>Word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Sawyer::Container::BitVector::Word</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base storage type. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00071">71</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="ad0d02ed250ef2712b681970b37b1bb61" name="ad0d02ed250ef2712b681970b37b1bb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d02ed250ef2712b681970b37b1bb61">&#9670;&#160;</a></span>BitRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Interval.html">BitVectorSupport::BitRange</a> <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">Sawyer::Container::BitVector::BitRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes an inclusive interval of bit indices. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00072">72</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0ace0972d3cec4c55a5b2106a92301ed" name="a0ace0972d3cec4c55a5b2106a92301ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ace0972d3cec4c55a5b2106a92301ed">&#9670;&#160;</a></span>BitVector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sawyer::Container::BitVector::BitVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct an empty vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00102">102</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="a9b8e95f965808f5077abc300d0afdd51" name="a9b8e95f965808f5077abc300d0afdd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8e95f965808f5077abc300d0afdd51">&#9670;&#160;</a></span>BitVector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sawyer::Container::BitVector::BitVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00105">105</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="a67f2a07d84ef2c8d3c5acbeea8ee0e18" name="a67f2a07d84ef2c8d3c5acbeea8ee0e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f2a07d84ef2c8d3c5acbeea8ee0e18">&#9670;&#160;</a></span>BitVector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sawyer::Container::BitVector::BitVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a vector of specified size. </p>
<p>All bits in this vector will be set to the <code>newBits</code> value. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00110">110</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l00215">resize()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9aea292e884c332e080857bfc430ad82" name="a9aea292e884c332e080857bfc430ad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aea292e884c332e080857bfc430ad82">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> Sawyer::Container::BitVector::parse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a bit vector by reading a string. </p>
<p>Reads a bit vector from the string and returns the result. The input string has an optional suffix ("h" for hexadecimal) or optioanl prefix ("0x" for hexadecimal, "0b" or binary, or "0" for octal). It does not have both; if a suffix is present then the parser does not search for a prefix. Lack of both prefix and suffix implies decimal format. Any recognized suffix or prefix is stripped from the value, and the number of valid digits is counted and used to calculate the width of the resulting bit vector. For instance, if three octal digits are found (not counting the "0" prefix) then the resulting bit vector will have nine bits &ndash; three per digit. The string is then passed to <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8a9b8a0fa11da896cd0020bdb9efd5c8">fromBinary</a>, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0e6abe52dc52264242ca79999561a8d7">fromOctal</a>, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#aa5387e3566bf3e55c40b9f0c982b7e52">fromDecimal</a>, or <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a8c1f6849ce8000a9f7228104f464591e">fromHex</a> for parsing.</p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00125">125</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01448">fromBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01367">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01394">fromHex()</a>, and <a class="el" href="BitVector_8h_source.html#l01421">fromOctal()</a>.</p>

</div>
</div>
<a id="abc2a6ea93f6c711c9de69d88ff5ec987" name="abc2a6ea93f6c711c9de69d88ff5ec987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2a6ea93f6c711c9de69d88ff5ec987">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment. </p>
<p>Makes this bit vector an exact copy of the <code>other</code> vector.</p>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ae020499e74716a481e10acc5b12d75d2">copy</a> method is similar but does not change the <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a49f05ce7f5af5ee0e9869a84db392301" title="Size of vector in bits.">size</a> of the destination vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00194">194</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="af8335826daf5ee30dab6bc9cba96bdfa" name="af8335826daf5ee30dab6bc9cba96bdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8335826daf5ee30dab6bc9cba96bdfa">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the vector is empty. </p>
<p>Returns true if this vector contains no data. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00203">203</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01312">Rose::BinaryAnalysis::SymbolicExpression::Leaf::isConstant()</a>.</p>

</div>
</div>
<a id="a49f05ce7f5af5ee0e9869a84db392301" name="a49f05ce7f5af5ee0e9869a84db392301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f05ce7f5af5ee0e9869a84db392301">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of vector in bits. </p>
<p>Returns the size of this vector in bits. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00208">208</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpressionParser_8h_source.html#l00089">Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Token()</a>, <a class="el" href="BitVector_8h_source.html#l00251">baseSize()</a>, <a class="el" href="BitVector_8h_source.html#l00405">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00942">multiply()</a>, <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>, <a class="el" href="BitVector_8h_source.html#l01233">toInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l01256">toSignedInteger()</a>.</p>

</div>
</div>
<a id="a714048799b18f6129aaee008f8fb2627" name="a714048799b18f6129aaee008f8fb2627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714048799b18f6129aaee008f8fb2627">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change vector size. </p>
<p>Changes the size of a vector, measured in bits, by either adding or removing bits from the most-significant side of this vector. If new bits are added they are each given the value <code>newBits</code>. Increasing the size of a vector may cause it to reallocate and copy its internal data structures. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00215">215</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l00281">clear()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">Sawyer::Container::BitVectorSupport::setValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00110">BitVector()</a>, <a class="el" href="BitVector_8h_source.html#l00942">multiply()</a>, and <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>.</p>

</div>
</div>
<a id="a1cbd82b71d7ce2c95fb21d8aaedebb8f" name="a1cbd82b71d7ce2c95fb21d8aaedebb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd82b71d7ce2c95fb21d8aaedebb8f">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size before reallocation. </p>
<p>Returns the maximum number of bits to which this vector could be resized via <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a714048799b18f6129aaee008f8fb2627">resize</a> before it becomes necessary to reallocate its internal data structures. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00236">236</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="a6cd958a91e697da6ae26aa3cc91b2ba9" name="a6cd958a91e697da6ae26aa3cc91b2ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd958a91e697da6ae26aa3cc91b2ba9">&#9670;&#160;</a></span>hull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> Sawyer::Container::BitVector::hull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1Container_1_1Interval.html" title="Range of values delimited by endpoints.">Interval</a> representing the entire vector. </p>
<p>Returns the smallest index interval that includes all bits. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00243">243</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00844">add()</a>, <a class="el" href="BitVector_8h_source.html#l01045">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01077">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01109">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l00292">clear()</a>, <a class="el" href="BitVector_8h_source.html#l01172">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01212">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00811">decrement()</a>, <a class="el" href="BitVector_8h_source.html#l00405">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l01462">fromBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01474">fromBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01381">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01408">fromHex()</a>, <a class="el" href="BitVector_8h_source.html#l01353">fromInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01435">fromOctal()</a>, <a class="el" href="BitVector_8h_source.html#l00793">increment()</a>, <a class="el" href="BitVector_8h_source.html#l01013">invert()</a>, <a class="el" href="BitVector_8h_source.html#l00519">isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00499">isAllSet()</a>, <a class="el" href="BitVector_8h_source.html#l01134">isEqualToZero()</a>, <a class="el" href="BitVector_8h_source.html#l00447">leastSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00629">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00429">leastSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00483">mostSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00589">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00465">mostSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00924">multiply10()</a>, <a class="el" href="BitVector_8h_source.html#l00549">nClear()</a>, <a class="el" href="BitVector_8h_source.html#l00774">negate()</a>, <a class="el" href="BitVector_8h_source.html#l00534">nSet()</a>, <a class="el" href="BitVector_8h_source.html#l00751">rotateLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00730">rotateRight()</a>, <a class="el" href="BitVector_8h_source.html#l00311">set()</a>, <a class="el" href="BitVector_8h_source.html#l00328">setValue()</a>, <a class="el" href="BitVector_8h_source.html#l00657">shiftLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00682">shiftRight()</a>, <a class="el" href="BitVector_8h_source.html#l00709">shiftRightArithmetic()</a>, <a class="el" href="BitVector_8h_source.html#l00915">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00882">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l01316">toBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01327">toBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01278">toHex()</a>, <a class="el" href="BitVector_8h_source.html#l01233">toInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01297">toOctal()</a>, and <a class="el" href="BitVector_8h_source.html#l01256">toSignedInteger()</a>.</p>

</div>
</div>
<a id="a740220b2578abfbaacd1dca3be0a781d" name="a740220b2578abfbaacd1dca3be0a781d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740220b2578abfbaacd1dca3be0a781d">&#9670;&#160;</a></span>baseSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> Sawyer::Container::BitVector::baseSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a bit range from a starting offset and size. </p>
<p>This is just a convenience wrapper around <a class="el" href="classSawyer_1_1Container_1_1Interval.html#a136b9afce8c48871c21c58dc9ecdc48f" title="Construct an interval from one endpoint and a size.">BitRange::baseSize()</a> so that name qualification can be avoided when "using
namespace" directives are not employed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00251">251</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00173">Sawyer::Container::Interval&lt; size_t &gt;::baseSize()</a>, and <a class="el" href="BitVector_8h_source.html#l00208">size()</a>.</p>

</div>
</div>
<a id="a575b1366b4be5447c6e13929b09a7e2f" name="a575b1366b4be5447c6e13929b09a7e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575b1366b4be5447c6e13929b09a7e2f">&#9670;&#160;</a></span>hull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> Sawyer::Container::BitVector::hull </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a bit range from min and max positions. </p>
<p>This is just a convenience wrapper around <a class="el" href="classSawyer_1_1Container_1_1Interval.html#a164457a90e3cc9c898d0eea5a57fca2a" title="Construct an interval from two endpoints.">BitRange::hull(size_t,size_t)</a> so that name qualification can be avoided when "using namespace" directives are not employed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00259">259</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="Interval_8h_source.html#l00162">Sawyer::Container::Interval&lt; size_t &gt;::hull()</a>.</p>

</div>
</div>
<a id="a80b2c635fc6d9f089c5f8336b2ece893" name="a80b2c635fc6d9f089c5f8336b2ece893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b2c635fc6d9f089c5f8336b2ece893">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve one bit. </p>
<p>Returns the value of the bit at the specified index in constant time. The index must be a valid index for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00271">271</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00384">Sawyer::Container::BitVectorSupport::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphTraversal_8h_source.html#l00724">Sawyer::Container::Algorithm::GraphTraversal&lt; G, Order, Direction &gt;::isDiscovered()</a>, <a class="el" href="GraphTraversal_8h_source.html#l00733">Sawyer::Container::Algorithm::GraphTraversal&lt; G, Order, Direction &gt;::isVisited()</a>, <a class="el" href="BitVector_8h_source.html#l00942">multiply()</a>, and <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>.</p>

</div>
</div>
<a id="a0980597d500db192bbabcb60429b6b32" name="a0980597d500db192bbabcb60429b6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0980597d500db192bbabcb60429b6b32">&#9670;&#160;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign zero to some bits. </p>
<p>Clears bits by assigning false to each bit in the specified range. The convention is that "clear" means to assign false to a bit and should not be confused with the STL usage of the word, namely to erase all values from a container. To erase all bits from a vector, use <code>resize(0)</code>. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00281">281</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00400">Sawyer::Container::BitVectorSupport::clear()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00215">resize()</a>.</p>

</div>
</div>
<a id="a7819e37d0b36f7805388f2883bb89628" name="a7819e37d0b36f7805388f2883bb89628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7819e37d0b36f7805388f2883bb89628">&#9670;&#160;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign zero to all bits. </p>
<p>Clears bits by assigning false to all bits in this vector. The convention is that "clear" means to assign false to to a bit and should not be confused with the STL usage of the word, namely to erase all values from a container. To erase all bits from a vector, use <code>resize(0)</code>. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00292">292</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00400">Sawyer::Container::BitVectorSupport::clear()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a80a1d3ad781210d44368f4a2536b0f00" name="a80a1d3ad781210d44368f4a2536b0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a1d3ad781210d44368f4a2536b0f00">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign true to some bits. </p>
<p>Sets bits by assigning true (or <code>newBits</code>) to each bit in the specified range. The convention is that "set" means to assign true to a bit; to assign a specific value use <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a79bf0d5cf5b1df24d6c7106964e817f4">setValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00301">301</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00417">Sawyer::Container::BitVectorSupport::set()</a>.</p>

</div>
</div>
<a id="a61456be73a9e4deeb05d7957dfdb369c" name="a61456be73a9e4deeb05d7957dfdb369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61456be73a9e4deeb05d7957dfdb369c">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign true to all bits. </p>
<p>Sets bits by assigning true (or <code>newBits</code>) to all bits in this vector. The convention is that "set" means to assign true to a bit; to assign a specific value use <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a79bf0d5cf5b1df24d6c7106964e817f4">setValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00311">311</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00417">Sawyer::Container::BitVectorSupport::set()</a>.</p>

</div>
</div>
<a id="a79bf0d5cf5b1df24d6c7106964e817f4" name="a79bf0d5cf5b1df24d6c7106964e817f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bf0d5cf5b1df24d6c7106964e817f4">&#9670;&#160;</a></span>setValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::setValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign true/false to some bits. </p>
<p>Sets the bits in the specified range to the specified value. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00319">319</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">Sawyer::Container::BitVectorSupport::setValue()</a>.</p>

</div>
</div>
<a id="aa8380210716c085004adb77e785000d9" name="aa8380210716c085004adb77e785000d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8380210716c085004adb77e785000d9">&#9670;&#160;</a></span>setValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::setValue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign true/false to all bits. </p>
<p>Sets all bits to the specified value. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00328">328</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00426">Sawyer::Container::BitVectorSupport::setValue()</a>.</p>

</div>
</div>
<a id="ae020499e74716a481e10acc5b12d75d2" name="ae020499e74716a481e10acc5b12d75d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae020499e74716a481e10acc5b12d75d2">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy some bits. </p>
<p>Copies bits from <code>other</code> specified by <code>from</code> into this vector specified by <code>to</code>. The ranges must be the same size and must be valid for their respective vectors. The <code>other</code> vector is permitted to be the same vector as <code>this</code>, in which case <code>from</code> is also permitted to overlap with <code>to</code>.</p>
<dl class="section see"><dt>See also</dt><dd>Copy constructor and assignment operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00340">340</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">Sawyer::Container::BitVectorSupport::copy()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a36178a0b193130fdfdc4cbbdd74fd124" name="a36178a0b193130fdfdc4cbbdd74fd124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36178a0b193130fdfdc4cbbdd74fd124">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy some bits. </p>
<p>Copies bits from the range <code>from</code> to the range <code>to</code>. Both ranges must be the same size, and they may overlap.</p>
<dl class="section see"><dt>See also</dt><dd>Copy constructor and assignment operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00352">352</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00448">Sawyer::Container::BitVectorSupport::copy()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a583c7d435b045a3d62328752b02303af" name="a583c7d435b045a3d62328752b02303af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583c7d435b045a3d62328752b02303af">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap some bits. </p>
<p>Swaps bits between <code>range1</code> of this vector and <code>range2</code> of the <code>other</code> vector. Both ranges must be the same size and must be valid for their respective vectors. The <code>other</code> vector is permitted to be the same vector as <code>this</code>, but <code>range1</code> and <code>range2</code> are not permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00364">364</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00470">Sawyer::Container::BitVectorSupport::swap()</a>.</p>

</div>
</div>
<a id="aead49c379759a7a63bada0d41f2d57aa" name="aead49c379759a7a63bada0d41f2d57aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead49c379759a7a63bada0d41f2d57aa">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap some bits. </p>
<p>Swaps bits between <code>range1</code> and <code>range2</code> of this vector. Both ranges must be the same size, and must be valid for this vector, and must not overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00375">375</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00470">Sawyer::Container::BitVectorSupport::swap()</a>.</p>

</div>
</div>
<a id="af4b6f1a123ba6df173b13778849316d0" name="af4b6f1a123ba6df173b13778849316d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b6f1a123ba6df173b13778849316d0">&#9670;&#160;</a></span>equalTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::equalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two ranges are equal. </p>
<p>Returns true if the bits of the first range are equal to the bits in the second range. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00385">385</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00497">Sawyer::Container::BitVectorSupport::equalTo()</a>.</p>

</div>
</div>
<a id="a28925c27e64e2b1ade881763045312c7" name="a28925c27e64e2b1ade881763045312c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28925c27e64e2b1ade881763045312c7">&#9670;&#160;</a></span>equalTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::equalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the bits of two ranges are equal. </p>
<p>Returns true if the bits contained in the first range match the bits contained in the second range. If the ranges are different sizes then returns false. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00395">395</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00497">Sawyer::Container::BitVectorSupport::equalTo()</a>.</p>

</div>
</div>
<a id="a7bfed3d4d52afa6dbadde6723e072879" name="a7bfed3d4d52afa6dbadde6723e072879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfed3d4d52afa6dbadde6723e072879">&#9670;&#160;</a></span>equalTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::equalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the bits of one vector are equal to the bits of the other. </p>
<p>If the vectors are different sizes then they are considered to be unequal regardless of their content. See also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a90fc1666d8ef5d669b67dfcbc3303633">compare</a>. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00405">405</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00497">Sawyer::Container::BitVectorSupport::equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVector_8h_source.html#l00208">size()</a>.</p>

</div>
</div>
<a id="a53036b9231a66110d4cec2e356b04389" name="a53036b9231a66110d4cec2e356b04389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53036b9231a66110d4cec2e356b04389">&#9670;&#160;</a></span>leastSignificantSetBit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantSetBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the least significant set bit. </p>
<p>Returns the index for the least significant bit that has the value true in the specified range. The range must be valid for this vector. If the range has no such bits, including the case when the range is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00420">420</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00534">Sawyer::Container::BitVectorSupport::leastSignificantSetBit()</a>.</p>

</div>
</div>
<a id="ac46793b2a3bb72eb91412c7518527a6b" name="ac46793b2a3bb72eb91412c7518527a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46793b2a3bb72eb91412c7518527a6b">&#9670;&#160;</a></span>leastSignificantSetBit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantSetBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the least significant set bit. </p>
<p>Returns the index for the least significant bit that has the value true. If no bit is true, including the case when the vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00429">429</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00534">Sawyer::Container::BitVectorSupport::leastSignificantSetBit()</a>.</p>

</div>
</div>
<a id="a1a0a1eb5f442810516f5f99bb0ae8d9d" name="a1a0a1eb5f442810516f5f99bb0ae8d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0a1eb5f442810516f5f99bb0ae8d9d">&#9670;&#160;</a></span>leastSignificantClearBit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantClearBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the least significant clear bit. </p>
<p>Returns the index for the least significant bit that has the value false in the specified range. The range must be valid for this vector. If the range has no such bits, including the case when the range is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00438">438</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00566">Sawyer::Container::BitVectorSupport::leastSignificantClearBit()</a>.</p>

</div>
</div>
<a id="a5f3994e3f76b2a5a470f1464666845a4" name="a5f3994e3f76b2a5a470f1464666845a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3994e3f76b2a5a470f1464666845a4">&#9670;&#160;</a></span>leastSignificantClearBit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantClearBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the least significant clear bit. </p>
<p>Returns the index for the least significant bit that has the value false. If no bit is false, including the case when the vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00447">447</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00566">Sawyer::Container::BitVectorSupport::leastSignificantClearBit()</a>.</p>

</div>
</div>
<a id="a1e6a06fb217e86247e57e1c39f849a6b" name="a1e6a06fb217e86247e57e1c39f849a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6a06fb217e86247e57e1c39f849a6b">&#9670;&#160;</a></span>mostSignificantSetBit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantSetBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the most significant set bit. </p>
<p>Returns the index for the most significant bit that has the value true in the specified range. The range must be valid for this vector. If the range has no such bits, including the case when the range is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00456">456</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00599">Sawyer::Container::BitVectorSupport::mostSignificantSetBit()</a>.</p>

</div>
</div>
<a id="a09da55a7c778f124d5fdc84a284b9036" name="a09da55a7c778f124d5fdc84a284b9036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09da55a7c778f124d5fdc84a284b9036">&#9670;&#160;</a></span>mostSignificantSetBit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantSetBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the most significant set bit. </p>
<p>Returns the index for the most significant bit that has the value true. If no bit is true, including the case when the vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00465">465</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00599">Sawyer::Container::BitVectorSupport::mostSignificantSetBit()</a>.</p>

</div>
</div>
<a id="af514bc9ef1002590da3739e023f364c7" name="af514bc9ef1002590da3739e023f364c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af514bc9ef1002590da3739e023f364c7">&#9670;&#160;</a></span>mostSignificantClearBit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantClearBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the most significant clear bit. </p>
<p>Returns the index for the most significant bit that has the value false in the specified range. The range must be valid for this vector. If the range has no such bits, including the case when the range is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00474">474</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00632">Sawyer::Container::BitVectorSupport::mostSignificantClearBit()</a>.</p>

</div>
</div>
<a id="ab064e9fcfbe409df184018199d685b65" name="ab064e9fcfbe409df184018199d685b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab064e9fcfbe409df184018199d685b65">&#9670;&#160;</a></span>mostSignificantClearBit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantClearBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the most significant clear bit. </p>
<p>Returns the index for the most significant bit that has the value false. If no bit is false, including the case when the vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00483">483</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00632">Sawyer::Container::BitVectorSupport::mostSignificantClearBit()</a>.</p>

</div>
</div>
<a id="ad336fe1195eca05b15f7053bf3fc51e5" name="ad336fe1195eca05b15f7053bf3fc51e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad336fe1195eca05b15f7053bf3fc51e5">&#9670;&#160;</a></span>isAllSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isAllSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if all bits are set. </p>
<p>Returns true if all bits are set within the specified range, or if the range is empty. The range must be valid for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00491">491</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00644">Sawyer::Container::BitVectorSupport::isAllSet()</a>.</p>

</div>
</div>
<a id="a04d0555e81447c9c34e87a04e69d604c" name="a04d0555e81447c9c34e87a04e69d604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d0555e81447c9c34e87a04e69d604c">&#9670;&#160;</a></span>isAllSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isAllSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if all bits are set. </p>
<p>Returns true if all bits are set, or if the vector is empty. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00499">499</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00644">Sawyer::Container::BitVectorSupport::isAllSet()</a>.</p>

</div>
</div>
<a id="a181cbb8cf30a0da90e7f59523346c64d" name="a181cbb8cf30a0da90e7f59523346c64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181cbb8cf30a0da90e7f59523346c64d">&#9670;&#160;</a></span>isAllClear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isAllClear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if all bits are clear. </p>
<p>Returns true if all bits are clear within the specified range, or if the range is empty. The range must be valid for this vector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3012f0488776cca578c5cb0fad346541" title="Compare to zero.">isEqualToZero</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00509">509</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00652">Sawyer::Container::BitVectorSupport::isAllClear()</a>.</p>

</div>
</div>
<a id="a109be965d9669dd08314709049442308" name="a109be965d9669dd08314709049442308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109be965d9669dd08314709049442308">&#9670;&#160;</a></span>isAllClear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isAllClear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if all bits are clear. </p>
<p>Returns true if all bits are clear, or if the vector is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a3012f0488776cca578c5cb0fad346541" title="Compare to zero.">isEqualToZero</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00519">519</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00652">Sawyer::Container::BitVectorSupport::isAllClear()</a>.</p>

</div>
</div>
<a id="ade5be5afa5176b7fb00267f9442cb18a" name="ade5be5afa5176b7fb00267f9442cb18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5be5afa5176b7fb00267f9442cb18a">&#9670;&#160;</a></span>nSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::nSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of set bits. </p>
<p>Returns the number of bits that are set in the specified range. The range must be valid for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00526">526</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00675">Sawyer::Container::BitVectorSupport::nSet()</a>.</p>

</div>
</div>
<a id="ac39cd6df295bdd530451cfa7be5902dc" name="ac39cd6df295bdd530451cfa7be5902dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39cd6df295bdd530451cfa7be5902dc">&#9670;&#160;</a></span>nSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::nSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of set bits. </p>
<p>Returns the number of bits that are set. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00534">534</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00675">Sawyer::Container::BitVectorSupport::nSet()</a>.</p>

</div>
</div>
<a id="aef1bdd8fbd8a0ac8ed712ccbe28116a5" name="aef1bdd8fbd8a0ac8ed712ccbe28116a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1bdd8fbd8a0ac8ed712ccbe28116a5">&#9670;&#160;</a></span>nClear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::nClear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of clear bits. </p>
<p>Returns the number of bits that are clear in the specified range. The range must be valid for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00541">541</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00700">Sawyer::Container::BitVectorSupport::nClear()</a>.</p>

</div>
</div>
<a id="a4abbce4dbbafd07ddd11f7b5db604355" name="a4abbce4dbbafd07ddd11f7b5db604355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abbce4dbbafd07ddd11f7b5db604355">&#9670;&#160;</a></span>nClear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::nClear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of clear bits. </p>
<p>Returns the number of bits that are clear. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00549">549</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00700">Sawyer::Container::BitVectorSupport::nClear()</a>.</p>

</div>
</div>
<a id="a67ff2458cf147b294782d2fd98a47d44" name="a67ff2458cf147b294782d2fd98a47d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ff2458cf147b294782d2fd98a47d44">&#9670;&#160;</a></span>mostSignificantDifference() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find most significant difference. </p>
<p>Finds the most significant bit that differs between <code>range1</code> of this vector and <code>range2</code> of the <code>other</code> vector and returns its offset from the beginning of the ranges. Both ranges must be the same size and must be valid for their respective vectors. If no bits differ, including the case when both ranges are empty, then nothing is returned. The <code>other</code> vector is permitted to be the same as <code>this</code> vector, in which case the ranges are also permitted to overlap.</p>
<p>Note that the return value is not a vector index, but rather an offset with respect to the starting index in each of the ranges. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00563">563</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00766">Sawyer::Container::BitVectorSupport::mostSignificantDifference()</a>.</p>

</div>
</div>
<a id="a9abdeb49aa4a53c30052ad21b9bd82ff" name="a9abdeb49aa4a53c30052ad21b9bd82ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abdeb49aa4a53c30052ad21b9bd82ff">&#9670;&#160;</a></span>mostSignificantDifference() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find most significant difference. </p>
<p>Finds the most significant bit that differs between the two specified ranges of this vector and returns its offset from the beginning of the ranges. Both ranges must be the same size and must be valid for this vector. If no bits differ, including the case when both ranges are empty, then nothing is returned. The ranges are permitted to overlap.</p>
<p>Note that the return value is not a vector index, but rather an offset with respect to the starting index in each of the ranges. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00578">578</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00766">Sawyer::Container::BitVectorSupport::mostSignificantDifference()</a>.</p>

</div>
</div>
<a id="a0f0ede72b5194893bdf7e37d38401c3f" name="a0f0ede72b5194893bdf7e37d38401c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0ede72b5194893bdf7e37d38401c3f">&#9670;&#160;</a></span>mostSignificantDifference() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::mostSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find most significant difference. </p>
<p>Finds the most significant bit that differs between this vector and the <code>other</code> vector and return its index. Both vectors must be the same size. If no bits differ, including the case when this vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00589">589</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00766">Sawyer::Container::BitVectorSupport::mostSignificantDifference()</a>.</p>

</div>
</div>
<a id="ae59fd100ec69f48a55bd96ed8f83d93e" name="ae59fd100ec69f48a55bd96ed8f83d93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59fd100ec69f48a55bd96ed8f83d93e">&#9670;&#160;</a></span>leastSignificantDifference() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find least significant difference. </p>
<p>Finds the least significant bit that differs between <code>range1</code> of this vector and <code>range2</code> of the <code>other</code> vector and returns its offset from the beginning of the ranges. Both ranges must be the same size and must be valid for their respective vectors. If no bits differ, including the case when both ranges are empty, then nothing is returned. The <code>other</code> vector is permitted to be the same as <code>this</code> vector, in which case the ranges are also permitted to overlap.</p>
<p>Note that the return value is not a vector index, but rather an offset with respect to the starting index in each of the ranges. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00603">603</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00732">Sawyer::Container::BitVectorSupport::leastSignificantDifference()</a>.</p>

</div>
</div>
<a id="a88d5a51ea6bb3bd6add0de488ff716bc" name="a88d5a51ea6bb3bd6add0de488ff716bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d5a51ea6bb3bd6add0de488ff716bc">&#9670;&#160;</a></span>leastSignificantDifference() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find least significant difference. </p>
<p>Finds the least significant bit that differs between the two specified ranges of this vector and returns its offset from the beginning of the ranges. Both ranges must be the same size and must be valid for this vector. If no bits differ, including the case when both ranges are empty, then nothing is returned. The ranges are permitted to overlap.</p>
<p>Note that the return value is not a vector index, but rather an offset with respect to the starting index in each of the ranges. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00618">618</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00732">Sawyer::Container::BitVectorSupport::leastSignificantDifference()</a>.</p>

</div>
</div>
<a id="ac59dab3531a35d7289e68bc910fda371" name="ac59dab3531a35d7289e68bc910fda371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59dab3531a35d7289e68bc910fda371">&#9670;&#160;</a></span>leastSignificantDifference() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; size_t &gt; Sawyer::Container::BitVector::leastSignificantDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find least significant difference. </p>
<p>Finds the least significant bit that differs between this vector and the <code>other</code> vector and return its index. Both vectors must be the same size. If no bits differ, including the case when this vector is empty, then nothing is returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00629">629</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00732">Sawyer::Container::BitVectorSupport::leastSignificantDifference()</a>.</p>

</div>
</div>
<a id="aeb12c7ef3b96723eaccdd99152f7374e" name="aeb12c7ef3b96723eaccdd99152f7374e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb12c7ef3b96723eaccdd99152f7374e">&#9670;&#160;</a></span>shiftLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits left. </p>
<p>Shifts the bits in the specified range of this vector left (to more significant positions) by <code>nShift</code> bits. Bits shifted off the left of the range are discarded; new bits shifted into the right of the range are introduced with the value <code>newBits</code>. The range must be valid for this vector. If <code>nShift</code> is zero or the range is empty then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of the range has the same effect as filling the range with <code>newBits</code> (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00644">644</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00793">Sawyer::Container::BitVectorSupport::shiftLeft()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00942">multiply()</a>, and <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>.</p>

</div>
</div>
<a id="adc7b631db6561cae01f60691ad4476a8" name="adc7b631db6561cae01f60691ad4476a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7b631db6561cae01f60691ad4476a8">&#9670;&#160;</a></span>shiftLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits left. </p>
<p>Shifts all bits of this vector left (to more significant positions) by <code>nShift</code> bits. Bits shifted off the left of this vector are discarded; new bits shifted into the right of this vector are introduced with the value <code>newBits</code>. If <code>nShift</code> is zero or the vector is empty then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of this vector has the same effect as filling the vector with <code>newBits</code> (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00657">657</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00793">Sawyer::Container::BitVectorSupport::shiftLeft()</a>.</p>

</div>
</div>
<a id="a140f099df2da66d37dd12fafaf72dcd2" name="a140f099df2da66d37dd12fafaf72dcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140f099df2da66d37dd12fafaf72dcd2">&#9670;&#160;</a></span>shiftRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits right. </p>
<p>Shifts the bits in the specified range of this vector right (to less significant positions) by <code>nShift</code> bits. Bits shifted off the right of the range are discarded; new bits shifted into the left of the range are introduced with the value <code>newBits</code>. The range must be valid for this vector. If <code>nShift</code> is zero or the range is empty then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of the range has the same effect as filling the range with <code>newBits</code> (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00669">669</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00811">Sawyer::Container::BitVectorSupport::shiftRight()</a>.</p>

</div>
</div>
<a id="a0a18d20c3c06c71b87e5bd3c970cfe71" name="a0a18d20c3c06c71b87e5bd3c970cfe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a18d20c3c06c71b87e5bd3c970cfe71">&#9670;&#160;</a></span>shiftRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits right. </p>
<p>Shifts all bits of this vector right (to less significant positions) by <code>nShift</code> bits. Bits shifted off the right of this vector are discarded; new bits shifted into the left of this vector are introduced with the value <code>newBits</code>. If <code>nShift</code> is zero or the vector is empty then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of this vector has the same effect as filling the vector with <code>newBits</code> (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00682">682</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00811">Sawyer::Container::BitVectorSupport::shiftRight()</a>.</p>

</div>
</div>
<a id="acda2b3e05c1eb84009a3c21ab10c803b" name="acda2b3e05c1eb84009a3c21ab10c803b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda2b3e05c1eb84009a3c21ab10c803b">&#9670;&#160;</a></span>shiftRightArithmetic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftRightArithmetic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits right. </p>
<p>Shifts the bits in the specified range of this vector right (to less significant positions) by <code>nShift</code> bits. Bits shifted off the right of the range are discarded; new bits shifted into the left of the range are introduced with the same value as the original most-significant bit of the range. The range must be valid for this vector. If <code>nShift</code> is zero or the range is empty or a singleton then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of the range has the same effect as filling the range with its original most-significant bit (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00695">695</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00829">Sawyer::Container::BitVectorSupport::shiftRightArithmetic()</a>.</p>

</div>
</div>
<a id="a690607194a260b5a515c40b7595addac" name="a690607194a260b5a515c40b7595addac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690607194a260b5a515c40b7595addac">&#9670;&#160;</a></span>shiftRightArithmetic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::shiftRightArithmetic </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift bits right. </p>
<p>Shifts the bits in this vector right (to less significant positions) by <code>nShift</code> bits. Bits shifted off the right of this vector are discarded; new bits shifted into the left of this vector are introduced with the same value as the original most-significant bit of this vector. If <code>nShift</code> is zero or the vector is empty or only a single bit then no operation is performed. Specifying an <code>nShift</code> value equal to or greater than the size of this vector has the same effect as filling the vector with its original most-significant bit (see also, <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a80a1d3ad781210d44368f4a2536b0f00">set</a> and <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0980597d500db192bbabcb60429b6b32">clear</a>, which are probably more efficient). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00709">709</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00829">Sawyer::Container::BitVectorSupport::shiftRightArithmetic()</a>.</p>

</div>
</div>
<a id="a7e3ec60dc574af9174051fea4c8ad4a9" name="a7e3ec60dc574af9174051fea4c8ad4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ec60dc574af9174051fea4c8ad4a9">&#9670;&#160;</a></span>rotateRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::rotateRight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate bits right. </p>
<p>Rotates the bits in the specified range to the right (to less significant positions) by shifting right and reintroducing the bits shifted off the right end into the left end. The range must be valid for this vector. If <code>nShift</code> is zero modulo the range size, or the range is empty, then no operation is performed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00719">719</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00841">Sawyer::Container::BitVectorSupport::rotateRight()</a>.</p>

</div>
</div>
<a id="a733aa7cc9229323e2426a6321be2b813" name="a733aa7cc9229323e2426a6321be2b813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733aa7cc9229323e2426a6321be2b813">&#9670;&#160;</a></span>rotateRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::rotateRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate bits right. </p>
<p>Rotates all bits in this vector to the right (to less significant positions) by shifting right and reintroducing the bits shifted off the right end into the left end. If <code>nShift</code> is zero modulo this vector size, or this vector is empty, then no operation is performed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00730">730</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00841">Sawyer::Container::BitVectorSupport::rotateRight()</a>.</p>

</div>
</div>
<a id="a490beac89b7f12dd266a5059e4171ace" name="a490beac89b7f12dd266a5059e4171ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490beac89b7f12dd266a5059e4171ace">&#9670;&#160;</a></span>rotateLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::rotateLeft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate bits left. </p>
<p>Rotates the bits in the specified range to the left (to more significant positions) by shifting left and reintroducing the bits shifted off the left end into the right end. The range must be valid for this vector. If <code>nShift</code> is zero modulo the range size, or the range is empty, then no operation is performed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00740">740</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00865">Sawyer::Container::BitVectorSupport::rotateLeft()</a>.</p>

</div>
</div>
<a id="a0787632027438de63cf1c7335c03455e" name="a0787632027438de63cf1c7335c03455e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0787632027438de63cf1c7335c03455e">&#9670;&#160;</a></span>rotateLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::rotateLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nShift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate bits left. </p>
<p>Rotates all bits in this vector to the left (to more significant positions) by shifting left and reintroducing the bits shifted off the left end into the right end. If <code>nShift</code> is zero modulo this vector size, or this vector is empty, then no operation is performed. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00751">751</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00865">Sawyer::Container::BitVectorSupport::rotateLeft()</a>.</p>

</div>
</div>
<a id="a1c6f68f08471307cc33fe905ff8c9885" name="a1c6f68f08471307cc33fe905ff8c9885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6f68f08471307cc33fe905ff8c9885">&#9670;&#160;</a></span>negate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::negate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates bits as integer. </p>
<p>Treats <code>range1</code> of this vector as a two's complement integer and negates it, storing the result back into the same range of bits. The range must be valid for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00764">764</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01104">Sawyer::Container::BitVectorSupport::negate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>.</p>

</div>
</div>
<a id="a3bee6b5849173d4510648dfb7f6b5759" name="a3bee6b5849173d4510648dfb7f6b5759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bee6b5849173d4510648dfb7f6b5759">&#9670;&#160;</a></span>negate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates bits as integer. </p>
<p>Treats all bits of this vector as a two's complement integer and negates it, storing the result back into this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00774">774</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01104">Sawyer::Container::BitVectorSupport::negate()</a>.</p>

</div>
</div>
<a id="a0b8e8dff6b39ae8302ab79e14dbba981" name="a0b8e8dff6b39ae8302ab79e14dbba981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8e8dff6b39ae8302ab79e14dbba981">&#9670;&#160;</a></span>increment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment bits as integer. </p>
<p>Treats <code>range1</code> of this vector as an integer and adds one to it, storing the result back into this vector. The range must be valid for this vector. Returns true if all bits were originally set and the result is all clear (i.e., returns the carry-out value) . </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00784">784</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01067">Sawyer::Container::BitVectorSupport::increment()</a>.</p>

</div>
</div>
<a id="a117b599387241c144ea353bc8dcc45fa" name="a117b599387241c144ea353bc8dcc45fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117b599387241c144ea353bc8dcc45fa">&#9670;&#160;</a></span>increment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::increment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment bits as integer. </p>
<p>Treats the entire vector as an integer and adds one to it, storing the result back into the vector. Returns true if all bits were originally set and the result is all clear (i.e., returns the carry-out value). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00793">793</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01067">Sawyer::Container::BitVectorSupport::increment()</a>.</p>

</div>
</div>
<a id="a7add238864186bb80ffcb2dbb2e326a3" name="a7add238864186bb80ffcb2dbb2e326a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7add238864186bb80ffcb2dbb2e326a3">&#9670;&#160;</a></span>decrement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::decrement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement bits as integer. </p>
<p>Treats <code>range1</code> of this vector as an integer and subtracts one from it, storing the result back into this vector. The range must be valid for this vector. Returns true if all bits were originally clear and the result is all set (i.e., returns the overflow bit) . </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00802">802</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01094">Sawyer::Container::BitVectorSupport::decrement()</a>.</p>

</div>
</div>
<a id="a182e6fe271710ec91e7d18d6dc2fd30f" name="a182e6fe271710ec91e7d18d6dc2fd30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182e6fe271710ec91e7d18d6dc2fd30f">&#9670;&#160;</a></span>decrement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::decrement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement bits as integer. </p>
<p>Treats the entire vector as an integer and subtracts one from it, storing the result back into the vector. Returns true if all bits were originally clear and the result is all set (i.e., returns the overflow bit). </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00811">811</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01094">Sawyer::Container::BitVectorSupport::decrement()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="ad227b36add661119094a305c657b56d2" name="ad227b36add661119094a305c657b56d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad227b36add661119094a305c657b56d2">&#9670;&#160;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add bits as integers. </p>
<p>Treats <code>range1</code> of this vector and <code>range2</code> of the <code>other</code> vector as integers, sums them, and stores the result in <code>range1</code> of this vector. The ranges must be valid for their respective vectors, and both ranges must be the same size. The <code>other</code> vector is permitted to be the same vector as <code>this</code>, in which case the ranges are also permitted to overlap. Returns the final carry-out value which is not stored in the result. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00821">821</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">Sawyer::Container::BitVectorSupport::add()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00942">multiply()</a>, and <a class="el" href="BitVector_8h_source.html#l00958">multiplySigned()</a>.</p>

</div>
</div>
<a id="a5c47d36d3799d8c60cf4d46b290e7f24" name="a5c47d36d3799d8c60cf4d46b290e7f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c47d36d3799d8c60cf4d46b290e7f24">&#9670;&#160;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add bits as integers. </p>
<p>Treats <code>range1</code> and <code>range2</code> of this vector as integers, sums them, and stores the result in <code>range1</code>. The ranges must be valid for this vector and both ranges must be the same size. The are permitted to overlap. Returns the final carry-out value which is not stored in the result. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00832">832</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">Sawyer::Container::BitVectorSupport::add()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="aeb237dc83e46c180388691861f8b4671" name="aeb237dc83e46c180388691861f8b4671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb237dc83e46c180388691861f8b4671">&#9670;&#160;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add bits as integers. </p>
<p>Treats this vector and the <code>other</code> vector as integers, sums them, and stores the result in this vector. Both vectors must be the same size. The <code>other</code> vector is permitted to be the same as <code>this</code> vector, in which case it numerically doubles the value (like a left shift by one bit). Returns the final carry-out value which is not stored in the result. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00844">844</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01135">Sawyer::Container::BitVectorSupport::add()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a6330fd3a1a3fc89162aa89b980efcfd7" name="a6330fd3a1a3fc89162aa89b980efcfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6330fd3a1a3fc89162aa89b980efcfd7">&#9670;&#160;</a></span>subtract() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract bits as integers. </p>
<p>Treats <code>range1</code> of this vector and <code>range2</code> of the <code>other</code> vector as integers, subtracts <code>other</code> from <code>this</code>, and stores the result in <code>range1</code> of this vector. The ranges must be valid for their respective vectors, and both ranges must be the same size. The <code>other</code> vector is permitted to be the same vector as <code>this</code>, in which case the ranges are also permitted to overlap. Returns false only when an overflow occurs (i.e., the integer interpretation of this vector is unsigned-greater-than the integer from the <code>other</code> vector). If the vectors are interpreted as two's complement signed integers then an overflow is indicated when both operands have the same sign and the result has a different sign. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00857">857</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01148">Sawyer::Container::BitVectorSupport::subtract()</a>.</p>

</div>
</div>
<a id="ae1129a4ee284d2eecb2a8137ed0cd7d6" name="ae1129a4ee284d2eecb2a8137ed0cd7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1129a4ee284d2eecb2a8137ed0cd7d6">&#9670;&#160;</a></span>subtract() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract bits as integers. </p>
<p>Treats <code>range1</code> and <code>range2</code> of this vector as integers, subtracts the integer in <code>range2</code> from the integer in <code>range1</code>, and stores the result in <code>range1</code> of this vector. The ranges must be valid for this vector, and both ranges must be the same size. The ranges are permitted to overlap. Returns false only when an overflow occurs (i.e., the integer interpretation of <code>range1</code> is unsigned-greater-than the integer from <code>range2</code>). If the ranges are interpreted as containing two's complement signed integers then an overflow is indicated when both operands have the same sign and the result has a different sign. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00871">871</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01148">Sawyer::Container::BitVectorSupport::subtract()</a>.</p>

</div>
</div>
<a id="a7f7a4bc2e937ba6156cdee10a4c083a7" name="a7f7a4bc2e937ba6156cdee10a4c083a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7a4bc2e937ba6156cdee10a4c083a7">&#9670;&#160;</a></span>subtract() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract bits as integers. </p>
<p>Treats this vector and the <code>other</code> vector as integers, subtracts <code>other</code> from <code>this</code>, and stores the result in this vector. Both vectors must be the same size. The <code>other</code> vector is permitted to be the same as <code>this</code> vector, in which case this vector is filled with zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00882">882</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01148">Sawyer::Container::BitVectorSupport::subtract()</a>.</p>

</div>
</div>
<a id="a44d58fa62f0d6d80374a3d9d3df7154b" name="a44d58fa62f0d6d80374a3d9d3df7154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d58fa62f0d6d80374a3d9d3df7154b">&#9670;&#160;</a></span>signExtend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::signExtend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bits and sign extend. </p>
<p>Copies bits from <code>range2</code> of the <code>other</code> vector to <code>range1</code> of this vector while sign extending. That is, if the destination is larger than the source, the most significant bit of the source is repeated to fill the high order bits of the destination. Both ranges must be valid for their respective vectors. The <code>other</code> vector is permitted to be the same as <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00892">892</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">Sawyer::Container::BitVectorSupport::signExtend()</a>.</p>

</div>
</div>
<a id="a86261dc840e385cd2be6daaf109a2287" name="a86261dc840e385cd2be6daaf109a2287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86261dc840e385cd2be6daaf109a2287">&#9670;&#160;</a></span>signExtend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::signExtend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bits and sign extend. </p>
<p>Copies bits from <code>range2</code> of this vector to <code>range1</code> of this vector while sign extending. That is, if the destination is larger than the source, the most significant bit of the source is repeated to fill the high order bits of the destination. Both ranges must be valid for this vector, and are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00904">904</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">Sawyer::Container::BitVectorSupport::signExtend()</a>.</p>

</div>
</div>
<a id="a3f5e43e5ce97d5da496c5d5a7c35bdec" name="a3f5e43e5ce97d5da496c5d5a7c35bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5e43e5ce97d5da496c5d5a7c35bdec">&#9670;&#160;</a></span>signExtend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::signExtend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy bits and sign extend. </p>
<p>Copies bits from the <code>other</code> vector to this vector while sign extending. That is, if the destination is larger than the source, the most significant bit of the source is repeated to fill the high order bits of the destination. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00915">915</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01164">Sawyer::Container::BitVectorSupport::signExtend()</a>.</p>

</div>
</div>
<a id="a5e9294b32d004aebfdbb1a7bcf0ad38e" name="a5e9294b32d004aebfdbb1a7bcf0ad38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9294b32d004aebfdbb1a7bcf0ad38e">&#9670;&#160;</a></span>multiply10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::multiply10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply by 10. </p>
<p>Threats this vector as an unsigned integer and multiplies it by 10. If the product doesn't fit in the same vector then the high order bits of the product are truncated. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00924">924</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01187">Sawyer::Container::BitVectorSupport::multiply10()</a>.</p>

</div>
</div>
<a id="a0dc7465f286ffa459338dfb11c7adc4f" name="a0dc7465f286ffa459338dfb11c7adc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc7465f286ffa459338dfb11c7adc4f">&#9670;&#160;</a></span>multiply10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::multiply10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply by 10. </p>
<p>Treats <code>range</code> of this vector as an unsigned integer and multiplies it by 10, storing the result back into the same range, possibly truncating the result in the process. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00933">933</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01187">Sawyer::Container::BitVectorSupport::multiply10()</a>.</p>

</div>
</div>
<a id="ab0458442defdf8b2718edf162bf46b16" name="ab0458442defdf8b2718edf162bf46b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0458442defdf8b2718edf162bf46b16">&#9670;&#160;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> Sawyer::Container::BitVector::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two bit vectors. </p>
<p>Multiplies <code>this</code> bit vector with <code>other</code>, both interpreted as unsigned integer, to produce a result bit vector whose width is the sum of the two input widths. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00942">942</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l00821">add()</a>, <a class="el" href="BitVector_8h_source.html#l00271">get()</a>, <a class="el" href="BitVector_8h_source.html#l00215">resize()</a>, <a class="el" href="BitVector_8h_source.html#l00644">shiftLeft()</a>, and <a class="el" href="BitVector_8h_source.html#l00208">size()</a>.</p>

</div>
</div>
<a id="a240689423b2de539bd83328a2a36dcca" name="a240689423b2de539bd83328a2a36dcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240689423b2de539bd83328a2a36dcca">&#9670;&#160;</a></span>multiplySigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> Sawyer::Container::BitVector::multiplySigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two signed integers. </p>
<p>Multiplies this bit vector with <code>other</code>, both interpreted as signed integers, to produce a result bit vector whose width is the sum of the two input widths. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l00958">958</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l00821">add()</a>, <a class="el" href="BitVector_8h_source.html#l00271">get()</a>, <a class="el" href="BitVector_8h_source.html#l00764">negate()</a>, <a class="el" href="BitVector_8h_source.html#l00215">resize()</a>, <a class="el" href="BitVector_8h_source.html#l00644">shiftLeft()</a>, and <a class="el" href="BitVector_8h_source.html#l00208">size()</a>.</p>

</div>
</div>
<a id="a79639c80681c3f649e08079ff35b1637" name="a79639c80681c3f649e08079ff35b1637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79639c80681c3f649e08079ff35b1637">&#9670;&#160;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert bits. </p>
<p>Each bit in the specified range is inverted. The range must be valid for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01004">1004</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00889">Sawyer::Container::BitVectorSupport::invert()</a>.</p>

</div>
</div>
<a id="af8971e6f9cbf70e12fe65952830dea3a" name="af8971e6f9cbf70e12fe65952830dea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8971e6f9cbf70e12fe65952830dea3a">&#9670;&#160;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert bits. </p>
<p>Each bit in this vector is inverted. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01013">1013</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00889">Sawyer::Container::BitVectorSupport::invert()</a>.</p>

</div>
</div>
<a id="afbddaaf873aab6ed2071cff72950d6ed" name="afbddaaf873aab6ed2071cff72950d6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbddaaf873aab6ed2071cff72950d6ed">&#9670;&#160;</a></span>bitwiseAnd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise AND. </p>
<p>Computes the bit-wise AND of <code>range1</code> from this vector and <code>range2</code> of the <code>other</code> vector, storing the result in <code>range1</code>. The ranges must be valid for their respective vectors and must be the same size. The <code>other</code> vector is permitted to refer to <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01023">1023</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00907">Sawyer::Container::BitVectorSupport::bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a1c57ddd6b1522169e684080dd03d475f" name="a1c57ddd6b1522169e684080dd03d475f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c57ddd6b1522169e684080dd03d475f">&#9670;&#160;</a></span>bitwiseAnd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise AND. </p>
<p>Computes the bit-wise AND of <code>range1</code> and <code>range2</code> of this vector, storing the result in <code>range1</code>. The ranges must be valid for this vector and must be the same size. They are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01034">1034</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00907">Sawyer::Container::BitVectorSupport::bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a6f7fdf21a35a68f8a28b16698d4cc37c" name="a6f7fdf21a35a68f8a28b16698d4cc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7fdf21a35a68f8a28b16698d4cc37c">&#9670;&#160;</a></span>bitwiseAnd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise AND. </p>
<p>Computes the bit-wise AND of this vector and the <code>other</code> vector, storing the result in this vector. The vectors must be the same size. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01045">1045</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00907">Sawyer::Container::BitVectorSupport::bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a86f0eb0b601d8deed4bc44e18de13a8d" name="a86f0eb0b601d8deed4bc44e18de13a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f0eb0b601d8deed4bc44e18de13a8d">&#9670;&#160;</a></span>bitwiseOr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseOr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise OR. </p>
<p>Computes the bit-wise OR of <code>range1</code> from this vector and <code>range2</code> of the <code>other</code> vector, storing the result in <code>range1</code>. The ranges must be valid for their respective vectors and must be the same size. The <code>other</code> vector is permitted to refer to <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01055">1055</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00925">Sawyer::Container::BitVectorSupport::bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a8807bd882a430d12d8998b5631caa890" name="a8807bd882a430d12d8998b5631caa890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8807bd882a430d12d8998b5631caa890">&#9670;&#160;</a></span>bitwiseOr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseOr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise OR. </p>
<p>Computes the bit-wise OR of <code>range1</code> and <code>range2</code> of this vector, storing the result in <code>range1</code>. The ranges must be valid for this vector and must be the same size. They are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01066">1066</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00925">Sawyer::Container::BitVectorSupport::bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a47671e8d5dd237d71c2f9d865a164f8d" name="a47671e8d5dd237d71c2f9d865a164f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47671e8d5dd237d71c2f9d865a164f8d">&#9670;&#160;</a></span>bitwiseOr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseOr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise OR. </p>
<p>Computes the bit-wise OR of this vector and the <code>other</code> vector, storing the result in this vector. The vectors must be the same size. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01077">1077</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00925">Sawyer::Container::BitVectorSupport::bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a76496f612e4a491de89e79f3614153a4" name="a76496f612e4a491de89e79f3614153a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76496f612e4a491de89e79f3614153a4">&#9670;&#160;</a></span>bitwiseXor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseXor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise XOR. </p>
<p>Computes the bit-wise XOR of <code>range1</code> from this vector and <code>range2</code> of the <code>other</code> vector, storing the result in <code>range1</code>. The ranges must be valid for their respective vectors and must be the same size. The <code>other</code> vector is permitted to refer to <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01087">1087</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00943">Sawyer::Container::BitVectorSupport::bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="acd1e91d618fc95ccec420977dad82cb6" name="acd1e91d618fc95ccec420977dad82cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e91d618fc95ccec420977dad82cb6">&#9670;&#160;</a></span>bitwiseXor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseXor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise XOR. </p>
<p>Computes the bit-wise XOR of <code>range1</code> and <code>range2</code> of this vector, storing the result in <code>range1</code>. The ranges must be valid for this vector and must be the same size. They are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01098">1098</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00943">Sawyer::Container::BitVectorSupport::bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="aae09af97e4709d43d42b324fd2b39e77" name="aae09af97e4709d43d42b324fd2b39e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae09af97e4709d43d42b324fd2b39e77">&#9670;&#160;</a></span>bitwiseXor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::bitwiseXor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-wise XOR. </p>
<p>Computes the bit-wise XOR of this vector and the <code>other</code> vector, storing the result in this vector. The vectors must be the same size. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01109">1109</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l00943">Sawyer::Container::BitVectorSupport::bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a3012f0488776cca578c5cb0fad346541" name="a3012f0488776cca578c5cb0fad346541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3012f0488776cca578c5cb0fad346541">&#9670;&#160;</a></span>isEqualToZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isEqualToZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare to zero. </p>
<p>Compares the integer value referred to by the specified range with zero. Returns true if the value is equal to zero the range is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a181cbb8cf30a0da90e7f59523346c64d" title="True if all bits are clear.">isAllClear</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01124">1124</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01206">Sawyer::Container::BitVectorSupport::isEqualToZero()</a>.</p>

</div>
</div>
<a id="aa7bb56406c26e008ec5960c485e8e8a5" name="aa7bb56406c26e008ec5960c485e8e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bb56406c26e008ec5960c485e8e8a5">&#9670;&#160;</a></span>isEqualToZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::Container::BitVector::isEqualToZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare to zero. </p>
<p>Returns true if this vector is empty all bits are false.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a181cbb8cf30a0da90e7f59523346c64d" title="True if all bits are clear.">isAllClear</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01134">1134</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01206">Sawyer::Container::BitVectorSupport::isEqualToZero()</a>.</p>

</div>
</div>
<a id="a90fc1666d8ef5d669b67dfcbc3303633" name="a90fc1666d8ef5d669b67dfcbc3303633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fc1666d8ef5d669b67dfcbc3303633">&#9670;&#160;</a></span>compare() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as integers. </p>
<p>Compares <code>range1</code> from this vector with <code>range2</code> from the <code>other</code> vector as integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if the <code>range1</code> value is less than the <code>range2</code> value, returns zero if they are equal, and returns positive if the <code>range1</code> value is greater than the <code>range2</code> value. The ranges must be valid for their respective vectors, and need not be the same size (the smaller range will be temporarily zero extended on its most significant end). An empty range is treated as zero. The <code>other</code> vector is permitted to refer to <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01146">1146</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">Sawyer::Container::BitVectorSupport::compare()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a8f10771f342e38cd77e95a734376b80d" name="a8f10771f342e38cd77e95a734376b80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f10771f342e38cd77e95a734376b80d">&#9670;&#160;</a></span>compare() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as integers. </p>
<p>Compares <code>range1</code> and <code>range2</code> from this vector as integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if the <code>range1</code> value is less than the <code>range2</code> value, returns zero if they are equal, and returns positive if the <code>range1</code> value is greater than the <code>range2</code> value. The ranges must be valid for this vector, and need not be the same size (the smaller range will be temporarily zero extended on its most significant end). An empty range is interpreted as zero. The ranges are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01159">1159</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01237">Sawyer::Container::BitVectorSupport::compare()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a4603ab0e8dd9ab4cb295e094f4e84cf6" name="a4603ab0e8dd9ab4cb295e094f4e84cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4603ab0e8dd9ab4cb295e094f4e84cf6">&#9670;&#160;</a></span>compare() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as integers. </p>
<p>Compares the bits of this vector with the bits of <code>other</code> as integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if <code>this</code> value is less than the <code>other</code> value, returns zero if they are equal, and returns positive if <code>this</code> value is greater than the <code>other</code> value. The vectors need not be the same size (the smaller vector will be temporarily zero extended on its most significant end). An empty vector is treated as zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01172">1172</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01237">Sawyer::Container::BitVectorSupport::compare()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a691fba45b6b6a518841734bc14d1afb3" name="a691fba45b6b6a518841734bc14d1afb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691fba45b6b6a518841734bc14d1afb3">&#9670;&#160;</a></span>compareSigned() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compareSigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as signed integers. </p>
<p>Compares <code>range1</code> from this vector with <code>range2</code> from the <code>other</code> vector as signed, two's complement integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if the <code>range1</code> value is less than the <code>range2</code> value, returns zero if they are equal, and returns positive if the <code>range1</code> value is greater than the <code>range2</code> value. The ranges must be valid for their respective vectors, and need not be the same size (the smaller range will be temporarily zero extended on its most significant end). An empty range is treated as zero. The <code>other</code> vector is permitted to refer to <code>this</code> vector, in which case the ranges are also permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01185">1185</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01272">Sawyer::Container::BitVectorSupport::compareSigned()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a42d9d1e4fdf0b5404b9e64cff9a45403" name="a42d9d1e4fdf0b5404b9e64cff9a45403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d9d1e4fdf0b5404b9e64cff9a45403">&#9670;&#160;</a></span>compareSigned() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compareSigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as signed integers. </p>
<p>Compares <code>range1</code> and <code>range2</code> from this vector as signed, two's complement integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if the <code>range1</code> value is less than the <code>range2</code> value, returns zero if they are equal, and returns positive if the <code>range1</code> value is greater than the <code>range2</code> value. The ranges must be valid for this vector, and need not be the same size (the smaller range will be temporarily zero extended on its most significant end). An empty range is interpreted as zero. The ranges are permitted to overlap. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01199">1199</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01272">Sawyer::Container::BitVectorSupport::compareSigned()</a>, and <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="afca98c42b8427dc519c3f8be083fed19" name="afca98c42b8427dc519c3f8be083fed19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca98c42b8427dc519c3f8be083fed19">&#9670;&#160;</a></span>compareSigned() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Sawyer::Container::BitVector::compareSigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare bits as signed integers. </p>
<p>Compares the bits of this vector with the bits of <code>other</code> as signed, two's complement integers and returns a value whose sign indicates the ordering relationship between the two ranges. Returns negative if <code>this</code> value is less than the <code>other</code> value, returns zero if they are equal, and returns positive if <code>this</code> value is greater than the <code>other</code> value. The vectors need not be the same size (the smaller vector will be temporarily zero extended on its most significant end). An empty vector is treated as zero. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01212">1212</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVectorSupport_8h_source.html#l01272">Sawyer::Container::BitVectorSupport::compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a2615057433c0ff469c0e7454cf58a1fc" name="a2615057433c0ff469c0e7454cf58a1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2615057433c0ff469c0e7454cf58a1fc">&#9670;&#160;</a></span>toInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::uint64_t Sawyer::Container::BitVector::toInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret bits as an unsigned integer. </p>
<p>Returns the bits of the specified range by interpreting them as an unsigned integer. The range must be valid for this vector. If the range contains more than 64 bits then only the low-order 64 bits are considered. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01224">1224</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00983">Sawyer::Container::BitVectorSupport::toInteger()</a>.</p>

</div>
</div>
<a id="aa444e97765fed6bfdba4a49c8cf7922f" name="aa444e97765fed6bfdba4a49c8cf7922f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa444e97765fed6bfdba4a49c8cf7922f">&#9670;&#160;</a></span>toInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::uint64_t Sawyer::Container::BitVector::toInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret bits as an unsigned integer. </p>
<p>Returns the bits of this vector by interpreting them as an unsigned integer. If this vector contains more than 64 bits then only the low-order 64 bits are considered. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01233">1233</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, <a class="el" href="BitVector_8h_source.html#l00208">size()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00983">Sawyer::Container::BitVectorSupport::toInteger()</a>.</p>

</div>
</div>
<a id="ab6ee12d53023c66fbec2bf0e616d1911" name="ab6ee12d53023c66fbec2bf0e616d1911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ee12d53023c66fbec2bf0e616d1911">&#9670;&#160;</a></span>toSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::int64_t Sawyer::Container::BitVector::toSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret bits as a signed integer. </p>
<p>Returns the bits of the specified range by interpreting them as a two's complement signed integer, sign extended to the width of the return value. The range must be valid for this vector. If the range size is one bit then the value zero or one is returned; if the range size is less than 64 bits then the bits are sign extended to a width of 64; if the range is larger than 64 bits then only the low-order 64 bits are returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01245">1245</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00983">Sawyer::Container::BitVectorSupport::toInteger()</a>.</p>

</div>
</div>
<a id="a5a8ffe8c8bc61e949cb0d09fb20873f7" name="a5a8ffe8c8bc61e949cb0d09fb20873f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8ffe8c8bc61e949cb0d09fb20873f7">&#9670;&#160;</a></span>toSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::int64_t Sawyer::Container::BitVector::toSignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret bits as a signed integer. </p>
<p>Returns the bits of the specified range by interpreting them as a two's complement signed integer, sign extended to the width of the return value. The range must be valid for this vector. If the range size is one bit then the value zero or one is returned; if the range size is less than 64 bits then the bits are sign extended to a width of 64; if the range is larger than 64 bits then only the low-order 64 bits are returned. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01256">1256</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, <a class="el" href="BitVector_8h_source.html#l00208">size()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01021">Sawyer::Container::BitVectorSupport::toSignedInteger()</a>.</p>

</div>
</div>
<a id="aba6c52521549bf68b18c873e2d966cfd" name="aba6c52521549bf68b18c873e2d966cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6c52521549bf68b18c873e2d966cfd">&#9670;&#160;</a></span>toHex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toHex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to a hexadecimal string. </p>
<p>Returns a string which is the hexadecimal representation of the bits in the specified range. The range must be valid for this vector. No prefix or suffix is added (e.g., no leading "0x" or trailing "h"). The number of digits in the return value is the minimum required to explicitly represent each bit of the range, including leading zeros; an empty range will return an empty string. The returned string is lower case. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01268">1268</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01445">Sawyer::Container::BitVectorSupport::toHex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l00156">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::print()</a>.</p>

</div>
</div>
<a id="a2980cc6a48c4230d49d52904b5a3d5a1" name="a2980cc6a48c4230d49d52904b5a3d5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2980cc6a48c4230d49d52904b5a3d5a1">&#9670;&#160;</a></span>toHex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to a hexadecimal string. </p>
<p>Returns a string which is the hexadecimal representation of the bits in this vector. No prefix or suffix is added (e.g., no leading "0x" or trailing "h"). The number of digits in the return value is the minimum required to explicitly represent each bit of the vector, including leading zeros; an empty vector will return an empty string. The returned string is lower case. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01278">1278</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01445">Sawyer::Container::BitVectorSupport::toHex()</a>.</p>

</div>
</div>
<a id="a52256895bb5ef38b77f2c934e8985081" name="a52256895bb5ef38b77f2c934e8985081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52256895bb5ef38b77f2c934e8985081">&#9670;&#160;</a></span>toOctal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toOctal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an octal string. </p>
<p>Returns a string which is the octal representation of the bits in the specified range. The range must be valid for this vector. No prefix or suffix is added (e.g., no extra leading "0" or trailing "o"). The number of digits in the return value is the minimum required to explicitly represent each bit of the range, including leading zeros; an empty range will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01288">1288</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01457">Sawyer::Container::BitVectorSupport::toOctal()</a>.</p>

</div>
</div>
<a id="a0f4f1645907e8529617502374aad1e24" name="a0f4f1645907e8529617502374aad1e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4f1645907e8529617502374aad1e24">&#9670;&#160;</a></span>toOctal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toOctal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an octal string. </p>
<p>Returns a string which is the octal representation of the bits in this vector. No prefix or suffix is added (e.g., no leading "0" or trailing "o"). The number of digits in the return value is the minimum required to explicitly represent each bit of the vector, including leading zeros; an empty vector will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01297">1297</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01457">Sawyer::Container::BitVectorSupport::toOctal()</a>.</p>

</div>
</div>
<a id="a64f3412c5d67cf9f0918d9509be70ed6" name="a64f3412c5d67cf9f0918d9509be70ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f3412c5d67cf9f0918d9509be70ed6">&#9670;&#160;</a></span>toBinary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toBinary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to a binary string. </p>
<p>Returns a string which is the binary representation of the bits in the specified range. The range must be valid for this vector. No prefix or suffix is added (e.g., no extra leading or trailing "b"). The number of digits in the return value is the minimum required to explicitly represent each bit of the range, including leading zeros; an empty range will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01307">1307</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01469">Sawyer::Container::BitVectorSupport::toBinary()</a>.</p>

</div>
</div>
<a id="ad1bfe032526f900c40bbf24723ba96a6" name="ad1bfe032526f900c40bbf24723ba96a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bfe032526f900c40bbf24723ba96a6">&#9670;&#160;</a></span>toBinary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::Container::BitVector::toBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an binary string. </p>
<p>Returns a string which is the binary representation of the bits in this vector. No prefix or suffix is added (e.g., no leading or trailing "b"). The number of digits in the return value is the minimum required to explicitly represent each bit of the vector, including leading zeros; an empty vector will return an empty string. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01316">1316</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01469">Sawyer::Container::BitVectorSupport::toBinary()</a>.</p>

</div>
</div>
<a id="a4e92229a96633b7b5a59f890b00b0dd2" name="a4e92229a96633b7b5a59f890b00b0dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e92229a96633b7b5a59f890b00b0dd2">&#9670;&#160;</a></span>toBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; Sawyer::Container::BitVector::toBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to a vector of bytes. </p>
<p>The returned vector is in little endian order. The size of the returned vector is rounded up to the next whole byte and any extra bits in the return value are cleared. For instance, if this bit vector contains 13 bits, then the return value will be two bytes with the highest order three bits of the second byte cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01327">1327</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a7e297c817dcaf28d237d927a2c1662ce" name="a7e297c817dcaf28d237d927a2c1662ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e297c817dcaf28d237d927a2c1662ce">&#9670;&#160;</a></span>toBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; Sawyer::Container::BitVector::toBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to a vector of bytes. </p>
<p>The returned vector is in little endian order. The size of the returned vector is rounded up to the next whole byte and any extra bits in the return value are cleared. For instance, if this bit vector contains 13 bits, then the return value will be two bytes with the highest order three bits of the second byte cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01330">1330</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a3d943b31226c1b9de7eb40ff1a06f774" name="a3d943b31226c1b9de7eb40ff1a06f774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d943b31226c1b9de7eb40ff1a06f774">&#9670;&#160;</a></span>fromInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from an integer. </p>
<p>Assigns the specified value to the bits indicated by <code>range</code> of this vector. If the range contains fewer than 64 bits then only the low order bits of <code>value</code> are used; if the range contains more than 64 bits then the high-order bits are cleared. The range must be a valid range for this vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01340">1340</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l00957">Sawyer::Container::BitVectorSupport::fromInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AddressMap_8h_source.html#l00156">Sawyer::Container::AddressMapConstraints&lt; AddressMap &gt;::print()</a>.</p>

</div>
</div>
<a id="aa84a01afa37f69796d1ef506a9326b6e" name="aa84a01afa37f69796d1ef506a9326b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84a01afa37f69796d1ef506a9326b6e">&#9670;&#160;</a></span>fromInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromInteger </td>
          <td>(</td>
          <td class="paramtype">boost::uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from an integer. </p>
<p>Assigns the specified value to this vector. If this vector contains fewer than 64 bits then only the low order bits of <code>value</code> are used; if this vector contains more than 64 bits then the high-order bits are cleared. The size of this vector is not changed by this operation.</p>
<dl class="section see"><dt>See also</dt><dd>The assignment operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01353">1353</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l00957">Sawyer::Container::BitVectorSupport::fromInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="aa5387e3566bf3e55c40b9f0c982b7e52" name="aa5387e3566bf3e55c40b9f0c982b7e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5387e3566bf3e55c40b9f0c982b7e52">&#9670;&#160;</a></span>fromDecimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromDecimal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains bits from a decimal representation. </p>
<p>Assigns the specified value, represented in decimal, to the specified range of this vector. The <code>input</code> string must contain only valid decimal digits '0' through '9' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. The range must be valid for this vector. If the number of supplied digits is larger than what is required to initialize the specified range then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire range then the high order bits of the range are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01367">1367</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01533">Sawyer::Container::BitVectorSupport::fromDecimal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00125">parse()</a>.</p>

</div>
</div>
<a id="afd6382d86d3ba3cd42f0fff269d0fecd" name="afd6382d86d3ba3cd42f0fff269d0fecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6382d86d3ba3cd42f0fff269d0fecd">&#9670;&#160;</a></span>fromDecimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromDecimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a decimal representation. </p>
<p>Assigns the specified value, represented in decimal, to this vector. The <code>input</code> string must contain only valid decimal digits '0' through '9' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize this vector then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire vector then the high order bits of the vector are cleared. The size of this vector is not changed by this operation. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01381">1381</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01533">Sawyer::Container::BitVectorSupport::fromDecimal()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a8c1f6849ce8000a9f7228104f464591e" name="a8c1f6849ce8000a9f7228104f464591e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1f6849ce8000a9f7228104f464591e">&#9670;&#160;</a></span>fromHex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromHex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a hexadecimal representation. </p>
<p>Assigns the specified value, represented in hexadecimal, to the specified range of this vector. The <code>input</code> string must contain only valid hexadecimal digits '0' through '9', 'a' through 'f', and 'A' through 'F', or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. The range must be valid for this vector. If the number of supplied digits is larger than what is required to initialize the specified range then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire range then the high order bits of the range are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01394">1394</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01575">Sawyer::Container::BitVectorSupport::fromHex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00125">parse()</a>.</p>

</div>
</div>
<a id="a0bff43127d36f97c7e2c7cf843ff1f88" name="a0bff43127d36f97c7e2c7cf843ff1f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff43127d36f97c7e2c7cf843ff1f88">&#9670;&#160;</a></span>fromHex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromHex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a hexadecimal representation. </p>
<p>Assigns the specified value, represented in hexadecimal, to this vector. The <code>input</code> string must contain only valid hexadecimal digits '0' through '9', 'a' through 'f', and 'A' through 'F', or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize this vector then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire vector then the high order bits of the vector are cleared. The size of this vector is not changed by this operation. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01408">1408</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01575">Sawyer::Container::BitVectorSupport::fromHex()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a0e6abe52dc52264242ca79999561a8d7" name="a0e6abe52dc52264242ca79999561a8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6abe52dc52264242ca79999561a8d7">&#9670;&#160;</a></span>fromOctal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromOctal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from an octal representation. </p>
<p>Assigns the specified value, represented in octal, to the specified range of this vector. The <code>input</code> string must contain only valid octal digits '0' through '7' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. The range must be valid for this vector. If the number of supplied digits is larger than what is required to initialize the specified range then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire range then the high order bits of the range are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01421">1421</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01586">Sawyer::Container::BitVectorSupport::fromOctal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00125">parse()</a>.</p>

</div>
</div>
<a id="a1b6222dfa99ebe1fb47577045fa79b73" name="a1b6222dfa99ebe1fb47577045fa79b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6222dfa99ebe1fb47577045fa79b73">&#9670;&#160;</a></span>fromOctal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromOctal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from an octal representation. </p>
<p>Assigns the specified value, represented in octal, to this vector. The <code>input</code> string must contain only valid octal digits '0' through '7' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize this vector then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire vector then the high order bits of the vector are cleared. The size of this vector is not changed by this operation. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01435">1435</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01586">Sawyer::Container::BitVectorSupport::fromOctal()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a8a9b8a0fa11da896cd0020bdb9efd5c8" name="a8a9b8a0fa11da896cd0020bdb9efd5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b8a0fa11da896cd0020bdb9efd5c8">&#9670;&#160;</a></span>fromBinary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a binary representation. </p>
<p>Assigns the specified value, represented in binary, to the specified range of this vector. The <code>input</code> string must contain only valid binary digits '0' and '1' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. The range must be valid for this vector. If the number of supplied digits is larger than what is required to initialize the specified range then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire range then the high order bits of the range are cleared. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01448">1448</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01492">checkRange()</a>, <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVectorSupport_8h_source.html#l01597">Sawyer::Container::BitVectorSupport::fromBinary()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00125">parse()</a>.</p>

</div>
</div>
<a id="ac2d8b0f5e4ab64ef5bb320ab532c2f9b" name="ac2d8b0f5e4ab64ef5bb320ab532c2f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d8b0f5e4ab64ef5bb320ab532c2f9b">&#9670;&#160;</a></span>fromBinary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromBinary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a binary representation. </p>
<p>Assigns the specified value, represented in binary, to this vector. The <code>input</code> string must contain only valid binary digits '0' and '1' or the underscore character (to make long strings more readable), or else an <code>std::runtime_error</code> is thrown. If the number of supplied digits is larger than what is required to initialize this vector then the extra data is discarded. On the other hand, if the length of the string is insufficient to initialize the entire vector then the high order bits of the vector are cleared. The size of this vector is not changed by this operation. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01462">1462</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, <a class="el" href="BitVectorSupport_8h_source.html#l01597">Sawyer::Container::BitVectorSupport::fromBinary()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="a9e4074aa6f1e1d4b2ba75aa902fd772a" name="a9e4074aa6f1e1d4b2ba75aa902fd772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4074aa6f1e1d4b2ba75aa902fd772a">&#9670;&#160;</a></span>fromBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromBytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a byte vector. </p>
<p>Reads bits from the little-endian byte vector and copies them into the specified range of this bit vector. If no range is specified, then this entire bit vector is initialized. The byte vector must be long enough to initialize the specified range or the whole bit vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01474">1474</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>, and <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

</div>
</div>
<a id="af52e0fffaa76392c6804ef5a5115b43d" name="af52e0fffaa76392c6804ef5a5115b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52e0fffaa76392c6804ef5a5115b43d">&#9670;&#160;</a></span>fromBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html">BitVector</a> &amp; Sawyer::Container::BitVector::fromBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain bits from a byte vector. </p>
<p>Reads bits from the little-endian byte vector and copies them into the specified range of this bit vector. If no range is specified, then this entire bit vector is initialized. The byte vector must be long enough to initialize the specified range or the whole bit vector. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01478">1478</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l01502">data()</a>.</p>

</div>
</div>
<a id="a4aef9f4b51c24193972024d5db21bf51" name="a4aef9f4b51c24193972024d5db21bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aef9f4b51c24193972024d5db21bf51">&#9670;&#160;</a></span>checkRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::Container::BitVector::checkRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#ad0d02ed250ef2712b681970b37b1bb61">BitRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Assert.html" title="Run-time logic assertions.">Assert</a> valid range. </p>
<p>Asserts that the specified range is valid for this vector. This is intended mostly for internal use and does nothing when assertions are disabled. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01492">1492</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">References <a class="el" href="BitVector_8h_source.html#l00243">hull()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00832">add()</a>, <a class="el" href="BitVector_8h_source.html#l00821">add()</a>, <a class="el" href="BitVector_8h_source.html#l01034">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01023">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01066">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01055">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01098">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01087">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l00281">clear()</a>, <a class="el" href="BitVector_8h_source.html#l01159">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01146">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01199">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01185">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00352">copy()</a>, <a class="el" href="BitVector_8h_source.html#l00340">copy()</a>, <a class="el" href="BitVector_8h_source.html#l00802">decrement()</a>, <a class="el" href="BitVector_8h_source.html#l00385">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00395">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l01448">fromBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01367">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01394">fromHex()</a>, <a class="el" href="BitVector_8h_source.html#l01340">fromInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01421">fromOctal()</a>, <a class="el" href="BitVector_8h_source.html#l00271">get()</a>, <a class="el" href="BitVector_8h_source.html#l00784">increment()</a>, <a class="el" href="BitVector_8h_source.html#l01004">invert()</a>, <a class="el" href="BitVector_8h_source.html#l00509">isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00491">isAllSet()</a>, <a class="el" href="BitVector_8h_source.html#l01124">isEqualToZero()</a>, <a class="el" href="BitVector_8h_source.html#l00438">leastSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00618">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00603">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00420">leastSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00474">mostSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00578">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00563">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00456">mostSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00541">nClear()</a>, <a class="el" href="BitVector_8h_source.html#l00764">negate()</a>, <a class="el" href="BitVector_8h_source.html#l00526">nSet()</a>, <a class="el" href="BitVector_8h_source.html#l00740">rotateLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00719">rotateRight()</a>, <a class="el" href="BitVector_8h_source.html#l00301">set()</a>, <a class="el" href="BitVector_8h_source.html#l00319">setValue()</a>, <a class="el" href="BitVector_8h_source.html#l00644">shiftLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00669">shiftRight()</a>, <a class="el" href="BitVector_8h_source.html#l00695">shiftRightArithmetic()</a>, <a class="el" href="BitVector_8h_source.html#l00904">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00892">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00871">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00857">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00364">swap()</a>, <a class="el" href="BitVector_8h_source.html#l00375">swap()</a>, <a class="el" href="BitVector_8h_source.html#l01224">toInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l01245">toSignedInteger()</a>.</p>

</div>
</div>
<a id="a78fa539344cebb182887eb009089ee20" name="a78fa539344cebb182887eb009089ee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa539344cebb182887eb009089ee20">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Word</a> * Sawyer::Container::BitVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw data for vector. </p>
<p>Returns a pointer to the raw data for the vector. This is mostly for internal use so that the raw data can be passed to the <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html" title="Support functions for bit vectors.">BitVectorSupport</a> functions. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01502">1502</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BitVector_8h_source.html#l00832">add()</a>, <a class="el" href="BitVector_8h_source.html#l00821">add()</a>, <a class="el" href="BitVector_8h_source.html#l00844">add()</a>, <a class="el" href="BitVector_8h_source.html#l01034">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01023">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01045">bitwiseAnd()</a>, <a class="el" href="BitVector_8h_source.html#l01066">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01055">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01077">bitwiseOr()</a>, <a class="el" href="BitVector_8h_source.html#l01098">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01087">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l01109">bitwiseXor()</a>, <a class="el" href="BitVector_8h_source.html#l00292">clear()</a>, <a class="el" href="BitVector_8h_source.html#l00281">clear()</a>, <a class="el" href="BitVector_8h_source.html#l01159">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01146">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01172">compare()</a>, <a class="el" href="BitVector_8h_source.html#l01199">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01185">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l01212">compareSigned()</a>, <a class="el" href="BitVector_8h_source.html#l00352">copy()</a>, <a class="el" href="BitVector_8h_source.html#l00340">copy()</a>, <a class="el" href="BitVector_8h_source.html#l00811">decrement()</a>, <a class="el" href="BitVector_8h_source.html#l00802">decrement()</a>, <a class="el" href="BitVector_8h_source.html#l00385">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00395">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l00405">equalTo()</a>, <a class="el" href="BitVector_8h_source.html#l01448">fromBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01462">fromBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01478">fromBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01474">fromBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01367">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01381">fromDecimal()</a>, <a class="el" href="BitVector_8h_source.html#l01394">fromHex()</a>, <a class="el" href="BitVector_8h_source.html#l01408">fromHex()</a>, <a class="el" href="BitVector_8h_source.html#l01353">fromInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01340">fromInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01421">fromOctal()</a>, <a class="el" href="BitVector_8h_source.html#l01435">fromOctal()</a>, <a class="el" href="BitVector_8h_source.html#l00271">get()</a>, <a class="el" href="BitVector_8h_source.html#l00793">increment()</a>, <a class="el" href="BitVector_8h_source.html#l00784">increment()</a>, <a class="el" href="BitVector_8h_source.html#l01013">invert()</a>, <a class="el" href="BitVector_8h_source.html#l01004">invert()</a>, <a class="el" href="BitVector_8h_source.html#l00519">isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00509">isAllClear()</a>, <a class="el" href="BitVector_8h_source.html#l00499">isAllSet()</a>, <a class="el" href="BitVector_8h_source.html#l00491">isAllSet()</a>, <a class="el" href="BitVector_8h_source.html#l01134">isEqualToZero()</a>, <a class="el" href="BitVector_8h_source.html#l01124">isEqualToZero()</a>, <a class="el" href="BitVector_8h_source.html#l00447">leastSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00438">leastSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00618">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00603">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00629">leastSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00429">leastSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00420">leastSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00483">mostSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00474">mostSignificantClearBit()</a>, <a class="el" href="BitVector_8h_source.html#l00578">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00563">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00589">mostSignificantDifference()</a>, <a class="el" href="BitVector_8h_source.html#l00465">mostSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00456">mostSignificantSetBit()</a>, <a class="el" href="BitVector_8h_source.html#l00924">multiply10()</a>, <a class="el" href="BitVector_8h_source.html#l00933">multiply10()</a>, <a class="el" href="BitVector_8h_source.html#l00549">nClear()</a>, <a class="el" href="BitVector_8h_source.html#l00541">nClear()</a>, <a class="el" href="BitVector_8h_source.html#l00774">negate()</a>, <a class="el" href="BitVector_8h_source.html#l00764">negate()</a>, <a class="el" href="BitVector_8h_source.html#l00534">nSet()</a>, <a class="el" href="BitVector_8h_source.html#l00526">nSet()</a>, <a class="el" href="BitVector_8h_source.html#l00215">resize()</a>, <a class="el" href="BitVector_8h_source.html#l00740">rotateLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00751">rotateLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00719">rotateRight()</a>, <a class="el" href="BitVector_8h_source.html#l00730">rotateRight()</a>, <a class="el" href="BitVector_8h_source.html#l00311">set()</a>, <a class="el" href="BitVector_8h_source.html#l00301">set()</a>, <a class="el" href="BitVector_8h_source.html#l00328">setValue()</a>, <a class="el" href="BitVector_8h_source.html#l00319">setValue()</a>, <a class="el" href="BitVector_8h_source.html#l00644">shiftLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00657">shiftLeft()</a>, <a class="el" href="BitVector_8h_source.html#l00669">shiftRight()</a>, <a class="el" href="BitVector_8h_source.html#l00682">shiftRight()</a>, <a class="el" href="BitVector_8h_source.html#l00695">shiftRightArithmetic()</a>, <a class="el" href="BitVector_8h_source.html#l00709">shiftRightArithmetic()</a>, <a class="el" href="BitVector_8h_source.html#l00904">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00892">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00915">signExtend()</a>, <a class="el" href="BitVector_8h_source.html#l00871">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00857">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00882">subtract()</a>, <a class="el" href="BitVector_8h_source.html#l00364">swap()</a>, <a class="el" href="BitVector_8h_source.html#l00375">swap()</a>, <a class="el" href="BitVector_8h_source.html#l01316">toBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01307">toBinary()</a>, <a class="el" href="BitVector_8h_source.html#l01327">toBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01330">toBytes()</a>, <a class="el" href="BitVector_8h_source.html#l01278">toHex()</a>, <a class="el" href="BitVector_8h_source.html#l01268">toHex()</a>, <a class="el" href="BitVector_8h_source.html#l01233">toInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01224">toInteger()</a>, <a class="el" href="BitVector_8h_source.html#l01297">toOctal()</a>, <a class="el" href="BitVector_8h_source.html#l01288">toOctal()</a>, <a class="el" href="BitVector_8h_source.html#l01256">toSignedInteger()</a>, and <a class="el" href="BitVector_8h_source.html#l01245">toSignedInteger()</a>.</p>

</div>
</div>
<a id="adedf1b5b45390bdad1857d7b6dd06bb5" name="adedf1b5b45390bdad1857d7b6dd06bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedf1b5b45390bdad1857d7b6dd06bb5">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a0381629ea9a527d239916f0efd7168c9">Word</a> * Sawyer::Container::BitVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw data for vector. </p>
<p>Returns a pointer to the raw data for the vector. This is mostly for internal use so that the raw data can be passed to the <a class="el" href="namespaceSawyer_1_1Container_1_1BitVectorSupport.html" title="Support functions for bit vectors.">BitVectorSupport</a> functions. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01506">1506</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<a id="a65bf331c28cb21168e6e4fab44b446ea" name="a65bf331c28cb21168e6e4fab44b446ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bf331c28cb21168e6e4fab44b446ea">&#9670;&#160;</a></span>dataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Sawyer::Container::BitVector::dataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw data size. </p>
<p>Returns the number of elements of type Word in the array returned by the <a class="el" href="classSawyer_1_1Container_1_1BitVector.html#a78fa539344cebb182887eb009089ee20">data</a> method. </p>

<p class="definition">Definition at line <a class="el" href="BitVector_8h_source.html#l01514">1514</a> of file <a class="el" href="BitVector_8h_source.html">BitVector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BitVector_8h_source.html">BitVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
