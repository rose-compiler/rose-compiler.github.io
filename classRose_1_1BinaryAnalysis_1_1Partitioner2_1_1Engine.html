<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::Engine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::Engine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Base class for engines driving the partitioner. </p>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a> is an abstract base class whose derived classes implement the algorithms for creating functions, basic blocks, instructions, control flow graphs (CFGs), address usage maps (AUMs), static data blocks, and everything else that can be stored in a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>.</p>
<p>Although subclasses can be instantiated directly, it is often easier to do so through the base class's factory methods. For instance, a tool that operates on various kinds of specimens would want to decide what engine subclass to instantiate based on the types of specimens that are being analyzed. The ROSE library defines a few sublcasses, and the factory mechanism allows external tools to register their own subclasses.</p>
<h1><a class="anchor" id="Rose_BinaryAnalysis_Partitioner2_Engine_factories"></a>
Factories</h1>
<p>Using the engine factories is a two-step process: first the subclasses are registered with the ROSE library, then the ROSE library chooses which engine should be instantiated and does so.</p>
<p>A subclass is registered by instantiating a "factory instance" of the subclass and calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7f09b6e269acd25faa5440211241e16b">registerFactory</a>, which takes shared ownership of the factory instance. Additional member functions such as <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6ba2e4b809563f44a45c45368e65dcc6">deregisterFactory</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> can be used to manipulate the factory list. The engine types that are built into ROSE are registered automatically and appear at the beginning of the list.</p>
<p>To directly instantiate an instance of a subclass without going through the factory mechanism, one calls the static <code>instance</code> method of the subclass. The <code>instance</code> method allocates a new instance in the heap and returns a shared-ownership pointer to the new instance. This is how almost all binary analysis works in ROSE.</p>
<p>On the other hand, to instantiate an engine using the factory method, one calls the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa90d4d8152cb5abecef50a2bcad1ead0">Engine::forge</a> static member function. The words "forge" and "factory" both start with "f" as a reminder that they go together in this API. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa90d4d8152cb5abecef50a2bcad1ead0">forge</a> method will scan the list of registered factories from the end toward the beginning and the first factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true will be the type of engine to be used. The engine actually returned is not the registered factory directly, but the result of calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a76f5b0cd482ce8f8d40647f1f7000e1d">instanceFromFactory</a> on the registered factory.</p>
<h1><a class="anchor" id="Rose_BinaryAnalysis_Partitioner2_Engine_commandlineparsing"></a>
Command-line parsing</h1>
<p>Every engine instance has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a> property. Currently this is shared by all engine types, but in the future we may make this more extensible. Every engine supports ROSE's command-line parsing (<a class="el" href="namespaceSawyer_1_1CommandLine.html">Sawyer::CommandLine</a>) to modify its settings from the command-line. There is a chicken-or-egg dilemma with command-line parsing: in order to choose the correct engine type, we need to find the command-line positional arguments that describe the specimen; in order to find the positional arguments, we need to be able to accurately parse the command-line switches; in order to parse the engine-specific command-line switches, we need to know which engine will be used for the parsing.</p>
<p>The solution that ROSE uses isn't perfect, but works well in practice. Each engine type is able to register its command-line switches as a switch group within a command-line parser. As long as the switches don't conflict with each other, or can be disambiguated to not conflict, we're able to parse the command-line switches as the union of all the switches from all known engine types. Switches can be disambiguated by giving each engine type its own switch group name (i.e., optional switch prefix). For example, the JVM engine might use "--[jvm-]foo" while the binary machine engine uses "--[binary-]foo".</p>
<p>In order to choose a matching factory from the list of factories, ROSE constructs a temporary command-line parser that handles the switches from all known engines and binds the parser to the registered factories (i.e., the presence of a switch modifies the settings in the factory instance). ROSE then parses the command-line to find the specimen positional arguments which it uses to choose a factory instance. Once the factory instance is chosen, ROSE instantiates a regular instance from the factory and constructs a new command-line parser with just that engine's switches, and bound to the engine being returned. Later, when the tool parses the command-line for real and applies the parse result, the returned engine's settings are updated.</p>
<p>Although this mechanism for handling engine-specific command-line switches is not perfect, we think it will provide a means by which tools can define their own command-line switches, and other factories besides <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a> can operate in similar ways.</p>
<h1><a class="anchor" id="Rose_BinaryAnalysis_Partitioner2_Engine_basic"></a>
Basic usage</h1>
<p>An engine drives the process of building a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner2::Partitioner</a> which is then used as an efficient means of obtaining information that's needed during analysis. Although every engine can operate in a different way, there's a common API that's intended to be quite general. The engine API is divided into abstraction layers. The most abstract layer consists of functions that do the most things in one step, from parsing of command-lines to generation of the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> and/or abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). The next layer of less abstract functions does smaller parts, such as parsing containers like ELF or PE, loading parts of specimen files into memory, finding related specimens like shared libraries, linking specimens together into a common address space, organizing instructions into basic blocks and functions, creating an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, etc. Finally, at the least level of abstraction, many of the functions are specific enough to be defined only in subclasses.</p>
<p>Here's an example of basic usage of the engine to instantiate and populate a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> that can be used for analysis. First, the tool needs to define the necessary classes, which it can do by including either the top-level "Partitioner2.h" header, or the headers for the individual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html" title="Binary function detection.">Partitioner2</a> types.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose.html">Rose</a>;</div>
<div class="line"><span class="keyword">namespace </span>P2 = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a>;</div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1Partitioner2_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a></div><div class="ttdoc">Binary function detection.</div><div class="ttdef"><b>Definition</b> <a href="Partitioner2_8h_source.html#l00050">Partitioner2.h:50</a></div></div>
<div class="ttc" id="anamespaceRose_html"><div class="ttname"><a href="namespaceRose.html">Rose</a></div><div class="ttdoc">The ROSE library.</div><div class="ttdef"><b>Definition</b> <a href="BinaryTutorial_8dox_source.html#l00003">BinaryTutorial.dox:3</a></div></div>
</div><!-- fragment --><p>Most tools, after initializing the ROSE library, will create a command-line parser to parse the tool's own switches.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    ROSE_INITIALIZE;</div>
<div class="line">    std::string purpose = <span class="stringliteral">&quot;disassembles a binary specimen&quot;</span>;</div>
<div class="line">    std::string description =</div>
<div class="line">        <span class="stringliteral">&quot;This tool disassembles the specified specimen and presents the &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;results as a pseudo assembly listing, that is, a listing intended &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;for human consumption rather than assembly.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    ToolSettings <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>;</div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> parser = buildSwitchParser(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_html_acab999b1599d0e262cb07d859925b188"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">Rose::BinaryAnalysis::Partitioner2::Engine::settings</a></div><div class="ttdeci">const Settings &amp; settings() const</div><div class="ttdoc">Property: All settings.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a></div><div class="ttdoc">The parser for a program command line.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02756">Sawyer/CommandLine.h:2756</a></div></div>
</div><!-- fragment --><p>In order for the tool to choose the correct engine, it needs to be able to find the positional command-line arguments that describe the specimen. The tool could do all its own command-line parsing and adjust the values in a <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Engine::Settings</a> object which it ultimately copies into an engine instance, or it could use ROSE's command-line parsing mechanism. We'll show the latter since we already started creating such a parser above.</p>
<p>Since we're using ROSE to parse the command-line, we pass the command-line and our partial command-line parser to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa90d4d8152cb5abecef50a2bcad1ead0">forge</a> method like this:</p>
<div class="fragment"><div class="line">P2::Engine::Ptr engine = P2::Engine::forge(argc, argv, parser);</div>
</div><!-- fragment --><p>When the forge call returns, it also adjusts the parser so it knows how to parse the command-line switches that are specific to the returned engine type, and those switches are bound to the settings in that returned engine instance. Thus the tool is now able to parse the command-line, update the settings in the engine, and obtain the positional arguments that describe the specimen.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a> = parser.<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">parse</a>(argc, argv).<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b">apply</a>().<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#adbdafd6227ba5292448acf7792adfe90">unreachedArgs</a>();</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_html_a67cb0f9a5384de07b24893dbbe049428"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">Rose::BinaryAnalysis::Partitioner2::Engine::specimen</a></div><div class="ttdeci">const std::vector&lt; std::string &gt; &amp; specimen() const</div><div class="ttdoc">Property: specimen.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_a193dc3b5dc738f0db4b69842ca56ba8b"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b">Sawyer::CommandLine::ParserResult::apply</a></div><div class="ttdeci">const ParserResult &amp; apply() const</div><div class="ttdoc">Saves parsed values in switch-specified locations.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_adbdafd6227ba5292448acf7792adfe90"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#adbdafd6227ba5292448acf7792adfe90">Sawyer::CommandLine::ParserResult::unreachedArgs</a></div><div class="ttdeci">std::vector&lt; std::string &gt; unreachedArgs() const</div><div class="ttdoc">Returns program arguments that were not reached during parsing.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html_acadfcac830d7855ae15b39ef9ce1aebb"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">Sawyer::CommandLine::Parser::parse</a></div><div class="ttdeci">ParserResult parse(int argc, char *argv[])</div><div class="ttdoc">Parse program arguments.</div></div>
</div><!-- fragment --><p>Finally, now that the engine has been obtained, the tool can cause the engine to produce a fully initialized <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>, or do any of the other things that an engine is designed to do.</p>
<div class="fragment"><div class="line">P2::Partitioner::Ptr partitioner = engine.partition(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>);</div>
</div><!-- fragment --><p>On the other hand, if you perform your own command-line parser then you'll have the engine settings and the specimen arguments already parsed, in which case you can create the engine with fewer steps:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">    P2::Engine::Settings <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>;</div>
<div class="line">    std::vector&lt;std::string&gt; <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a> = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a447357ce51bd95c4ac58c456c9bd9ce8">parseCommandLine</a>(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>);</div>
<div class="line">    <span class="keyword">auto</span> engine = P2::Engine::forge(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>);</div>
<div class="line">    <span class="keyword">auto</span> partitioner = engine-&gt;partition(<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_html_a447357ce51bd95c4ac58c456c9bd9ce8"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a447357ce51bd95c4ac58c456c9bd9ce8">Rose::BinaryAnalysis::Partitioner2::Engine::parseCommandLine</a></div><div class="ttdeci">Sawyer::CommandLine::ParserResult parseCommandLine(int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</div><div class="ttdoc">Parse the command-line.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Rose_BinaryAnalysis_Partitioner2_Engine_sa"></a>
See also</h1>
<p>See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">Partitioner2::EngineJvm</a>, and the documentation for non-ROSE engines. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2Engine_8h_source.html#l00156">156</a> of file <a class="el" href="Partitioner2_2Engine_8h_source.html">Partitioner2/Engine.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Partitioner2_2Engine_8h_source.html">Rose/BinaryAnalysis/Partitioner2/Engine.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Partitioner2::Engine:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_inherit__map">
<area shape="rect" title="Base class for engines driving the partitioner." alt="" coords="224,37,372,77"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html" title="Engine for specimens containing machine instructions." alt="" coords="420,5,601,45"/>
<area shape="poly" title=" " alt="" coords="385,41,419,36,420,42,386,47"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html" title="Engine for Java Virtual Machine (JVM) specimens." alt="" coords="426,69,595,109"/>
<area shape="poly" title=" " alt="" coords="386,68,426,74,425,79,386,73"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="14,15,167,41"/>
<area shape="poly" title=" " alt="" coords="182,38,224,44,223,49,181,43"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="5,65,176,105"/>
<area shape="poly" title=" " alt="" coords="189,69,224,65,224,70,190,75"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Partitioner2::Engine:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_coll__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_coll__map">
<area shape="rect" title="Base class for engines driving the partitioner." alt="" coords="101,93,249,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,13,159,38"/>
<area shape="poly" title=" " alt="" coords="108,46,156,91,152,95,104,50"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="183,5,354,45"/>
<area shape="poly" title=" " alt="" coords="239,57,199,95,195,91,235,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1AllButLastArguments.html">AllButLastArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All but the last N arguments are the specimen.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1AllButLastArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1AllPositionalArguments.html">AllPositionalArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all positional arguments as the specimen.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1AllPositionalArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1BasicBlockFinalizer.html">BasicBlockFinalizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1CodeConstants.html">CodeConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors from the engine.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1FirstPositionalArguments.html">FirstPositionalArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up to first N arguments are the specimen.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1FirstPositionalArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1GroupedPositionalArguments.html">GroupedPositionalArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nth group of arguments are the specimen.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1GroupedPositionalArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to parse positional command-line arguments.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html" title="Settings for the engine.">Settings</a> for the engine.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6d6fb0584387aa535765e2b075086d67" id="r_a6d6fb0584387aa535765e2b075086d67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6d6fb0584387aa535765e2b075086d67">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a></td></tr>
<tr class="memdesc:a6d6fb0584387aa535765e2b075086d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:a6d6fb0584387aa535765e2b075086d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abffbe6a56926af17bdab6884678e7f41" id="r_abffbe6a56926af17bdab6884678e7f41"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abffbe6a56926af17bdab6884678e7f41">commandLineSwitches</a> ()</td></tr>
<tr class="memdesc:abffbe6a56926af17bdab6884678e7f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches for a particular engine.  <br /></td></tr>
<tr class="separator:abffbe6a56926af17bdab6884678e7f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9965bfadc44cb954411f3b3e6854669" id="r_aa9965bfadc44cb954411f3b3e6854669"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa9965bfadc44cb954411f3b3e6854669">allCommandLineSwitches</a> ()</td></tr>
<tr class="memdesc:aa9965bfadc44cb954411f3b3e6854669"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of command-line switches for all engines.  <br /></td></tr>
<tr class="separator:aa9965bfadc44cb954411f3b3e6854669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bce2bee37696e1401bfb11a671302b" id="r_a38bce2bee37696e1401bfb11a671302b"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a38bce2bee37696e1401bfb11a671302b">specimenNameDocumentation</a> ()=0</td></tr>
<tr class="memdesc:a38bce2bee37696e1401bfb11a671302b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation about how the specimen is specified.  <br /></td></tr>
<tr class="separator:a38bce2bee37696e1401bfb11a671302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37280b77d886d4b41e9234494adfff2b" id="r_a37280b77d886d4b41e9234494adfff2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a37280b77d886d4b41e9234494adfff2b">addToParser</a> (<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a37280b77d886d4b41e9234494adfff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switches and sections to command-line parser.  <br /></td></tr>
<tr class="separator:a37280b77d886d4b41e9234494adfff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ae9710eca6a74838e7cf5a8c874c9" id="r_a215ae9710eca6a74838e7cf5a8c874c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a215ae9710eca6a74838e7cf5a8c874c9">addAllToParser</a> (<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a215ae9710eca6a74838e7cf5a8c874c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switches and sections to command-line parser.  <br /></td></tr>
<tr class="separator:a215ae9710eca6a74838e7cf5a8c874c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec299a2c212759c27c10d848f65172" id="r_a15ec299a2c212759c27c10d848f65172"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a> (const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a15ec299a2c212759c27c10d848f65172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a command-line parser.  <br /></td></tr>
<tr class="separator:a15ec299a2c212759c27c10d848f65172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcb86e6e754431fc1896eae344f07c0" id="r_abbcb86e6e754431fc1896eae344f07c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>) const =0</td></tr>
<tr class="memdesc:abbcb86e6e754431fc1896eae344f07c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for matching a concrete engine factory by settings and specimen.  <br /></td></tr>
<tr class="separator:abbcb86e6e754431fc1896eae344f07c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f5b0cd482ce8f8d40647f1f7000e1d" id="r_a76f5b0cd482ce8f8d40647f1f7000e1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a76f5b0cd482ce8f8d40647f1f7000e1d">instanceFromFactory</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)=0</td></tr>
<tr class="memdesc:a76f5b0cd482ce8f8d40647f1f7000e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for factories.  <br /></td></tr>
<tr class="separator:a76f5b0cd482ce8f8d40647f1f7000e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ba1b48d82005b53a7a917bcd91297a" id="r_ab7ba1b48d82005b53a7a917bcd91297a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab7ba1b48d82005b53a7a917bcd91297a">isFactory</a> () const</td></tr>
<tr class="memdesc:ab7ba1b48d82005b53a7a917bcd91297a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is a factory.  <br /></td></tr>
<tr class="separator:ab7ba1b48d82005b53a7a917bcd91297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c9b0d871777a9bc0e661f2ae02eddd" id="r_ad1c9b0d871777a9bc0e661f2ae02eddd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ad1c9b0d871777a9bc0e661f2ae02eddd">reset</a> ()</td></tr>
<tr class="memdesc:ad1c9b0d871777a9bc0e661f2ae02eddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the engine to its initial state.  <br /></td></tr>
<tr class="separator:ad1c9b0d871777a9bc0e661f2ae02eddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc475e28fdf2a920aefc74a3fc687dd" id="r_a2fc475e28fdf2a920aefc74a3fc687dd"><td class="memItemLeft" align="right" valign="top"><a id="a2fc475e28fdf2a920aefc74a3fc687dd" name="a2fc475e28fdf2a920aefc74a3fc687dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>savePartitioner</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const boost::filesystem::path &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>=<a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a>)</td></tr>
<tr class="separator:a2fc475e28fdf2a920aefc74a3fc687dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15494ebc5c7683c9c7eb83e7f74f5a20" id="r_a15494ebc5c7683c9c7eb83e7f74f5a20"><td class="memItemLeft" align="right" valign="top"><a id="a15494ebc5c7683c9c7eb83e7f74f5a20" name="a15494ebc5c7683c9c7eb83e7f74f5a20"></a>
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadPartitioner</b> (const boost::filesystem::path &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>=<a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a>)</td></tr>
<tr class="separator:a15494ebc5c7683c9c7eb83e7f74f5a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cedac33fe84b58e81691982fd59c044" id="r_a8cedac33fe84b58e81691982fd59c044"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a8cedac33fe84b58e81691982fd59c044">checkSettings</a> ()</td></tr>
<tr class="memdesc:a8cedac33fe84b58e81691982fd59c044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check settings after command-line is processed.  <br /></td></tr>
<tr class="separator:a8cedac33fe84b58e81691982fd59c044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c851c4255123937a69bf226fda5cfd4" id="r_a2c851c4255123937a69bf226fda5cfd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a2c851c4255123937a69bf226fda5cfd4">isRbaFile</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a2c851c4255123937a69bf226fda5cfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a specimen is an RBA file.  <br /></td></tr>
<tr class="separator:a2c851c4255123937a69bf226fda5cfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac7e86f89e17c2157d282fa93ea677b" id="r_acac7e86f89e17c2157d282fa93ea677b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acac7e86f89e17c2157d282fa93ea677b">isNonContainer</a> (const std::string &amp;)=0</td></tr>
<tr class="memdesc:acac7e86f89e17c2157d282fa93ea677b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a specimen name is a non-container.  <br /></td></tr>
<tr class="separator:acac7e86f89e17c2157d282fa93ea677b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa2d53efe401584ac697a0e7c904eb" id="r_a72aa2d53efe401584ac697a0e7c904eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">areContainersParsed</a> () const =0</td></tr>
<tr class="memdesc:a72aa2d53efe401584ac697a0e7c904eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if containers are parsed.  <br /></td></tr>
<tr class="separator:a72aa2d53efe401584ac697a0e7c904eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fe78b82a4d4495b16b273c91b36dd1" id="r_a63fe78b82a4d4495b16b273c91b36dd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a> () const</td></tr>
<tr class="memdesc:a63fe78b82a4d4495b16b273c91b36dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if specimens are loaded.  <br /></td></tr>
<tr class="separator:a63fe78b82a4d4495b16b273c91b36dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dca7dc0c1b3324ffe113cf5e1f2c2b" id="r_a80dca7dc0c1b3324ffe113cf5e1f2c2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a80dca7dc0c1b3324ffe113cf5e1f2c2b">adjustMemoryMap</a> ()</td></tr>
<tr class="memdesc:a80dca7dc0c1b3324ffe113cf5e1f2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust memory map post-loading.  <br /></td></tr>
<tr class="separator:a80dca7dc0c1b3324ffe113cf5e1f2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed290482cc798c43c78592e8d44820e3" id="r_aed290482cc798c43c78592e8d44820e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed290482cc798c43c78592e8d44820e3">checkCreatePartitionerPrerequisites</a> () const</td></tr>
<tr class="memdesc:aed290482cc798c43c78592e8d44820e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that we have everything necessary to create a partitioner.  <br /></td></tr>
<tr class="separator:aed290482cc798c43c78592e8d44820e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0922cec9d5f1f67e5efa9cd5ce965b47" id="r_a0922cec9d5f1f67e5efa9cd5ce965b47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a0922cec9d5f1f67e5efa9cd5ce965b47">createBarePartitioner</a> ()</td></tr>
<tr class="memdesc:a0922cec9d5f1f67e5efa9cd5ce965b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bare partitioner.  <br /></td></tr>
<tr class="separator:a0922cec9d5f1f67e5efa9cd5ce965b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12a693635a6ec60ec512263070f6c01" id="r_aa12a693635a6ec60ec512263070f6c01"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa12a693635a6ec60ec512263070f6c01">createPartitioner</a> ()=0</td></tr>
<tr class="memdesc:aa12a693635a6ec60ec512263070f6c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create partitioner.  <br /></td></tr>
<tr class="separator:aa12a693635a6ec60ec512263070f6c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b274b6cd96d876c4e5813ba9967b572" id="r_a9b274b6cd96d876c4e5813ba9967b572"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9b274b6cd96d876c4e5813ba9967b572">runPartitionerInit</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)=0</td></tr>
<tr class="memdesc:a9b274b6cd96d876c4e5813ba9967b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds interesting things to work on initially.  <br /></td></tr>
<tr class="separator:a9b274b6cd96d876c4e5813ba9967b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f8fda7a63fde3b1a080972d66f99c8" id="r_a33f8fda7a63fde3b1a080972d66f99c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a33f8fda7a63fde3b1a080972d66f99c8">runPartitionerRecursive</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)=0</td></tr>
<tr class="memdesc:a33f8fda7a63fde3b1a080972d66f99c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the recursive part of partioning.  <br /></td></tr>
<tr class="separator:a33f8fda7a63fde3b1a080972d66f99c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e3e5118b7540c0734a5dd692fd2a45" id="r_a71e3e5118b7540c0734a5dd692fd2a45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a71e3e5118b7540c0734a5dd692fd2a45">runPartitionerFinal</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)=0</td></tr>
<tr class="memdesc:a71e3e5118b7540c0734a5dd692fd2a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the final parts of partitioning.  <br /></td></tr>
<tr class="separator:a71e3e5118b7540c0734a5dd692fd2a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed87fa166db4263d0c3efe1b2eb2dead" id="r_aed87fa166db4263d0c3efe1b2eb2dead"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:aed87fa166db4263d0c3efe1b2eb2dead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:aed87fa166db4263d0c3efe1b2eb2dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9300f21efb63affa59ff7aa1cbeb48" id="r_adc9300f21efb63affa59ff7aa1cbeb48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#adc9300f21efb63affa59ff7aa1cbeb48">labelAddresses</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:adc9300f21efb63affa59ff7aa1cbeb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label addresses.  <br /></td></tr>
<tr class="separator:adc9300f21efb63affa59ff7aa1cbeb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40871501faf9246979de4e2209129a3b" id="r_a40871501faf9246979de4e2209129a3b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a40871501faf9246979de4e2209129a3b">makeConfiguredDataBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:a40871501faf9246979de4e2209129a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make data blocks based on configuration.  <br /></td></tr>
<tr class="separator:a40871501faf9246979de4e2209129a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e535db9df960aae0490a3ca8537deb4" id="r_a7e535db9df960aae0490a3ca8537deb4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7e535db9df960aae0490a3ca8537deb4">makeConfiguredFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:a7e535db9df960aae0490a3ca8537deb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions based on configuration information.  <br /></td></tr>
<tr class="separator:a7e535db9df960aae0490a3ca8537deb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6053c48791d8c34c6c40ec28d766e" id="r_aebc6053c48791d8c34c6c40ec28d766e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aebc6053c48791d8c34c6c40ec28d766e">updateAnalysisResults</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:aebc6053c48791d8c34c6c40ec28d766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs various analysis passes.  <br /></td></tr>
<tr class="separator:aebc6053c48791d8c34c6c40ec28d766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ecebed849132c397314472662f9371" id="r_a81ecebed849132c397314472662f9371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> ()</td></tr>
<tr class="memdesc:a81ecebed849132c397314472662f9371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>.  <br /></td></tr>
<tr class="separator:a81ecebed849132c397314472662f9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7578d0b2e81c599a3b4749bad2e54fb5" id="r_a7578d0b2e81c599a3b4749bad2e54fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">frontend</a> (int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a7578d0b2e81c599a3b4749bad2e54fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:a7578d0b2e81c599a3b4749bad2e54fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada804bf70502647031d9bb3cf717d8c2" id="r_ada804bf70502647031d9bb3cf717d8c2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ada804bf70502647031d9bb3cf717d8c2">frontend</a> (const std::vector&lt; std::string &gt; &amp;args, const std::string &amp;purpose, const std::string &amp;description)=0</td></tr>
<tr class="memdesc:ada804bf70502647031d9bb3cf717d8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:ada804bf70502647031d9bb3cf717d8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a447357ce51bd95c4ac58c456c9bd9ce8" id="r_a447357ce51bd95c4ac58c456c9bd9ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a447357ce51bd95c4ac58c456c9bd9ce8">parseCommandLine</a> (int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a447357ce51bd95c4ac58c456c9bd9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the command-line.  <br /></td></tr>
<tr class="separator:a447357ce51bd95c4ac58c456c9bd9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed3d22decbdafc35b9c897b14b239a" id="r_a7fed3d22decbdafc35b9c897b14b239a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7fed3d22decbdafc35b9c897b14b239a">parseCommandLine</a> (const std::vector&lt; std::string &gt; &amp;args, const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a7fed3d22decbdafc35b9c897b14b239a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the command-line.  <br /></td></tr>
<tr class="separator:a7fed3d22decbdafc35b9c897b14b239a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac5ab3614209149b652b26e2aa24cd064" id="r_ac5ab3614209149b652b26e2aa24cd064"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ac5ab3614209149b652b26e2aa24cd064">buildAst</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:ac5ab3614209149b652b26e2aa24cd064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an abstract syntax tree.  <br /></td></tr>
<tr class="separator:ac5ab3614209149b652b26e2aa24cd064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced447c1be5912055c4229329294360" id="r_acced447c1be5912055c4229329294360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acced447c1be5912055c4229329294360">buildAst</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:acced447c1be5912055c4229329294360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an abstract syntax tree.  <br /></td></tr>
<tr class="separator:acced447c1be5912055c4229329294360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acd6774f4a00e3395348580911f20cf7b" id="r_acd6774f4a00e3395348580911f20cf7b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">parseContainers</a> (const std::vector&lt; std::string &gt; &amp;fileNames)=0</td></tr>
<tr class="memdesc:acd6774f4a00e3395348580911f20cf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse specimen binary containers.  <br /></td></tr>
<tr class="separator:acd6774f4a00e3395348580911f20cf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7302b9664b6c6f3736391ff691d10d" id="r_a9c7302b9664b6c6f3736391ff691d10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9c7302b9664b6c6f3736391ff691d10d">parseContainers</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a9c7302b9664b6c6f3736391ff691d10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse specimen binary containers.  <br /></td></tr>
<tr class="separator:a9c7302b9664b6c6f3736391ff691d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae4be5fcd45af5fcdfec6df6a416d7d28" id="r_ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and/or link interpretation.  <br /></td></tr>
<tr class="separator:ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc081451bcc8e731855d4fa8feb953c2" id="r_acc081451bcc8e731855d4fa8feb953c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acc081451bcc8e731855d4fa8feb953c2">loadSpecimens</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:acc081451bcc8e731855d4fa8feb953c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and/or link interpretation.  <br /></td></tr>
<tr class="separator:acc081451bcc8e731855d4fa8feb953c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af906e88cbeeebed28dd5f4250f3da920" id="r_af906e88cbeeebed28dd5f4250f3da920"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">partition</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:af906e88cbeeebed28dd5f4250f3da920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:af906e88cbeeebed28dd5f4250f3da920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602cb50f4790c6e788288ae7a280f41" id="r_ad602cb50f4790c6e788288ae7a280f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ad602cb50f4790c6e788288ae7a280f41">partition</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:ad602cb50f4790c6e788288ae7a280f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:ad602cb50f4790c6e788288ae7a280f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a300676870a43dbd55a4f06f26cebf4c3" id="r_a300676870a43dbd55a4f06f26cebf4c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a300676870a43dbd55a4f06f26cebf4c3">memoryMap</a> () const</td></tr>
<tr class="memdesc:a300676870a43dbd55a4f06f26cebf4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: memory map.  <br /></td></tr>
<tr class="separator:a300676870a43dbd55a4f06f26cebf4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000fe1570b5566a3173053c5f7816289" id="r_a000fe1570b5566a3173053c5f7816289"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a000fe1570b5566a3173053c5f7816289">memoryMap</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;)</td></tr>
<tr class="memdesc:a000fe1570b5566a3173053c5f7816289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: memory map.  <br /></td></tr>
<tr class="separator:a000fe1570b5566a3173053c5f7816289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aee425610d4789639e5f963bce81f8354" id="r_aee425610d4789639e5f963bce81f8354"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a> ()</td></tr>
<tr class="memdesc:aee425610d4789639e5f963bce81f8354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the architecture.  <br /></td></tr>
<tr class="separator:aee425610d4789639e5f963bce81f8354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4950d36daffee4e6b047ae8fe1cccca" id="r_ab4950d36daffee4e6b047ae8fe1cccca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab4950d36daffee4e6b047ae8fe1cccca">obtainArchitecture</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;hint)</td></tr>
<tr class="memdesc:ab4950d36daffee4e6b047ae8fe1cccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the architecture.  <br /></td></tr>
<tr class="separator:ab4950d36daffee4e6b047ae8fe1cccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acba323f9eb246e9263f6aa55227434fd" id="r_acba323f9eb246e9263f6aa55227434fd"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acba323f9eb246e9263f6aa55227434fd">name</a> () const</td></tr>
<tr class="memdesc:acba323f9eb246e9263f6aa55227434fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:acba323f9eb246e9263f6aa55227434fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842497578115bbfe34b1f3d4b9ab86ff" id="r_a842497578115bbfe34b1f3d4b9ab86ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a842497578115bbfe34b1f3d4b9ab86ff">name</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a842497578115bbfe34b1f3d4b9ab86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:a842497578115bbfe34b1f3d4b9ab86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acab999b1599d0e262cb07d859925b188" id="r_acab999b1599d0e262cb07d859925b188"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a> () const</td></tr>
<tr class="memdesc:acab999b1599d0e262cb07d859925b188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:acab999b1599d0e262cb07d859925b188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19421321588268b8d8270c56ae9bdd43" id="r_a19421321588268b8d8270c56ae9bdd43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a19421321588268b8d8270c56ae9bdd43">settings</a> ()</td></tr>
<tr class="memdesc:a19421321588268b8d8270c56ae9bdd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:a19421321588268b8d8270c56ae9bdd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b51b3ed2d11e9a180f13aa3f72ae8" id="r_aa91b51b3ed2d11e9a180f13aa3f72ae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa91b51b3ed2d11e9a180f13aa3f72ae8">settings</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:aa91b51b3ed2d11e9a180f13aa3f72ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:aa91b51b3ed2d11e9a180f13aa3f72ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0cd13654a6f74cbe6bf1aaab2b02d4f" id="r_ac0cd13654a6f74cbe6bf1aaab2b02d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ac0cd13654a6f74cbe6bf1aaab2b02d4f">basicBlockWorkList</a> () const</td></tr>
<tr class="memdesc:ac0cd13654a6f74cbe6bf1aaab2b02d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:ac0cd13654a6f74cbe6bf1aaab2b02d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5e841a637fae01e5f67b9bd2d0791" id="r_a3dd5e841a637fae01e5f67b9bd2d0791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a3dd5e841a637fae01e5f67b9bd2d0791">basicBlockWorkList</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a3dd5e841a637fae01e5f67b9bd2d0791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:a3dd5e841a637fae01e5f67b9bd2d0791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1bab30a181f9806cfe919a77c9dc69" id="r_aca1bab30a181f9806cfe919a77c9dc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aca1bab30a181f9806cfe919a77c9dc69">codeFunctionPointers</a> () const</td></tr>
<tr class="memdesc:aca1bab30a181f9806cfe919a77c9dc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Instruction <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> constants.  <br /></td></tr>
<tr class="separator:aca1bab30a181f9806cfe919a77c9dc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674052dfc3833ed2146e109949204f3d" id="r_a674052dfc3833ed2146e109949204f3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a674052dfc3833ed2146e109949204f3d">codeFunctionPointers</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a674052dfc3833ed2146e109949204f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:a674052dfc3833ed2146e109949204f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a61f0160caff0aec828f1d3936fc3c672" id="r_a61f0160caff0aec828f1d3936fc3c672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> () const</td></tr>
<tr class="memdesc:a61f0160caff0aec828f1d3936fc3c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: interpretation.  <br /></td></tr>
<tr class="separator:a61f0160caff0aec828f1d3936fc3c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0facdf97da071420d67bc1f3cba89a66" id="r_a0facdf97da071420d67bc1f3cba89a66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a0facdf97da071420d67bc1f3cba89a66">interpretation</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a0facdf97da071420d67bc1f3cba89a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: interpretation.  <br /></td></tr>
<tr class="separator:a0facdf97da071420d67bc1f3cba89a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70c0f282763bdfbfe83ca9fe2aae52ff" id="r_a70c0f282763bdfbfe83ca9fe2aae52ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a70c0f282763bdfbfe83ca9fe2aae52ff">progress</a> () const</td></tr>
<tr class="memdesc:a70c0f282763bdfbfe83ca9fe2aae52ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: progress reporting.  <br /></td></tr>
<tr class="separator:a70c0f282763bdfbfe83ca9fe2aae52ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902ca55f8dbf32a33fb6cc4365ac0745" id="r_a902ca55f8dbf32a33fb6cc4365ac0745"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a902ca55f8dbf32a33fb6cc4365ac0745">progress</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a> &amp;)</td></tr>
<tr class="memdesc:a902ca55f8dbf32a33fb6cc4365ac0745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: progress reporting.  <br /></td></tr>
<tr class="separator:a902ca55f8dbf32a33fb6cc4365ac0745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67cb0f9a5384de07b24893dbbe049428" id="r_a67cb0f9a5384de07b24893dbbe049428"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a> () const</td></tr>
<tr class="memdesc:a67cb0f9a5384de07b24893dbbe049428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: specimen.  <br /></td></tr>
<tr class="separator:a67cb0f9a5384de07b24893dbbe049428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d41a99dac587136cb1fe7227efd9ccf" id="r_a8d41a99dac587136cb1fe7227efd9ccf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a8d41a99dac587136cb1fe7227efd9ccf">specimen</a> (const std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:a8d41a99dac587136cb1fe7227efd9ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: specimen.  <br /></td></tr>
<tr class="separator:a8d41a99dac587136cb1fe7227efd9ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedFromThis"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedFromThis')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedFromThis.html">Sawyer::SharedFromThis&lt; Engine &gt;</a></td></tr>
<tr class="memitem:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a5225cf4c7055339254ace1c62005ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; Engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a5225cf4c7055339254ace1c62005ac55">sharedFromThis</a> ()</td></tr>
<tr class="memdesc:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a8b829a965e98f9ccb1b22da4a68a6f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; const Engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a8b829a965e98f9ccb1b22da4a68a6f76">sharedFromThis</a> () const</td></tr>
<tr class="memdesc:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a13bddfb4b277b18db273c069840be0bb" id="r_a13bddfb4b277b18db273c069840be0bb"><td class="memItemLeft" align="right" valign="top"><a id="a13bddfb4b277b18db273c069840be0bb" name="a13bddfb4b277b18db273c069840be0bb"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">EngineBinaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> ()</td></tr>
<tr class="separator:a13bddfb4b277b18db273c069840be0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42955b75ee9cd84996ed37bc21e15fe6" id="r_a42955b75ee9cd84996ed37bc21e15fe6"><td class="memItemLeft" align="right" valign="top">static std::list&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a42955b75ee9cd84996ed37bc21e15fe6">allSpecimenNameDocumentation</a> ()</td></tr>
<tr class="memdesc:a42955b75ee9cd84996ed37bc21e15fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for all specimen specifications.  <br /></td></tr>
<tr class="separator:a42955b75ee9cd84996ed37bc21e15fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09b6e269acd25faa5440211241e16b" id="r_a7f09b6e269acd25faa5440211241e16b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7f09b6e269acd25faa5440211241e16b">registerFactory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;factory)</td></tr>
<tr class="memdesc:a7f09b6e269acd25faa5440211241e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an engine as a factory.  <br /></td></tr>
<tr class="separator:a7f09b6e269acd25faa5440211241e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2e4b809563f44a45c45368e65dcc6" id="r_a6ba2e4b809563f44a45c45368e65dcc6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6ba2e4b809563f44a45c45368e65dcc6">deregisterFactory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;factory)</td></tr>
<tr class="memdesc:a6ba2e4b809563f44a45c45368e65dcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a concrete engine factory from the registry.  <br /></td></tr>
<tr class="separator:a6ba2e4b809563f44a45c45368e65dcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f067ece2ed379c79f4bbe336157c9" id="r_af57f067ece2ed379c79f4bbe336157c9"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> ()</td></tr>
<tr class="memdesc:af57f067ece2ed379c79f4bbe336157c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all registered factories.  <br /></td></tr>
<tr class="separator:af57f067ece2ed379c79f4bbe336157c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72813aecbbc6fd95879101b6b7f3337" id="r_af72813aecbbc6fd95879101b6b7f3337"><td class="memItemLeft" align="right" valign="top"><a id="af72813aecbbc6fd95879101b6b7f3337" name="af72813aecbbc6fd95879101b6b7f3337"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>disassembleForRoseFrontend</b> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="separator:af72813aecbbc6fd95879101b6b7f3337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa90d4d8152cb5abecef50a2bcad1ead0" id="r_aa90d4d8152cb5abecef50a2bcad1ead0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa90d4d8152cb5abecef50a2bcad1ead0">forge</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>)</td></tr>
<tr class="memdesc:aa90d4d8152cb5abecef50a2bcad1ead0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:aa90d4d8152cb5abecef50a2bcad1ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff42b8cc81375666b980eda02d7d57" id="r_adaff42b8cc81375666b980eda02d7d57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#adaff42b8cc81375666b980eda02d7d57">forge</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>)</td></tr>
<tr class="memdesc:adaff42b8cc81375666b980eda02d7d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:adaff42b8cc81375666b980eda02d7d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d3672eaf562d61ab9b9b15bfbf670" id="r_af00d3672eaf562d61ab9b9b15bfbf670"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af00d3672eaf562d61ab9b9b15bfbf670">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:af00d3672eaf562d61ab9b9b15bfbf670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:af00d3672eaf562d61ab9b9b15bfbf670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66876ae7496f3b458d0c075b5d3162a8" id="r_a66876ae7496f3b458d0c075b5d3162a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a66876ae7496f3b458d0c075b5d3162a8">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;)</td></tr>
<tr class="memdesc:a66876ae7496f3b458d0c075b5d3162a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a66876ae7496f3b458d0c075b5d3162a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab046f7fa773f082cbb0f711559fbfeb0" id="r_ab046f7fa773f082cbb0f711559fbfeb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab046f7fa773f082cbb0f711559fbfeb0">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:ab046f7fa773f082cbb0f711559fbfeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ab046f7fa773f082cbb0f711559fbfeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c3b88e4f6949949cc0bc4c395b67b8" id="r_a99c3b88e4f6949949cc0bc4c395b67b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a99c3b88e4f6949949cc0bc4c395b67b8">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a99c3b88e4f6949949cc0bc4c395b67b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a99c3b88e4f6949949cc0bc4c395b67b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade324e5393f7ae45f7be7e53e6e2d4df" id="r_ade324e5393f7ae45f7be7e53e6e2d4df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ade324e5393f7ae45f7be7e53e6e2d4df">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:ade324e5393f7ae45f7be7e53e6e2d4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ade324e5393f7ae45f7be7e53e6e2d4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dc261d14b5695073763e7766356a8d" id="r_ab8dc261d14b5695073763e7766356a8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab8dc261d14b5695073763e7766356a8d">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;)</td></tr>
<tr class="memdesc:ab8dc261d14b5695073763e7766356a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ab8dc261d14b5695073763e7766356a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b35e356be7686b6633aae4472b2a00" id="r_a04b35e356be7686b6633aae4472b2a00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a04b35e356be7686b6633aae4472b2a00">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:a04b35e356be7686b6633aae4472b2a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a04b35e356be7686b6633aae4472b2a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8013243b2c883aaace4648b4f2201c2" id="r_ae8013243b2c883aaace4648b4f2201c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae8013243b2c883aaace4648b4f2201c2">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:ae8013243b2c883aaace4648b4f2201c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ae8013243b2c883aaace4648b4f2201c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9051325ca23c62b8035964a4b41fdc59" id="r_a9051325ca23c62b8035964a4b41fdc59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9051325ca23c62b8035964a4b41fdc59">Engine</a> ()=delete</td></tr>
<tr class="memdesc:a9051325ca23c62b8035964a4b41fdc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a9051325ca23c62b8035964a4b41fdc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079607f269069d05dbe16261f5dac540" id="r_a079607f269069d05dbe16261f5dac540"><td class="memItemLeft" align="right" valign="top"><a id="a079607f269069d05dbe16261f5dac540" name="a079607f269069d05dbe16261f5dac540"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Engine</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;)=delete</td></tr>
<tr class="separator:a079607f269069d05dbe16261f5dac540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf88e836b7dd11cf54ed71dc7889e4f8" id="r_acf88e836b7dd11cf54ed71dc7889e4f8"><td class="memItemLeft" align="right" valign="top"><a id="acf88e836b7dd11cf54ed71dc7889e4f8" name="acf88e836b7dd11cf54ed71dc7889e4f8"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;)=delete</td></tr>
<tr class="separator:acf88e836b7dd11cf54ed71dc7889e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55f6cfe8aaf65af3a72dd5a9af2b224" id="r_ac55f6cfe8aaf65af3a72dd5a9af2b224"><td class="memItemLeft" align="right" valign="top"><a id="ac55f6cfe8aaf65af3a72dd5a9af2b224" name="ac55f6cfe8aaf65af3a72dd5a9af2b224"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Engine</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acba323f9eb246e9263f6aa55227434fd">name</a>, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>)</td></tr>
<tr class="memdesc:ac55f6cfe8aaf65af3a72dd5a9af2b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating <code>instance</code> constructors are implemented by the non-abstract subclasses. <br /></td></tr>
<tr class="separator:ac55f6cfe8aaf65af3a72dd5a9af2b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae928c9aa8c908b38f3493e3d815d5d42" id="r_ae928c9aa8c908b38f3493e3d815d5d42"><td class="memItemLeft" align="right" valign="top"><a id="ae928c9aa8c908b38f3493e3d815d5d42" name="ae928c9aa8c908b38f3493e3d815d5d42"></a>
virtual <a class="el" href="classSgProject.html">SgProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>roseFrontendReplacement</b> (const std::vector&lt; boost::filesystem::path &gt; &amp;fileNames)=0</td></tr>
<tr class="separator:ae928c9aa8c908b38f3493e3d815d5d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6d6fb0584387aa535765e2b075086d67" name="a6d6fb0584387aa535765e2b075086d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6fb0584387aa535765e2b075086d67">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6d6fb0584387aa535765e2b075086d67">Rose::BinaryAnalysis::Partitioner2::Engine::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner2_2Engine_8h_source.html#l00162">162</a> of file <a class="el" href="Partitioner2_2Engine_8h_source.html">Partitioner2/Engine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9051325ca23c62b8035964a4b41fdc59" name="a9051325ca23c62b8035964a4b41fdc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9051325ca23c62b8035964a4b41fdc59">&#9670;&#160;</a></span>Engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::Partitioner2::Engine::Engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructor is deleted and class noncopyable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abffbe6a56926af17bdab6884678e7f41" name="abffbe6a56926af17bdab6884678e7f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffbe6a56926af17bdab6884678e7f41">&#9670;&#160;</a></span>commandLineSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt; Rose::BinaryAnalysis::Partitioner2::Engine::commandLineSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches for a particular engine. </p>
<p>Returns the list of switch groups that declare the command-line switches specific to a particular engine. Since every <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a></code> subclass needs its own particular switches (possibly in addition to the base class switches), this is implemented in each subclass that needs switches. The base class returns a list of switch groups that are applicable to all engines, although the subclasses can refine this list, and the subclass implementations should augment what the base implementation returns.</p>
<p>In order to implement the "--help" switch to show the man page, we need a way to include the switch documentation for all possible engine subclasses at once. Therefore, the returned command line switch groups must have names and prefixes that are unique across all subclasses, and the descriptions should refer to the name of the subclass. For instance, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a> class, which returns many switch groups, will name the switch groups like "binary-load", "binary-dis", "binary-part", "binary-ast", etc. and will make it clear in each group description that these switches are intended for the binary engine.</p>
<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa9965bfadc44cb954411f3b3e6854669">allCommandLineSwitches</a> for details about how the "--help" man page is constructed. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a2bf97876fddae32fcdbf921acdac5ad3">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="aa9965bfadc44cb954411f3b3e6854669" name="aa9965bfadc44cb954411f3b3e6854669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9965bfadc44cb954411f3b3e6854669">&#9670;&#160;</a></span>allCommandLineSwitches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt; Rose::BinaryAnalysis::Partitioner2::Engine::allCommandLineSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of command-line switches for all engines. </p>
<p>This function is used to construct the man page for a tool. It invokes <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abffbe6a56926af17bdab6884678e7f41">commandLineSwitches</a> for the base class and every registered subclass in the opposite order they were registered (i.e., the same order they're matched). It then traverses the list and removes any group that has the same name or prefix as an earlier group. The final list is returned. </p>

</div>
</div>
<a id="a38bce2bee37696e1401bfb11a671302b" name="a38bce2bee37696e1401bfb11a671302b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bce2bee37696e1401bfb11a671302b">&#9670;&#160;</a></span>specimenNameDocumentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; std::string, std::string &gt; Rose::BinaryAnalysis::Partitioner2::Engine::specimenNameDocumentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Documentation about how the specimen is specified. </p>
<p>The documentation string that's returned is expected to be used in a command-line parser description and thus may contain special formatting constructs. For most engine subclasses, this will be a description of those command-line positional arguments that describe the specimen. For instance, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> subclass would probably document that the specimen consists of one or more file names ending with the string ".class".</p>
<p>In order to support the &ndash;help switch that generates the man page, it must be possible to include the documentation for all subclasses concurrently. Therefore, each subclass returns both a section title and the section documentation string. The section title and documentation string should make it clear that this part of the documentation applies only to that particular subclass. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aebd369fe7e4baa7949c16c6209994f88">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a94dbf99b23dc64761074b956085ddcba">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a42955b75ee9cd84996ed37bc21e15fe6" name="a42955b75ee9cd84996ed37bc21e15fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42955b75ee9cd84996ed37bc21e15fe6">&#9670;&#160;</a></span>allSpecimenNameDocumentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::list&lt; std::pair&lt; std::string, std::string &gt; &gt; Rose::BinaryAnalysis::Partitioner2::Engine::allSpecimenNameDocumentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Documentation for all specimen specifications. </p>
<p>This function calls the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a38bce2bee37696e1401bfb11a671302b">specimenNameDocumentation</a> for all registered subclasses in the reverse order their factories were registered, which is the same order they're matched. It then combines (and warns) documentation that has the same title and returns the (possibly modified) list. The list consists of pairs where the first of each pair is the unique section title and the second is the documentation tht goes into that section. </p>

</div>
</div>
<a id="a37280b77d886d4b41e9234494adfff2b" name="a37280b77d886d4b41e9234494adfff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37280b77d886d4b41e9234494adfff2b">&#9670;&#160;</a></span>addToParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::addToParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switches and sections to command-line parser. </p>
<p>The switches and special documentation sections for the particular parser are added to the specified command-line parser.</p>
<p>Note that if you intend to create a parser that recognizes more than one engine type, it is better to use <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a215ae9710eca6a74838e7cf5a8c874c9">addAllToParser</a> since that function is better for this purpose. If you want to include only a few engines, consider clearing the engine factory list and replacing it with only those you want before calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a215ae9710eca6a74838e7cf5a8c874c9">addAllToParser</a>. </p>

</div>
</div>
<a id="a215ae9710eca6a74838e7cf5a8c874c9" name="a215ae9710eca6a74838e7cf5a8c874c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ae9710eca6a74838e7cf5a8c874c9">&#9670;&#160;</a></span>addAllToParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Engine::addAllToParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add switches and sections to command-line parser. </p>
<p>This function adds switch groups and descriptions for all available engine subclases, thus producing a parser that's suitable for generating a man page. It uses <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa9965bfadc44cb954411f3b3e6854669">allCommandLineSwitches</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a42955b75ee9cd84996ed37bc21e15fe6">allSpecimenNameDocumentation</a> to acheive this goal. </p>

</div>
</div>
<a id="a15ec299a2c212759c27c10d848f65172" name="a15ec299a2c212759c27c10d848f65172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ec299a2c212759c27c10d848f65172">&#9670;&#160;</a></span>commandLineParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> Rose::BinaryAnalysis::Partitioner2::Engine::commandLineParser </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a command-line parser. </p>
<p>This creates and returns a command-line parser that contains the switch groups and documentation sections for all registered engines. No other switches are included in the parser, particularly the switches defined by <a class="el" href="namespaceRose_1_1CommandLine.html#aa45373f941972ac9daa3851f7c290fcb">Rose::CommandLine::genericSwitches</a>.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning. </p>

</div>
</div>
<a id="a7f09b6e269acd25faa5440211241e16b" name="a7f09b6e269acd25faa5440211241e16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f09b6e269acd25faa5440211241e16b">&#9670;&#160;</a></span>registerFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::Partitioner2::Engine::registerFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an engine as a factory. </p>
<p>The specified engine is added to the end of a list of engine prototypical factory objects. When a new engine is needed, this list is scanned in reverse order until one of the <code>matchFactory</code> predicates for the prototypical object returns true, at which time a new copy of that object is created by passing the lookup arguments to its virtual <code>instanceFromFactory</code> constructor.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a6ba2e4b809563f44a45c45368e65dcc6" name="a6ba2e4b809563f44a45c45368e65dcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba2e4b809563f44a45c45368e65dcc6">&#9670;&#160;</a></span>deregisterFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Rose::BinaryAnalysis::Partitioner2::Engine::deregisterFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a concrete engine factory from the registry. </p>
<p>The last occurrence of the specified factory is removed from the list of registered factories. This function returns true if a factory was removed, and false if no registered factories match.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="af57f067ece2ed379c79f4bbe336157c9" name="af57f067ece2ed379c79f4bbe336157c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57f067ece2ed379c79f4bbe336157c9">&#9670;&#160;</a></span>registeredFactories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Engine::registeredFactories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of all registered factories. </p>
<p>The returned list contains the registered factories in the order they were registereed, which is the reverse order of how they're searched.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="aa90d4d8152cb5abecef50a2bcad1ead0" name="aa90d4d8152cb5abecef50a2bcad1ead0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90d4d8152cb5abecef50a2bcad1ead0">&#9670;&#160;</a></span>forge() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>specimen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="adaff42b8cc81375666b980eda02d7d57" name="adaff42b8cc81375666b980eda02d7d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaff42b8cc81375666b980eda02d7d57">&#9670;&#160;</a></span>forge() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>specimen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="af00d3672eaf562d61ab9b9b15bfbf670" name="af00d3672eaf562d61ab9b9b15bfbf670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00d3672eaf562d61ab9b9b15bfbf670">&#9670;&#160;</a></span>forge() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a66876ae7496f3b458d0c075b5d3162a8" name="a66876ae7496f3b458d0c075b5d3162a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66876ae7496f3b458d0c075b5d3162a8">&#9670;&#160;</a></span>forge() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ab046f7fa773f082cbb0f711559fbfeb0" name="ab046f7fa773f082cbb0f711559fbfeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab046f7fa773f082cbb0f711559fbfeb0">&#9670;&#160;</a></span>forge() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a99c3b88e4f6949949cc0bc4c395b67b8" name="a99c3b88e4f6949949cc0bc4c395b67b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c3b88e4f6949949cc0bc4c395b67b8">&#9670;&#160;</a></span>forge() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ade324e5393f7ae45f7be7e53e6e2d4df" name="ade324e5393f7ae45f7be7e53e6e2d4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade324e5393f7ae45f7be7e53e6e2d4df">&#9670;&#160;</a></span>forge() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ab8dc261d14b5695073763e7766356a8d" name="ab8dc261d14b5695073763e7766356a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dc261d14b5695073763e7766356a8d">&#9670;&#160;</a></span>forge() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a04b35e356be7686b6633aae4472b2a00" name="a04b35e356be7686b6633aae4472b2a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b35e356be7686b6633aae4472b2a00">&#9670;&#160;</a></span>forge() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ae8013243b2c883aaace4648b4f2201c2" name="ae8013243b2c883aaace4648b4f2201c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8013243b2c883aaace4648b4f2201c2">&#9670;&#160;</a></span>forge() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::forge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable engine based on the specimen. </p>
<p>Scans the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> list in the reverse order looking for a factory whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">matchFactory</a> predicate returns true. The first factory whose predicate returns true is used to create and return a new concrete engine object by invoking the factory's virtual <code>instanceFromFactory</code> constructor with the first argument of this function.</p>
<p>The version that takes a string or vector of strings, the "specimen", returns a new engine from the first factory that says it can handle those strings. For instance, if the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> can handle a specimen whose name is a class file having the extension ".class".</p>
<p>The versions that takes a command-line switch parser and a an optional command-line positional argument parser attempts to parse the command-line to obtain the specimen, which is then passed to the version that takes a specimen. The incoming parser should not have definitions for switches that adjust the engine settings&ndash;they will be added automatically to the parser before returning. The returned parser will be augmented with switches for all engines so that "--help" and friends work propertly, however only the switches applicable to the returned engine will be linked to the returned engine (switches for other engine types are linked to their respective factories as a holding area, although they're never used for anything).</p>
<p>If settings are specified, then they are the defaults to be adjusted by the command-line parser. These defaults will also show up in the man page.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="abbcb86e6e754431fc1896eae344f07c0" name="abbcb86e6e754431fc1896eae344f07c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcb86e6e754431fc1896eae344f07c0">&#9670;&#160;</a></span>matchFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::Engine::matchFactory </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>specimen</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate for matching a concrete engine factory by settings and specimen. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ad03bd239e6a7015113c65d86c57aae74">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#ac79c9191fb40db7f08ee8f15fd13cdc1">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a76f5b0cd482ce8f8d40647f1f7000e1d" name="a76f5b0cd482ce8f8d40647f1f7000e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f5b0cd482ce8f8d40647f1f7000e1d">&#9670;&#160;</a></span>instanceFromFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::instanceFromFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor for factories. </p>
<p>This creates a new object by calling the class method <code>instance</code> for the class of which <code>this</code> is a type. All arguments are passed to <code>instance</code>. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a1bb71405fbca62ef852af0e581ef6831">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#aa36da2da6db2348f1944811d885e26cd">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="ab7ba1b48d82005b53a7a917bcd91297a" name="ab7ba1b48d82005b53a7a917bcd91297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ba1b48d82005b53a7a917bcd91297a">&#9670;&#160;</a></span>isFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Engine::isFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this object is a factory. </p>
<p>Factories are created by the <code>factory</code> class methods rather than the usual <code>instance</code> class methods. A factory object should only be used to create other (non-factory) objects by registering it as a factory and eventually calling (directly or indirectly) its <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a76f5b0cd482ce8f8d40647f1f7000e1d">instanceFromFactory</a> object method. </p>

</div>
</div>
<a id="a7578d0b2e81c599a3b4749bad2e54fb5" name="a7578d0b2e81c599a3b4749bad2e54fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7578d0b2e81c599a3b4749bad2e54fb5">&#9670;&#160;</a></span>frontend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::frontend </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most basic usage of the partitioner. </p>
<p>This method does everything from parsing the command-line to generating an abstract syntax tree. If all is successful, then an abstract syntax tree is returned. The return value is a <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> node that contains all the detected functions. If the specimen consisted of an ELF or PE container then the parent nodes of the returned <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will lead eventually to an <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> node.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The command-line supports a "--help" (or "-h") switch to describe all other switches and arguments, essentially generating output like a Unix man(1) page.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="ada804bf70502647031d9bb3cf717d8c2" name="ada804bf70502647031d9bb3cf717d8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada804bf70502647031d9bb3cf717d8c2">&#9670;&#160;</a></span>frontend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::frontend </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most basic usage of the partitioner. </p>
<p>This method does everything from parsing the command-line to generating an abstract syntax tree. If all is successful, then an abstract syntax tree is returned. The return value is a <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> node that contains all the detected functions. If the specimen consisted of an ELF or PE container then the parent nodes of the returned <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will lead eventually to an <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> node.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The command-line supports a "--help" (or "-h") switch to describe all other switches and arguments, essentially generating output like a Unix man(1) page.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6f07fd60c2747e9367dec98def840779">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a5e1ec1aaf71858e0a2413a264ce29ea2">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ada804bf70502647031d9bb3cf717d8c2">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="ad1c9b0d871777a9bc0e661f2ae02eddd" name="ad1c9b0d871777a9bc0e661f2ae02eddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c9b0d871777a9bc0e661f2ae02eddd">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the engine to its initial state. </p>
<p>This does not reset the settings properties since that can be done easily by constructing a new engine. It only resets the interpretation, binary loader, and memory map so all the top-level steps get executed again. This is a useful way to re-use the same partitioner to process multiple specimens. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3fe27b15b46d801340c5d72886941941">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="a447357ce51bd95c4ac58c456c9bd9ce8" name="a447357ce51bd95c4ac58c456c9bd9ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447357ce51bd95c4ac58c456c9bd9ce8">&#9670;&#160;</a></span>parseCommandLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a> Rose::BinaryAnalysis::Partitioner2::Engine::parseCommandLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the command-line. </p>
<p>This method parses the command-line and uses it to update this engine's settings. Since a command line is usually more than just engine-related switches, the more usual approach is for the user to obtain engine-related command-line switch declarations and parse the command-line in user code.</p>
<p>This function automatically applies the command-line when it's successfully parsed, thereby updating this engine's settings. If something goes wrong with the command-line then an <code>std::runtime_error</code> is thrown.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If the tool requires additional switches, an opportunity to adjust the parser, or other special handling, it can call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a> to obtain a parser and then call its <code>parse</code> and <code>apply</code> methods explicitly.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="a7fed3d22decbdafc35b9c897b14b239a" name="a7fed3d22decbdafc35b9c897b14b239a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fed3d22decbdafc35b9c897b14b239a">&#9670;&#160;</a></span>parseCommandLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a> Rose::BinaryAnalysis::Partitioner2::Engine::parseCommandLine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the command-line. </p>
<p>This method parses the command-line and uses it to update this engine's settings. Since a command line is usually more than just engine-related switches, the more usual approach is for the user to obtain engine-related command-line switch declarations and parse the command-line in user code.</p>
<p>This function automatically applies the command-line when it's successfully parsed, thereby updating this engine's settings. If something goes wrong with the command-line then an <code>std::runtime_error</code> is thrown.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If the tool requires additional switches, an opportunity to adjust the parser, or other special handling, it can call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a> to obtain a parser and then call its <code>parse</code> and <code>apply</code> methods explicitly.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="ac5ab3614209149b652b26e2aa24cd064" name="ac5ab3614209149b652b26e2aa24cd064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ab3614209149b652b26e2aa24cd064">&#9670;&#160;</a></span>buildAst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::buildAst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain an abstract syntax tree. </p>
<p>Constructs a new abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) from partitioner information with these steps:</p>
<ul>
<li>If the partitioner has not been run yet, then do that now with the same arguments. The zero-argument version invokes the zero-argument <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">partition</a>, which requires that the specimen has already been loaded by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>.</li>
</ul>
<ul>
<li>Call <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af774642c835f58878dfe39a06c23184c" title="Builds an AST from the CFG.">Modules::buildAst</a> to build the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.</li>
</ul>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a38b30b8e67b6837e20622f5b6589e97d">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a5f8f3f752f0269a974f2945502793861">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac5ab3614209149b652b26e2aa24cd064">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="acced447c1be5912055c4229329294360" name="acced447c1be5912055c4229329294360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acced447c1be5912055c4229329294360">&#9670;&#160;</a></span>buildAst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::buildAst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an abstract syntax tree. </p>
<p>Constructs a new abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) from partitioner information with these steps:</p>
<ul>
<li>If the partitioner has not been run yet, then do that now with the same arguments. The zero-argument version invokes the zero-argument <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">partition</a>, which requires that the specimen has already been loaded by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>.</li>
</ul>
<ul>
<li>Call <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af774642c835f58878dfe39a06c23184c" title="Builds an AST from the CFG.">Modules::buildAst</a> to build the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.</li>
</ul>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="acd6774f4a00e3395348580911f20cf7b" name="acd6774f4a00e3395348580911f20cf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6774f4a00e3395348580911f20cf7b">&#9670;&#160;</a></span>parseContainers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> * Rose::BinaryAnalysis::Partitioner2::Engine::parseContainers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse specimen binary containers. </p>
<p>Parses the ELF and PE binary containers to create an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). If <code>fileNames</code> contains names that are recognized as raw data or other non-containers then they are skipped over at this stage but processed during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> stage.</p>
<p>This method tries to determine the specimen architecture. It also resets the interpretation to be the return value (see below), and clears the memory map.</p>
<p>Returns a binary interpretation (perhaps one of many). ELF files have only one interpretation; PE files have a DOS and a PE interpretation and this method will return the PE interpretation. The user may, at this point, select a different interpretation. If the list of names has nothing suitable for ROSE's <code>frontend</code> function (the thing that does the container parsing) then the null pointer is returned.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a131b9a3cb5ab3ae8457023e764187f">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a75fab415a0ebc7fcd88afe0c9fadd67d">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#acd6774f4a00e3395348580911f20cf7b">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="a9c7302b9664b6c6f3736391ff691d10d" name="a9c7302b9664b6c6f3736391ff691d10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7302b9664b6c6f3736391ff691d10d">&#9670;&#160;</a></span>parseContainers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> * Rose::BinaryAnalysis::Partitioner2::Engine::parseContainers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse specimen binary containers. </p>
<p>Parses the ELF and PE binary containers to create an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). If <code>fileNames</code> contains names that are recognized as raw data or other non-containers then they are skipped over at this stage but processed during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> stage.</p>
<p>This method tries to determine the specimen architecture. It also resets the interpretation to be the return value (see below), and clears the memory map.</p>
<p>Returns a binary interpretation (perhaps one of many). ELF files have only one interpretation; PE files have a DOS and a PE interpretation and this method will return the PE interpretation. The user may, at this point, select a different interpretation. If the list of names has nothing suitable for ROSE's <code>frontend</code> function (the thing that does the container parsing) then the null pointer is returned.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="ae4be5fcd45af5fcdfec6df6a416d7d28" name="ae4be5fcd45af5fcdfec6df6a416d7d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4be5fcd45af5fcdfec6df6a416d7d28">&#9670;&#160;</a></span>loadSpecimens() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::loadSpecimens </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and/or link interpretation. </p>
<p>Loads and/or links the engine's interpretation according to the engine's binary loader with these steps:</p>
<ul>
<li>Clears any existing memory map in the engine.</li>
</ul>
<ul>
<li>If the binary containers have not been parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">areContainersParsed</a> returns false, i.e., engine has a null binary interpretation) then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">parseContainers</a> is called with the same arguments.</li>
</ul>
<ul>
<li>If binary containers are present but the chosen binary interpretation's memory map is null or empty, then initialize the memory map.</li>
</ul>
<ul>
<li>Continue initializing the memory map by processing all non-container arguments.</li>
</ul>
<p>Returns a reference to the engine's memory map.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a08d2426746f27ad8d1dcd200cfd61b58">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae4be5fcd45af5fcdfec6df6a416d7d28">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="acc081451bcc8e731855d4fa8feb953c2" name="acc081451bcc8e731855d4fa8feb953c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc081451bcc8e731855d4fa8feb953c2">&#9670;&#160;</a></span>loadSpecimens() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::loadSpecimens </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and/or link interpretation. </p>
<p>Loads and/or links the engine's interpretation according to the engine's binary loader with these steps:</p>
<ul>
<li>Clears any existing memory map in the engine.</li>
</ul>
<ul>
<li>If the binary containers have not been parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">areContainersParsed</a> returns false, i.e., engine has a null binary interpretation) then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">parseContainers</a> is called with the same arguments.</li>
</ul>
<ul>
<li>If binary containers are present but the chosen binary interpretation's memory map is null or empty, then initialize the memory map.</li>
</ul>
<ul>
<li>Continue initializing the memory map by processing all non-container arguments.</li>
</ul>
<p>Returns a reference to the engine's memory map.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="af906e88cbeeebed28dd5f4250f3da920" name="af906e88cbeeebed28dd5f4250f3da920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af906e88cbeeebed28dd5f4250f3da920">&#9670;&#160;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition instructions into basic blocks and functions. </p>
<p>Disassembles and organizes instructions into basic blocks and functions with these steps:</p>
<ul>
<li>If the specimen is not loaded (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a>) then call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>. The no-argument version of this function requires that specimens have already been loaded.</li>
</ul>
<ul>
<li>Determine the architecture for the specimen by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a>.</li>
</ul>
<ul>
<li>Create a partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa12a693635a6ec60ec512263070f6c01">createPartitioner</a>.</li>
</ul>
<ul>
<li>Run the partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a>.</li>
</ul>
<p>Returns the partitioner that was used and which contains the results.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9adf0374e582f86a3cd0b03a007a73c8">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a89f88828ef3e35c29b25065203b40a2d">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#af906e88cbeeebed28dd5f4250f3da920">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>.</p>

</div>
</div>
<a id="ad602cb50f4790c6e788288ae7a280f41" name="ad602cb50f4790c6e788288ae7a280f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad602cb50f4790c6e788288ae7a280f41">&#9670;&#160;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::partition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition instructions into basic blocks and functions. </p>
<p>Disassembles and organizes instructions into basic blocks and functions with these steps:</p>
<ul>
<li>If the specimen is not loaded (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a>) then call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>. The no-argument version of this function requires that specimens have already been loaded.</li>
</ul>
<ul>
<li>Determine the architecture for the specimen by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a>.</li>
</ul>
<ul>
<li>Create a partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa12a693635a6ec60ec512263070f6c01">createPartitioner</a>.</li>
</ul>
<ul>
<li>Run the partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a>.</li>
</ul>
<p>Returns the partitioner that was used and which contains the results.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="a8cedac33fe84b58e81691982fd59c044" name="a8cedac33fe84b58e81691982fd59c044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cedac33fe84b58e81691982fd59c044">&#9670;&#160;</a></span>checkSettings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::checkSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check settings after command-line is processed. </p>
<p>This does some checks and further configuration immediately after processing the command line. It's also called by most of the top-level operations.</p>
<p>If an ISA name is specified in the settings and no architecture has been set yet, then an architecture is chosen. </p>

</div>
</div>
<a id="a2c851c4255123937a69bf226fda5cfd4" name="a2c851c4255123937a69bf226fda5cfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c851c4255123937a69bf226fda5cfd4">&#9670;&#160;</a></span>isRbaFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::Engine::isRbaFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a specimen is an RBA file. </p>
<p>Returns true if the name looks like a ROSE Binary <a class="el" href="classAnalysis.html">Analysis</a> file. Such files are not intended to be passed to ROSE's global <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5" title="Most basic usage of the partitioner.">frontend</a></code> function but may be passed to this <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a>'s <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">Engine::frontend</a> method. </p>

</div>
</div>
<a id="acac7e86f89e17c2157d282fa93ea677b" name="acac7e86f89e17c2157d282fa93ea677b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac7e86f89e17c2157d282fa93ea677b">&#9670;&#160;</a></span>isNonContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::Engine::isNonContainer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a specimen name is a non-container. </p>
<p>Certain strings are recognized as special instructions for how to adjust a memory map and are not intended to be passed to ROSE's <code>frontend</code> function. This predicate returns true for such strings. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6b5ab46a4ea34326e3962f12304058e3">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a7fc5c3fd6423f7cedca1511420518457">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a72aa2d53efe401584ac697a0e7c904eb" name="a72aa2d53efe401584ac697a0e7c904eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa2d53efe401584ac697a0e7c904eb">&#9670;&#160;</a></span>areContainersParsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::Engine::areContainersParsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if containers are parsed. </p>
<p>Specifically, returns true if the engine has a non-null interpretation. If it has a null interpretation then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">parseContainers</a> might have already been called but no binary containers specified, in which case calling it again with the same file names will have no effect. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#af6e73e30a9c1c80a21816deeb6a84d95">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a63fe78b82a4d4495b16b273c91b36dd1" name="a63fe78b82a4d4495b16b273c91b36dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fe78b82a4d4495b16b273c91b36dd1">&#9670;&#160;</a></span>areSpecimensLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::Engine::areSpecimensLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if specimens are loaded. </p>
<p>Specifically, returns true if the memory map is non-empty. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a8225929892f77ae82230a3e7a0d8330e">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a80dca7dc0c1b3324ffe113cf5e1f2c2b" name="a80dca7dc0c1b3324ffe113cf5e1f2c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dca7dc0c1b3324ffe113cf5e1f2c2b">&#9670;&#160;</a></span>adjustMemoryMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::adjustMemoryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust memory map post-loading. </p>
<p>Make adjustments to the memory map after the specimen is loaded. </p>

</div>
</div>
<a id="a300676870a43dbd55a4f06f26cebf4c3" name="a300676870a43dbd55a4f06f26cebf4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300676870a43dbd55a4f06f26cebf4c3">&#9670;&#160;</a></span>memoryMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::memoryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: memory map. </p>
<p>Returns the memory map resulting from the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> step. This is a combination of the memory map created by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1BinaryLoader.html" title="Base class for loading a static or dynamic object.">BinaryLoader</a> and stored in the interpretation, and the application of any memory map resources (non-container arguments). During partitioning operations the memory map comes from the partitioner itself. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>. </p>

</div>
</div>
<a id="a000fe1570b5566a3173053c5f7816289" name="a000fe1570b5566a3173053c5f7816289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000fe1570b5566a3173053c5f7816289">&#9670;&#160;</a></span>memoryMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::memoryMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: memory map. </p>
<p>Returns the memory map resulting from the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> step. This is a combination of the memory map created by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1BinaryLoader.html" title="Base class for loading a static or dynamic object.">BinaryLoader</a> and stored in the interpretation, and the application of any memory map resources (non-container arguments). During partitioning operations the memory map comes from the partitioner itself. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a>. </p>

</div>
</div>
<a id="aee425610d4789639e5f963bce81f8354" name="aee425610d4789639e5f963bce81f8354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee425610d4789639e5f963bce81f8354">&#9670;&#160;</a></span>obtainArchitecture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::obtainArchitecture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the architecture. </p>
<p>Chooses an architecture based on one of the following (in this order):</p>
<ul>
<li>If this engine's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> property is non-null, then return that architecture.</li>
</ul>
<ul>
<li>If this engine's ISA name setting is non-empty, then use an architecture that handles that name.</li>
</ul>
<ul>
<li>If a binary container was parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">areContainersParsed</a> returns true and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> is non-null) then try to choose an architecture based on the interpretation.</li>
</ul>
<ul>
<li>If a <code>hint</code> is supplied, then use it.</li>
</ul>
<ul>
<li>Fail by throwing a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NotFound.html">Architecture::NotFound</a> error.</li>
</ul>
<p>In any case, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> property is set to this method's return value. </p>

</div>
</div>
<a id="ab4950d36daffee4e6b047ae8fe1cccca" name="ab4950d36daffee4e6b047ae8fe1cccca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4950d36daffee4e6b047ae8fe1cccca">&#9670;&#160;</a></span>obtainArchitecture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::obtainArchitecture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the architecture. </p>
<p>Chooses an architecture based on one of the following (in this order):</p>
<ul>
<li>If this engine's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> property is non-null, then return that architecture.</li>
</ul>
<ul>
<li>If this engine's ISA name setting is non-empty, then use an architecture that handles that name.</li>
</ul>
<ul>
<li>If a binary container was parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">areContainersParsed</a> returns true and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> is non-null) then try to choose an architecture based on the interpretation.</li>
</ul>
<ul>
<li>If a <code>hint</code> is supplied, then use it.</li>
</ul>
<ul>
<li>Fail by throwing a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NotFound.html">Architecture::NotFound</a> error.</li>
</ul>
<p>In any case, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> property is set to this method's return value. </p>

</div>
</div>
<a id="aed290482cc798c43c78592e8d44820e3" name="aed290482cc798c43c78592e8d44820e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed290482cc798c43c78592e8d44820e3">&#9670;&#160;</a></span>checkCreatePartitionerPrerequisites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::checkCreatePartitionerPrerequisites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that we have everything necessary to create a partitioner. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#ac175d3b69b10acf89428e9c295493ccd">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a0922cec9d5f1f67e5efa9cd5ce965b47" name="a0922cec9d5f1f67e5efa9cd5ce965b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0922cec9d5f1f67e5efa9cd5ce965b47">&#9670;&#160;</a></span>createBarePartitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::createBarePartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a bare partitioner. </p>
<p>A bare partitioner, as far as the engine is concerned, is one that has characteristics that are common across all architectures but which is missing all architecture-specific functionality. Using the partitioner's own constructor is not quite the same&ndash;that would produce an even more bare partitioner! </p>

</div>
</div>
<a id="aa12a693635a6ec60ec512263070f6c01" name="aa12a693635a6ec60ec512263070f6c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12a693635a6ec60ec512263070f6c01">&#9670;&#160;</a></span>createPartitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::createPartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create partitioner. </p>
<p>This is the method usually called to create a new partitioner. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#adfd9912394b62e64189721f25d5a16e8">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#ae988dd860f6466a85a59dbdba8b0328f">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a9b274b6cd96d876c4e5813ba9967b572" name="a9b274b6cd96d876c4e5813ba9967b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b274b6cd96d876c4e5813ba9967b572">&#9670;&#160;</a></span>runPartitionerInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::runPartitionerInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds interesting things to work on initially. </p>
<p>Seeds the partitioner with addresses and functions where recursive disassembly should begin. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a1d69777f095a892b69c3e4ff85fd5129">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a403987905a70b9775165188e06bc194f">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a33f8fda7a63fde3b1a080972d66f99c8" name="a33f8fda7a63fde3b1a080972d66f99c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8fda7a63fde3b1a080972d66f99c8">&#9670;&#160;</a></span>runPartitionerRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::runPartitionerRecursive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the recursive part of partioning. </p>
<p>This is the long-running guts of the partitioner. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9024f922e4da510563597d09560802df">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#afec6a10fca194bfcc1ac3b650496a067">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="a71e3e5118b7540c0734a5dd692fd2a45" name="a71e3e5118b7540c0734a5dd692fd2a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e3e5118b7540c0734a5dd692fd2a45">&#9670;&#160;</a></span>runPartitionerFinal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::runPartitionerFinal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the final parts of partitioning. </p>
<p>This does anything necessary after the main part of partitioning is finished. For instance, it might give names to some functions that don't have names yet. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a46b2658f7518581ccbddb00060132b7c">Rose::BinaryAnalysis::Partitioner2::EngineBinary</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html#a474238bdb74d036bdff7d9388a4f565e">Rose::BinaryAnalysis::Partitioner2::EngineJvm</a>.</p>

</div>
</div>
<a id="aed87fa166db4263d0c3efe1b2eb2dead" name="aed87fa166db4263d0c3efe1b2eb2dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed87fa166db4263d0c3efe1b2eb2dead">&#9670;&#160;</a></span>runPartitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::runPartitioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitions instructions into basic blocks and functions. </p>
<p>This method is a wrapper around a number of lower-level partitioning steps that uses the specified interpretation to instantiate functions and then uses the specified partitioner to discover basic blocks and use the CFG to assign basic blocks to functions. It is often overridden by subclasses. </p>

</div>
</div>
<a id="adc9300f21efb63affa59ff7aa1cbeb48" name="adc9300f21efb63affa59ff7aa1cbeb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9300f21efb63affa59ff7aa1cbeb48">&#9670;&#160;</a></span>labelAddresses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::labelAddresses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Label addresses. </p>
<p>Labels addresses according to symbols, etc. Address labels are used for things like giving an unnamed function a name when it's attached to the partitioner's CFG/AUM. </p>

</div>
</div>
<a id="a40871501faf9246979de4e2209129a3b" name="a40871501faf9246979de4e2209129a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40871501faf9246979de4e2209129a3b">&#9670;&#160;</a></span>makeConfiguredDataBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Engine::makeConfiguredDataBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make data blocks based on configuration. </p>
<p>NOTE: for now, all this does is label the datablock addresses. FIXME[Robb P. Matzke 2015-05-12] </p>

</div>
</div>
<a id="a7e535db9df960aae0490a3ca8537deb4" name="a7e535db9df960aae0490a3ca8537deb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e535db9df960aae0490a3ca8537deb4">&#9670;&#160;</a></span>makeConfiguredFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Engine::makeConfiguredFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions based on configuration information. </p>
<p>Uses the supplied function configuration information to make functions. </p>

</div>
</div>
<a id="aebc6053c48791d8c34c6c40ec28d766e" name="aebc6053c48791d8c34c6c40ec28d766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc6053c48791d8c34c6c40ec28d766e">&#9670;&#160;</a></span>updateAnalysisResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::updateAnalysisResults </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs various analysis passes. </p>
<p>Runs each analysis over all functions to ensure that results are cached. This should typically be done after functions are discovered and before the final <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> is generated, otherwise the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will not contain cached results for functions and blocks for which an analysis was not performed. </p>

</div>
</div>
<a id="acba323f9eb246e9263f6aa55227434fd" name="acba323f9eb246e9263f6aa55227434fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba323f9eb246e9263f6aa55227434fd">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::Engine::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name. </p>
<p>The name of the engine comes from the engine factory, will be empty if not a factory. </p>

</div>
</div>
<a id="a842497578115bbfe34b1f3d4b9ab86ff" name="a842497578115bbfe34b1f3d4b9ab86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842497578115bbfe34b1f3d4b9ab86ff">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Engine::name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name. </p>
<p>The name of the engine comes from the engine factory, will be empty if not a factory. </p>

</div>
</div>
<a id="a81ecebed849132c397314472662f9371" name="a81ecebed849132c397314472662f9371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ecebed849132c397314472662f9371">&#9670;&#160;</a></span>architecture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::architecture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>. </p>
<p>The non-null object representing architecture-specific information is returned, or an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NotFound.html">Architecture::NotFound</a> exception is thrown if there is no architecture and none can be determined. </p>

</div>
</div>
<a id="acab999b1599d0e262cb07d859925b188" name="acab999b1599d0e262cb07d859925b188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab999b1599d0e262cb07d859925b188">&#9670;&#160;</a></span>settings() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Partitioner2::Engine::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: All settings. </p>
<p>Returns a reference to the engine settings structures. Alternatively, some settings also have a corresponding engine member function to query or adjust the setting directly. </p>

</div>
</div>
<a id="a19421321588268b8d8270c56ae9bdd43" name="a19421321588268b8d8270c56ae9bdd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19421321588268b8d8270c56ae9bdd43">&#9670;&#160;</a></span>settings() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Partitioner2::Engine::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: All settings. </p>
<p>Returns a reference to the engine settings structures. Alternatively, some settings also have a corresponding engine member function to query or adjust the setting directly. </p>

</div>
</div>
<a id="aa91b51b3ed2d11e9a180f13aa3f72ae8" name="aa91b51b3ed2d11e9a180f13aa3f72ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91b51b3ed2d11e9a180f13aa3f72ae8">&#9670;&#160;</a></span>settings() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Engine::settings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: All settings. </p>
<p>Returns a reference to the engine settings structures. Alternatively, some settings also have a corresponding engine member function to query or adjust the setting directly. </p>

</div>
</div>
<a id="ac0cd13654a6f74cbe6bf1aaab2b02d4f" name="ac0cd13654a6f74cbe6bf1aaab2b02d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd13654a6f74cbe6bf1aaab2b02d4f">&#9670;&#160;</a></span>basicBlockWorkList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a> Rose::BinaryAnalysis::Partitioner2::Engine::basicBlockWorkList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list. </p>
<p>This property holds the list of what blocks to work on next. </p>

</div>
</div>
<a id="a3dd5e841a637fae01e5f67b9bd2d0791" name="a3dd5e841a637fae01e5f67b9bd2d0791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd5e841a637fae01e5f67b9bd2d0791">&#9670;&#160;</a></span>basicBlockWorkList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Engine::basicBlockWorkList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list. </p>
<p>This property holds the list of what blocks to work on next. </p>

</div>
</div>
<a id="aca1bab30a181f9806cfe919a77c9dc69" name="aca1bab30a181f9806cfe919a77c9dc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1bab30a181f9806cfe919a77c9dc69">&#9670;&#160;</a></span>codeFunctionPointers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a> Rose::BinaryAnalysis::Partitioner2::Engine::codeFunctionPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Instruction <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> constants. </p>
<p>This property holds constants that are found in instruction ASTs. </p>

</div>
</div>
<a id="a674052dfc3833ed2146e109949204f3d" name="a674052dfc3833ed2146e109949204f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674052dfc3833ed2146e109949204f3d">&#9670;&#160;</a></span>codeFunctionPointers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Engine::codeFunctionPointers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list. </p>
<p>This property holds the list of what blocks to work on next. </p>

</div>
</div>
<a id="a61f0160caff0aec828f1d3936fc3c672" name="a61f0160caff0aec828f1d3936fc3c672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f0160caff0aec828f1d3936fc3c672">&#9670;&#160;</a></span>interpretation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> * Rose::BinaryAnalysis::Partitioner2::Engine::interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: interpretation. </p>
<p>The interpretation which is being analyzed. The interpretation is chosen when an ELF or PE container is parsed, and the user can set it to something else if desired. For instance, parsing a PE file will set the interpretation to PE, but the user can reset it to DOS to disassemble the DOS part of the executable. </p>

</div>
</div>
<a id="a0facdf97da071420d67bc1f3cba89a66" name="a0facdf97da071420d67bc1f3cba89a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0facdf97da071420d67bc1f3cba89a66">&#9670;&#160;</a></span>interpretation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::interpretation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: interpretation. </p>
<p>The interpretation which is being analyzed. The interpretation is chosen when an ELF or PE container is parsed, and the user can set it to something else if desired. For instance, parsing a PE file will set the interpretation to PE, but the user can reset it to DOS to disassemble the DOS part of the executable. </p>

</div>
</div>
<a id="a70c0f282763bdfbfe83ca9fe2aae52ff" name="a70c0f282763bdfbfe83ca9fe2aae52ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c0f282763bdfbfe83ca9fe2aae52ff">&#9670;&#160;</a></span>progress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: progress reporting. </p>
<p>The optional object to receive progress reports. </p>

</div>
</div>
<a id="a902ca55f8dbf32a33fb6cc4365ac0745" name="a902ca55f8dbf32a33fb6cc4365ac0745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902ca55f8dbf32a33fb6cc4365ac0745">&#9670;&#160;</a></span>progress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::progress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: progress reporting. </p>
<p>The optional object to receive progress reports. </p>

</div>
</div>
<a id="a67cb0f9a5384de07b24893dbbe049428" name="a67cb0f9a5384de07b24893dbbe049428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cb0f9a5384de07b24893dbbe049428">&#9670;&#160;</a></span>specimen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Rose::BinaryAnalysis::Partitioner2::Engine::specimen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: specimen. </p>
<p>The specimen is a list of additional command line arguments. It is often a list of file names. </p>

</div>
</div>
<a id="a8d41a99dac587136cb1fe7227efd9ccf" name="a8d41a99dac587136cb1fe7227efd9ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d41a99dac587136cb1fe7227efd9ccf">&#9670;&#160;</a></span>specimen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::Engine::specimen </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: specimen. </p>
<p>The specimen is a list of additional command line arguments. It is often a list of file names. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Partitioner2_2Engine_8h_source.html">Partitioner2/Engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
