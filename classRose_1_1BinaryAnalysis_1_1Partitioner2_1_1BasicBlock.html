<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::BasicBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::BasicBlock Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Basic block information. </p>
<p>A basic block is a sequence of distinct instructions with linear control flow from the first instruction to the last. No edges are permitted to enter or leave the basic block except to the first instruction and from the last instruction, respectively. The instructions of a basic block are not required to be contiguous or non-overlapping or at increasing addresses.</p>
<p>In the absense of interrupt handling, the instructions of a basic block are executed entirely. In the absense of multi-threading, no other instructions intervene.</p>
<p>A basic block is a read-only object once it reaches the BB_COMPLETE state, and can thus be shared between partitioners and threads. The memory for these objects is shared and managed by a shared pointer implementation.</p>
<p>A basic block may belong to multiple functions.</p>
<p>Thread safety: Most of this API is not thread safe, however it is possible to call the non-safe functions as long as no other thread is modifying the basic block at the same tme. The functions for querying and modifying the semantic state are thread safe since they're often called from parallel analysis, but no non-safe methods should be called at the same time by other threads.</p>
<p>See also, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> which is how a basic block (and some other things) are represented in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00165">165</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="BasicBlock_8h_source.html">Rose/BinaryAnalysis/Partitioner2/BasicBlock.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Partitioner2::BasicBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_inherit__map">
<area shape="rect" title="Basic block information." alt="" coords="82,93,253,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,13,159,38"/>
<area shape="poly" title=" " alt="" coords="106,46,150,91,146,95,102,50"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="183,5,325,45"/>
<area shape="poly" title=" " alt="" coords="226,57,189,95,185,91,223,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Partitioner2::BasicBlock:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_coll__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock_coll__map">
<area shape="rect" title="Basic block information." alt="" coords="82,93,253,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,13,159,38"/>
<area shape="poly" title=" " alt="" coords="106,46,150,91,146,95,102,50"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="183,5,325,45"/>
<area shape="poly" title=" " alt="" coords="226,57,189,95,185,91,223,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a231e80cbd7f85887d95e9174d2feb2" id="r_a9a231e80cbd7f85887d95e9174d2feb2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Ptr</a></td></tr>
<tr class="memdesc:a9a231e80cbd7f85887d95e9174d2feb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a basic block.  <br /></td></tr>
<tr class="separator:a9a231e80cbd7f85887d95e9174d2feb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2ef3f10b2c962bebf4a18f476b2200" id="r_acd2ef3f10b2c962bebf4a18f476b2200"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#acd2ef3f10b2c962bebf4a18f476b2200">Successor</a> = <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a></td></tr>
<tr class="memdesc:acd2ef3f10b2c962bebf4a18f476b2200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic block successor.  <br /></td></tr>
<tr class="separator:acd2ef3f10b2c962bebf4a18f476b2200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9337bb89b6c23d87f28fdb059e7ef263" id="r_a9337bb89b6c23d87f28fdb059e7ef263"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Successors</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">BasicBlockSuccessors</a></td></tr>
<tr class="memdesc:a9337bb89b6c23d87f28fdb059e7ef263"><td class="mdescLeft">&#160;</td><td class="mdescRight">All successors in no particular order.  <br /></td></tr>
<tr class="separator:a9337bb89b6c23d87f28fdb059e7ef263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage" id="r_a6232bff42634b42d2dcd3b68ba39a39c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSawyer_1_1SynchronizationTraits.html">SynchronizationTraits</a>&lt; SyncTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a6232bff42634b42d2dcd3b68ba39a39c">Sync</a></td></tr>
<tr class="separator:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06c67f8a6384f220d3f940d0f3adf5b0" id="r_a06c67f8a6384f220d3f940d0f3adf5b0"><td class="memItemLeft" align="right" valign="top"><a id="a06c67f8a6384f220d3f940d0f3adf5b0" name="a06c67f8a6384f220d3f940d0f3adf5b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyCache</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;other)</td></tr>
<tr class="separator:a06c67f8a6384f220d3f940d0f3adf5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d112db803427e7efa8c573ea67ce4" id="r_ab26d112db803427e7efa8c573ea67ce4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ab26d112db803427e7efa8c573ea67ce4">create</a> (rose_addr_t startVa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;partitioner) const</td></tr>
<tr class="memdesc:ab26d112db803427e7efa8c573ea67ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor.  <br /></td></tr>
<tr class="separator:ab26d112db803427e7efa8c573ea67ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02dc5b7cca7811f4e9df0ccd7f8f05" id="r_a0d02dc5b7cca7811f4e9df0ccd7f8f05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a0d02dc5b7cca7811f4e9df0ccd7f8f05">clearCache</a> ()</td></tr>
<tr class="memdesc:a0d02dc5b7cca7811f4e9df0ccd7f8f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all cached data.  <br /></td></tr>
<tr class="separator:a0d02dc5b7cca7811f4e9df0ccd7f8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabc20b98046fe33c35d40780e0478a2" id="r_aeabc20b98046fe33c35d40780e0478a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aeabc20b98046fe33c35d40780e0478a2">isFrozen</a> () const</td></tr>
<tr class="memdesc:aeabc20b98046fe33c35d40780e0478a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if basic block is read-only.  <br /></td></tr>
<tr class="separator:aeabc20b98046fe33c35d40780e0478a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8722459585ec6491c5802eeb016bd980" id="r_a8722459585ec6491c5802eeb016bd980"><td class="memItemLeft" align="right" valign="top">rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8722459585ec6491c5802eeb016bd980">address</a> () const</td></tr>
<tr class="memdesc:a8722459585ec6491c5802eeb016bd980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address for a basic block.  <br /></td></tr>
<tr class="separator:a8722459585ec6491c5802eeb016bd980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224098d4b0f51356b78d2fb5c5a90abc" id="r_a224098d4b0f51356b78d2fb5c5a90abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a224098d4b0f51356b78d2fb5c5a90abc">insnAddresses</a> () const</td></tr>
<tr class="memdesc:a224098d4b0f51356b78d2fb5c5a90abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all instruction addresses.  <br /></td></tr>
<tr class="separator:a224098d4b0f51356b78d2fb5c5a90abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63596073bbdb19c172fe367f17d53ad0" id="r_a63596073bbdb19c172fe367f17d53ad0"><td class="memItemLeft" align="right" valign="top">rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a63596073bbdb19c172fe367f17d53ad0">fallthroughVa</a> () const</td></tr>
<tr class="memdesc:a63596073bbdb19c172fe367f17d53ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address after the end of the final instruction.  <br /></td></tr>
<tr class="separator:a63596073bbdb19c172fe367f17d53ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57eefdafbd29acec40991d7ed0af2f6" id="r_ab57eefdafbd29acec40991d7ed0af2f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ab57eefdafbd29acec40991d7ed0af2f6">nInstructions</a> () const</td></tr>
<tr class="memdesc:ab57eefdafbd29acec40991d7ed0af2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of instructions in this block.  <br /></td></tr>
<tr class="separator:ab57eefdafbd29acec40991d7ed0af2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae472645e65da98340f932233c68dda" id="r_a4ae472645e65da98340f932233c68dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a4ae472645e65da98340f932233c68dda">isEmpty</a> () const</td></tr>
<tr class="memdesc:a4ae472645e65da98340f932233c68dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this basic block has no instructions.  <br /></td></tr>
<tr class="separator:a4ae472645e65da98340f932233c68dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9652c7e4c7e35a17631bba9dd34699" id="r_a2a9652c7e4c7e35a17631bba9dd34699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a2a9652c7e4c7e35a17631bba9dd34699">instructionExists</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a2a9652c7e4c7e35a17631bba9dd34699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this basic block contains an instruction at a specific address.  <br /></td></tr>
<tr class="separator:a2a9652c7e4c7e35a17631bba9dd34699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a477e20fd7aa8bfbfc6681cce2ac12a" id="r_a6a477e20fd7aa8bfbfc6681cce2ac12a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a6a477e20fd7aa8bfbfc6681cce2ac12a">instructionExists</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a6a477e20fd7aa8bfbfc6681cce2ac12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this basic block contains the specified instruction.  <br /></td></tr>
<tr class="separator:a6a477e20fd7aa8bfbfc6681cce2ac12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c4962c3081ed175270f9582b434ab" id="r_ad96c4962c3081ed175270f9582b434ab"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ad96c4962c3081ed175270f9582b434ab">instructions</a> () const</td></tr>
<tr class="memdesc:ad96c4962c3081ed175270f9582b434ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instructions for this block.  <br /></td></tr>
<tr class="separator:ad96c4962c3081ed175270f9582b434ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21ad4f5ec7c1a8a711a1c2e9215aa0" id="r_a9b21ad4f5ec7c1a8a711a1c2e9215aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9b21ad4f5ec7c1a8a711a1c2e9215aa0">append</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>
<tr class="memdesc:a9b21ad4f5ec7c1a8a711a1c2e9215aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an instruction to a basic block.  <br /></td></tr>
<tr class="separator:a9b21ad4f5ec7c1a8a711a1c2e9215aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a60139976768f55084989706caa54c" id="r_af5a60139976768f55084989706caa54c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#af5a60139976768f55084989706caa54c">pop</a> ()</td></tr>
<tr class="memdesc:af5a60139976768f55084989706caa54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the latest append.  <br /></td></tr>
<tr class="separator:af5a60139976768f55084989706caa54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39ef62d894b0a950dd73b997a6ddcf4" id="r_ab39ef62d894b0a950dd73b997a6ddcf4"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ab39ef62d894b0a950dd73b997a6ddcf4">explicitConstants</a> () const</td></tr>
<tr class="memdesc:ab39ef62d894b0a950dd73b997a6ddcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of explicit constants.  <br /></td></tr>
<tr class="separator:ab39ef62d894b0a950dd73b997a6ddcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466722f645e9372f1909c22825f4d663" id="r_a466722f645e9372f1909c22825f4d663"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a466722f645e9372f1909c22825f4d663">nDataBlocks</a> () const</td></tr>
<tr class="memdesc:a466722f645e9372f1909c22825f4d663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of data blocks owned.  <br /></td></tr>
<tr class="separator:a466722f645e9372f1909c22825f4d663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff173598e2f2d95457418b006ae6ee7f" id="r_aff173598e2f2d95457418b006ae6ee7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aff173598e2f2d95457418b006ae6ee7f">dataAddresses</a> () const</td></tr>
<tr class="memdesc:aff173598e2f2d95457418b006ae6ee7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses that are part of static data.  <br /></td></tr>
<tr class="separator:aff173598e2f2d95457418b006ae6ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fdac38b5832b7b1d19b298ffec5ebe" id="r_ad7fdac38b5832b7b1d19b298ffec5ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ad7fdac38b5832b7b1d19b298ffec5ebe">dataBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ad7fdac38b5832b7b1d19b298ffec5ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this basic block contains the specified data block or equivalent data block.  <br /></td></tr>
<tr class="separator:ad7fdac38b5832b7b1d19b298ffec5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ae26a8fc2001990a8c1f933b13a249" id="r_a82ae26a8fc2001990a8c1f933b13a249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a82ae26a8fc2001990a8c1f933b13a249">insertDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a82ae26a8fc2001990a8c1f933b13a249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this basic block own the specified data block or equivalent data block.  <br /></td></tr>
<tr class="separator:a82ae26a8fc2001990a8c1f933b13a249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e053d29e968c1e3f6e017f1333fd521" id="r_a7e053d29e968c1e3f6e017f1333fd521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a7e053d29e968c1e3f6e017f1333fd521">eraseDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a7e053d29e968c1e3f6e017f1333fd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove specified or equivalent data block from this basic block.  <br /></td></tr>
<tr class="separator:a7e053d29e968c1e3f6e017f1333fd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ed6e8dcad61c0721e296ee6700d6c8" id="r_a14ed6e8dcad61c0721e296ee6700d6c8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a14ed6e8dcad61c0721e296ee6700d6c8">dataBlocks</a> () const</td></tr>
<tr class="memdesc:a14ed6e8dcad61c0721e296ee6700d6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data blocks owned.  <br /></td></tr>
<tr class="separator:a14ed6e8dcad61c0721e296ee6700d6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032e89c52cc51996592155c9dbfa3499" id="r_a032e89c52cc51996592155c9dbfa3499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html">BasicBlockSemantics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a032e89c52cc51996592155c9dbfa3499">semantics</a> () const</td></tr>
<tr class="memdesc:a032e89c52cc51996592155c9dbfa3499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about semantics.  <br /></td></tr>
<tr class="separator:a032e89c52cc51996592155c9dbfa3499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b365a03211eaee8481bfa81c95d10a2" id="r_a8b365a03211eaee8481bfa81c95d10a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8b365a03211eaee8481bfa81c95d10a2">dropSemantics</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a8b365a03211eaee8481bfa81c95d10a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops semantic information.  <br /></td></tr>
<tr class="separator:a8b365a03211eaee8481bfa81c95d10a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac7730dde2c0892743facfac8e7f471" id="r_aeac7730dde2c0892743facfac8e7f471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html">BasicBlockSemantics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aeac7730dde2c0892743facfac8e7f471">undropSemantics</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:aeac7730dde2c0892743facfac8e7f471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undrop semantics.  <br /></td></tr>
<tr class="separator:aeac7730dde2c0892743facfac8e7f471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c654cd9ae99fc94b4ed6aef533bde1e" id="r_a2c654cd9ae99fc94b4ed6aef533bde1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; std::set&lt; rose_addr_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a2c654cd9ae99fc94b4ed6aef533bde1e">ghostSuccessors</a> () const</td></tr>
<tr class="memdesc:a2c654cd9ae99fc94b4ed6aef533bde1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ghost successors.  <br /></td></tr>
<tr class="separator:a2c654cd9ae99fc94b4ed6aef533bde1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8828571c3b2ce211b23eab06954392b4" id="r_a8828571c3b2ce211b23eab06954392b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8828571c3b2ce211b23eab06954392b4">clearSuccessors</a> ()</td></tr>
<tr class="memdesc:a8828571c3b2ce211b23eab06954392b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all successor information.  <br /></td></tr>
<tr class="separator:a8828571c3b2ce211b23eab06954392b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac9606c4530a4329d9c13b8481f04f" id="r_a0fac9606c4530a4329d9c13b8481f04f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a0fac9606c4530a4329d9c13b8481f04f">isFunctionCall</a> () const</td></tr>
<tr class="memdesc:a0fac9606c4530a4329d9c13b8481f04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a function call?  <br /></td></tr>
<tr class="separator:a0fac9606c4530a4329d9c13b8481f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cba0e6d74ca362e15b69353c08c00a" id="r_a58cba0e6d74ca362e15b69353c08c00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a58cba0e6d74ca362e15b69353c08c00a">isFunctionCall</a> (bool flag) const</td></tr>
<tr class="separator:a58cba0e6d74ca362e15b69353c08c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3777bc1f90bc2144ea6db80122b33c8" id="r_aa3777bc1f90bc2144ea6db80122b33c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aa3777bc1f90bc2144ea6db80122b33c8">isFunctionReturn</a> () const</td></tr>
<tr class="memdesc:aa3777bc1f90bc2144ea6db80122b33c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a function return?  <br /></td></tr>
<tr class="separator:aa3777bc1f90bc2144ea6db80122b33c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2202ebb6bb1d8976ddffd83219e06e" id="r_a5f2202ebb6bb1d8976ddffd83219e06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a5f2202ebb6bb1d8976ddffd83219e06e">isFunctionReturn</a> (bool flag) const</td></tr>
<tr class="separator:a5f2202ebb6bb1d8976ddffd83219e06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ccc46880a0675733716e9f7c9b3d9" id="r_af52ccc46880a0675733716e9f7c9b3d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#af52ccc46880a0675733716e9f7c9b3d9">mayReturn</a> () const</td></tr>
<tr class="memdesc:af52ccc46880a0675733716e9f7c9b3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">May-return property.  <br /></td></tr>
<tr class="separator:af52ccc46880a0675733716e9f7c9b3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06a4f7abd42461ed12a7ab0a4f42356" id="r_aa06a4f7abd42461ed12a7ab0a4f42356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aa06a4f7abd42461ed12a7ab0a4f42356">mayReturn</a> (bool flag) const</td></tr>
<tr class="separator:aa06a4f7abd42461ed12a7ab0a4f42356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0479fb434e791cd1288c22d70c497d4a" id="r_a0479fb434e791cd1288c22d70c497d4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a0479fb434e791cd1288c22d70c497d4a">popsStack</a> () const</td></tr>
<tr class="memdesc:a0479fb434e791cd1288c22d70c497d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops stack property.  <br /></td></tr>
<tr class="separator:a0479fb434e791cd1288c22d70c497d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d163645170aa929831f5b911fb5adb6" id="r_a5d163645170aa929831f5b911fb5adb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a5d163645170aa929831f5b911fb5adb6">popsStack</a> (bool flag) const</td></tr>
<tr class="separator:a5d163645170aa929831f5b911fb5adb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e7bae56ad720a45c3b43d73fa84a45" id="r_a42e7bae56ad720a45c3b43d73fa84a45"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a42e7bae56ad720a45c3b43d73fa84a45">printableName</a> () const</td></tr>
<tr class="memdesc:a42e7bae56ad720a45c3b43d73fa84a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">A printable name for this basic block.  <br /></td></tr>
<tr class="separator:a42e7bae56ad720a45c3b43d73fa84a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:affc0f5765eae013301d327ba9f1f144e" id="r_affc0f5765eae013301d327ba9f1f144e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#affc0f5765eae013301d327ba9f1f144e">comment</a> () const</td></tr>
<tr class="memdesc:affc0f5765eae013301d327ba9f1f144e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comment.  <br /></td></tr>
<tr class="separator:affc0f5765eae013301d327ba9f1f144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8543c4058aa6c1c982cc55f40bba8f84" id="r_a8543c4058aa6c1c982cc55f40bba8f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8543c4058aa6c1c982cc55f40bba8f84">comment</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8543c4058aa6c1c982cc55f40bba8f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comment.  <br /></td></tr>
<tr class="separator:a8543c4058aa6c1c982cc55f40bba8f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8cde5ef0a6712aa8031b813dca3cb307" id="r_a8cde5ef0a6712aa8031b813dca3cb307"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8cde5ef0a6712aa8031b813dca3cb307">sourceLocation</a> () const</td></tr>
<tr class="memdesc:a8cde5ef0a6712aa8031b813dca3cb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional location in source code.  <br /></td></tr>
<tr class="separator:a8cde5ef0a6712aa8031b813dca3cb307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b53b39f27db7c32fe09e8fcd8ba8b4" id="r_a60b53b39f27db7c32fe09e8fcd8ba8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a60b53b39f27db7c32fe09e8fcd8ba8b4">sourceLocation</a> (const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp;loc)</td></tr>
<tr class="memdesc:a60b53b39f27db7c32fe09e8fcd8ba8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional location in source code.  <br /></td></tr>
<tr class="separator:a60b53b39f27db7c32fe09e8fcd8ba8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4bc0f1672e3dc41fb8856c57a2e97df7" id="r_a4bc0f1672e3dc41fb8856c57a2e97df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a4bc0f1672e3dc41fb8856c57a2e97df7">instructionIndex</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:a4bc0f1672e3dc41fb8856c57a2e97df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of an instruction.  <br /></td></tr>
<tr class="separator:a4bc0f1672e3dc41fb8856c57a2e97df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f255d1bb40d22c4131a9e9669f54508" id="r_a0f255d1bb40d22c4131a9e9669f54508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a0f255d1bb40d22c4131a9e9669f54508">instructionIndex</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a0f255d1bb40d22c4131a9e9669f54508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of an instruction.  <br /></td></tr>
<tr class="separator:a0f255d1bb40d22c4131a9e9669f54508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac010780fd90b4adb57021d5d65838f90" id="r_ac010780fd90b4adb57021d5d65838f90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Successors</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#ac010780fd90b4adb57021d5d65838f90">successors</a> () const</td></tr>
<tr class="memdesc:ac010780fd90b4adb57021d5d65838f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors.  <br /></td></tr>
<tr class="separator:ac010780fd90b4adb57021d5d65838f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24afeeb9e31007a37253cb71c05a509f" id="r_a24afeeb9e31007a37253cb71c05a509f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a24afeeb9e31007a37253cb71c05a509f">successors</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Successors</a> &amp;)</td></tr>
<tr class="memdesc:a24afeeb9e31007a37253cb71c05a509f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors.  <br /></td></tr>
<tr class="separator:a24afeeb9e31007a37253cb71c05a509f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a373d4b07069a23ddcb352ab9821e2fe4" id="r_a373d4b07069a23ddcb352ab9821e2fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a373d4b07069a23ddcb352ab9821e2fe4">insertSuccessor</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a> type=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Confidence</a> confidence=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc">ASSUMED</a>)</td></tr>
<tr class="memdesc:a373d4b07069a23ddcb352ab9821e2fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new successor.  <br /></td></tr>
<tr class="separator:a373d4b07069a23ddcb352ab9821e2fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea312296f400f41477f8ca44f486702" id="r_a3ea312296f400f41477f8ca44f486702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a3ea312296f400f41477f8ca44f486702">insertSuccessor</a> (rose_addr_t va, size_t nBits, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a> type=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Confidence</a> confidence=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc">ASSUMED</a>)</td></tr>
<tr class="memdesc:a3ea312296f400f41477f8ca44f486702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new successor.  <br /></td></tr>
<tr class="separator:a3ea312296f400f41477f8ca44f486702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae15492e36a2af8002023cab5afeaf671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae15492e36a2af8002023cab5afeaf671">Storage</a> ()</td></tr>
<tr class="memdesc:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9f66f01b292f92cdc70a18de1a7085ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9f66f01b292f92cdc70a18de1a7085ef">Storage</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae0dda357eaeee6b1974c3feae00c40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae0dda357eaeee6b1974c3feae00c40dd">operator=</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_abf3618e6d7c3a3f4bcc38ad23da3b8e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#abf3618e6d7c3a3f4bcc38ad23da3b8e9">attributeExists</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check attribute existence.  <br /></td></tr>
<tr class="separator:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a5a79e661eb48d0b9548bd0dacc63daba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a5a79e661eb48d0b9548bd0dacc63daba">eraseAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>)</td></tr>
<tr class="memdesc:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute.  <br /></td></tr>
<tr class="separator:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ab9276a22e706c4e76d65d45e715051e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ab9276a22e706c4e76d65d45e715051e0">clearAttributes</a> ()</td></tr>
<tr class="memdesc:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all attributes.  <br /></td></tr>
<tr class="separator:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9900916e61e6c0ce53e87803221962c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9900916e61e6c0ce53e87803221962c0">setAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute.  <br /></td></tr>
<tr class="separator:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a2143837f634be78ae5143e962d272fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a2143837f634be78ae5143e962d272fb8">setAttributeMaybe</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute if not already present.  <br /></td></tr>
<tr class="separator:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae39391002b59fc46db71a536cbe3e075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae39391002b59fc46db71a536cbe3e075">getAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute that is known to exist.  <br /></td></tr>
<tr class="separator:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a921b9ff8dc5cd78f751517bc22127496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a921b9ff8dc5cd78f751517bc22127496">attributeOrElse</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;dflt) const</td></tr>
<tr class="memdesc:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a specified value.  <br /></td></tr>
<tr class="separator:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a80072b861bfe95e1146934a3a53506ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a80072b861bfe95e1146934a3a53506ed">attributeOrDefault</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a default-constructed value.  <br /></td></tr>
<tr class="separator:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4277013fbe140a78e10182ca9053935c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4277013fbe140a78e10182ca9053935c">optionalAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute as an optional value.  <br /></td></tr>
<tr class="separator:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4b9e838c10d8c99838518457b35783ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4b9e838c10d8c99838518457b35783ac">nAttributes</a> () const</td></tr>
<tr class="memdesc:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <br /></td></tr>
<tr class="separator:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a1739a58e26f1dd40590fd9ee78936781"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a1739a58e26f1dd40590fd9ee78936781">attributeIds</a> () const</td></tr>
<tr class="memdesc:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ID numbers for all IDs stored in this container.  <br /></td></tr>
<tr class="separator:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a721dec9e5a95c29572286457d7a5a3d2" id="r_a721dec9e5a95c29572286457d7a5a3d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a721dec9e5a95c29572286457d7a5a3d2">instance</a> (rose_addr_t startVa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;partitioner)</td></tr>
<tr class="memdesc:a721dec9e5a95c29572286457d7a5a3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static allocating constructor.  <br /></td></tr>
<tr class="separator:a721dec9e5a95c29572286457d7a5a3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7f2ba555b56da2af6616de42a8c93350" id="r_a7f2ba555b56da2af6616de42a8c93350"><td class="memItemLeft" align="right" valign="top"><a id="a7f2ba555b56da2af6616de42a8c93350" name="a7f2ba555b56da2af6616de42a8c93350"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BasicBlock</b> (rose_addr_t startVa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="separator:a7f2ba555b56da2af6616de42a8c93350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9a231e80cbd7f85887d95e9174d2feb2" name="a9a231e80cbd7f85887d95e9174d2feb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a231e80cbd7f85887d95e9174d2feb2">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Rose::BinaryAnalysis::Partitioner2::BasicBlock::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a basic block. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00168">168</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="acd2ef3f10b2c962bebf4a18f476b2200" name="acd2ef3f10b2c962bebf4a18f476b2200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2ef3f10b2c962bebf4a18f476b2200">&#9670;&#160;</a></span>Successor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#acd2ef3f10b2c962bebf4a18f476b2200">Rose::BinaryAnalysis::Partitioner2::BasicBlock::Successor</a> =  <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSuccessor.html">BasicBlockSuccessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic block successor. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00171">171</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a9337bb89b6c23d87f28fdb059e7ef263" name="a9337bb89b6c23d87f28fdb059e7ef263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9337bb89b6c23d87f28fdb059e7ef263">&#9670;&#160;</a></span>Successors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Rose::BinaryAnalysis::Partitioner2::BasicBlock::Successors</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">BasicBlockSuccessors</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All successors in no particular order. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00174">174</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a721dec9e5a95c29572286457d7a5a3d2" name="a721dec9e5a95c29572286457d7a5a3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721dec9e5a95c29572286457d7a5a3d2">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Ptr</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::instance </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static allocating constructor. </p>
<p>The <code>startVa</code> is the starting address for this basic block. The <code>partitioner</code> is the partitioner on whose behalf this basic block is created. The partitioner is not stored in the basic block, but is only used to initialize certain data members of the block (such as its instruction dispatcher). </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00238">238</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicBlock_8h_source.html#l00247">create()</a>.</p>

</div>
</div>
<a id="ab26d112db803427e7efa8c573ea67ce4" name="ab26d112db803427e7efa8c573ea67ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26d112db803427e7efa8c573ea67ce4">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9a231e80cbd7f85887d95e9174d2feb2">Ptr</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::create </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor. </p>
<p>The <code>startVa</code> is the starting address for this basic block. The <code>partitioner</code> is the partitioner on whose behalf this basic block is created. The partitioner is not stored in the basic block, but is only used to initialize certain data members of the block (such as its instruction dispatcher). </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00247">247</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00238">instance()</a>.</p>

</div>
</div>
<a id="a0d02dc5b7cca7811f4e9df0ccd7f8f05" name="a0d02dc5b7cca7811f4e9df0ccd7f8f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d02dc5b7cca7811f4e9df0ccd7f8f05">&#9670;&#160;</a></span>clearCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::clearCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all cached data. </p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00258">258</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="aeabc20b98046fe33c35d40780e0478a2" name="aeabc20b98046fe33c35d40780e0478a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabc20b98046fe33c35d40780e0478a2">&#9670;&#160;</a></span>isFrozen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::BasicBlock::isFrozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if basic block is read-only. </p>
<p>Returns true if read-only, false otherwise.</p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00272">272</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="affc0f5765eae013301d327ba9f1f144e" name="affc0f5765eae013301d327ba9f1f144e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc0f5765eae013301d327ba9f1f144e">&#9670;&#160;</a></span>comment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::comment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comment. </p>
<p>A basic block may have a multi-line, plain-text comment.</p>
<p>Thread safety: This method is not thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00284">284</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a8543c4058aa6c1c982cc55f40bba8f84" name="a8543c4058aa6c1c982cc55f40bba8f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8543c4058aa6c1c982cc55f40bba8f84">&#9670;&#160;</a></span>comment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comment. </p>
<p>A basic block may have a multi-line, plain-text comment.</p>
<p>Thread safety: This method is not thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00285">285</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a8cde5ef0a6712aa8031b813dca3cb307" name="a8cde5ef0a6712aa8031b813dca3cb307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cde5ef0a6712aa8031b813dca3cb307">&#9670;&#160;</a></span>sourceLocation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::sourceLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional location in source code. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00291">291</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a60b53b39f27db7c32fe09e8fcd8ba8b4" name="a60b53b39f27db7c32fe09e8fcd8ba8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b53b39f27db7c32fe09e8fcd8ba8b4">&#9670;&#160;</a></span>sourceLocation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::sourceLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional location in source code. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00292">292</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a8722459585ec6491c5802eeb016bd980" name="a8722459585ec6491c5802eeb016bd980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8722459585ec6491c5802eeb016bd980">&#9670;&#160;</a></span>address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rose_addr_t Rose::BinaryAnalysis::Partitioner2::BasicBlock::address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address for a basic block. </p>
<p>A basic block's address is also the starting address of its initial instruction. The initial instruction need not be the instruction with the lowest address, but rather the instruction which is always executed first by the basic block.</p>
<p>Thread safety: This method is thread-safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00307">307</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a224098d4b0f51356b78d2fb5c5a90abc" name="a224098d4b0f51356b78d2fb5c5a90abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224098d4b0f51356b78d2fb5c5a90abc">&#9670;&#160;</a></span>insnAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::insnAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all instruction addresses. </p>
<p>The return value is the set of all virtual addresses for both instruction starting addresses and the internal addresses of instructions.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a63596073bbdb19c172fe367f17d53ad0" name="a63596073bbdb19c172fe367f17d53ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63596073bbdb19c172fe367f17d53ad0">&#9670;&#160;</a></span>fallthroughVa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rose_addr_t Rose::BinaryAnalysis::Partitioner2::BasicBlock::fallthroughVa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address after the end of the final instruction. </p>
<p>This is the address that immediately follows the final byte of the instruction that is executed last by the basic block. The final executed instruction need not be the instruction with the highest address.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="ab57eefdafbd29acec40991d7ed0af2f6" name="ab57eefdafbd29acec40991d7ed0af2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57eefdafbd29acec40991d7ed0af2f6">&#9670;&#160;</a></span>nInstructions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::BasicBlock::nInstructions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of instructions in this block. </p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00331">331</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a4ae472645e65da98340f932233c68dda" name="a4ae472645e65da98340f932233c68dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae472645e65da98340f932233c68dda">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::BasicBlock::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this basic block has no instructions. </p>
<p>A basic block is always expected to have at least one instruction whose address is the same as the basic block's address, and this method returns true if that instruction has not yet been discovered and appended to this basic block. A basic block may also own data blocks, but they are not counted by this method.</p>
<p>Thread safety: This method is thread-safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00343">343</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a2a9652c7e4c7e35a17631bba9dd34699" name="a2a9652c7e4c7e35a17631bba9dd34699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9652c7e4c7e35a17631bba9dd34699">&#9670;&#160;</a></span>instructionExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Partitioner2::BasicBlock::instructionExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if this basic block contains an instruction at a specific address. </p>
<p>Returns a non-null instruction pointer if this basic block contains an instruction that starts at the specified address, returns null otherwise.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a6a477e20fd7aa8bfbfc6681cce2ac12a" name="a6a477e20fd7aa8bfbfc6681cce2ac12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a477e20fd7aa8bfbfc6681cce2ac12a">&#9670;&#160;</a></span>instructionExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; Rose::BinaryAnalysis::Partitioner2::BasicBlock::instructionExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this basic block contains the specified instruction. </p>
<p>If the basic block contains the instruction then this method returns the index of this instruction within the block, otherwise it returns nothing.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a4bc0f1672e3dc41fb8856c57a2e97df7" name="a4bc0f1672e3dc41fb8856c57a2e97df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc0f1672e3dc41fb8856c57a2e97df7">&#9670;&#160;</a></span>instructionIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; Rose::BinaryAnalysis::Partitioner2::BasicBlock::instructionIndex </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of an instruction. </p>
<p>Returns the position (index) of the specified instruction within this basic block. If the instruction doesn't exist then returns nothing. </p>

</div>
</div>
<a id="a0f255d1bb40d22c4131a9e9669f54508" name="a0f255d1bb40d22c4131a9e9669f54508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f255d1bb40d22c4131a9e9669f54508">&#9670;&#160;</a></span>instructionIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; Rose::BinaryAnalysis::Partitioner2::BasicBlock::instructionIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of an instruction. </p>
<p>Returns the position (index) of the specified instruction within this basic block. If the instruction doesn't exist then returns nothing. </p>

</div>
</div>
<a id="ad96c4962c3081ed175270f9582b434ab" name="ad96c4962c3081ed175270f9582b434ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96c4962c3081ed175270f9582b434ab">&#9670;&#160;</a></span>instructions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::instructions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the instructions for this block. </p>
<p>Instructions are returned in the order they would be executed (i.e., the order they were added to the block). Blocks in the undiscovered and not-existing states never have instructions (they return an empty vector); blocks in the incomplete and complete states always return at least one instruction.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00381">381</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a9b21ad4f5ec7c1a8a711a1c2e9215aa0" name="a9b21ad4f5ec7c1a8a711a1c2e9215aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b21ad4f5ec7c1a8a711a1c2e9215aa0">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an instruction to a basic block. </p>
<p>If this is the first instruction then the instruction address must match the block's starting address, otherwise the new instruction must not already be a member of this basic block. No other attempt is made to verify the integrety of the intra-block control flow (i.e., we do not check that the previous instruction had a single successor which is the newly appended instruction). It is an error to attempt to append to a frozen block.</p>
<p>The partitioner argument is only used for adjusting the instruction semantics framework for the block.</p>
<p>When adding multiple instructions:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BasicBlock::Ptr</a> bb = protoBlock-&gt;instance(startingVa, partitioner)</div>
<div class="line">    -&gt;append(partitioner, insn1)-&gt;append(parititoner, insn2)-&gt;append(partitioner, insn3);</div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; BasicBlock &gt;</a></div></div>
</div><!-- fragment --><p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="af5a60139976768f55084989706caa54c" name="af5a60139976768f55084989706caa54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a60139976768f55084989706caa54c">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo the latest append. </p>
<p>An append can be undone so that instructions can be appended, the result checked, and then undone. Only one level of undo is available.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ab39ef62d894b0a950dd73b997a6ddcf4" name="ab39ef62d894b0a950dd73b997a6ddcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39ef62d894b0a950dd73b997a6ddcf4">&#9670;&#160;</a></span>explicitConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::BasicBlock::explicitConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of explicit constants. </p>
<p>Traverses all the instructions of this basic block and returns all explicit constants found in the instruction operands. Some architectures call these "immediate values".</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a466722f645e9372f1909c22825f4d663" name="a466722f645e9372f1909c22825f4d663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466722f645e9372f1909c22825f4d663">&#9670;&#160;</a></span>nDataBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::BasicBlock::nDataBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of data blocks owned. </p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="aff173598e2f2d95457418b006ae6ee7f" name="aff173598e2f2d95457418b006ae6ee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff173598e2f2d95457418b006ae6ee7f">&#9670;&#160;</a></span>dataAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::dataAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses that are part of static data. </p>
<p>Returns all addresses that are part of static data.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="ad7fdac38b5832b7b1d19b298ffec5ebe" name="ad7fdac38b5832b7b1d19b298ffec5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fdac38b5832b7b1d19b298ffec5ebe">&#9670;&#160;</a></span>dataBlockExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::dataBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if this basic block contains the specified data block or equivalent data block. </p>
<p>If the basic block owns the specified data block or an equivalent data block then this method returns a pointer to the existing data block, otherwise it returns the null pointer.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a82ae26a8fc2001990a8c1f933b13a249" name="a82ae26a8fc2001990a8c1f933b13a249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ae26a8fc2001990a8c1f933b13a249">&#9670;&#160;</a></span>insertDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::BasicBlock::insertDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this basic block own the specified data block or equivalent data block. </p>
<p>If the specified data block is not yet owned by this basic block and the basic block contains no equivalent data block, then the specified data block is added as a member of this basic block and this method returns true. Otherwise, this basic block already contains the specified data block or an equivalent data block and the method returns false. A data block cannot be inserted when this basic block is frozen.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a7e053d29e968c1e3f6e017f1333fd521" name="a7e053d29e968c1e3f6e017f1333fd521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e053d29e968c1e3f6e017f1333fd521">&#9670;&#160;</a></span>eraseDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::eraseDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove specified or equivalent data block from this basic block. </p>
<p>If this basic block is in a detached state (i.e., not part of the CFG/AUM) then the specified data block or equivalent data block is removed from this basic block. Returns the data block that was erased, or null if none was erased.</p>
<p>It is an error to invoke this method on basic block that is attached to the CFG/AUM, for which <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#aeabc20b98046fe33c35d40780e0478a2">isFrozen</a> returns true. This method is a no-op if the specified data block is a null pointer. </p>

</div>
</div>
<a id="a14ed6e8dcad61c0721e296ee6700d6c8" name="a14ed6e8dcad61c0721e296ee6700d6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ed6e8dcad61c0721e296ee6700d6c8">&#9670;&#160;</a></span>dataBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::dataBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data blocks owned. </p>
<p>Returned vector is sorted according to data block starting address.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00467">467</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a032e89c52cc51996592155c9dbfa3499" name="a032e89c52cc51996592155c9dbfa3499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032e89c52cc51996592155c9dbfa3499">&#9670;&#160;</a></span>semantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html">BasicBlockSemantics</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::semantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about semantics. </p>
<p>Although most of the returned information can also be obtained by calling individual accessor functions, this function returns all the information as a single atomic operation.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a8b365a03211eaee8481bfa81c95d10a2" name="a8b365a03211eaee8481bfa81c95d10a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b365a03211eaee8481bfa81c95d10a2">&#9670;&#160;</a></span>dropSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::dropSemantics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops semantic information. </p>
<p>This function deletes semantic information for the basic block and can be used to save space. The partitioner can be configured to drop semantic information when a basic block is attached to the CFG. The partitioner is used only for adjusting the instruction semantics framework for the block.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="aeac7730dde2c0892743facfac8e7f471" name="aeac7730dde2c0892743facfac8e7f471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac7730dde2c0892743facfac8e7f471">&#9670;&#160;</a></span>undropSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockSemantics.html">BasicBlockSemantics</a> Rose::BinaryAnalysis::Partitioner2::BasicBlock::undropSemantics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undrop semantics. </p>
<p>This is the inverse of dropSemantics. If semantics have been dropped then they will be recalculated if possible. If semantics have not been dropped then nothing happens. The partitioner is used only for adjusting the instruction semantics framework for the block.</p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="ac010780fd90b4adb57021d5d65838f90" name="ac010780fd90b4adb57021d5d65838f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010780fd90b4adb57021d5d65838f90">&#9670;&#160;</a></span>successors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Successors</a> &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::successors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors. </p>
<p>The control flow successors indicate how control leaves the end of a basic block. These successors should be the most basic level of information; e.g., a basic block that results in an unconditional function call should not have an edge representing the return from that call. The successors are typically computed in the partitioner and cached in the basic block.</p>
<p>Thread safety: The accessor is not thread safe since it returns a reference; The mutator is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00516">516</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a24afeeb9e31007a37253cb71c05a509f" name="a24afeeb9e31007a37253cb71c05a509f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24afeeb9e31007a37253cb71c05a509f">&#9670;&#160;</a></span>successors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::successors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a9337bb89b6c23d87f28fdb059e7ef263">Successors</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control flow successors. </p>
<p>The control flow successors indicate how control leaves the end of a basic block. These successors should be the most basic level of information; e.g., a basic block that results in an unconditional function call should not have an edge representing the return from that call. The successors are typically computed in the partitioner and cached in the basic block.</p>
<p>Thread safety: The accessor is not thread safe since it returns a reference; The mutator is thread safe. </p>

</div>
</div>
<a id="a2c654cd9ae99fc94b4ed6aef533bde1e" name="a2c654cd9ae99fc94b4ed6aef533bde1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c654cd9ae99fc94b4ed6aef533bde1e">&#9670;&#160;</a></span>ghostSuccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; std::set&lt; rose_addr_t &gt; &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::ghostSuccessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ghost successors. </p>
<p>A ghost successor is a control flow successor that is present in an individual instruction, but not present in the broader scope of a basic block. Ghost successors typically occur when a conditional branch instruction in the middle of a basic block has an opaque predicate, causing it to become an unconditional branch. The return value is the union of the ghost successors for each instruction in the basic block, and is updated whenever the set of instructions in the basic block changes. The ghost successors are typically computed in the partitioner and cached in the basic block.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00530">530</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a373d4b07069a23ddcb352ab9821e2fe4" name="a373d4b07069a23ddcb352ab9821e2fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373d4b07069a23ddcb352ab9821e2fe4">&#9670;&#160;</a></span>insertSuccessor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::insertSuccessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Confidence</a>&#160;</td>
          <td class="paramname"><em>confidence</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc">ASSUMED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new successor. </p>
<p>Inserts a new successor into the cached successor list. If the successor is already present then it is not added again (the comparison uses structural equivalance). Both the expression and the edge type are significant when comparing. For instance, it is permissible to have a function call edge and a call-return edge that both point to the fall-through address.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a3ea312296f400f41477f8ca44f486702" name="a3ea312296f400f41477f8ca44f486702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea312296f400f41477f8ca44f486702">&#9670;&#160;</a></span>insertSuccessor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::insertSuccessor </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3">Confidence</a>&#160;</td>
          <td class="paramname"><em>confidence</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8fe96c83c4b19e6723fc7e63c05643d3a4c7223eb439ddb4271ace85d291f01cc">ASSUMED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new successor. </p>
<p>Inserts a new successor into the cached successor list. If the successor is already present then it is not added again (the comparison uses structural equivalance). Both the expression and the edge type are significant when comparing. For instance, it is permissible to have a function call edge and a call-return edge that both point to the fall-through address.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a8828571c3b2ce211b23eab06954392b4" name="a8828571c3b2ce211b23eab06954392b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8828571c3b2ce211b23eab06954392b4">&#9670;&#160;</a></span>clearSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::clearSuccessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all successor information. </p>
<p>Thread safety: This method is thread safe. </p>

</div>
</div>
<a id="a0fac9606c4530a4329d9c13b8481f04f" name="a0fac9606c4530a4329d9c13b8481f04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fac9606c4530a4329d9c13b8481f04f">&#9670;&#160;</a></span>isFunctionCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::isFunctionCall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a function call? </p>
<p>If the basic block appears to be a function call then this property is set to true. A block is a function call if it appears to store a return value on the stack and then unconditionally branch to a function. It need not end with a specific CALL instruction, nor are all CALL instructions actually function calls. This property is typically computed in the partitioner and cached in the basic block.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00564">564</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a58cba0e6d74ca362e15b69353c08c00a" name="a58cba0e6d74ca362e15b69353c08c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cba0e6d74ca362e15b69353c08c00a">&#9670;&#160;</a></span>isFunctionCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::isFunctionCall </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00565">565</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="aa3777bc1f90bc2144ea6db80122b33c8" name="aa3777bc1f90bc2144ea6db80122b33c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3777bc1f90bc2144ea6db80122b33c8">&#9670;&#160;</a></span>isFunctionReturn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::isFunctionReturn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a function return? </p>
<p>This property indicates whether the basic block appears to be a return from a function call. A block is a return from a function call if, after the block is executed, the instruction pointer contains the value stored in memory one past the top of the stack.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00574">574</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a5f2202ebb6bb1d8976ddffd83219e06e" name="a5f2202ebb6bb1d8976ddffd83219e06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2202ebb6bb1d8976ddffd83219e06e">&#9670;&#160;</a></span>isFunctionReturn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::isFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00575">575</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="af52ccc46880a0675733716e9f7c9b3d9" name="af52ccc46880a0675733716e9f7c9b3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52ccc46880a0675733716e9f7c9b3d9">&#9670;&#160;</a></span>mayReturn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::mayReturn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May-return property. </p>
<p>This property holds a Boolean that indicates whether a function-return basic block is reachable from this basic block. In other words, if control enters this basic block, might the top stack frame eventually be popped?</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00583">583</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="aa06a4f7abd42461ed12a7ab0a4f42356" name="aa06a4f7abd42461ed12a7ab0a4f42356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06a4f7abd42461ed12a7ab0a4f42356">&#9670;&#160;</a></span>mayReturn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::mayReturn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00584">584</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a0479fb434e791cd1288c22d70c497d4a" name="a0479fb434e791cd1288c22d70c497d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0479fb434e791cd1288c22d70c497d4a">&#9670;&#160;</a></span>popsStack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp; Rose::BinaryAnalysis::Partitioner2::BasicBlock::popsStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops stack property. </p>
<p>This property holds a Boolean that indicates whether this basic block is known to have a net stack popping effect.</p>
<p>Thread safety: This method is not thread safe since it returns a reference. </p>

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00591">591</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a5d163645170aa929831f5b911fb5adb6" name="a5d163645170aa929831f5b911fb5adb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d163645170aa929831f5b911fb5adb6">&#9670;&#160;</a></span>popsStack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::BasicBlock::popsStack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BasicBlock_8h_source.html#l00592">592</a> of file <a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a>.</p>

</div>
</div>
<a id="a42e7bae56ad720a45c3b43d73fa84a45" name="a42e7bae56ad720a45c3b43d73fa84a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e7bae56ad720a45c3b43d73fa84a45">&#9670;&#160;</a></span>printableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::BasicBlock::printableName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A printable name for this basic block. </p>
<p>Returns a string like 'basic block 0x10001234'.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BasicBlock_8h_source.html">BasicBlock.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
