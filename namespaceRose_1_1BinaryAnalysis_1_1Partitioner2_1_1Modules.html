<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::Modules Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html">Modules</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::Modules Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Miscellaneous supporting functions for disassembly. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1AddGhostSuccessors.html">AddGhostSuccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow basic block ghost edges.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1AddGhostSuccessors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1BasicBlockSizeLimiter.html">BasicBlockSizeLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to limit basic block size.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1BasicBlockSizeLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1CfgGraphVizDumper.html">CfgGraphVizDumper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a> file for the CFG at a certain time.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1CfgGraphVizDumper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1Debugger.html">Debugger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient place to attach a debugger.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1Debugger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1HexDumper.html">HexDumper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a hexdump at a certain time.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1HexDumper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1InstructionLister.html">InstructionLister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List some instructions at a certain time.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1InstructionLister.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1IpRewriter.html">IpRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to rewrite CFG edges.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1IpRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1MatchThunk.html">MatchThunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match thunk.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1MatchThunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1PreventDiscontiguousBlocks.html">PreventDiscontiguousBlocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent discontiguous basic blocks.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules_1_1PreventDiscontiguousBlocks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7d9a71347c5b75a83349a22b674a8500" id="r_a7d9a71347c5b75a83349a22b674a8500"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a7d9a71347c5b75a83349a22b674a8500">canonicalFunctionName</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a7d9a71347c5b75a83349a22b674a8500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert system function names to ROSE canonical form.  <br /></td></tr>
<tr class="separator:a7d9a71347c5b75a83349a22b674a8500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726b7756398c1350344d320d232ef40c" id="r_a726b7756398c1350344d320d232ef40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a726b7756398c1350344d320d232ef40c">demangleFunctionNames</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a726b7756398c1350344d320d232ef40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle all function names.  <br /></td></tr>
<tr class="separator:a726b7756398c1350344d320d232ef40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716fcec0bda669add631a73df077cad6" id="r_a716fcec0bda669add631a73df077cad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a716fcec0bda669add631a73df077cad6">deExecuteZeros</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;map, size_t threshold, size_t leaveAtFront=16, size_t leaveAtBack=1)</td></tr>
<tr class="memdesc:a716fcec0bda669add631a73df077cad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove execute permissions for zeros.  <br /></td></tr>
<tr class="separator:a716fcec0bda669add631a73df077cad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018d1ff978ae35d522f6755e6875a882" id="r_a018d1ff978ae35d522f6755e6875a882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a018d1ff978ae35d522f6755e6875a882">nameStrings</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:a018d1ff978ae35d522f6755e6875a882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give labels to string constants.  <br /></td></tr>
<tr class="separator:a018d1ff978ae35d522f6755e6875a882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216ea55f0a08b56999f1b37fb710f5eb" id="r_a216ea55f0a08b56999f1b37fb710f5eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a216ea55f0a08b56999f1b37fb710f5eb">nameConstants</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;)</td></tr>
<tr class="memdesc:a216ea55f0a08b56999f1b37fb710f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives names to constants in instructions.  <br /></td></tr>
<tr class="separator:a216ea55f0a08b56999f1b37fb710f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c50385c403673e021ceb9f606b66c" id="r_a4f9c50385c403673e021ceb9f606b66c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a4f9c50385c403673e021ceb9f606b66c">findNoopFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a4f9c50385c403673e021ceb9f606b66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find functions that are no-ops.  <br /></td></tr>
<tr class="separator:a4f9c50385c403673e021ceb9f606b66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac948044c7adfb0bfc28b576dc04a1c9f" id="r_ac948044c7adfb0bfc28b576dc04a1c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#ac948044c7adfb0bfc28b576dc04a1c9f">nameNoopFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:ac948044c7adfb0bfc28b576dc04a1c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give names to functions that are no-ops.  <br /></td></tr>
<tr class="separator:ac948044c7adfb0bfc28b576dc04a1c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5dca9be2986caef8c5db21be5547a3" id="r_a9c5dca9be2986caef8c5db21be5547a3"><td class="memItemLeft" align="right" valign="top">boost::logic::tribool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a9c5dca9be2986caef8c5db21be5547a3">isStackBasedReturn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a9c5dca9be2986caef8c5db21be5547a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if basic block is a stack-based function return.  <br /></td></tr>
<tr class="separator:a9c5dca9be2986caef8c5db21be5547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e300db123ae767a8384633e3c43e8aa" id="r_a3e300db123ae767a8384633e3c43e8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a3e300db123ae767a8384633e3c43e8aa">buildBasicBlockAst</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;)</td></tr>
<tr class="memdesc:a3e300db123ae767a8384633e3c43e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for basic block.  <br /></td></tr>
<tr class="separator:a3e300db123ae767a8384633e3c43e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af341d998dfb013ea8cedf3c631ef1b8d" id="r_af341d998dfb013ea8cedf3c631ef1b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af341d998dfb013ea8cedf3c631ef1b8d">buildDataBlockAst</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;)</td></tr>
<tr class="memdesc:af341d998dfb013ea8cedf3c631ef1b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for data block.  <br /></td></tr>
<tr class="separator:af341d998dfb013ea8cedf3c631ef1b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8835fdabb5e5e7b92fc35a13d7d9c091" id="r_a8835fdabb5e5e7b92fc35a13d7d9c091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a8835fdabb5e5e7b92fc35a13d7d9c091">buildFunctionAst</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;)</td></tr>
<tr class="memdesc:a8835fdabb5e5e7b92fc35a13d7d9c091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for function.  <br /></td></tr>
<tr class="separator:a8835fdabb5e5e7b92fc35a13d7d9c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e8d34cfbb93587b5502fbd43b06bc" id="r_a470e8d34cfbb93587b5502fbd43b06bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a470e8d34cfbb93587b5502fbd43b06bc">buildGlobalBlockAst</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;)</td></tr>
<tr class="memdesc:a470e8d34cfbb93587b5502fbd43b06bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the global block <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a470e8d34cfbb93587b5502fbd43b06bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af774642c835f58878dfe39a06c23184c" id="r_af774642c835f58878dfe39a06c23184c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af774642c835f58878dfe39a06c23184c">buildAst</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;settings=<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html#a733c7992fcec425428cb0bccbfb119d5">AstConstructionSettings::strict</a>())</td></tr>
<tr class="memdesc:af774642c835f58878dfe39a06c23184c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from the CFG.  <br /></td></tr>
<tr class="separator:af774642c835f58878dfe39a06c23184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a598dfc9c915dff355935902fbedd6" id="r_aa6a598dfc9c915dff355935902fbedd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#aa6a598dfc9c915dff355935902fbedd6">fixupAstPointers</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL)</td></tr>
<tr class="memdesc:aa6a598dfc9c915dff355935902fbedd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes pointers in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:aa6a598dfc9c915dff355935902fbedd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20837cd53e957b3b3204612a4637f451" id="r_a20837cd53e957b3b3204612a4637f451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a20837cd53e957b3b3204612a4637f451">fixupAstCallingConventions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>
<tr class="memdesc:a20837cd53e957b3b3204612a4637f451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes calling convention results.  <br /></td></tr>
<tr class="separator:a20837cd53e957b3b3204612a4637f451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1806f4456a786025363aea6333713598" id="r_a1806f4456a786025363aea6333713598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a1806f4456a786025363aea6333713598">labelSymbolAddresses</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="memdesc:a1806f4456a786025363aea6333713598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give labels to addresses that are symbols.  <br /></td></tr>
<tr class="separator:a1806f4456a786025363aea6333713598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c" id="r_a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c">labelSymbolAddresses</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give labels to addresses that are symbols.  <br /></td></tr>
<tr class="separator:a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4f32b56bd5e211aa5b275bd0965f413b" id="r_a4f32b56bd5e211aa5b275bd0965f413b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a4f32b56bd5e211aa5b275bd0965f413b">findSymbolFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="memdesc:a4f32b56bd5e211aa5b275bd0965f413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions for which symbols exist.  <br /></td></tr>
<tr class="separator:a4f32b56bd5e211aa5b275bd0965f413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29888a836f80e73fe3a09e418e1de83d" id="r_a29888a836f80e73fe3a09e418e1de83d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a29888a836f80e73fe3a09e418e1de83d">findSymbolFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a29888a836f80e73fe3a09e418e1de83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions for which symbols exist.  <br /></td></tr>
<tr class="separator:a29888a836f80e73fe3a09e418e1de83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dcb59f6b12463b57f45ec427a8a206" id="r_ab7dcb59f6b12463b57f45ec427a8a206"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#ab7dcb59f6b12463b57f45ec427a8a206">findSymbolFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *, std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ab7dcb59f6b12463b57f45ec427a8a206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions for which symbols exist.  <br /></td></tr>
<tr class="separator:ab7dcb59f6b12463b57f45ec427a8a206"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7d9a71347c5b75a83349a22b674a8500" name="a7d9a71347c5b75a83349a22b674a8500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9a71347c5b75a83349a22b674a8500">&#9670;&#160;</a></span>canonicalFunctionName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Modules::canonicalFunctionName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert system function names to ROSE canonical form. </p>
<p>ROSE always stores library function names as "function@library" with the reasoning that the function name is typically more important than the library name and storing them this way leads to better presentation in sorted lists. This function recognizes and converts the form "library.dll:function" and will convert "KERNEL32.dll:EncodePointer" to "EncodePointer@KERNEL32.dll"</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe.html#a2a64a7aeaa3ffe9eb9a7820e6ca81758" title="Convert function name to system representation.">ModulesPe::systemFunctionName</a> and possibly other OS-specific formatters. </dd></dl>

</div>
</div>
<a id="a726b7756398c1350344d320d232ef40c" name="a726b7756398c1350344d320d232ef40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726b7756398c1350344d320d232ef40c">&#9670;&#160;</a></span>demangleFunctionNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::demangleFunctionNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangle all function names. </p>
<p>Run the name demangler on all functions that have a non-empty name and no demangled name. Assign the result as each function's demangled name if it's different than the true name. </p>

</div>
</div>
<a id="a716fcec0bda669add631a73df077cad6" name="a716fcec0bda669add631a73df077cad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716fcec0bda669add631a73df077cad6">&#9670;&#160;</a></span>deExecuteZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Modules::deExecuteZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leaveAtFront</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leaveAtBack</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove execute permissions for zeros. </p>
<p>Scans memory to find consecutive zero bytes and removes execute permission from them. Only occurrences of at least <code>threshold</code> consecutive zeros are found, and only a subset of those occurrences have their execute permission removed. Namely, whenever an interval of addresses is found that contain all zeros, the interval is narrowed by eliminating the first few bytes (<code>leaveAtFront</code>) and last few bytes (<code>leaveAtBack</code>), and execute permissions are removed for this narrowed interval.</p>
<p>Returns the set of addresses whose access permissions were changed, which may be slightly fewer addresses than which contain zeros due to the <code>leaveAtFront</code> and <code>leaveAtBack</code>. The set of found zeros can be recovered from the return value by iterating over the intervals in the set and inserting the <code>leaveAtFront</code> and <code>leaveAtBack</code> addresses at each end of each interval.</p>
<p>If <code>threshold</code> is zero or the <code>leaveAtFront</code> and <code>leaveAtBack</code> sum to at least <code>threshold</code> then nothing happens. </p>

</div>
</div>
<a id="a1806f4456a786025363aea6333713598" name="a1806f4456a786025363aea6333713598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1806f4456a786025363aea6333713598">&#9670;&#160;</a></span>labelSymbolAddresses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::labelSymbolAddresses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give labels to addresses that are symbols. </p>
<p>Scans the specified binary container and labels those virtual addresses that correspond to symbols. This function does not create any functions in the partitioner, it only gives names to certain addresses. If the same address is labeled more than once by symbols with different names then one name is chosen arbitrarily. </p>

</div>
</div>
<a id="a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c" name="a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcd01ea2d0cd35e03b7cc7ccbcaeb1c">&#9670;&#160;</a></span>labelSymbolAddresses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::labelSymbolAddresses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give labels to addresses that are symbols. </p>
<p>Scans the specified binary container and labels those virtual addresses that correspond to symbols. This function does not create any functions in the partitioner, it only gives names to certain addresses. If the same address is labeled more than once by symbols with different names then one name is chosen arbitrarily. </p>

</div>
</div>
<a id="a018d1ff978ae35d522f6755e6875a882" name="a018d1ff978ae35d522f6755e6875a882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018d1ff978ae35d522f6755e6875a882">&#9670;&#160;</a></span>nameStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::nameStrings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give labels to string constants. </p>
<p>Finds integer constants that are within the specified range of values and are the address if a C-style NUL-terminated ASCII string and adds a comment to the constant (if it had none previously) to describe the string. All instructions that are attached to the CFG/AUM are processed. The instructions are modified by attaching the comment, but the comments are not added to the partitioners address name map. </p>

</div>
</div>
<a id="a4f32b56bd5e211aa5b275bd0965f413b" name="a4f32b56bd5e211aa5b275bd0965f413b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f32b56bd5e211aa5b275bd0965f413b">&#9670;&#160;</a></span>findSymbolFunctions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Modules::findSymbolFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions for which symbols exist. </p>
<p>Scans the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find symbols that point to functions and makes a function at each such address. A function is made only if an instruction can be disassembled at the address. The return value is a sorted list of unique functions. </p>

</div>
</div>
<a id="a29888a836f80e73fe3a09e418e1de83d" name="a29888a836f80e73fe3a09e418e1de83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29888a836f80e73fe3a09e418e1de83d">&#9670;&#160;</a></span>findSymbolFunctions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Modules::findSymbolFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions for which symbols exist. </p>
<p>Scans the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find symbols that point to functions and makes a function at each such address. A function is made only if an instruction can be disassembled at the address. The return value is a sorted list of unique functions. </p>

</div>
</div>
<a id="ab7dcb59f6b12463b57f45ec427a8a206" name="ab7dcb59f6b12463b57f45ec427a8a206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dcb59f6b12463b57f45ec427a8a206">&#9670;&#160;</a></span>findSymbolFunctions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Modules::findSymbolFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions for which symbols exist. </p>
<p>Scans the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find symbols that point to functions and makes a function at each such address. A function is made only if an instruction can be disassembled at the address. The return value is a sorted list of unique functions. </p>

</div>
</div>
<a id="a216ea55f0a08b56999f1b37fb710f5eb" name="a216ea55f0a08b56999f1b37fb710f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216ea55f0a08b56999f1b37fb710f5eb">&#9670;&#160;</a></span>nameConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::nameConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives names to constants in instructions. </p>
<p>Scans the entire list of attached instructions and give each constant integer expression a name if the value of the expression happens to be an address that has a name and lies within the interval. </p>

</div>
</div>
<a id="a4f9c50385c403673e021ceb9f606b66c" name="a4f9c50385c403673e021ceb9f606b66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9c50385c403673e021ceb9f606b66c">&#9670;&#160;</a></span>findNoopFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Modules::findNoopFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find functions that are no-ops. </p>
<p>Finds functions that are no-ops and returns them in ascending order of entry addresses. </p>

</div>
</div>
<a id="ac948044c7adfb0bfc28b576dc04a1c9f" name="ac948044c7adfb0bfc28b576dc04a1c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac948044c7adfb0bfc28b576dc04a1c9f">&#9670;&#160;</a></span>nameNoopFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::nameNoopFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give names to functions that are no-ops. </p>
<p>Scans the list of attached functions to find those whose only action is to return to the caller (via <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a4f9c50385c403673e021ceb9f606b66c">findNoopFunctions</a>) and gives names to those that don't have names. The names are of the form "noop_ADDR() -&gt; void" where ADDR is the hexadecimal entry address. The C++ trailing return type syntax is used so that functions can be easily sorted according to their names. </p>

</div>
</div>
<a id="a9c5dca9be2986caef8c5db21be5547a3" name="a9c5dca9be2986caef8c5db21be5547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5dca9be2986caef8c5db21be5547a3">&#9670;&#160;</a></span>isStackBasedReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::logic::tribool Rose::BinaryAnalysis::Partitioner2::Modules::isStackBasedReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if basic block is a stack-based function return. </p>
<p>Determines whether the specified basic block is a function return by examining the semantics of the basic block. If at the end of the basic block, the instruction pointer has the same value as the value stored on-past-the-end of the stack it means that the basic block popped the next execution address from the top of the stack. Returns indeterminate if this property could not be determined, such as is the case when semantics are not enabled. </p>

</div>
</div>
<a id="a3e300db123ae767a8384633e3c43e8aa" name="a3e300db123ae767a8384633e3c43e8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e300db123ae767a8384633e3c43e8aa">&#9670;&#160;</a></span>buildBasicBlockAst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Modules::buildBasicBlockAst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for basic block. </p>
<p>Builds and returns an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for the specified basic block. The basic block must not be a null pointer, but it need not be in the CFG. </p>

</div>
</div>
<a id="af341d998dfb013ea8cedf3c631ef1b8d" name="af341d998dfb013ea8cedf3c631ef1b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af341d998dfb013ea8cedf3c631ef1b8d">&#9670;&#160;</a></span>buildDataBlockAst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Modules::buildDataBlockAst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for data block. </p>
<p>Builds and returns an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for the specified data block. The data block must not be a null pointer, but it need not be in the CFG. </p>

</div>
</div>
<a id="a8835fdabb5e5e7b92fc35a13d7d9c091" name="a8835fdabb5e5e7b92fc35a13d7d9c091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8835fdabb5e5e7b92fc35a13d7d9c091">&#9670;&#160;</a></span>buildFunctionAst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> * Rose::BinaryAnalysis::Partitioner2::Modules::buildFunctionAst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for function. </p>
<p>Builds and returns an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> for the specified function. The function must not be a null pointer, but it need not be in the CFG. The function will have children created only for its basic blocks that exist in the CFG (otherwise the partitioner doesn't know about them). </p>

</div>
</div>
<a id="a470e8d34cfbb93587b5502fbd43b06bc" name="a470e8d34cfbb93587b5502fbd43b06bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470e8d34cfbb93587b5502fbd43b06bc">&#9670;&#160;</a></span>buildGlobalBlockAst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Modules::buildGlobalBlockAst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the global block <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>A global block's children are all the functions contained in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, which in turn contain <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> IR nodes for the basic blocks, which in turn contain instructions. </p>

</div>
</div>
<a id="af774642c835f58878dfe39a06c23184c" name="af774642c835f58878dfe39a06c23184c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af774642c835f58878dfe39a06c23184c">&#9670;&#160;</a></span>buildAst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Modules::buildAst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname"><em>interp</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html#a733c7992fcec425428cb0bccbfb119d5">AstConstructionSettings::strict</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from the CFG. </p>
<p>Builds an abstract syntax tree from the control flow graph. The returned <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> will have child functions; each function (<a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a>) will have child basic blocks; each basic block (<a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>) will have child instructions.</p>
<p>This function is the same as <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#a470e8d34cfbb93587b5502fbd43b06bc">buildGlobalBlockAst</a> except it also calls various <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> fixup functions. Providing an interpretation allows more fixups to occur. Also, if <code>interp</code> is non-null then the returned global block is attached to the interpretation in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> (any previous global block is detached but not destroyed). </p>

</div>
</div>
<a id="aa6a598dfc9c915dff355935902fbedd6" name="aa6a598dfc9c915dff355935902fbedd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a598dfc9c915dff355935902fbedd6">&#9670;&#160;</a></span>fixupAstPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::fixupAstPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>ast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname"><em>interp</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixes pointers in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Traverses the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find SgAsmIntegerValueExpressions and changes absolute values to relative values. If such an expression is the starting address of a function then the expression will point to that function; else if the expression is the starting address of a basic block then the expression will point to that basic block; else if the expression is the starting address of an instruction then the expression will point to that instruction; else if the expression evaluates to an address inside a mapped section, then the expression will become relative to the start of the best section. Pointers into sections are only created if an interpretation is specified. </p>

</div>
</div>
<a id="a20837cd53e957b3b3204612a4637f451" name="a20837cd53e957b3b3204612a4637f451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20837cd53e957b3b3204612a4637f451">&#9670;&#160;</a></span>fixupAstCallingConventions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Modules::fixupAstCallingConventions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>ast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixes calling convention results. </p>
<p>This function uses the results of previous calling convention analysis to assign calling convention definitions to the functions in the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. There's often more than one definition that matches the analysis results, and this fixup pass attempts to assign the best definitions. It does so by first ranking the definitions according to how often they match across all the functions known to the partitioner. Then, for each function in the specified <code>ast</code>, the we also get a list matching definitions (if a calling convention analysis has been run on that function). We copy into the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> that function's definition which has the highest global ranking. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
