<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::ControlFlow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">ControlFlow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1ControlFlow-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::ControlFlow Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Binary control flow analysis. </p>
<p>This class serves mostly to organize the functions that operate on control flow graphs, but also provides a container for various settings that influence the control flow analyses, such as the vertex and edge filters. The features described here are one form of control flow graph; see also the control flow graph used by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">function</a>detection", which is easier to work with and has more features.

The AST contains an implied CFG by virtue of storing control flow successor addresses in each basic block (SgAsmBlock).
The successor information is initialized by the Partitioner class when the AST is built (see Partitioner::build_ast())
and is available with SgAsmBlock::get_successors().  The SgAsmBlock::get_successors_complete() returns a Boolean
indicating whether the set of successors is completely known. Successors would be incomplete, for instance, for a block
that ends with a computed branch whose targets could not be statically determined. The AST-stored implied graph can be
turned into an explicit Boost graph with various "build" methods defined in this class.

Explicit CFGs use the Boost Graph Library API and come in two flavors: graphs whose vertices are basic blocks, and
graphs whose vertices are instructions.  Although the AST is optimized to store control flow information over basic
blocks, an instruction-based CFG can always be created from a basic block CFG since flow of control within a basic
block is trivial.  It is often easier to work with instruction-based CFGs even though they can be much larger.  Most of
the following documentation describes these explicit Boost CFG graphs.

The CFGs on which this class operates must follow the Boost Graph Library (BGL) API, although not necessarily a BGL
implementation. The graph type is normally a template parameter for the methods herein.  This class provides two
typedefs for graphs implemented in BGL: BlockGraph is for basic-block CFGs and InsnGraph is for instruction CFGs.
The graph must support the BGL adjacency_list graph API with the following features:

&lt;ul&gt;
  &lt;li&gt;the graph vertices are stored as a vector ("vecS" as the second template argument of adjacency_list)&lt;/li&gt;
  &lt;li&gt;the graph is bidirectional ("bidrectionalS" as the third template argument),&lt;/li&gt;
  &lt;li&gt;the boost::vertex_name property is a SgAsmBlock pointer.&lt;/li&gt;
&lt;/ul&gt;

The wikipedia entry for "Control Flow Graph" [1] has many useful definitions. The BGL documentation is located at the
http://www.boost.org web site.

Control flow graphs can be calculated over any subtree of the AST rooted below a SgAsmInterpretation.  It doesn't make
sense to compute inter-interpretation CFGs since the OS only ever loads one interpretation at a time (instructions from
two different interpretations might share the same virtual address). Usually one creates CFGs that span a single
function or a whole interpretation.  The vertex and edge filtes can restrict which vertices and edges are considered by
the various methods of this class.  For instance, to create a global CFG that has no inter-function edges
one could do the following (see also, Rose::BinaryAnalysis::FunctionCall):

@code 
// Create a filter that rejects all inter-function edges
struct NoCallEdges: public ControlFlow::EdgeFilter {
    bool operator()(ControlFlow *analyzer, SgAsmNode *src, SgAsmNode *dst) {
        SgAsmFunction *src_func = SageInterface::getEnclosingNode&lt;SgAsmFunction&gt;(src);
        SgAsmFunction *dst_func = SageInterface::getEnclosingNode&lt;SgAsmFunction&gt;(dst);
        return dst_func != src_func;
    }
} edge_filter;

// Create the control flow analyzer and set its edge filter.
ControlFlow analyzer;
analyzer.set_edge_filter(&amp;edge_filter);

// Generate a block-based CFG over an entire interpretation. It will include
// all basic blocks, but only intra-function edges.
typedef ControlFlow::BlockGraph CFG_B;
SgAsmInterpretation *interp = ...;
CFG_B cfg1 = analyzer.build_block_cfg_from_ast&lt;CFG_B&gt;(interp);

// Generate an instruction-based CFG over an entire interpretation. It will
// include all instructions, but only intra-function edges.
typedef ControlFlow::InsnGraph CFG_I;
CFG_I cfg2 = analyzer.build_insn_cfg_from_ast&lt;CFG_I&gt;(interp);
@endcode

Another way to exclude vertices and/or edges from a graph is to first build a complete graph and then do a filtered
copy to obtain a second graph with only the desired vertices and edges.

@code 
// Build a complete CFG graph using a default control flow analyzer.
CFG_I cfg3 = ControlFlow().build_insn_cfg_from_ast&lt;CFG_I&gt;(interp);

// Using the same analyzer as the previous example, one that
// filters out all but the function call edges, create a call
// graph.
CFG_I cfg4 = analyzer.copy(cfg3);
@endcode

See also, Rose::BinaryAnalysis::FunctionCall, which computes a function call graph whose vertices are functions rather
than the basic blocks or instructions used in a CFG.

Since binary control flow graphs follow the BGL API they can be easily printed as GraphViz graphs using
boost::write_graphviz().  If you want something other than vertex descriptors in the graphs, you could use a
PropertyWriter class, like this one, which labels the vertices with the basic block address.  Ideally, one would use a
class template, but we keep this example simple:

@code 
// Label the graphviz vertices with basic block addresses.
// Boost requires this to be declared at file scope.
struct GraphvizVertexWriter {
    const Rose::BinaryAnalysis::ControlFlow::Graph &amp;cfg;
    GraphvizVertexWriter(Rose::BinaryAnalysis::ControlFlow::Graph &amp;cfg): cfg(cfg) {}
    typedef boost::graph_traits&lt;Rose::BinaryAnalysis::ControlFlow::Graph&gt;::vertex_descriptor Vertex;
    void operator()(std::ostream &amp;output, const Vertex &amp;v) {
        SgAsmBlock *block = get_ast_node(cfg, v);
        output &lt;&lt;"[ label="" &lt;&lt;StringUtility::addrToString(block-&gt;get_address()) &lt;&lt;"" ]"; } };</p>
<p>// Write the graph boost::write_graphviz(std::cout, cfg, GraphvizVertexWriter(cfg)); </p>
<p>We also define a similar write_graphviz method within this class that differs from the Boost implementation in two ways. First, the GraphViz file that it produces has the vertices organized into clusters based on the function in which they appear. Second, the vertex and edge property writers are passed as const references to avoid unnecessary copying.</p>
<p>[1] <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Control_flow_graph">https://secure.wikimedia.org/wikipedia/en/wiki/Control_flow_graph</a> </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00135">135</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="ControlFlow_8h_source.html">Rose/BinaryAnalysis/ControlFlow.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::ControlFlow:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1ControlFlow__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1ControlFlow_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1ControlFlow_coll__map" id="aRose_1_1BinaryAnalysis_1_1ControlFlow_coll__map">
<area shape="rect" title="Binary control flow analysis." alt="" coords="301,37,449,77"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html" title="Filter for vertices." alt="" coords="5,5,180,45"/>
<area shape="poly" title=" " alt="" coords="194,34,301,46,301,52,193,39"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html" title="Filter for edges." alt="" coords="9,69,176,109"/>
<area shape="poly" title=" " alt="" coords="190,76,301,63,301,68,190,81"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1DefaultEdgePropertyWriter.html">DefaultEdgePropertyWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default edge property writer is a no-op.  <a href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1DefaultEdgePropertyWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1DefaultVertexPropertyWriter.html">DefaultVertexPropertyWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default vertex property writer is a no-op.  <a href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1DefaultVertexPropertyWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for edges.  <a href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1FunctionSubgraphInfo.html">FunctionSubgraphInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of vertices and intra-function edges for one function.  <a href="structRose_1_1BinaryAnalysis_1_1ControlFlow_1_1FunctionSubgraphInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for vertices.  <a href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa983e4fa7e4a7f1bfa20758d0502ff1d" id="r_aa983e4fa7e4a7f1bfa20758d0502ff1d"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list&lt; boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt; boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aa983e4fa7e4a7f1bfa20758d0502ff1d">BlockGraph</a></td></tr>
<tr class="memdesc:aa983e4fa7e4a7f1bfa20758d0502ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default basic block control flow graph type.  <br /></td></tr>
<tr class="separator:aa983e4fa7e4a7f1bfa20758d0502ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0228a0cf3e8a8b5214ab57c37157d" id="r_a7aa0228a0cf3e8a8b5214ab57c37157d"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list&lt; boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt; boost::vertex_name_t, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a7aa0228a0cf3e8a8b5214ab57c37157d">InsnGraph</a></td></tr>
<tr class="memdesc:a7aa0228a0cf3e8a8b5214ab57c37157d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instruction-based control flow graph.  <br /></td></tr>
<tr class="separator:a7aa0228a0cf3e8a8b5214ab57c37157d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf06837ba4e61a78fce3704d367643d3" id="r_acf06837ba4e61a78fce3704d367643d3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aa983e4fa7e4a7f1bfa20758d0502ff1d">BlockGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#acf06837ba4e61a78fce3704d367643d3">Graph</a></td></tr>
<tr class="memdesc:acf06837ba4e61a78fce3704d367643d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default control flow graph.  <br /></td></tr>
<tr class="separator:acf06837ba4e61a78fce3704d367643d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a128f8a91dd79f968bb26a25ae405d2b7" id="r_a128f8a91dd79f968bb26a25ae405d2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f8a91dd79f968bb26a25ae405d2b7">clear_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>
<tr class="memdesc:a128f8a91dd79f968bb26a25ae405d2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears successor information from the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a128f8a91dd79f968bb26a25ae405d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb58ee064532f5fc04c80717d1a897d" id="r_a1eb58ee064532f5fc04c80717d1a897d"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a1eb58ee064532f5fc04c80717d1a897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a1eb58ee064532f5fc04c80717d1a897d">apply_to_ast</a> (const ControlFlowGraph &amp;)</td></tr>
<tr class="memdesc:a1eb58ee064532f5fc04c80717d1a897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies graph to <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a1eb58ee064532f5fc04c80717d1a897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22b5af1389515af8cd1709d7f996b3" id="r_abc22b5af1389515af8cd1709d7f996b3"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:abc22b5af1389515af8cd1709d7f996b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#abc22b5af1389515af8cd1709d7f996b3">cache_vertex_descriptors</a> (const ControlFlowGraph &amp;)</td></tr>
<tr class="memdesc:abc22b5af1389515af8cd1709d7f996b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache basic block vertex descriptors in <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:abc22b5af1389515af8cd1709d7f996b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a62412e4cfe198490e6340db8da17e" id="r_a04a62412e4cfe198490e6340db8da17e"><td class="memTemplParams" colspan="2">template&lt;class InsnCFG &gt; </td></tr>
<tr class="memitem:a04a62412e4cfe198490e6340db8da17e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a04a62412e4cfe198490e6340db8da17e">fixup_fcall_fret</a> (InsnCFG &amp;cfg, bool preserve_call_fallthrough_edges)</td></tr>
<tr class="memdesc:a04a62412e4cfe198490e6340db8da17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up a CFG by changing function call and return edges.  <br /></td></tr>
<tr class="separator:a04a62412e4cfe198490e6340db8da17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b7c7406565d0543fd663d5eca03d15" id="r_a30b7c7406565d0543fd663d5eca03d15"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a30b7c7406565d0543fd663d5eca03d15"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a30b7c7406565d0543fd663d5eca03d15">flow_order</a> (const ControlFlowGraph &amp;, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, std::vector&lt; size_t &gt; *reverse_order=NULL)</td></tr>
<tr class="memdesc:a30b7c7406565d0543fd663d5eca03d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders nodes by depth first search reverse post order.  <br /></td></tr>
<tr class="separator:a30b7c7406565d0543fd663d5eca03d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d63fbc56e0732cc023bd8fef267261" id="r_af8d63fbc56e0732cc023bd8fef267261"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:af8d63fbc56e0732cc023bd8fef267261"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#af8d63fbc56e0732cc023bd8fef267261">return_blocks</a> (const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>
<tr class="memdesc:af8d63fbc56e0732cc023bd8fef267261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of function return blocks.  <br /></td></tr>
<tr class="separator:af8d63fbc56e0732cc023bd8fef267261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0594107b091ebfc718ef87d1c7028559" id="r_a0594107b091ebfc718ef87d1c7028559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a0594107b091ebfc718ef87d1c7028559">set_vertex_filter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>
<tr class="memdesc:a0594107b091ebfc718ef87d1c7028559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the vertex filter.  <br /></td></tr>
<tr class="separator:a0594107b091ebfc718ef87d1c7028559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754251590a5e75992d786b5203772129" id="r_a754251590a5e75992d786b5203772129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a754251590a5e75992d786b5203772129">get_vertex_filter</a> () const</td></tr>
<tr class="memdesc:a754251590a5e75992d786b5203772129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the vertex filter.  <br /></td></tr>
<tr class="separator:a754251590a5e75992d786b5203772129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b366120080e8f48f9725c0f50168e91" id="r_a4b366120080e8f48f9725c0f50168e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a4b366120080e8f48f9725c0f50168e91">set_edge_filter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>
<tr class="memdesc:a4b366120080e8f48f9725c0f50168e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the edge filter.  <br /></td></tr>
<tr class="separator:a4b366120080e8f48f9725c0f50168e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853fd2914def69ce27ced0cef47a91fe" id="r_a853fd2914def69ce27ced0cef47a91fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a853fd2914def69ce27ced0cef47a91fe">get_edge_filter</a> () const</td></tr>
<tr class="memdesc:a853fd2914def69ce27ced0cef47a91fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate the edge filter.  <br /></td></tr>
<tr class="separator:a853fd2914def69ce27ced0cef47a91fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ace043dd131523311b8dea787a8d16431" id="r_ace043dd131523311b8dea787a8d16431"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#ace043dd131523311b8dea787a8d16431">is_vertex_filtered</a> (<a class="el" href="classSgAsmNode.html">SgAsmNode</a> *bb_or_insn, <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>
<tr class="memdesc:ace043dd131523311b8dea787a8d16431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a vertex is filtered out.  <br /></td></tr>
<tr class="separator:ace043dd131523311b8dea787a8d16431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93806c4f7adb759296727009be4c1243" id="r_a93806c4f7adb759296727009be4c1243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a93806c4f7adb759296727009be4c1243">is_vertex_filtered</a> (<a class="el" href="classSgAsmNode.html">SgAsmNode</a> *bb_or_insn)</td></tr>
<tr class="memdesc:a93806c4f7adb759296727009be4c1243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a vertex is filtered out.  <br /></td></tr>
<tr class="separator:a93806c4f7adb759296727009be4c1243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20f57d9536c23abe3c17273c6eb13207" id="r_a20f57d9536c23abe3c17273c6eb13207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a20f57d9536c23abe3c17273c6eb13207">is_edge_filtered</a> (<a class="el" href="classSgAsmNode.html">SgAsmNode</a> *src, <a class="el" href="classSgAsmNode.html">SgAsmNode</a> *dst, <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>
<tr class="memdesc:a20f57d9536c23abe3c17273c6eb13207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an edge is filtered out.  <br /></td></tr>
<tr class="separator:a20f57d9536c23abe3c17273c6eb13207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dffbafb097be903c06b65a616b6248" id="r_a72dffbafb097be903c06b65a616b6248"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a72dffbafb097be903c06b65a616b6248">is_edge_filtered</a> (<a class="el" href="classSgAsmNode.html">SgAsmNode</a> *src, <a class="el" href="classSgAsmNode.html">SgAsmNode</a> *dst)</td></tr>
<tr class="memdesc:a72dffbafb097be903c06b65a616b6248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an edge is filtered out.  <br /></td></tr>
<tr class="separator:a72dffbafb097be903c06b65a616b6248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9328c747abd4d9a9054cca11a6634296" id="r_a9328c747abd4d9a9054cca11a6634296"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a9328c747abd4d9a9054cca11a6634296"><td class="memTemplItemLeft" align="right" valign="top">ControlFlowGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296">build_block_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a9328c747abd4d9a9054cca11a6634296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a9328c747abd4d9a9054cca11a6634296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247e110fe84b56aa268246d55a9d5cf8" id="r_a247e110fe84b56aa268246d55a9d5cf8"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a247e110fe84b56aa268246d55a9d5cf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a247e110fe84b56aa268246d55a9d5cf8">build_block_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, ControlFlowGraph &amp;cfg)</td></tr>
<tr class="memdesc:a247e110fe84b56aa268246d55a9d5cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a247e110fe84b56aa268246d55a9d5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f35c7506ae6e53ae9554ee5c01fda" id="r_a128f35c7506ae6e53ae9554ee5c01fda"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a128f35c7506ae6e53ae9554ee5c01fda"><td class="memTemplItemLeft" align="right" valign="top">ControlFlowGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda">build_insn_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a128f35c7506ae6e53ae9554ee5c01fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a128f35c7506ae6e53ae9554ee5c01fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fa76b878aadc4b5ff96290b01a018a" id="r_af9fa76b878aadc4b5ff96290b01a018a"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:af9fa76b878aadc4b5ff96290b01a018a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#af9fa76b878aadc4b5ff96290b01a018a">build_insn_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, ControlFlowGraph &amp;cfg)</td></tr>
<tr class="memdesc:af9fa76b878aadc4b5ff96290b01a018a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:af9fa76b878aadc4b5ff96290b01a018a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a479eac417970808ed3c7a7f6ca62cda0" id="r_a479eac417970808ed3c7a7f6ca62cda0"><td class="memTemplParams" colspan="2">template&lt;class BlockCFG , class InsnCFG &gt; </td></tr>
<tr class="memitem:a479eac417970808ed3c7a7f6ca62cda0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a479eac417970808ed3c7a7f6ca62cda0">explode_blocks</a> (const BlockCFG &amp;cfgb, InsnCFG &amp;cfgi)</td></tr>
<tr class="memdesc:a479eac417970808ed3c7a7f6ca62cda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instruction control flow graph from a basic block control flow graph.  <br /></td></tr>
<tr class="separator:a479eac417970808ed3c7a7f6ca62cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af2091a31b8d5fbbf8320354e04f3c81e" id="r_af2091a31b8d5fbbf8320354e04f3c81e"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:af2091a31b8d5fbbf8320354e04f3c81e"><td class="memTemplItemLeft" align="right" valign="top">ControlFlowGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#af2091a31b8d5fbbf8320354e04f3c81e">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:af2091a31b8d5fbbf8320354e04f3c81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph with only function call edges.  <br /></td></tr>
<tr class="separator:af2091a31b8d5fbbf8320354e04f3c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdbe84a3507e90d2527b51d754044e8" id="r_a6fdbe84a3507e90d2527b51d754044e8"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a6fdbe84a3507e90d2527b51d754044e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a6fdbe84a3507e90d2527b51d754044e8">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, ControlFlowGraph &amp;cfg)</td></tr>
<tr class="memdesc:a6fdbe84a3507e90d2527b51d754044e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a control flow graph with only function call edges.  <br /></td></tr>
<tr class="separator:a6fdbe84a3507e90d2527b51d754044e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3e4a69d240244682f933a26c9f893e1b" id="r_a3e4a69d240244682f933a26c9f893e1b"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:a3e4a69d240244682f933a26c9f893e1b"><td class="memTemplItemLeft" align="right" valign="top">ControlFlowGraph&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a3e4a69d240244682f933a26c9f893e1b">copy</a> (const ControlFlowGraph &amp;src)</td></tr>
<tr class="memdesc:a3e4a69d240244682f933a26c9f893e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a graph while filtering.  <br /></td></tr>
<tr class="separator:a3e4a69d240244682f933a26c9f893e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa883c7189d8caba3e284ef4201ba6030" id="r_aa883c7189d8caba3e284ef4201ba6030"><td class="memTemplParams" colspan="2">template&lt;class ControlFlowGraph &gt; </td></tr>
<tr class="memitem:aa883c7189d8caba3e284ef4201ba6030"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aa883c7189d8caba3e284ef4201ba6030">copy</a> (const ControlFlowGraph &amp;src, ControlFlowGraph &amp;dst)</td></tr>
<tr class="memdesc:aa883c7189d8caba3e284ef4201ba6030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a graph while filtering.  <br /></td></tr>
<tr class="separator:aa883c7189d8caba3e284ef4201ba6030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d7f897b153911049f9ed8888ffbda8a" id="r_a5d7f897b153911049f9ed8888ffbda8a"><td class="memTemplParams" colspan="2">template&lt;typename CFG , class VertexPropertyWriter , class EdgePropertyWriter &gt; </td></tr>
<tr class="memitem:a5d7f897b153911049f9ed8888ffbda8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a5d7f897b153911049f9ed8888ffbda8a">write_graphviz</a> (std::ostream &amp;, const CFG &amp;, const VertexPropertyWriter &amp;, const EdgePropertyWriter &amp;)</td></tr>
<tr class="memdesc:a5d7f897b153911049f9ed8888ffbda8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a CFG to a graphviz file, creating a cluster subgraph for each function.  <br /></td></tr>
<tr class="separator:a5d7f897b153911049f9ed8888ffbda8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81f752d6b36a0775d5752320e1278e9" id="r_af81f752d6b36a0775d5752320e1278e9"><td class="memTemplParams" colspan="2">template&lt;typename CFG &gt; </td></tr>
<tr class="memitem:af81f752d6b36a0775d5752320e1278e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#af81f752d6b36a0775d5752320e1278e9">write_graphviz</a> (std::ostream &amp;out, const CFG &amp;cfg)</td></tr>
<tr class="memdesc:af81f752d6b36a0775d5752320e1278e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a CFG to a graphviz file, creating a cluster subgraph for each function.  <br /></td></tr>
<tr class="separator:af81f752d6b36a0775d5752320e1278e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8c3b804375b14a57ef3e7edab3c9c7" id="r_a7a8c3b804375b14a57ef3e7edab3c9c7"><td class="memTemplParams" colspan="2">template&lt;typename CFG , class VertexPropertyWriter &gt; </td></tr>
<tr class="memitem:a7a8c3b804375b14a57ef3e7edab3c9c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a7a8c3b804375b14a57ef3e7edab3c9c7">write_graphviz</a> (std::ostream &amp;out, const CFG &amp;cfg, const VertexPropertyWriter &amp;vpw)</td></tr>
<tr class="memdesc:a7a8c3b804375b14a57ef3e7edab3c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a CFG to a graphviz file, creating a cluster subgraph for each function.  <br /></td></tr>
<tr class="separator:a7a8c3b804375b14a57ef3e7edab3c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aafbca6c8da2d66cc7819c4dbd1b9113c" id="r_aafbca6c8da2d66cc7819c4dbd1b9113c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aafbca6c8da2d66cc7819c4dbd1b9113c">vertex_filter</a></td></tr>
<tr class="separator:aafbca6c8da2d66cc7819c4dbd1b9113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6bb36d0ec3197379dee2cc0e2832b5" id="r_a1a6bb36d0ec3197379dee2cc0e2832b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a1a6bb36d0ec3197379dee2cc0e2832b5">edge_filter</a></td></tr>
<tr class="separator:a1a6bb36d0ec3197379dee2cc0e2832b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa983e4fa7e4a7f1bfa20758d0502ff1d" name="aa983e4fa7e4a7f1bfa20758d0502ff1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa983e4fa7e4a7f1bfa20758d0502ff1d">&#9670;&#160;</a></span>BlockGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>*&gt; &gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aa983e4fa7e4a7f1bfa20758d0502ff1d">Rose::BinaryAnalysis::ControlFlow::BlockGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default basic block control flow graph type. </p>
<p>A control flow graph is has a Boost graph interface whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> nodes in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> (via the boost::vertex_name property). The graph edges represent flow of control from one basic block to another. Since the control flow graph is a Boost graph, it is endowed with all the features of a Boost graph and can be the operand of the various Boost graph algorithms. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> for specifics about what is included in such a graph.</p>
<p>It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself&ndash;change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;BlockGraph&gt;::vertex_descriptor <a class="code hl_struct" href="structVertex.html">Vertex</a>;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;BlockGraph&gt;::edge_descriptor <a class="code hl_struct" href="structEdge.html">Edge</a>;</div>
<div class="ttc" id="astructEdge_html"><div class="ttname"><a href="structEdge.html">Edge</a></div><div class="ttdef"><b>Definition</b> <a href="SgGraphTemplate_8h_source.html#l00012">SgGraphTemplate.h:12</a></div></div>
<div class="ttc" id="astructVertex_html"><div class="ttname"><a href="structVertex.html">Vertex</a></div><div class="ttdef"><b>Definition</b> <a href="SgGraphTemplate_8h_source.html#l00007">SgGraphTemplate.h:7</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00163">163</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="a7aa0228a0cf3e8a8b5214ab57c37157d" name="a7aa0228a0cf3e8a8b5214ab57c37157d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0228a0cf3e8a8b5214ab57c37157d">&#9670;&#160;</a></span>InsnGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a>*&gt; &gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a7aa0228a0cf3e8a8b5214ab57c37157d">Rose::BinaryAnalysis::ControlFlow::InsnGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default instruction-based control flow graph. </p>
<p>A control flow graph has a Boost graph interface whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmInstruction.html" title="Base class for machine instructions.">SgAsmInstruction</a> nodes in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> (via the boost::vertex_name property). The graph edges represent flow of control from one instruction to another. Since the control flow graph is a Boost graph, it is endowed with all the features of a Boost graph and can be the operand of the various Boost graph algorithms. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a> for specifics about what is included in such a graph.</p>
<p>It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself&ndash;change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;InsnGraph&gt;::vertex_descriptor <a class="code hl_struct" href="structVertex.html">Vertex</a>;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;InsnGraph&gt;::edge_descriptor <a class="code hl_struct" href="structEdge.html">Edge</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00186">186</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="acf06837ba4e61a78fce3704d367643d3" name="acf06837ba4e61a78fce3704d367643d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf06837ba4e61a78fce3704d367643d3">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#aa983e4fa7e4a7f1bfa20758d0502ff1d">BlockGraph</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#acf06837ba4e61a78fce3704d367643d3">Rose::BinaryAnalysis::ControlFlow::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default control flow graph. </p>
<p>The original <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html" title="Binary control flow analysis.">Rose::BinaryAnalysis::ControlFlow</a> API defined only "Graph", which was a basic-block control flow graph. We continue to define that type for backward compatibility. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00190">190</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9549fc2000f8cbc4b5c4bc5dd310a6a2" name="a9549fc2000f8cbc4b5c4bc5dd310a6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9549fc2000f8cbc4b5c4bc5dd310a6a2">&#9670;&#160;</a></span>ControlFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::ControlFlow::ControlFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00137">137</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0594107b091ebfc718ef87d1c7028559" name="a0594107b091ebfc718ef87d1c7028559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0594107b091ebfc718ef87d1c7028559">&#9670;&#160;</a></span>set_vertex_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::set_vertex_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the vertex filter. </p>
<p>When building a control flow graph, the vertex filter is invoked on each vertex which is about to be added. If the filter returns false then that block is not added to the graph. A null filter accepts all vertices. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00224">224</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="a754251590a5e75992d786b5203772129" name="a754251590a5e75992d786b5203772129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754251590a5e75992d786b5203772129">&#9670;&#160;</a></span>get_vertex_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> * Rose::BinaryAnalysis::ControlFlow::get_vertex_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the vertex filter. </p>
<p>When building a control flow graph, the vertex filter is invoked on each vertex which is about to be added. If the filter returns false then that block is not added to the graph. A null filter accepts all vertices. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00225">225</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="a4b366120080e8f48f9725c0f50168e91" name="a4b366120080e8f48f9725c0f50168e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b366120080e8f48f9725c0f50168e91">&#9670;&#160;</a></span>set_edge_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::set_edge_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the edge filter. </p>
<p>When building a control flow graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00234">234</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00698">build_cg_from_ast()</a>.</p>

</div>
</div>
<a id="a853fd2914def69ce27ced0cef47a91fe" name="a853fd2914def69ce27ced0cef47a91fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853fd2914def69ce27ced0cef47a91fe">&#9670;&#160;</a></span>get_edge_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> * Rose::BinaryAnalysis::ControlFlow::get_edge_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manipulate the edge filter. </p>
<p>When building a control flow graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00235">235</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00698">build_cg_from_ast()</a>.</p>

</div>
</div>
<a id="ace043dd131523311b8dea787a8d16431" name="ace043dd131523311b8dea787a8d16431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace043dd131523311b8dea787a8d16431">&#9670;&#160;</a></span>is_vertex_filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::ControlFlow::is_vertex_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>bb_or_insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a vertex is filtered out. </p>
<p>Returns true if the vertex would be filtered out by being rejected by the current vertex filter. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00243">243</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00600">apply_to_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00631">cache_vertex_descriptors()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00732">copy()</a>.</p>

</div>
</div>
<a id="a93806c4f7adb759296727009be4c1243" name="a93806c4f7adb759296727009be4c1243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93806c4f7adb759296727009be4c1243">&#9670;&#160;</a></span>is_vertex_filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::ControlFlow::is_vertex_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>bb_or_insn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a vertex is filtered out. </p>
<p>Returns true if the vertex would be filtered out by being rejected by the current vertex filter. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00244">244</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00244">is_vertex_filtered()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00244">is_vertex_filtered()</a>.</p>

</div>
</div>
<a id="a20f57d9536c23abe3c17273c6eb13207" name="a20f57d9536c23abe3c17273c6eb13207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f57d9536c23abe3c17273c6eb13207">&#9670;&#160;</a></span>is_edge_filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::ControlFlow::is_edge_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an edge is filtered out. </p>
<p>Returns true if the edge would be filtered out by being rejected by the current edge filter. The <code>src</code> and <code>dst</code> are the source and destination vertex nodes, either basic blocks or instructions depending on the graph type. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00253">253</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00600">apply_to_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00654">build_block_cfg_from_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00732">copy()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00256">is_edge_filtered()</a>.</p>

</div>
</div>
<a id="a72dffbafb097be903c06b65a616b6248" name="a72dffbafb097be903c06b65a616b6248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dffbafb097be903c06b65a616b6248">&#9670;&#160;</a></span>is_edge_filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::ControlFlow::is_edge_filtered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an edge is filtered out. </p>
<p>Returns true if the edge would be filtered out by being rejected by the current edge filter. The <code>src</code> and <code>dst</code> are the source and destination vertex nodes, either basic blocks or instructions depending on the graph type. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00256">256</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00253">is_edge_filtered()</a>.</p>

</div>
</div>
<a id="a128f8a91dd79f968bb26a25ae405d2b7" name="a128f8a91dd79f968bb26a25ae405d2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128f8a91dd79f968bb26a25ae405d2b7">&#9670;&#160;</a></span>clear_ast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::clear_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>ast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears successor information from the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Traverses the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> and clears the successor lists for all basic blocks. The blocks are visited by an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> traversal, not by following successor pointers.</p>
<p>The current vertex filter determines which edges are filtered. </p>

</div>
</div>
<a id="a1eb58ee064532f5fc04c80717d1a897d" name="a1eb58ee064532f5fc04c80717d1a897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb58ee064532f5fc04c80717d1a897d">&#9670;&#160;</a></span>apply_to_ast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::apply_to_ast </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies graph to <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Just as a control flow graph can be built from the successor lists stored in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> or <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a>), a graph can be used to initialize the successor information in an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. This function does that. Only the blocks which are vertices of the graph and which pass the current vertex filter are affected. Only edges that pass the current edge filter are added as successors to the (cleared) block successor list.</p>
<p>Not all instruction-based graphs can be written back to the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> because the implied basic block structure of the graph might not match the explicit basic block structure in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. Perhaps a future version will allow the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to be restructured by this operation.</p>
<p>At this time [2011-05-19] the successor_complete property of each affected block is set to true, but this may change in the future. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00600">600</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="classSgAsmStatement.html#ac0959f1b0d967f7aff9032c2a4e2ab92">SgAsmStatement::get_address()</a>, <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmBlock.html#a31ca54ec6ee0dfff832a935fe08e3d80">SgAsmBlock::get_successors()</a>, <a class="el" href="ControlFlow_8h_source.html#l00253">is_edge_filtered()</a>, <a class="el" href="ControlFlow_8h_source.html#l00243">is_vertex_filtered()</a>, and <a class="el" href="classSgAsmBlock.html#a36093d36e7cf41bf6422a575a2249a67">SgAsmBlock::set_successorsComplete()</a>.</p>

</div>
</div>
<a id="abc22b5af1389515af8cd1709d7f996b3" name="abc22b5af1389515af8cd1709d7f996b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc22b5af1389515af8cd1709d7f996b3">&#9670;&#160;</a></span>cache_vertex_descriptors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::cache_vertex_descriptors </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache basic block vertex descriptors in <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>The vertices of a control flow graph are of type <a class="el" href="structVertex.html">Vertex</a>, and point at the basic blocks (<a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>) of the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. Although most graph algorithms will only need to map <a class="el" href="structVertex.html">Vertex</a> to <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>, the inverse mapping is also sometimes useful. That mapping can be stored into an std::map via graph traversal, or stored in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> itself attached to each <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>. Using an std::map requires an O(log N) lookup each time we need to get the vertex descriptor from a block, while storing the vertex descriptor in the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> requires O(1) lookup time.</p>
<p>The vertex descriptors are available via SgAsmBlock::get_cached_vertex(). Other graph types (e.g., dominance graphs) might also use the same cache line. The cached vertex is stored as a size_t, which is the same underlying type for CFG vertices.</p>
<p>The current vertex filter determines which blocks are modified. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00631">631</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="ControlFlow_8h_source.html#l00243">is_vertex_filtered()</a>, and <a class="el" href="classSgAsmBlock.html#a17e7dbc727dc8e4ec706cc6f35a9f2d4">SgAsmBlock::set_cachedVertex()</a>.</p>

</div>
</div>
<a id="a9328c747abd4d9a9054cca11a6634296" name="a9328c747abd4d9a9054cca11a6634296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9328c747abd4d9a9054cca11a6634296">&#9670;&#160;</a></span>build_block_cfg_from_ast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph Rose::BinaryAnalysis::ControlFlow::build_block_cfg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#a286999bcbc32e375deb28279c7fd883f" title="Property: Control flow successors.">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html" title="Base class for integer values.">SgAsmIntegerValueExpression</a>. The specified <code>root</code> for the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> should generally not include multiple interpretations (<a class="el" href="classSgAsmInterpretation.html" title="Represents an interpretation of a binary container.">SgAsmInterpretation</a>) since the OS never loads more than one interpretation at a time.</p>
<p>The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): </p><ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> builds a CFG whose vertices are basic blocks, while the <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a> builds a CFG whose vertices are instructions. Furthermore, the instruction-based CFG makes some adjustments to function call and function return nodes by invoking <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a04a62412e4cfe198490e6340db8da17e" title="Fix up a CFG by changing function call and return edges.">fixup_fcall_fret()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00988">988</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00988">build_block_cfg_from_ast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00988">build_block_cfg_from_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00698">build_cg_from_ast()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00687">build_insn_cfg_from_ast()</a>.</p>

</div>
</div>
<a id="a247e110fe84b56aa268246d55a9d5cf8" name="a247e110fe84b56aa268246d55a9d5cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247e110fe84b56aa268246d55a9d5cf8">&#9670;&#160;</a></span>build_block_cfg_from_ast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::build_block_cfg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#a286999bcbc32e375deb28279c7fd883f" title="Property: Control flow successors.">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html" title="Base class for integer values.">SgAsmIntegerValueExpression</a>. The specified <code>root</code> for the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> should generally not include multiple interpretations (<a class="el" href="classSgAsmInterpretation.html" title="Represents an interpretation of a binary container.">SgAsmInterpretation</a>) since the OS never loads more than one interpretation at a time.</p>
<p>The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): </p><ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> builds a CFG whose vertices are basic blocks, while the <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a> builds a CFG whose vertices are instructions. Furthermore, the instruction-based CFG makes some adjustments to function call and function return nodes by invoking <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a04a62412e4cfe198490e6340db8da17e" title="Fix up a CFG by changing function call and return edges.">fixup_fcall_fret()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00654">654</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmBlock.html#a31ca54ec6ee0dfff832a935fe08e3d80">SgAsmBlock::get_successors()</a>, <a class="el" href="util_2Map_8h_source.html#l00078">Map&lt; Key, T, Compare, Alloc &gt;::get_value_or()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00253">is_edge_filtered()</a>.</p>

</div>
</div>
<a id="a128f35c7506ae6e53ae9554ee5c01fda" name="a128f35c7506ae6e53ae9554ee5c01fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128f35c7506ae6e53ae9554ee5c01fda">&#9670;&#160;</a></span>build_insn_cfg_from_ast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph Rose::BinaryAnalysis::ControlFlow::build_insn_cfg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#a286999bcbc32e375deb28279c7fd883f" title="Property: Control flow successors.">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html" title="Base class for integer values.">SgAsmIntegerValueExpression</a>. The specified <code>root</code> for the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> should generally not include multiple interpretations (<a class="el" href="classSgAsmInterpretation.html" title="Represents an interpretation of a binary container.">SgAsmInterpretation</a>) since the OS never loads more than one interpretation at a time.</p>
<p>The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): </p><ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> builds a CFG whose vertices are basic blocks, while the <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a> builds a CFG whose vertices are instructions. Furthermore, the instruction-based CFG makes some adjustments to function call and function return nodes by invoking <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a04a62412e4cfe198490e6340db8da17e" title="Fix up a CFG by changing function call and return edges.">fixup_fcall_fret()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00997">997</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00997">build_insn_cfg_from_ast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00997">build_insn_cfg_from_ast()</a>.</p>

</div>
</div>
<a id="af9fa76b878aadc4b5ff96290b01a018a" name="af9fa76b878aadc4b5ff96290b01a018a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fa76b878aadc4b5ff96290b01a018a">&#9670;&#160;</a></span>build_insn_cfg_from_ast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::build_insn_cfg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph for part of an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p>Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#a286999bcbc32e375deb28279c7fd883f" title="Property: Control flow successors.">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html" title="Base class for integer values.">SgAsmIntegerValueExpression</a>. The specified <code>root</code> for the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> should generally not include multiple interpretations (<a class="el" href="classSgAsmInterpretation.html" title="Represents an interpretation of a binary container.">SgAsmInterpretation</a>) since the OS never loads more than one interpretation at a time.</p>
<p>The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): </p><ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>
<p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a9328c747abd4d9a9054cca11a6634296" title="Builds a control flow graph for part of an AST.">build_block_cfg_from_ast()</a> builds a CFG whose vertices are basic blocks, while the <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a128f35c7506ae6e53ae9554ee5c01fda" title="Builds a control flow graph for part of an AST.">build_insn_cfg_from_ast()</a> builds a CFG whose vertices are instructions. Furthermore, the instruction-based CFG makes some adjustments to function call and function return nodes by invoking <a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a04a62412e4cfe198490e6340db8da17e" title="Fix up a CFG by changing function call and return edges.">fixup_fcall_fret()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00687">687</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00988">build_block_cfg_from_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00771">explode_blocks()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00827">fixup_fcall_fret()</a>.</p>

</div>
</div>
<a id="a479eac417970808ed3c7a7f6ca62cda0" name="a479eac417970808ed3c7a7f6ca62cda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479eac417970808ed3c7a7f6ca62cda0">&#9670;&#160;</a></span>explode_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockCFG , class InsnCFG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::explode_blocks </td>
          <td>(</td>
          <td class="paramtype">const BlockCFG &amp;&#160;</td>
          <td class="paramname"><em>cfgb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsnCFG &amp;&#160;</td>
          <td class="paramname"><em>cfgi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instruction control flow graph from a basic block control flow graph. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00771">771</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="util_2Map_8h_source.html#l00061">Map&lt; Key, T, Compare, Alloc &gt;::get_one()</a>, <a class="el" href="classSgAsmBlock.html#a98c49f1b7720d5b0faf6170c55755fed">SgAsmBlock::get_statementList()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00567">Rose::BinaryAnalysis::put_ast_node()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00687">build_insn_cfg_from_ast()</a>.</p>

</div>
</div>
<a id="a04a62412e4cfe198490e6340db8da17e" name="a04a62412e4cfe198490e6340db8da17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a62412e4cfe198490e6340db8da17e">&#9670;&#160;</a></span>fixup_fcall_fret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InsnCFG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::fixup_fcall_fret </td>
          <td>(</td>
          <td class="paramtype">InsnCFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_call_fallthrough_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fix up a CFG by changing function call and return edges. </p>
<p>The <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> does not store function return edges (which this method adds), and the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> stores a fall-through edge for function call nodes for callees that may return (which this method removes). </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00827">827</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="WorkLists_8h_source.html#l00072">WorkList&lt; T, Compare &gt;::empty()</a>, <a class="el" href="classSgAsmStatement.html#ac0959f1b0d967f7aff9032c2a4e2ab92">SgAsmStatement::get_address()</a>, <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmFunction.html#a18b23b19d6538da747ea71ecd94262ae">SgAsmFunction::get_entryVa()</a>, <a class="el" href="util_2Map_8h_source.html#l00061">Map&lt; Key, T, Compare, Alloc &gt;::get_one()</a>, <a class="el" href="util_2Map_8h_source.html#l00078">Map&lt; Key, T, Compare, Alloc &gt;::get_value_or()</a>, <a class="el" href="classSgAsmBlock.html#a1ee31fd033fd6dbacfe12a2e865499ee">SgAsmBlock::isFunctionCall()</a>, <a class="el" href="WorkLists_8h_source.html#l00202">WorkList&lt; T, Compare &gt;::push()</a>, and <a class="el" href="WorkLists_8h_source.html#l00236">WorkList&lt; T, Compare &gt;::shift()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00687">build_insn_cfg_from_ast()</a>.</p>

</div>
</div>
<a id="af2091a31b8d5fbbf8320354e04f3c81e" name="af2091a31b8d5fbbf8320354e04f3c81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2091a31b8d5fbbf8320354e04f3c81e">&#9670;&#160;</a></span>build_cg_from_ast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph Rose::BinaryAnalysis::ControlFlow::build_cg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph with only function call edges. </p>
<p>This differs from a true <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998" title="The default function call graph type.">FunctionCall::Graph</a> in that the vertices of the returned graph point to basic blocks, while the vertices of a <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998" title="The default function call graph type.">FunctionCall::Graph</a> point to functions (<a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> nodes).</p>
<p>The graph is built by applying an edge filter (in addition to the edge filter that might be set by the user) that only accepts edges whose target is a function entry block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l01006">1006</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l01006">build_cg_from_ast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l01006">build_cg_from_ast()</a>.</p>

</div>
</div>
<a id="a6fdbe84a3507e90d2527b51d754044e8" name="a6fdbe84a3507e90d2527b51d754044e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdbe84a3507e90d2527b51d754044e8">&#9670;&#160;</a></span>build_cg_from_ast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::build_cg_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a control flow graph with only function call edges. </p>
<p>This differs from a true <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998" title="The default function call graph type.">FunctionCall::Graph</a> in that the vertices of the returned graph point to basic blocks, while the vertices of a <a class="el" href="classRose_1_1BinaryAnalysis_1_1FunctionCall.html#accf1caa8493b25dce524e99c107e5998" title="The default function call graph type.">FunctionCall::Graph</a> point to functions (<a class="el" href="classSgAsmFunction.html" title="Represents a synthesized function.">SgAsmFunction</a> nodes).</p>
<p>The graph is built by applying an edge filter (in addition to the edge filter that might be set by the user) that only accepts edges whose target is a function entry block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00698">698</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00988">build_block_cfg_from_ast()</a>, <a class="el" href="ControlFlow_8h_source.html#l00235">get_edge_filter()</a>, <a class="el" href="classSgAsmFunction.html#a85374a810087387df27743e02e84705c">SgAsmFunction::get_entryBlock()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00234">set_edge_filter()</a>.</p>

</div>
</div>
<a id="a3e4a69d240244682f933a26c9f893e1b" name="a3e4a69d240244682f933a26c9f893e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4a69d240244682f933a26c9f893e1b">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph Rose::BinaryAnalysis::ControlFlow::copy </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a graph while filtering. </p>
<p>Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).</p>
<p>If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00762">762</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00762">copy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00762">copy()</a>.</p>

</div>
</div>
<a id="aa883c7189d8caba3e284ef4201ba6030" name="aa883c7189d8caba3e284ef4201ba6030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa883c7189d8caba3e284ef4201ba6030">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::copy </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a graph while filtering. </p>
<p>Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).</p>
<p>If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00732">732</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="ControlFlow_8h_source.html#l00253">is_edge_filtered()</a>, <a class="el" href="ControlFlow_8h_source.html#l00243">is_vertex_filtered()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00567">Rose::BinaryAnalysis::put_ast_node()</a>.</p>

</div>
</div>
<a id="a5d7f897b153911049f9ed8888ffbda8a" name="a5d7f897b153911049f9ed8888ffbda8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7f897b153911049f9ed8888ffbda8a">&#9670;&#160;</a></span>write_graphviz() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFG , class VertexPropertyWriter , class EdgePropertyWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::write_graphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexPropertyWriter &amp;&#160;</td>
          <td class="paramname"><em>vpw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgePropertyWriter &amp;&#160;</td>
          <td class="paramname"><em>epw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a CFG to a graphviz file, creating a cluster subgraph for each function. </p>
<p>Write a control flow graph to a graphviz file, creating a cluster subgraph for each function. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l01016">1016</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString()</a>, <a class="el" href="ControlFlow_8h_source.html#l00556">Rose::BinaryAnalysis::get_ast_node()</a>, <a class="el" href="classSgAsmFunction.html#a18b23b19d6538da747ea71ecd94262ae">SgAsmFunction::get_entryVa()</a>, and <a class="el" href="classSgAsmFunction.html#acec5301595ccfbb00e17bc188e245733">SgAsmFunction::get_name()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_8h_source.html#l00428">write_graphviz()</a>, and <a class="el" href="ControlFlow_8h_source.html#l00433">write_graphviz()</a>.</p>

</div>
</div>
<a id="af81f752d6b36a0775d5752320e1278e9" name="af81f752d6b36a0775d5752320e1278e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81f752d6b36a0775d5752320e1278e9">&#9670;&#160;</a></span>write_graphviz() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::write_graphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a CFG to a graphviz file, creating a cluster subgraph for each function. </p>
<p>Write a control flow graph to a graphviz file, creating a cluster subgraph for each function. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00428">428</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l01016">write_graphviz()</a>.</p>

</div>
</div>
<a id="a7a8c3b804375b14a57ef3e7edab3c9c7" name="a7a8c3b804375b14a57ef3e7edab3c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8c3b804375b14a57ef3e7edab3c9c7">&#9670;&#160;</a></span>write_graphviz() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFG , class VertexPropertyWriter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::ControlFlow::write_graphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexPropertyWriter &amp;&#160;</td>
          <td class="paramname"><em>vpw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a CFG to a graphviz file, creating a cluster subgraph for each function. </p>
<p>Write a control flow graph to a graphviz file, creating a cluster subgraph for each function. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00433">433</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

<p class="reference">References <a class="el" href="ControlFlow_8h_source.html#l01016">write_graphviz()</a>.</p>

</div>
</div>
<a id="a30b7c7406565d0543fd663d5eca03d15" name="a30b7c7406565d0543fd663d5eca03d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b7c7406565d0543fd663d5eca03d15">&#9670;&#160;</a></span>flow_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt; Rose::BinaryAnalysis::ControlFlow::flow_order </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>reverse_order</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders nodes by depth first search reverse post order. </p>
<p>Reversed, depth-first-search, post-order is a common node order needed for solving flow equations, and this method returns a vector whose elements are graph vertices. The algorithm is to allocate the vector to be the same length as the total number of vertices in the graph, and then do a depth-first-search starting with the specified node. Each node is visited after all its children (post-order). Each node visit adds the node to the vector starting at the end of the vector and working forward.</p>
<p>If reverse_order is non-null then it will be the inverse mapping from the returned vector. In other words, if the return value is named forward_order, then</p>
<p>forward_order[i] == v implies reverse_order[v] == i</p>
<p>Here's an example of how this would typically be used.</p>
<div class="fragment"><div class="line">std::vector&lt;size_t&gt; rflowlist; <span class="comment">// reverse mapping</span></div>
<div class="line">std::vector&lt;ControlFlow::Vector&gt; flowlist;</div>
<div class="line">flowlist = <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">ControlFlow</a>().<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a30b7c7406565d0543fd663d5eca03d15">flow_order</a>(cfg, start, &amp;rflowlist);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> changed;</div>
<div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">    changed = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;flowlist.size(); ++i) {</div>
<div class="line">        ControlFlow::Vertex vertex = flowlist[i];</div>
<div class="line">        <span class="comment">// solve flow equation for vertex...</span></div>
<div class="line">        <span class="keywordflow">if</span> (result_at_vertex_changed)</div>
<div class="line">            changed = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">while</span> (changed);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1ControlFlow_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html">Rose::BinaryAnalysis::ControlFlow</a></div><div class="ttdoc">Binary control flow analysis.</div><div class="ttdef"><b>Definition</b> <a href="ControlFlow_8h_source.html#l00135">ControlFlow.h:135</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1ControlFlow_html_a30b7c7406565d0543fd663d5eca03d15"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1ControlFlow.html#a30b7c7406565d0543fd663d5eca03d15">Rose::BinaryAnalysis::ControlFlow::flow_order</a></div><div class="ttdeci">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt; flow_order(const ControlFlowGraph &amp;, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, std::vector&lt; size_t &gt; *reverse_order=NULL)</div><div class="ttdoc">Orders nodes by depth first search reverse post order.</div><div class="ttdef"><b>Definition</b> <a href="ControlFlow_8h_source.html#l00955">ControlFlow.h:955</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00955">955</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="af8d63fbc56e0732cc023bd8fef267261" name="af8d63fbc56e0732cc023bd8fef267261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d63fbc56e0732cc023bd8fef267261">&#9670;&#160;</a></span>return_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt; Rose::BinaryAnalysis::ControlFlow::return_blocks </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns list of function return blocks. </p>
<p>More specifically, this method traverses the control flow graph (CFG) beginning at the specified node and returns a list (in depth first search order) of all vertices which are in the connected subgraph and which do not have any known successors, but at least one unknown successor.</p>
<p>Currently works only for basic block CFGs. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00976">976</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aafbca6c8da2d66cc7819c4dbd1b9113c" name="aafbca6c8da2d66cc7819c4dbd1b9113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbca6c8da2d66cc7819c4dbd1b9113c">&#9670;&#160;</a></span>vertex_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a>* Rose::BinaryAnalysis::ControlFlow::vertex_filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00262">262</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<a id="a1a6bb36d0ec3197379dee2cc0e2832b5" name="a1a6bb36d0ec3197379dee2cc0e2832b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6bb36d0ec3197379dee2cc0e2832b5">&#9670;&#160;</a></span>edge_filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a>* Rose::BinaryAnalysis::ControlFlow::edge_filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ControlFlow_8h_source.html#l00263">263</a> of file <a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ControlFlow_8h_source.html">ControlFlow.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
