<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::AbstractLocation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1AbstractLocation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::AbstractLocation Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Abstract location. </p>
<p>An abstract location represents either a register name or memory address. Registers are represented by <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html" title="Describes (part of) a physical CPU register.">RegisterDescriptor</a> and addresses are represented by semantic values (subclasses of BaseSemantics::SValue).</p>
<p>For instance, to represent abstract locations where memory addresses have symbolic values, one uses:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> aloc1(REG_EAX); <span class="comment">// REG_EAX is a RegisterDescriptor</span></div>
<div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> aloc2(addr); <span class="comment">// addr is an SValuePtr for the symbolic semantics domain</span></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1AbstractLocation_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">Rose::BinaryAnalysis::AbstractLocation</a></div><div class="ttdoc">Abstract location.</div><div class="ttdef"><b>Definition</b> <a href="AbstractLocation_8h_source.html#l00032">AbstractLocation.h:32</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a></div><div class="ttdoc">Binary analysis.</div><div class="ttdef"><b>Definition</b> <a href="BinaryTutorial_8dox_source.html#l00004">BinaryTutorial.dox:4</a></div></div>
</div><!-- fragment --><p>Abstract locations are immutable objects.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a>. </p>

<p class="definition">Definition at line <a class="el" href="AbstractLocation_8h_source.html#l00032">32</a> of file <a class="el" href="AbstractLocation_8h_source.html">AbstractLocation.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="AbstractLocation_8h_source.html">Rose/BinaryAnalysis/AbstractLocation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::AbstractLocation:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1AbstractLocation__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1AbstractLocation_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1AbstractLocation_inherit__map" id="aRose_1_1BinaryAnalysis_1_1AbstractLocation_inherit__map">
<area shape="rect" title="Abstract location." alt="" coords="5,79,153,119"/>
<area shape="rect" href="classRose_1_1Location.html" title="Base class for location types." alt="" coords="24,5,135,31"/>
<area shape="poly" title=" " alt="" coords="82,44,82,78,77,78,77,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::AbstractLocation:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1AbstractLocation__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1AbstractLocation_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1AbstractLocation_coll__map" id="aRose_1_1BinaryAnalysis_1_1AbstractLocation_coll__map">
<area shape="rect" title="Abstract location." alt="" coords="5,79,153,119"/>
<area shape="rect" href="classRose_1_1Location.html" title="Base class for location types." alt="" coords="24,5,135,31"/>
<area shape="poly" title=" " alt="" coords="82,44,82,78,77,78,77,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa177db2769cae056e0261d8f04d268e0" id="r_aa177db2769cae056e0261d8f04d268e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Address</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a></td></tr>
<tr class="memdesc:aa177db2769cae056e0261d8f04d268e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of memory address.  <br /></td></tr>
<tr class="separator:aa177db2769cae056e0261d8f04d268e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f8b78269b71a7d48f6f1d021bdbb84d" id="r_a2f8b78269b71a7d48f6f1d021bdbb84d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a2f8b78269b71a7d48f6f1d021bdbb84d">AbstractLocation</a> ()</td></tr>
<tr class="memdesc:a2f8b78269b71a7d48f6f1d021bdbb84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a2f8b78269b71a7d48f6f1d021bdbb84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214837b1bb46e28f60df3b4d9db2cd43" id="r_a214837b1bb46e28f60df3b4d9db2cd43"><td class="memItemLeft" align="right" valign="top"><a id="a214837b1bb46e28f60df3b4d9db2cd43" name="a214837b1bb46e28f60df3b4d9db2cd43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbstractLocation</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;)</td></tr>
<tr class="memdesc:a214837b1bb46e28f60df3b4d9db2cd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a214837b1bb46e28f60df3b4d9db2cd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63805882126df4e7b489b776ae3387f3" id="r_a63805882126df4e7b489b776ae3387f3"><td class="memItemLeft" align="right" valign="top"><a id="a63805882126df4e7b489b776ae3387f3" name="a63805882126df4e7b489b776ae3387f3"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;)</td></tr>
<tr class="memdesc:a63805882126df4e7b489b776ae3387f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a63805882126df4e7b489b776ae3387f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1495feb45ba1a1b9d10bdcb25ce05a" id="r_a2c1495feb45ba1a1b9d10bdcb25ce05a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a2c1495feb45ba1a1b9d10bdcb25ce05a">AbstractLocation</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Address</a> &amp;, size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a9940167a24d0076e4e6f61b220b14dc2">nBytes</a>=0)</td></tr>
<tr class="memdesc:a2c1495feb45ba1a1b9d10bdcb25ce05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory referent.  <br /></td></tr>
<tr class="separator:a2c1495feb45ba1a1b9d10bdcb25ce05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913b22c50b0aaf22fbfa09f6146be38" id="r_af913b22c50b0aaf22fbfa09f6146be38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#af913b22c50b0aaf22fbfa09f6146be38">isValid</a> () const override</td></tr>
<tr class="memdesc:af913b22c50b0aaf22fbfa09f6146be38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object is valid.  <br /></td></tr>
<tr class="separator:af913b22c50b0aaf22fbfa09f6146be38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9382261731904254853ad44680f7150" id="r_aa9382261731904254853ad44680f7150"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa9382261731904254853ad44680f7150">toString</a> () const override</td></tr>
<tr class="memdesc:aa9382261731904254853ad44680f7150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert location to string.  <br /></td></tr>
<tr class="separator:aa9382261731904254853ad44680f7150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab383aaa1581897dd66ec07f3cc3516" id="r_a6ab383aaa1581897dd66ec07f3cc3516"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a6ab383aaa1581897dd66ec07f3cc3516">print</a> (std::ostream &amp;) const override</td></tr>
<tr class="memdesc:a6ab383aaa1581897dd66ec07f3cc3516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output location to a stream.  <br /></td></tr>
<tr class="separator:a6ab383aaa1581897dd66ec07f3cc3516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34967e62fb6e8eb2dfd860b7e9240a3f" id="r_a34967e62fb6e8eb2dfd860b7e9240a3f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a34967e62fb6e8eb2dfd860b7e9240a3f">printableName</a> () const override</td></tr>
<tr class="memdesc:a34967e62fb6e8eb2dfd860b7e9240a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert location to escaped, parsable string.  <br /></td></tr>
<tr class="separator:a34967e62fb6e8eb2dfd860b7e9240a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c21e855c461f54b9927b98d222315" id="r_afd4c21e855c461f54b9927b98d222315"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#afd4c21e855c461f54b9927b98d222315">isEqual</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;) const override</td></tr>
<tr class="memdesc:afd4c21e855c461f54b9927b98d222315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality and inequality.  <br /></td></tr>
<tr class="separator:afd4c21e855c461f54b9927b98d222315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517425a3fbea79c73c0da976d052b9fa" id="r_a517425a3fbea79c73c0da976d052b9fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a517425a3fbea79c73c0da976d052b9fa">operator&lt;</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;) const override</td></tr>
<tr class="separator:a517425a3fbea79c73c0da976d052b9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92009e8d3d7640da44547445da9fc4a3" id="r_a92009e8d3d7640da44547445da9fc4a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a92009e8d3d7640da44547445da9fc4a3">operator&lt;=</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;) const override</td></tr>
<tr class="separator:a92009e8d3d7640da44547445da9fc4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84313fa72c40ef0abe84df4bf9b64f4b" id="r_a84313fa72c40ef0abe84df4bf9b64f4b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a84313fa72c40ef0abe84df4bf9b64f4b">operator&gt;</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;) const override</td></tr>
<tr class="separator:a84313fa72c40ef0abe84df4bf9b64f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3ec9ae4fba9d115d034221e4d5bb99" id="r_ace3ec9ae4fba9d115d034221e4d5bb99"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#ace3ec9ae4fba9d115d034221e4d5bb99">operator&gt;=</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;) const override</td></tr>
<tr class="separator:ace3ec9ae4fba9d115d034221e4d5bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527f75f9ed2088f1d054fecce7daa643" id="r_a527f75f9ed2088f1d054fecce7daa643"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a527f75f9ed2088f1d054fecce7daa643">compare</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;other) const</td></tr>
<tr class="memdesc:a527f75f9ed2088f1d054fecce7daa643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two abstract locations.  <br /></td></tr>
<tr class="separator:a527f75f9ed2088f1d054fecce7daa643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cd2c01cc8fdfc28f806ed88ad993f3" id="r_a22cd2c01cc8fdfc28f806ed88ad993f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a22cd2c01cc8fdfc28f806ed88ad993f3">isRegister</a> () const</td></tr>
<tr class="memdesc:a22cd2c01cc8fdfc28f806ed88ad993f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks register reference.  <br /></td></tr>
<tr class="separator:a22cd2c01cc8fdfc28f806ed88ad993f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89643e545e9c235df7e8b520e2f20f0c" id="r_a89643e545e9c235df7e8b520e2f20f0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a89643e545e9c235df7e8b520e2f20f0c">isAddress</a> () const</td></tr>
<tr class="memdesc:a89643e545e9c235df7e8b520e2f20f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks memory reference.  <br /></td></tr>
<tr class="separator:a89643e545e9c235df7e8b520e2f20f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd197ace13c0ac5eeb3924b689790261" id="r_acd197ace13c0ac5eeb3924b689790261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#acd197ace13c0ac5eeb3924b689790261">getRegister</a> () const</td></tr>
<tr class="memdesc:acd197ace13c0ac5eeb3924b689790261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns register.  <br /></td></tr>
<tr class="separator:acd197ace13c0ac5eeb3924b689790261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b185600f3ac24e3f8786ca03eadfd4d" id="r_a8b185600f3ac24e3f8786ca03eadfd4d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a8b185600f3ac24e3f8786ca03eadfd4d">getAddress</a> () const</td></tr>
<tr class="memdesc:a8b185600f3ac24e3f8786ca03eadfd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns memory address.  <br /></td></tr>
<tr class="separator:a8b185600f3ac24e3f8786ca03eadfd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9940167a24d0076e4e6f61b220b14dc2" id="r_a9940167a24d0076e4e6f61b220b14dc2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a9940167a24d0076e4e6f61b220b14dc2">nBytes</a> () const</td></tr>
<tr class="memdesc:a9940167a24d0076e4e6f61b220b14dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of memory location in bytes.  <br /></td></tr>
<tr class="separator:a9940167a24d0076e4e6f61b220b14dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53744f182b6384b4dc73c9afee48cc7d" id="r_a53744f182b6384b4dc73c9afee48cc7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a53744f182b6384b4dc73c9afee48cc7d">mayAlias</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) const</td></tr>
<tr class="memdesc:a53744f182b6384b4dc73c9afee48cc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if two abstract locations could be aliases.  <br /></td></tr>
<tr class="separator:a53744f182b6384b4dc73c9afee48cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6083ee550548c8218354acd73148f5a2" id="r_a6083ee550548c8218354acd73148f5a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a6083ee550548c8218354acd73148f5a2">mustAlias</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) const</td></tr>
<tr class="memdesc:a6083ee550548c8218354acd73148f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if two abstract locations are certainly aliases.  <br /></td></tr>
<tr class="separator:a6083ee550548c8218354acd73148f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afe24a4c3d656c065a3bd2854c852a5a7" id="r_afe24a4c3d656c065a3bd2854c852a5a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#afe24a4c3d656c065a3bd2854c852a5a7">AbstractLocation</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:afe24a4c3d656c065a3bd2854c852a5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register referent.  <br /></td></tr>
<tr class="separator:afe24a4c3d656c065a3bd2854c852a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cd588074ad36087a60deca947311a7" id="r_ae5cd588074ad36087a60deca947311a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#ae5cd588074ad36087a60deca947311a7">AbstractLocation</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;regdict)</td></tr>
<tr class="memdesc:ae5cd588074ad36087a60deca947311a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register referent.  <br /></td></tr>
<tr class="separator:ae5cd588074ad36087a60deca947311a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a846d78f9cb26b0675e5835f2188cd7a2" id="r_a846d78f9cb26b0675e5835f2188cd7a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a846d78f9cb26b0675e5835f2188cd7a2">print</a> (std::ostream &amp;out, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;regdict) const</td></tr>
<tr class="memdesc:a846d78f9cb26b0675e5835f2188cd7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an abstract location.  <br /></td></tr>
<tr class="separator:a846d78f9cb26b0675e5835f2188cd7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e50181887a342db98622471afc39b7" id="r_a04e50181887a342db98622471afc39b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a04e50181887a342db98622471afc39b7">print</a> (std::ostream &amp;out, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">InstructionSemantics::BaseSemantics::Formatter</a> &amp;fmt) const</td></tr>
<tr class="memdesc:a04e50181887a342db98622471afc39b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an abstract location.  <br /></td></tr>
<tr class="separator:a04e50181887a342db98622471afc39b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a93e15e9f6d9aa3534ff090583f694" id="r_a24a93e15e9f6d9aa3534ff090583f694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a24a93e15e9f6d9aa3534ff090583f694">print</a> (std::ostream &amp;out, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;regdict, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">InstructionSemantics::BaseSemantics::Formatter</a> &amp;fmt) const</td></tr>
<tr class="memdesc:a24a93e15e9f6d9aa3534ff090583f694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an abstract location.  <br /></td></tr>
<tr class="separator:a24a93e15e9f6d9aa3534ff090583f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1Location"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1Location')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1Location.html">Rose::Location</a></td></tr>
<tr class="memitem:aba14ab381a79d16566c477286521a9ac inherit pub_methods_classRose_1_1Location" id="r_aba14ab381a79d16566c477286521a9ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Location.html#aba14ab381a79d16566c477286521a9ac">operator==</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;other) const final</td></tr>
<tr class="memdesc:aba14ab381a79d16566c477286521a9ac inherit pub_methods_classRose_1_1Location"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality and inequality.  <br /></td></tr>
<tr class="separator:aba14ab381a79d16566c477286521a9ac inherit pub_methods_classRose_1_1Location"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347e8b669ee8bef94f6ea600e2b1427a inherit pub_methods_classRose_1_1Location" id="r_a347e8b669ee8bef94f6ea600e2b1427a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Location.html#a347e8b669ee8bef94f6ea600e2b1427a">operator!=</a> (const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;other) const final</td></tr>
<tr class="memdesc:a347e8b669ee8bef94f6ea600e2b1427a inherit pub_methods_classRose_1_1Location"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality and inequality.  <br /></td></tr>
<tr class="separator:a347e8b669ee8bef94f6ea600e2b1427a inherit pub_methods_classRose_1_1Location"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c1188aa9e202654dfdda632a9d794e inherit pub_methods_classRose_1_1Location" id="r_aa4c1188aa9e202654dfdda632a9d794e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Location.html#aa4c1188aa9e202654dfdda632a9d794e">operator bool</a> () const final</td></tr>
<tr class="memdesc:aa4c1188aa9e202654dfdda632a9d794e inherit pub_methods_classRose_1_1Location"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object is valid.  <br /></td></tr>
<tr class="separator:aa4c1188aa9e202654dfdda632a9d794e inherit pub_methods_classRose_1_1Location"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d74ace5e568b55ff29939feb718c76 inherit pub_methods_classRose_1_1Location" id="r_aa7d74ace5e568b55ff29939feb718c76"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Location.html#aa7d74ace5e568b55ff29939feb718c76">operator!</a> () const final</td></tr>
<tr class="memdesc:aa7d74ace5e568b55ff29939feb718c76 inherit pub_methods_classRose_1_1Location"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object is empty.  <br /></td></tr>
<tr class="separator:aa7d74ace5e568b55ff29939feb718c76 inherit pub_methods_classRose_1_1Location"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5afe20213403ffc24efdda9d5c9cfe inherit pub_methods_classRose_1_1Location" id="r_a3a5afe20213403ffc24efdda9d5c9cfe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Location.html#a3a5afe20213403ffc24efdda9d5c9cfe">isEmpty</a> () const final</td></tr>
<tr class="memdesc:a3a5afe20213403ffc24efdda9d5c9cfe inherit pub_methods_classRose_1_1Location"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this object is empty.  <br /></td></tr>
<tr class="separator:a3a5afe20213403ffc24efdda9d5c9cfe inherit pub_methods_classRose_1_1Location"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a410ed83e36bfd2c35d6c6c3b87e0fa26" id="r_a410ed83e36bfd2c35d6c6c3b87e0fa26"><td class="memItemLeft" align="right" valign="top"><a id="a410ed83e36bfd2c35d6c6c3b87e0fa26" name="a410ed83e36bfd2c35d6c6c3b87e0fa26"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a410ed83e36bfd2c35d6c6c3b87e0fa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an abstract location from a string. <br /></td></tr>
<tr class="separator:a410ed83e36bfd2c35d6c6c3b87e0fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa177db2769cae056e0261d8f04d268e0" name="aa177db2769cae056e0261d8f04d268e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa177db2769cae056e0261d8f04d268e0">&#9670;&#160;</a></span>Address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Rose::BinaryAnalysis::AbstractLocation::Address</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of memory address. </p>

<p class="definition">Definition at line <a class="el" href="AbstractLocation_8h_source.html#l00034">34</a> of file <a class="el" href="AbstractLocation_8h_source.html">AbstractLocation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f8b78269b71a7d48f6f1d021bdbb84d" name="a2f8b78269b71a7d48f6f1d021bdbb84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8b78269b71a7d48f6f1d021bdbb84d">&#9670;&#160;</a></span>AbstractLocation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::AbstractLocation::AbstractLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an abstract location that does not refer to any location. The <a class="el" href="classRose_1_1Location.html#a3a5afe20213403ffc24efdda9d5c9cfe">isEmpty</a> method will return true for such objects. </p>

</div>
</div>
<a id="afe24a4c3d656c065a3bd2854c852a5a7" name="afe24a4c3d656c065a3bd2854c852a5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe24a4c3d656c065a3bd2854c852a5a7">&#9670;&#160;</a></span>AbstractLocation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::AbstractLocation::AbstractLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register referent. </p>
<p>Constructs an abstract location that refers to a register. </p>

</div>
</div>
<a id="ae5cd588074ad36087a60deca947311a7" name="ae5cd588074ad36087a60deca947311a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cd588074ad36087a60deca947311a7">&#9670;&#160;</a></span>AbstractLocation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::AbstractLocation::AbstractLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>regdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register referent. </p>
<p>Constructs an abstract location that refers to a register. </p>

</div>
</div>
<a id="a2c1495feb45ba1a1b9d10bdcb25ce05a" name="a2c1495feb45ba1a1b9d10bdcb25ce05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1495feb45ba1a1b9d10bdcb25ce05a">&#9670;&#160;</a></span>AbstractLocation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::AbstractLocation::AbstractLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Address</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory referent. </p>
<p>Constructs an abstract location that refers to a memory location. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af913b22c50b0aaf22fbfa09f6146be38" name="af913b22c50b0aaf22fbfa09f6146be38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af913b22c50b0aaf22fbfa09f6146be38">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether this object is valid. </p>

<p>Implements <a class="el" href="classRose_1_1Location.html#a368f993efa170f736c8b587129a1625c">Rose::Location</a>.</p>

</div>
</div>
<a id="aa9382261731904254853ad44680f7150" name="aa9382261731904254853ad44680f7150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9382261731904254853ad44680f7150">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::AbstractLocation::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert location to string. </p>
<p>Returns a string representation of the location. This representation is not necessarily parsable.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a6ab383aaa1581897dd66ec07f3cc3516">print</a>. </p>

<p>Implements <a class="el" href="classRose_1_1Location.html#af5d5615058f9bd9ed425a001dafccc5d">Rose::Location</a>.</p>

</div>
</div>
<a id="a6ab383aaa1581897dd66ec07f3cc3516" name="a6ab383aaa1581897dd66ec07f3cc3516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab383aaa1581897dd66ec07f3cc3516">&#9670;&#160;</a></span>print() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::AbstractLocation::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output location to a stream. </p>
<p>The format is the same as the <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa9382261731904254853ad44680f7150">toString</a> method and is not necessarily parsable.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa9382261731904254853ad44680f7150">toString</a>. </p>

<p>Implements <a class="el" href="classRose_1_1Location.html#ab6b6d5e37cdb35011729f18b01d63c27">Rose::Location</a>.</p>

</div>
</div>
<a id="a34967e62fb6e8eb2dfd860b7e9240a3f" name="a34967e62fb6e8eb2dfd860b7e9240a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34967e62fb6e8eb2dfd860b7e9240a3f">&#9670;&#160;</a></span>printableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::AbstractLocation::printableName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert location to escaped, parsable string. </p>
<p>Returns a string that can be safely emitted to a terminal. The format should also be parsable so the static <code>parse</code> method in subclasses can create an equal object from the string. </p>

<p>Implements <a class="el" href="classRose_1_1Location.html#af5a73559fadd6d8836774411d26f9b0c">Rose::Location</a>.</p>

</div>
</div>
<a id="afd4c21e855c461f54b9927b98d222315" name="afd4c21e855c461f54b9927b98d222315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4c21e855c461f54b9927b98d222315">&#9670;&#160;</a></span>isEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::isEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality and inequality. </p>
<p>Objects are equal if they are the same type and they point to the same location. Otherwise they are unequal.</p>
<p>The operator== is implemented in the base class only. For the expression <code>a == b</code> it calls both <code>a.isEqual(b)</code> and <code>b.isEqual(a)</code>, returning true only if both tests return true. Subclasses should implement <code>x.isEqual(y)</code> by dynamic casting <code>y</code> to the type of <code>x</code> and returning true if and only if the cast succeeds and <code>x</code> and <code>y</code> point to the same location.</p>
<p>The operator!= is implemented in the base class as the complement of operator==. </p>

<p>Implements <a class="el" href="classRose_1_1Location.html#ace581d4851fa26644afd9f96c41e989a">Rose::Location</a>.</p>

</div>
</div>
<a id="a517425a3fbea79c73c0da976d052b9fa" name="a517425a3fbea79c73c0da976d052b9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517425a3fbea79c73c0da976d052b9fa">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1Location.html">Rose::Location</a>.</p>

</div>
</div>
<a id="a92009e8d3d7640da44547445da9fc4a3" name="a92009e8d3d7640da44547445da9fc4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92009e8d3d7640da44547445da9fc4a3">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1Location.html">Rose::Location</a>.</p>

</div>
</div>
<a id="a84313fa72c40ef0abe84df4bf9b64f4b" name="a84313fa72c40ef0abe84df4bf9b64f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84313fa72c40ef0abe84df4bf9b64f4b">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1Location.html">Rose::Location</a>.</p>

</div>
</div>
<a id="ace3ec9ae4fba9d115d034221e4d5bb99" name="ace3ec9ae4fba9d115d034221e4d5bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3ec9ae4fba9d115d034221e4d5bb99">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::AbstractLocation::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1Location.html">Rose::Location</a>.</p>

</div>
</div>
<a id="a527f75f9ed2088f1d054fecce7daa643" name="a527f75f9ed2088f1d054fecce7daa643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527f75f9ed2088f1d054fecce7daa643">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rose::BinaryAnalysis::AbstractLocation::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two abstract locations. </p>
<p>Returns -1 if this location is less than <code>other</code>, 1 if this location is greater than <code>other</code>, or zero if this location is equal to <code>other</code>. </p>

</div>
</div>
<a id="a22cd2c01cc8fdfc28f806ed88ad993f3" name="a22cd2c01cc8fdfc28f806ed88ad993f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cd2c01cc8fdfc28f806ed88ad993f3">&#9670;&#160;</a></span>isRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::AbstractLocation::isRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks register reference. </p>
<p>Returns true if and only if this abstract location refers to a register. It is impossible for an abstract location to refer to both a register and memory. </p>

</div>
</div>
<a id="a89643e545e9c235df7e8b520e2f20f0c" name="a89643e545e9c235df7e8b520e2f20f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89643e545e9c235df7e8b520e2f20f0c">&#9670;&#160;</a></span>isAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::AbstractLocation::isAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks memory reference. </p>
<p>Returns true if and only if this abstract location refers to memory. It is impossible for an abstract location to refer to both a register and memory </p>

</div>
</div>
<a id="acd197ace13c0ac5eeb3924b689790261" name="acd197ace13c0ac5eeb3924b689790261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd197ace13c0ac5eeb3924b689790261">&#9670;&#160;</a></span>getRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::AbstractLocation::getRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns register. </p>
<p>Returns the register to which this abstract location refers. When called for an abstract location for which <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a22cd2c01cc8fdfc28f806ed88ad993f3">isRegister</a> returns false, the return value is an invalid register descriptor (i.e., one for which RegisterDescriptor::is_valid returns false. </p>

</div>
</div>
<a id="a8b185600f3ac24e3f8786ca03eadfd4d" name="a8b185600f3ac24e3f8786ca03eadfd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b185600f3ac24e3f8786ca03eadfd4d">&#9670;&#160;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#aa177db2769cae056e0261d8f04d268e0">Address</a> Rose::BinaryAnalysis::AbstractLocation::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns memory address. </p>
<p>Returns the memory address to which this abstract location refers. When called for an abstract location for which <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a89643e545e9c235df7e8b520e2f20f0c">isAddress</a> returns false, the return value is a null pointer. </p>

</div>
</div>
<a id="a9940167a24d0076e4e6f61b220b14dc2" name="a9940167a24d0076e4e6f61b220b14dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9940167a24d0076e4e6f61b220b14dc2">&#9670;&#160;</a></span>nBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::AbstractLocation::nBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns size of memory location in bytes. </p>
<p>Returns the size of the memory location in bytes if known, otherwise zero. It is not valid to call this for an abstract location that points to a register since registers are not always a multiple of the byte size. </p>

</div>
</div>
<a id="a53744f182b6384b4dc73c9afee48cc7d" name="a53744f182b6384b4dc73c9afee48cc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53744f182b6384b4dc73c9afee48cc7d">&#9670;&#160;</a></span>mayAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::AbstractLocation::mayAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if two abstract locations could be aliases. </p>
<p>Two abstract locations are aliases if they refer to the exact same register or memory address. By this definition, the AX and EAX registers in x86 are not aliases because they do not refer to the exact same register (one is 16 bits and the other is 32 bits, although the low-order 16 bits are aliases). Likewise, memory addresses are assumed to refer to 8 bit values and two memory addresses are aliases only when they are equal.</p>
<p>Since memory addresses may be symbolic, this function uses an SMT solver to return true if and only if equality of two addresses is satisfiable. </p>

</div>
</div>
<a id="a6083ee550548c8218354acd73148f5a2" name="a6083ee550548c8218354acd73148f5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6083ee550548c8218354acd73148f5a2">&#9670;&#160;</a></span>mustAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::AbstractLocation::mustAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if two abstract locations are certainly aliases. </p>
<p>Two abstract locations are aliases if they refer to the exact same register or memory address. By this definition, the AX and EAX registers in x86 are not aliases because they do not refer to the exact same register (one is 16 bits and the other is 32 bits, although the low-order 16 bits are aliases). Likewise, memory addresses are assumed to refer to 8 bit values and two memory addresses are aliases only when they are equal.</p>
<p>Since memory addresses may be symbolic, this function uses an SMT solver to return true if and only if the inequality of two addresses is unsatisfiable. </p>

</div>
</div>
<a id="a846d78f9cb26b0675e5835f2188cd7a2" name="a846d78f9cb26b0675e5835f2188cd7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846d78f9cb26b0675e5835f2188cd7a2">&#9670;&#160;</a></span>print() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::AbstractLocation::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>regdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an abstract location. </p>
<p>The optional register dictionary is used for register names, the optional formatter is used for memory address expressions. </p>

</div>
</div>
<a id="a04e50181887a342db98622471afc39b7" name="a04e50181887a342db98622471afc39b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e50181887a342db98622471afc39b7">&#9670;&#160;</a></span>print() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::AbstractLocation::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">InstructionSemantics::BaseSemantics::Formatter</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an abstract location. </p>
<p>The optional register dictionary is used for register names, the optional formatter is used for memory address expressions. </p>

</div>
</div>
<a id="a24a93e15e9f6d9aa3534ff090583f694" name="a24a93e15e9f6d9aa3534ff090583f694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a93e15e9f6d9aa3534ff090583f694">&#9670;&#160;</a></span>print() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::AbstractLocation::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>regdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">InstructionSemantics::BaseSemantics::Formatter</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an abstract location. </p>
<p>The optional register dictionary is used for register names, the optional formatter is used for memory address expressions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AbstractLocation_8h_source.html">AbstractLocation.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
