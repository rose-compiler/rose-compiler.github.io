<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Unparser::State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Unparser.html">Unparser</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Unparser::State Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> for unparsing. </p>
<p>This object stores the current state for unparsing. The state is kept separate from the unparser class so that (1) the unparser can be a const reference, and (2) multiple threads can be unparsing with the same unparser object. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00198">198</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Unparser_2Base_8h_source.html">Rose/BinaryAnalysis/Unparser/Base.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d08abd768c9aaaa591b0cdf8e3ac0ec" id="r_a9d08abd768c9aaaa591b0cdf8e3ac0ec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; rose_addr_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a9d08abd768c9aaaa591b0cdf8e3ac0ec">AddrString</a></td></tr>
<tr class="memdesc:a9d08abd768c9aaaa591b0cdf8e3ac0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> from address to string.  <br /></td></tr>
<tr class="separator:a9d08abd768c9aaaa591b0cdf8e3ac0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb4f0429fbdd5e2b26916b1b6591ec06" id="r_afb4f0429fbdd5e2b26916b1b6591ec06"><td class="memItemLeft" align="right" valign="top"><a id="afb4f0429fbdd5e2b26916b1b6591ec06" name="afb4f0429fbdd5e2b26916b1b6591ec06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>State</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a>)</td></tr>
<tr class="separator:afb4f0429fbdd5e2b26916b1b6591ec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab5635b826578474f84047034a3f9d" id="r_aa8ab5635b826578474f84047034a3f9d"><td class="memItemLeft" align="right" valign="top"><a id="aa8ab5635b826578474f84047034a3f9d" name="aa8ab5635b826578474f84047034a3f9d"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partitioner</b> () const</td></tr>
<tr class="memdesc:aa8ab5635b826578474f84047034a3f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Partitioner, which may be null. <br /></td></tr>
<tr class="separator:aa8ab5635b826578474f84047034a3f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e72fe6972c146d0a75be5a7969ee0" id="r_aca2e72fe6972c146d0a75be5a7969ee0"><td class="memItemLeft" align="right" valign="top"><a id="aca2e72fe6972c146d0a75be5a7969ee0" name="aca2e72fe6972c146d0a75be5a7969ee0"></a>
const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">Partitioner2::FunctionCallGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>cg</b> () const</td></tr>
<tr class="memdesc:aca2e72fe6972c146d0a75be5a7969ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Call grap, which may be empty. <br /></td></tr>
<tr class="separator:aca2e72fe6972c146d0a75be5a7969ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac01ef84ea6c542334ba09001cd3e4d9" id="r_aac01ef84ea6c542334ba09001cd3e4d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#aac01ef84ea6c542334ba09001cd3e4d9">isCfgVertexReachable</a> (size_t vertexId) const</td></tr>
<tr class="memdesc:aac01ef84ea6c542334ba09001cd3e4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reachability based on the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a22d88bd83f0dd5d6c565fc45b2e5103e">cfgVertexReachability</a> property.  <br /></td></tr>
<tr class="separator:aac01ef84ea6c542334ba09001cd3e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1638e6d5d48b0b3aef9a40cb8cc3651" id="r_aa1638e6d5d48b0b3aef9a40cb8cc3651"><td class="memItemLeft" align="right" valign="top"><a id="aa1638e6d5d48b0b3aef9a40cb8cc3651" name="aa1638e6d5d48b0b3aef9a40cb8cc3651"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>thisIsBasicBlockFirstInstruction</b> ()</td></tr>
<tr class="memdesc:aa1638e6d5d48b0b3aef9a40cb8cc3651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this when you're about to output the first instruction of a basic block. <br /></td></tr>
<tr class="separator:aa1638e6d5d48b0b3aef9a40cb8cc3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedc2dd54844c70485aa1155970a562f" id="r_afedc2dd54844c70485aa1155970a562f"><td class="memItemLeft" align="right" valign="top"><a id="afedc2dd54844c70485aa1155970a562f" name="afedc2dd54844c70485aa1155970a562f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>thisIsBasicBlockLastInstruction</b> ()</td></tr>
<tr class="memdesc:afedc2dd54844c70485aa1155970a562f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this when you're about to output the last instruction of a basic block. <br /></td></tr>
<tr class="separator:afedc2dd54844c70485aa1155970a562f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753e4ffcc3ccce21963961e8593b4f32" id="r_a753e4ffcc3ccce21963961e8593b4f32"><td class="memItemLeft" align="right" valign="top"><a id="a753e4ffcc3ccce21963961e8593b4f32" name="a753e4ffcc3ccce21963961e8593b4f32"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>currentFunction</b> () const</td></tr>
<tr class="separator:a753e4ffcc3ccce21963961e8593b4f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f60550f7132c971e425829e38e7ac1d" id="r_a7f60550f7132c971e425829e38e7ac1d"><td class="memItemLeft" align="right" valign="top"><a id="a7f60550f7132c971e425829e38e7ac1d" name="a7f60550f7132c971e425829e38e7ac1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>currentFunction</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;)</td></tr>
<tr class="separator:a7f60550f7132c971e425829e38e7ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480887d5696601c0a07fdbba952499f" id="r_a6480887d5696601c0a07fdbba952499f"><td class="memItemLeft" align="right" valign="top"><a id="a6480887d5696601c0a07fdbba952499f" name="a6480887d5696601c0a07fdbba952499f"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>currentBasicBlock</b> () const</td></tr>
<tr class="separator:a6480887d5696601c0a07fdbba952499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c003dc165407dca99c5eeedc633d603" id="r_a6c003dc165407dca99c5eeedc633d603"><td class="memItemLeft" align="right" valign="top"><a id="a6c003dc165407dca99c5eeedc633d603" name="a6c003dc165407dca99c5eeedc633d603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>currentBasicBlock</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;)</td></tr>
<tr class="separator:a6c003dc165407dca99c5eeedc633d603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8ae3c2acf3be1c6197ae8231c53c71" id="r_acc8ae3c2acf3be1c6197ae8231c53c71"><td class="memItemLeft" align="right" valign="top"><a id="acc8ae3c2acf3be1c6197ae8231c53c71" name="acc8ae3c2acf3be1c6197ae8231c53c71"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextInsnLabel</b> () const</td></tr>
<tr class="separator:acc8ae3c2acf3be1c6197ae8231c53c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e9b10d843cec40b84c449652a8f814" id="r_a31e9b10d843cec40b84c449652a8f814"><td class="memItemLeft" align="right" valign="top"><a id="a31e9b10d843cec40b84c449652a8f814" name="a31e9b10d843cec40b84c449652a8f814"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nextInsnLabel</b> (const std::string &amp;)</td></tr>
<tr class="separator:a31e9b10d843cec40b84c449652a8f814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951bcfcde23af7606cdb3f8ed925ed0" id="r_a7951bcfcde23af7606cdb3f8ed925ed0"><td class="memItemLeft" align="right" valign="top"><a id="a7951bcfcde23af7606cdb3f8ed925ed0" name="a7951bcfcde23af7606cdb3f8ed925ed0"></a>
const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterNames.html">RegisterNames</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>registerNames</b> () const</td></tr>
<tr class="separator:a7951bcfcde23af7606cdb3f8ed925ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4954ca4224065310e0a68f8c8995c1e" id="r_ad4954ca4224065310e0a68f8c8995c1e"><td class="memItemLeft" align="right" valign="top"><a id="ad4954ca4224065310e0a68f8c8995c1e" name="ad4954ca4224065310e0a68f8c8995c1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>registerNames</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterNames.html">RegisterNames</a> &amp;r)</td></tr>
<tr class="separator:ad4954ca4224065310e0a68f8c8995c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8753eabb25b2522caf555838b26471f1" id="r_a8753eabb25b2522caf555838b26471f1"><td class="memItemLeft" align="right" valign="top"><a id="a8753eabb25b2522caf555838b26471f1" name="a8753eabb25b2522caf555838b26471f1"></a>
const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a9d08abd768c9aaaa591b0cdf8e3ac0ec">AddrString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basicBlockLabels</b> () const</td></tr>
<tr class="separator:a8753eabb25b2522caf555838b26471f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf246d8dfaab07bac69a49177b64080" id="r_a7bf246d8dfaab07bac69a49177b64080"><td class="memItemLeft" align="right" valign="top"><a id="a7bf246d8dfaab07bac69a49177b64080" name="a7bf246d8dfaab07bac69a49177b64080"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a9d08abd768c9aaaa591b0cdf8e3ac0ec">AddrString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>basicBlockLabels</b> ()</td></tr>
<tr class="separator:a7bf246d8dfaab07bac69a49177b64080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70640faf0a631e23edcd578ce0218032" id="r_a70640faf0a631e23edcd578ce0218032"><td class="memItemLeft" align="right" valign="top"><a id="a70640faf0a631e23edcd578ce0218032" name="a70640faf0a631e23edcd578ce0218032"></a>
const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>frontUnparser</b> () const</td></tr>
<tr class="memdesc:a70640faf0a631e23edcd578ce0218032"><td class="mdescLeft">&#160;</td><td class="mdescRight">First unparser in the chained list of unparsers. <br /></td></tr>
<tr class="separator:a70640faf0a631e23edcd578ce0218032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22d88bd83f0dd5d6c565fc45b2e5103e" id="r_a22d88bd83f0dd5d6c565fc45b2e5103e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a22d88bd83f0dd5d6c565fc45b2e5103e">cfgVertexReachability</a> () const</td></tr>
<tr class="memdesc:a22d88bd83f0dd5d6c565fc45b2e5103e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html" title="Analysis that computes reachability of CFG vertices.">Reachability</a> analysis results.  <br /></td></tr>
<tr class="separator:a22d88bd83f0dd5d6c565fc45b2e5103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24cde4fdd590ccdff03c32c52212de6" id="r_af24cde4fdd590ccdff03c32c52212de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#af24cde4fdd590ccdff03c32c52212de6">cfgVertexReachability</a> (const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> &gt; &amp;)</td></tr>
<tr class="memdesc:af24cde4fdd590ccdff03c32c52212de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html" title="Analysis that computes reachability of CFG vertices.">Reachability</a> analysis results.  <br /></td></tr>
<tr class="separator:af24cde4fdd590ccdff03c32c52212de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a985facda40ce31cc8beb9cb90ea11da7" id="r_a985facda40ce31cc8beb9cb90ea11da7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a985facda40ce31cc8beb9cb90ea11da7">intraFunctionCfgArrows</a> () const</td></tr>
<tr class="memdesc:a985facda40ce31cc8beb9cb90ea11da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph arrows within a function.  <br /></td></tr>
<tr class="separator:a985facda40ce31cc8beb9cb90ea11da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d652f6c893f409d37b5d96a30a8a1d" id="r_a53d652f6c893f409d37b5d96a30a8a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a53d652f6c893f409d37b5d96a30a8a1d">intraFunctionCfgArrows</a> ()</td></tr>
<tr class="memdesc:a53d652f6c893f409d37b5d96a30a8a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow graph arrows within a function.  <br /></td></tr>
<tr class="separator:a53d652f6c893f409d37b5d96a30a8a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abde9556b2289fda9161c514fd54292e0" id="r_abde9556b2289fda9161c514fd54292e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a> () const</td></tr>
<tr class="memdesc:abde9556b2289fda9161c514fd54292e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined intra-function margin arrows.  <br /></td></tr>
<tr class="separator:abde9556b2289fda9161c514fd54292e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a62b7943f8937d5f563d88c972dd07c" id="r_a3a62b7943f8937d5f563d88c972dd07c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a3a62b7943f8937d5f563d88c972dd07c">intraFunctionBlockArrows</a> ()</td></tr>
<tr class="memdesc:a3a62b7943f8937d5f563d88c972dd07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined intra-function margin arrows.  <br /></td></tr>
<tr class="separator:a3a62b7943f8937d5f563d88c972dd07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acc709bc7ceb85aa4a920fda1185d8bcb" id="r_acc709bc7ceb85aa4a920fda1185d8bcb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#acc709bc7ceb85aa4a920fda1185d8bcb">globalBlockArrows</a> () const</td></tr>
<tr class="memdesc:acc709bc7ceb85aa4a920fda1185d8bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined arrows to basic blocks across entire output.  <br /></td></tr>
<tr class="separator:acc709bc7ceb85aa4a920fda1185d8bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f7ba52f3a65efe64ddc81e7a803387" id="r_a48f7ba52f3a65efe64ddc81e7a803387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a48f7ba52f3a65efe64ddc81e7a803387">globalBlockArrows</a> ()</td></tr>
<tr class="memdesc:a48f7ba52f3a65efe64ddc81e7a803387"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined arrows to basic blocks across entire output.  <br /></td></tr>
<tr class="separator:a48f7ba52f3a65efe64ddc81e7a803387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae58453d7648302b8696a45346b1c6fb3" id="r_ae58453d7648302b8696a45346b1c6fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a7fb9c48cb4ca39f33f31125e3825aabf">EdgeArrows::VertexId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#ae58453d7648302b8696a45346b1c6fb3">currentPredSuccId</a> () const</td></tr>
<tr class="memdesc:ae58453d7648302b8696a45346b1c6fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: ID for CFG edge arrow endpoint.  <br /></td></tr>
<tr class="separator:ae58453d7648302b8696a45346b1c6fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3bb3a19ef149a833954cadc37690f3" id="r_aaf3bb3a19ef149a833954cadc37690f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#aaf3bb3a19ef149a833954cadc37690f3">currentPredSuccId</a> (<a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a7fb9c48cb4ca39f33f31125e3825aabf">EdgeArrows::VertexId</a> &gt; id)</td></tr>
<tr class="memdesc:aaf3bb3a19ef149a833954cadc37690f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: ID for CFG edge arrow endpoint.  <br /></td></tr>
<tr class="separator:aaf3bb3a19ef149a833954cadc37690f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a03981cc01855ce569c3bcfd85eb9f127" id="r_a03981cc01855ce569c3bcfd85eb9f127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a03981cc01855ce569c3bcfd85eb9f127">cfgArrowsPointToInsns</a> () const</td></tr>
<tr class="memdesc:a03981cc01855ce569c3bcfd85eb9f127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether CFG margin arrows point to instructions.  <br /></td></tr>
<tr class="separator:a03981cc01855ce569c3bcfd85eb9f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f2d83de9316ed0ca0e053accd1d577" id="r_aa7f2d83de9316ed0ca0e053accd1d577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#aa7f2d83de9316ed0ca0e053accd1d577">cfgArrowsPointToInsns</a> (bool b)</td></tr>
<tr class="memdesc:aa7f2d83de9316ed0ca0e053accd1d577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether CFG margin arrows point to instructions.  <br /></td></tr>
<tr class="separator:aa7f2d83de9316ed0ca0e053accd1d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa83217671390867851b4c3408b61fb2c" id="r_aa83217671390867851b4c3408b61fb2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1StyleStack.html">StyleStack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#aa83217671390867851b4c3408b61fb2c">styleStack</a> () const</td></tr>
<tr class="memdesc:aa83217671390867851b4c3408b61fb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack of styles.  <br /></td></tr>
<tr class="separator:aa83217671390867851b4c3408b61fb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c1476c56585d7ac6082ea9cca78c8" id="r_aab6c1476c56585d7ac6082ea9cca78c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1StyleStack.html">StyleStack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#aab6c1476c56585d7ac6082ea9cca78c8">styleStack</a> ()</td></tr>
<tr class="memdesc:aab6c1476c56585d7ac6082ea9cca78c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack of styles.  <br /></td></tr>
<tr class="separator:aab6c1476c56585d7ac6082ea9cca78c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abc8bbca39329036ed36ce98fe699bf7a" id="r_abc8bbca39329036ed36ce98fe699bf7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abc8bbca39329036ed36ce98fe699bf7a">reachabilityName</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a57920b72f86df51e71a1aa7a9d3b1b72">Reachability::Reason</a> value, const std::string &amp;name)</td></tr>
<tr class="memdesc:abc8bbca39329036ed36ce98fe699bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a reachability name to a reachability value.  <br /></td></tr>
<tr class="separator:abc8bbca39329036ed36ce98fe699bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610896053f7220c7d6695eaead6e9905" id="r_a610896053f7220c7d6695eaead6e9905"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a610896053f7220c7d6695eaead6e9905">reachabilityName</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> value) const</td></tr>
<tr class="memdesc:a610896053f7220c7d6695eaead6e9905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a reachability name to a reachability value.  <br /></td></tr>
<tr class="separator:a610896053f7220c7d6695eaead6e9905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9d08abd768c9aaaa591b0cdf8e3ac0ec" name="a9d08abd768c9aaaa591b0cdf8e3ac0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d08abd768c9aaaa591b0cdf8e3ac0ec">&#9670;&#160;</a></span>AddrString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;rose_addr_t, std::string&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a9d08abd768c9aaaa591b0cdf8e3ac0ec">Rose::BinaryAnalysis::Unparser::State::AddrString</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> from address to string. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00200">200</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22d88bd83f0dd5d6c565fc45b2e5103e" name="a22d88bd83f0dd5d6c565fc45b2e5103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d88bd83f0dd5d6c565fc45b2e5103e">&#9670;&#160;</a></span>cfgVertexReachability() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> &gt; Rose::BinaryAnalysis::Unparser::State::cfgVertexReachability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html" title="Analysis that computes reachability of CFG vertices.">Reachability</a> analysis results. </p>
<p>This property stores a vector indexed by CFG vertex IDs that holds information about whether the vertex is reachable and why. </p>

</div>
</div>
<a id="af24cde4fdd590ccdff03c32c52212de6" name="af24cde4fdd590ccdff03c32c52212de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24cde4fdd590ccdff03c32c52212de6">&#9670;&#160;</a></span>cfgVertexReachability() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::State::cfgVertexReachability </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html" title="Analysis that computes reachability of CFG vertices.">Reachability</a> analysis results. </p>
<p>This property stores a vector indexed by CFG vertex IDs that holds information about whether the vertex is reachable and why. </p>

</div>
</div>
<a id="aac01ef84ea6c542334ba09001cd3e4d9" name="aac01ef84ea6c542334ba09001cd3e4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac01ef84ea6c542334ba09001cd3e4d9">&#9670;&#160;</a></span>isCfgVertexReachable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a> Rose::BinaryAnalysis::Unparser::State::isCfgVertexReachable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertexId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reachability based on the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a22d88bd83f0dd5d6c565fc45b2e5103e">cfgVertexReachability</a> property. </p>
<p>If the property has more elements than vertices in the CFG, then the extras are ignored; if the CFG is larger then the missing reachability values are assumed to be zero. </p>

</div>
</div>
<a id="a985facda40ce31cc8beb9cb90ea11da7" name="a985facda40ce31cc8beb9cb90ea11da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985facda40ce31cc8beb9cb90ea11da7">&#9670;&#160;</a></span>intraFunctionCfgArrows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::intraFunctionCfgArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow graph arrows within a function. </p>
<p>This property holds information about how and when to draw arrows in the left margin to represent the edges of a control flow graph whose endpoints are both within the same function. The object is initialized each time a function is entered (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a22df544f6a5e717d8e4d77f69129e029">Base::emitFunction</a>) just before emitting the first basic block, but only if the unparser settings indicate that these margin arrows should be displayed. The object is reset just after printing the basic blocks. The object should be in a default state when printing the function prologue and epilogue information, otherwise those parts of the output would be unecessarily indented.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#acc709bc7ceb85aa4a920fda1185d8bcb">globalBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00258">258</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="a53d652f6c893f409d37b5d96a30a8a1d" name="a53d652f6c893f409d37b5d96a30a8a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d652f6c893f409d37b5d96a30a8a1d">&#9670;&#160;</a></span>intraFunctionCfgArrows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::intraFunctionCfgArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow graph arrows within a function. </p>
<p>This property holds information about how and when to draw arrows in the left margin to represent the edges of a control flow graph whose endpoints are both within the same function. The object is initialized each time a function is entered (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a22df544f6a5e717d8e4d77f69129e029">Base::emitFunction</a>) just before emitting the first basic block, but only if the unparser settings indicate that these margin arrows should be displayed. The object is reset just after printing the basic blocks. The object should be in a default state when printing the function prologue and epilogue information, otherwise those parts of the output would be unecessarily indented.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#acc709bc7ceb85aa4a920fda1185d8bcb">globalBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00259">259</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="abde9556b2289fda9161c514fd54292e0" name="abde9556b2289fda9161c514fd54292e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde9556b2289fda9161c514fd54292e0">&#9670;&#160;</a></span>intraFunctionBlockArrows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::intraFunctionBlockArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined intra-function margin arrows. </p>
<p>This object holds information about user-defined arrows in the margin. These arrows point to/from basic blocks such that both basic blocks are in the same function.</p>
<p>To update these arrows during unparsing, the user should provide an unparser updateIntraFunctionArrows either by class derivation or chaining. The actual information about the arrows will be in that function's <code>state</code> argument in <code>state.intraFunctionBlockArrows()</code>.arrows. Although it will have already been computed, the <code>state.intraFunctionCfgArrows</code> can be adjusted at the same time.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a985facda40ce31cc8beb9cb90ea11da7">intraFunctionCfgArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#acc709bc7ceb85aa4a920fda1185d8bcb">globalBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00275">275</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="a3a62b7943f8937d5f563d88c972dd07c" name="a3a62b7943f8937d5f563d88c972dd07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a62b7943f8937d5f563d88c972dd07c">&#9670;&#160;</a></span>intraFunctionBlockArrows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::intraFunctionBlockArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined intra-function margin arrows. </p>
<p>This object holds information about user-defined arrows in the margin. These arrows point to/from basic blocks such that both basic blocks are in the same function.</p>
<p>To update these arrows during unparsing, the user should provide an unparser updateIntraFunctionArrows either by class derivation or chaining. The actual information about the arrows will be in that function's <code>state</code> argument in <code>state.intraFunctionBlockArrows()</code>.arrows. Although it will have already been computed, the <code>state.intraFunctionCfgArrows</code> can be adjusted at the same time.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a985facda40ce31cc8beb9cb90ea11da7">intraFunctionCfgArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#acc709bc7ceb85aa4a920fda1185d8bcb">globalBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00276">276</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="acc709bc7ceb85aa4a920fda1185d8bcb" name="acc709bc7ceb85aa4a920fda1185d8bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc709bc7ceb85aa4a920fda1185d8bcb">&#9670;&#160;</a></span>globalBlockArrows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::globalBlockArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined arrows to basic blocks across entire output. </p>
<p>This object holds information about user-defined arrows in the margin. These arrows point to/from basic blocks anywhere in the program (not just within functions as with <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>).</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a985facda40ce31cc8beb9cb90ea11da7">intraFunctionCfgArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00287">287</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="a48f7ba52f3a65efe64ddc81e7a803387" name="a48f7ba52f3a65efe64ddc81e7a803387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f7ba52f3a65efe64ddc81e7a803387">&#9670;&#160;</a></span>globalBlockArrows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1ArrowMargin.html">ArrowMargin</a> &amp; Rose::BinaryAnalysis::Unparser::State::globalBlockArrows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-defined arrows to basic blocks across entire output. </p>
<p>This object holds information about user-defined arrows in the margin. These arrows point to/from basic blocks anywhere in the program (not just within functions as with <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>).</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a985facda40ce31cc8beb9cb90ea11da7">intraFunctionCfgArrows</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#abde9556b2289fda9161c514fd54292e0">intraFunctionBlockArrows</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00288">288</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="ae58453d7648302b8696a45346b1c6fb3" name="ae58453d7648302b8696a45346b1c6fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58453d7648302b8696a45346b1c6fb3">&#9670;&#160;</a></span>currentPredSuccId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a7fb9c48cb4ca39f33f31125e3825aabf">EdgeArrows::VertexId</a> &gt; Rose::BinaryAnalysis::Unparser::State::currentPredSuccId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: ID for CFG edge arrow endpoint. </p>
<p>When generating margin arrows that point to the "predecessor:" and "successor:" lines of the output (instead of arrows that point to the basic block instructions), this property holds the ID number for the arrow endpoint. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a18c86449ca64c48c99d42db131c4cc85">EdgeArrows::computeCfgEdgeLayout</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00304">304</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="aaf3bb3a19ef149a833954cadc37690f3" name="aaf3bb3a19ef149a833954cadc37690f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3bb3a19ef149a833954cadc37690f3">&#9670;&#160;</a></span>currentPredSuccId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::State::currentPredSuccId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a7fb9c48cb4ca39f33f31125e3825aabf">EdgeArrows::VertexId</a> &gt;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: ID for CFG edge arrow endpoint. </p>
<p>When generating margin arrows that point to the "predecessor:" and "successor:" lines of the output (instead of arrows that point to the basic block instructions), this property holds the ID number for the arrow endpoint. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1EdgeArrows.html#a18c86449ca64c48c99d42db131c4cc85">EdgeArrows::computeCfgEdgeLayout</a>. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00305">305</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="a03981cc01855ce569c3bcfd85eb9f127" name="a03981cc01855ce569c3bcfd85eb9f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03981cc01855ce569c3bcfd85eb9f127">&#9670;&#160;</a></span>cfgArrowsPointToInsns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Unparser::State::cfgArrowsPointToInsns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether CFG margin arrows point to instructions. </p>
<p>If set, then the CFG arrows in the left margin origin from and point to instructions of basic blocks. If false, they originate from "successor:" lines and point to "predecessor:" lines. If there are no CFG margin arrows then the value of this property doesn't matter. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00315">315</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="aa7f2d83de9316ed0ca0e053accd1d577" name="aa7f2d83de9316ed0ca0e053accd1d577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f2d83de9316ed0ca0e053accd1d577">&#9670;&#160;</a></span>cfgArrowsPointToInsns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::State::cfgArrowsPointToInsns </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether CFG margin arrows point to instructions. </p>
<p>If set, then the CFG arrows in the left margin origin from and point to instructions of basic blocks. If false, they originate from "successor:" lines and point to "predecessor:" lines. If there are no CFG margin arrows then the value of this property doesn't matter. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00316">316</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="aa83217671390867851b4c3408b61fb2c" name="aa83217671390867851b4c3408b61fb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83217671390867851b4c3408b61fb2c">&#9670;&#160;</a></span>styleStack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1StyleStack.html">StyleStack</a> &amp; Rose::BinaryAnalysis::Unparser::State::styleStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Stack of styles. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00322">322</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="aab6c1476c56585d7ac6082ea9cca78c8" name="aab6c1476c56585d7ac6082ea9cca78c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6c1476c56585d7ac6082ea9cca78c8">&#9670;&#160;</a></span>styleStack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1StyleStack.html">StyleStack</a> &amp; Rose::BinaryAnalysis::Unparser::State::styleStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Stack of styles. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00323">323</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="abc8bbca39329036ed36ce98fe699bf7a" name="abc8bbca39329036ed36ce98fe699bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8bbca39329036ed36ce98fe699bf7a">&#9670;&#160;</a></span>reachabilityName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::State::reachabilityName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a57920b72f86df51e71a1aa7a9d3b1b72">Reachability::Reason</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a reachability name to a reachability value. </p>
<p>The two-argument version of this function associates a name with a value. An empty name clears the association.</p>
<p>The one-argument version returns the name corresponding to the value, or generates a name on the fly. To generate a name, the value is first looked up in the mapping and that name is used if present. Otherwise, the value is broken down into individual bits and the resulting string is the comma-separated names for each of the bits. If the mapping has a name for a bit then it's used. Otherwise, if the bit is greater than or equal to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a57920b72f86df51e71a1aa7a9d3b1b72">BinaryAnalysis::Reachability::Reason</a> <code>USER_DEFINED_0</code> the string will be "user-defined-x" where <code>x</code> is the number of bits to right shift the flag to make it equal to USER_DEFINED_0. Otherwise, the name of the bit is obtained by treating the value as an enum and obtaining the enum name. If that fails due to the fact that not all bits have corresponding enum constants, the name is the hexadecimal string for the bit. </p>

</div>
</div>
<a id="a610896053f7220c7d6695eaead6e9905" name="a610896053f7220c7d6695eaead6e9905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610896053f7220c7d6695eaead6e9905">&#9670;&#160;</a></span>reachabilityName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::State::reachabilityName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a396952b78b293a0619864a70319fa887">Reachability::ReasonFlags</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a reachability name to a reachability value. </p>
<p>The two-argument version of this function associates a name with a value. An empty name clears the association.</p>
<p>The one-argument version returns the name corresponding to the value, or generates a name on the fly. To generate a name, the value is first looked up in the mapping and that name is used if present. Otherwise, the value is broken down into individual bits and the resulting string is the comma-separated names for each of the bits. If the mapping has a name for a bit then it's used. Otherwise, if the bit is greater than or equal to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Reachability.html#a57920b72f86df51e71a1aa7a9d3b1b72">BinaryAnalysis::Reachability::Reason</a> <code>USER_DEFINED_0</code> the string will be "user-defined-x" where <code>x</code> is the number of bits to right shift the flag to make it equal to USER_DEFINED_0. Otherwise, the name of the bit is obtained by treating the value as an enum and obtaining the enum name. If that fails due to the fact that not all bits have corresponding enum constants, the name is the hexadecimal string for the bit. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
