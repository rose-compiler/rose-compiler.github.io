<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::EngineBinary Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::EngineBinary Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a> for specimens containing machine instructions. </p>
<p>This engine is reponsible for creating a partitioner for a specimen that has machine instructions such as the Intel x86 family of instruction sets, Arm instruction sets, PowerPC instructio sets, Motorola instruction sets, MIPS instruction sets, etc. It is specifically not to be used for byte code targeting the likes of the Java Virtual Machine (JVM) or the Common Language Runtime (CLR).</p>
<p>This engine provides an <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">instance</a> static member function that instantiates an engine of this type on the heap and returns a shared-ownership pointer to the instance. Refer to the base class, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a>, to learn how to instantiate engines from factories.</p>
<p>This engine uses a hybrid approach combining linear and recursvie diassembly. Linear disassembly progresses by starting at some low address in the specimen address space, disassembling one instruction, and then moving on to the next (fallthrough) address and repeating. This approach is quite good at disassembling everything (especially for fixed length instructions) but makes no attempt to organize instructions according to flow of control. On the other hand, recursive disassembly uses a work list containing known instruction addresses, disassembles an instruction from the worklist, determines its control flow successors, and adds those addresses to the work list. As a side effect, it produces a control flow graph. ROSE's hybrid approach uses linear disassembly to find starting points using heuristics such as common compiler function prologues and epilogues, references from symbol tables of various types, and other available data. Once starting points are known, ROSE uses recursive disassembly to follow the control flow. Various kinds of analysis and heuristics are used to control the finer points of recursive disassembly. Part of the trick to a successful and accurate disassembly of what is essentially equivalent to the halting problem, depends on finding the right balance between the pure recursive approach and the heuristics and analyses. This balance is often different for each kind of specimens. </p>

<p class="definition">Definition at line <a class="el" href="EngineBinary_8h_source.html#l00048">48</a> of file <a class="el" href="EngineBinary_8h_source.html">EngineBinary.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="EngineBinary_8h_source.html">Rose/BinaryAnalysis/Partitioner2/EngineBinary.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Partitioner2::EngineBinary:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_inherit__map">
<area shape="rect" title="Engine for specimens containing machine instructions." alt="" coords="5,93,187,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner." alt="" coords="22,5,170,45"/>
<area shape="poly" title=" " alt="" coords="99,59,99,93,93,93,93,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Partitioner2::EngineBinary:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_coll__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_coll__map">
<area shape="rect" title="Engine for specimens containing machine instructions." alt="" coords="5,93,187,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner." alt="" coords="22,5,170,45"/>
<area shape="poly" title=" " alt="" coords="99,59,99,93,93,93,93,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae3cf260dd6a68759d388ab2c97e281c6" id="r_ae3cf260dd6a68759d388ab2c97e281c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae3cf260dd6a68759d388ab2c97e281c6">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">EngineBinaryPtr</a></td></tr>
<tr class="memdesc:ae3cf260dd6a68759d388ab2c97e281c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:ae3cf260dd6a68759d388ab2c97e281c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a></td></tr>
<tr class="memitem:a6d6fb0584387aa535765e2b075086d67 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a6d6fb0584387aa535765e2b075086d67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6d6fb0584387aa535765e2b075086d67">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a></td></tr>
<tr class="memdesc:a6d6fb0584387aa535765e2b075086d67 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership pointer.  <br /></td></tr>
<tr class="separator:a6d6fb0584387aa535765e2b075086d67 inherit pub_types_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af55fe44a08aacc27646d9c2d0e3b988b" id="r_af55fe44a08aacc27646d9c2d0e3b988b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#af55fe44a08aacc27646d9c2d0e3b988b">loadVxCore</a> (const std::string &amp;spec)</td></tr>
<tr class="memdesc:af55fe44a08aacc27646d9c2d0e3b988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a vxcore specification and initializes memory.  <br /></td></tr>
<tr class="separator:af55fe44a08aacc27646d9c2d0e3b988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39c1182056d1aeb6e2ed37cae5f3af" id="r_afd39c1182056d1aeb6e2ed37cae5f3af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#afd39c1182056d1aeb6e2ed37cae5f3af">loadContainers</a> (const std::vector&lt; std::string &gt; &amp;fileNames)</td></tr>
<tr class="memdesc:afd39c1182056d1aeb6e2ed37cae5f3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads memory from binary containers.  <br /></td></tr>
<tr class="separator:afd39c1182056d1aeb6e2ed37cae5f3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99c554ea353e806ea2cd06c1cf91e8e" id="r_ad99c554ea353e806ea2cd06c1cf91e8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ad99c554ea353e806ea2cd06c1cf91e8e">loadNonContainers</a> (const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:ad99c554ea353e806ea2cd06c1cf91e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads memory from non-containers.  <br /></td></tr>
<tr class="separator:ad99c554ea353e806ea2cd06c1cf91e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaad4c513ab1367a57efb7020f59809b" id="r_adaad4c513ab1367a57efb7020f59809b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#adaad4c513ab1367a57efb7020f59809b">createTunedPartitioner</a> ()</td></tr>
<tr class="memdesc:adaad4c513ab1367a57efb7020f59809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tuned partitioner.  <br /></td></tr>
<tr class="separator:adaad4c513ab1367a57efb7020f59809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55935a1a8f329095d67e2db3297885e5" id="r_a55935a1a8f329095d67e2db3297885e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a55935a1a8f329095d67e2db3297885e5">createPartitionerFromAst</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a55935a1a8f329095d67e2db3297885e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partitioner from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.  <br /></td></tr>
<tr class="separator:a55935a1a8f329095d67e2db3297885e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064f6579ce755107d3068e8722ebbf8" id="r_a3064f6579ce755107d3068e8722ebbf8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3064f6579ce755107d3068e8722ebbf8">partitionCilSections</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a3064f6579ce755107d3068e8722ebbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition any sections containing CIL code.  <br /></td></tr>
<tr class="separator:a3064f6579ce755107d3068e8722ebbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920b49b4a35e607662ebe79ef38b684" id="r_ac920b49b4a35e607662ebe79ef38b684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac920b49b4a35e607662ebe79ef38b684">hasCilCodeSection</a> ()</td></tr>
<tr class="memdesc:ac920b49b4a35e607662ebe79ef38b684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the interpretation header contains a CIL code section.  <br /></td></tr>
<tr class="separator:ac920b49b4a35e607662ebe79ef38b684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743bb8de70898a560d3c5631352eb2d7" id="r_a743bb8de70898a560d3c5631352eb2d7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a743bb8de70898a560d3c5631352eb2d7">makeEntryFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a743bb8de70898a560d3c5631352eb2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions at specimen entry addresses.  <br /></td></tr>
<tr class="separator:a743bb8de70898a560d3c5631352eb2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79868798ac597701302c6eb6a4b8bcee" id="r_a79868798ac597701302c6eb6a4b8bcee"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a79868798ac597701302c6eb6a4b8bcee">makeErrorHandlingFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a79868798ac597701302c6eb6a4b8bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions at error handling addresses.  <br /></td></tr>
<tr class="separator:a79868798ac597701302c6eb6a4b8bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1c388456e2acfc151b837753c5b95" id="r_a3aa1c388456e2acfc151b837753c5b95"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3aa1c388456e2acfc151b837753c5b95">makeImportFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a3aa1c388456e2acfc151b837753c5b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions at import trampolines.  <br /></td></tr>
<tr class="separator:a3aa1c388456e2acfc151b837753c5b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc7d607787ddbd671d55461654fc9c2" id="r_a0bc7d607787ddbd671d55461654fc9c2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a0bc7d607787ddbd671d55461654fc9c2">makeExportFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a0bc7d607787ddbd671d55461654fc9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions at export addresses.  <br /></td></tr>
<tr class="separator:a0bc7d607787ddbd671d55461654fc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6cd542799c775c18a0b1e8224c6f25" id="r_a6a6cd542799c775c18a0b1e8224c6f25"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a6cd542799c775c18a0b1e8224c6f25">makeSymbolFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a6a6cd542799c775c18a0b1e8224c6f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions for symbols.  <br /></td></tr>
<tr class="separator:a6a6cd542799c775c18a0b1e8224c6f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cd71faaf8267a65bb259ae19fb891d" id="r_a51cd71faaf8267a65bb259ae19fb891d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a51cd71faaf8267a65bb259ae19fb891d">makeContainerFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a51cd71faaf8267a65bb259ae19fb891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions based on specimen container.  <br /></td></tr>
<tr class="separator:a51cd71faaf8267a65bb259ae19fb891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00eb185edcf2fd1ddc33cdd5c66b74e" id="r_af00eb185edcf2fd1ddc33cdd5c66b74e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#af00eb185edcf2fd1ddc33cdd5c66b74e">makeInterruptVectorFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;vector)</td></tr>
<tr class="memdesc:af00eb185edcf2fd1ddc33cdd5c66b74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions from an interrupt vector.  <br /></td></tr>
<tr class="separator:af00eb185edcf2fd1ddc33cdd5c66b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e80597c06b84a64ff67634429b1d3" id="r_a3b3e80597c06b84a64ff67634429b1d3"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3b3e80597c06b84a64ff67634429b1d3">makeUserFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const std::vector&lt; rose_addr_t &gt; &amp;)</td></tr>
<tr class="memdesc:a3b3e80597c06b84a64ff67634429b1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a function at each specified address.  <br /></td></tr>
<tr class="separator:a3b3e80597c06b84a64ff67634429b1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc17bce5e5b25955cbe4ba4cf29a11e" id="r_afdc17bce5e5b25955cbe4ba4cf29a11e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#afdc17bce5e5b25955cbe4ba4cf29a11e">discoverBasicBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:afdc17bce5e5b25955cbe4ba4cf29a11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover as many basic blocks as possible.  <br /></td></tr>
<tr class="separator:afdc17bce5e5b25955cbe4ba4cf29a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e884b6892acdfbf4f3e2b2064667ddc" id="r_a9e884b6892acdfbf4f3e2b2064667ddc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9e884b6892acdfbf4f3e2b2064667ddc">makeNextDataReferencedFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, rose_addr_t &amp;startVa)</td></tr>
<tr class="memdesc:a9e884b6892acdfbf4f3e2b2064667ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan read-only data to find function pointers.  <br /></td></tr>
<tr class="separator:a9e884b6892acdfbf4f3e2b2064667ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605a091498460bbb92e980d187fbe0dd" id="r_a605a091498460bbb92e980d187fbe0dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a605a091498460bbb92e980d187fbe0dd">makeNextCodeReferencedFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a605a091498460bbb92e980d187fbe0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan instruction ASTs to function pointers.  <br /></td></tr>
<tr class="separator:a605a091498460bbb92e980d187fbe0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d7f085078536ee5ee83c6af02c4732" id="r_a01d7f085078536ee5ee83c6af02c4732"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a01d7f085078536ee5ee83c6af02c4732">makeCalledFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a01d7f085078536ee5ee83c6af02c4732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions for function call edges.  <br /></td></tr>
<tr class="separator:a01d7f085078536ee5ee83c6af02c4732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88484e27e70924d65adc2b8f4006930a" id="r_a88484e27e70924d65adc2b8f4006930a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a88484e27e70924d65adc2b8f4006930a">makeFunctionFromInterFunctionCalls</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, rose_addr_t &amp;startVa)</td></tr>
<tr class="memdesc:a88484e27e70924d65adc2b8f4006930a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions from inter-function calls.  <br /></td></tr>
<tr class="separator:a88484e27e70924d65adc2b8f4006930a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6386ffa19a77f160ab5a50947a25586c" id="r_a6386ffa19a77f160ab5a50947a25586c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6386ffa19a77f160ab5a50947a25586c">discoverFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a6386ffa19a77f160ab5a50947a25586c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover as many functions as possible.  <br /></td></tr>
<tr class="separator:a6386ffa19a77f160ab5a50947a25586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ec9187929c555d19215b2ba685d95e" id="r_a09ec9187929c555d19215b2ba685d95e"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a09ec9187929c555d19215b2ba685d95e">attachDeadCodeToFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, size_t maxIterations=size_t(-1))</td></tr>
<tr class="memdesc:a09ec9187929c555d19215b2ba685d95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach dead code to function.  <br /></td></tr>
<tr class="separator:a09ec9187929c555d19215b2ba685d95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fffe1c37d1bb43728945763a249db3" id="r_a90fffe1c37d1bb43728945763a249db3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a90fffe1c37d1bb43728945763a249db3">attachPaddingToFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a90fffe1c37d1bb43728945763a249db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach function padding to function.  <br /></td></tr>
<tr class="separator:a90fffe1c37d1bb43728945763a249db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bda23e985da36fd069fb1bb1f51f22" id="r_a17bda23e985da36fd069fb1bb1f51f22"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a17bda23e985da36fd069fb1bb1f51f22">attachPaddingToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a17bda23e985da36fd069fb1bb1f51f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach padding to all functions.  <br /></td></tr>
<tr class="separator:a17bda23e985da36fd069fb1bb1f51f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63799c1787b8fce784cd45edc833e59" id="r_af63799c1787b8fce784cd45edc833e59"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#af63799c1787b8fce784cd45edc833e59">attachAllSurroundedCodeToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:af63799c1787b8fce784cd45edc833e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach all possible intra-function basic blocks to functions.  <br /></td></tr>
<tr class="separator:af63799c1787b8fce784cd45edc833e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ab05716aac3a6bf5e6e224f18d116" id="r_a708ab05716aac3a6bf5e6e224f18d116"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a708ab05716aac3a6bf5e6e224f18d116">attachSurroundedCodeToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a708ab05716aac3a6bf5e6e224f18d116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach intra-function basic blocks to functions.  <br /></td></tr>
<tr class="separator:a708ab05716aac3a6bf5e6e224f18d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bc2eb1026d7dfba09236a887d74e3f" id="r_a54bc2eb1026d7dfba09236a887d74e3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a54bc2eb1026d7dfba09236a887d74e3f">attachBlocksToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a54bc2eb1026d7dfba09236a887d74e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach basic blocks to functions.  <br /></td></tr>
<tr class="separator:a54bc2eb1026d7dfba09236a887d74e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a887afbd24570491c8188c101ff793" id="r_a26a887afbd24570491c8188c101ff793"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a26a887afbd24570491c8188c101ff793">attachDeadCodeToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, size_t maxIterations=size_t(-1))</td></tr>
<tr class="memdesc:a26a887afbd24570491c8188c101ff793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach dead code to functions.  <br /></td></tr>
<tr class="separator:a26a887afbd24570491c8188c101ff793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed1f753963e0afe63ac2e45327e8b19" id="r_a3ed1f753963e0afe63ac2e45327e8b19"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3ed1f753963e0afe63ac2e45327e8b19">attachSurroundedDataToFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a3ed1f753963e0afe63ac2e45327e8b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach intra-function data to functions.  <br /></td></tr>
<tr class="separator:a3ed1f753963e0afe63ac2e45327e8b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6e22d06ca7e370a24445a5bb941ae1" id="r_aaa6e22d06ca7e370a24445a5bb941ae1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aaa6e22d06ca7e370a24445a5bb941ae1">makeNextCallReturnEdge</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, boost::logic::tribool assumeCallReturns)</td></tr>
<tr class="memdesc:aaa6e22d06ca7e370a24445a5bb941ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a call-return edge and discover its basic block.  <br /></td></tr>
<tr class="separator:aaa6e22d06ca7e370a24445a5bb941ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b7d7b44f5ed59f362fed9c442fd5c" id="r_a457b7d7b44f5ed59f362fed9c442fd5c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a457b7d7b44f5ed59f362fed9c442fd5c">makeNextBasicBlockFromPlaceholder</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a457b7d7b44f5ed59f362fed9c442fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover basic block at next placeholder.  <br /></td></tr>
<tr class="separator:a457b7d7b44f5ed59f362fed9c442fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dc8c48c2006ea3ff9161528ca78bb9" id="r_a10dc8c48c2006ea3ff9161528ca78bb9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a10dc8c48c2006ea3ff9161528ca78bb9">makeNextBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a10dc8c48c2006ea3ff9161528ca78bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover a basic block.  <br /></td></tr>
<tr class="separator:a10dc8c48c2006ea3ff9161528ca78bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03bd239e6a7015113c65d86c57aae74" id="r_ad03bd239e6a7015113c65d86c57aae74"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ad03bd239e6a7015113c65d86c57aae74">matchFactory</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>) const override</td></tr>
<tr class="memdesc:ad03bd239e6a7015113c65d86c57aae74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for matching a concrete engine factory by settings and specimen.  <br /></td></tr>
<tr class="separator:ad03bd239e6a7015113c65d86c57aae74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb71405fbca62ef852af0e581ef6831" id="r_a1bb71405fbca62ef852af0e581ef6831"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a1bb71405fbca62ef852af0e581ef6831">instanceFromFactory</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;) override</td></tr>
<tr class="memdesc:a1bb71405fbca62ef852af0e581ef6831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for factories.  <br /></td></tr>
<tr class="separator:a1bb71405fbca62ef852af0e581ef6831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe27b15b46d801340c5d72886941941" id="r_a3fe27b15b46d801340c5d72886941941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a3fe27b15b46d801340c5d72886941941">reset</a> () override</td></tr>
<tr class="memdesc:a3fe27b15b46d801340c5d72886941941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the engine to its initial state.  <br /></td></tr>
<tr class="separator:a3fe27b15b46d801340c5d72886941941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07fd60c2747e9367dec98def840779" id="r_a6f07fd60c2747e9367dec98def840779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6f07fd60c2747e9367dec98def840779">frontend</a> (const std::vector&lt; std::string &gt; &amp;args, const std::string &amp;purpose, const std::string &amp;description) override</td></tr>
<tr class="memdesc:a6f07fd60c2747e9367dec98def840779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:a6f07fd60c2747e9367dec98def840779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a131b9a3cb5ab3ae8457023e764187f" id="r_a6a131b9a3cb5ab3ae8457023e764187f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a131b9a3cb5ab3ae8457023e764187f">parseContainers</a> (const std::vector&lt; std::string &gt; &amp;fileNames) override</td></tr>
<tr class="memdesc:a6a131b9a3cb5ab3ae8457023e764187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse specimen binary containers.  <br /></td></tr>
<tr class="separator:a6a131b9a3cb5ab3ae8457023e764187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4418f0c2482653d053a9968311de0f3" id="r_ab4418f0c2482653d053a9968311de0f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;()) override</td></tr>
<tr class="memdesc:ab4418f0c2482653d053a9968311de0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and/or link interpretation.  <br /></td></tr>
<tr class="separator:ab4418f0c2482653d053a9968311de0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adf0374e582f86a3cd0b03a007a73c8" id="r_a9adf0374e582f86a3cd0b03a007a73c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9adf0374e582f86a3cd0b03a007a73c8">partition</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;()) override</td></tr>
<tr class="memdesc:a9adf0374e582f86a3cd0b03a007a73c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:a9adf0374e582f86a3cd0b03a007a73c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b30b8e67b6837e20622f5b6589e97d" id="r_a38b30b8e67b6837e20622f5b6589e97d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a38b30b8e67b6837e20622f5b6589e97d">buildAst</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;()) override</td></tr>
<tr class="memdesc:a38b30b8e67b6837e20622f5b6589e97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an abstract syntax tree.  <br /></td></tr>
<tr class="separator:a38b30b8e67b6837e20622f5b6589e97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf97876fddae32fcdbf921acdac5ad3" id="r_a2bf97876fddae32fcdbf921acdac5ad3"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a2bf97876fddae32fcdbf921acdac5ad3">commandLineSwitches</a> () override</td></tr>
<tr class="memdesc:a2bf97876fddae32fcdbf921acdac5ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches for a particular engine.  <br /></td></tr>
<tr class="separator:a2bf97876fddae32fcdbf921acdac5ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd369fe7e4baa7949c16c6209994f88" id="r_aebd369fe7e4baa7949c16c6209994f88"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aebd369fe7e4baa7949c16c6209994f88">specimenNameDocumentation</a> () override</td></tr>
<tr class="memdesc:aebd369fe7e4baa7949c16c6209994f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation about how the specimen is specified.  <br /></td></tr>
<tr class="separator:aebd369fe7e4baa7949c16c6209994f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ab46a4ea34326e3962f12304058e3" id="r_a6b5ab46a4ea34326e3962f12304058e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6b5ab46a4ea34326e3962f12304058e3">isNonContainer</a> (const std::string &amp;) override</td></tr>
<tr class="memdesc:a6b5ab46a4ea34326e3962f12304058e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a specimen name is a non-container.  <br /></td></tr>
<tr class="separator:a6b5ab46a4ea34326e3962f12304058e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ad483d8789ee6daea7bcddd0e3a752" id="r_ac7ad483d8789ee6daea7bcddd0e3a752"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">areContainersParsed</a> () const override</td></tr>
<tr class="memdesc:ac7ad483d8789ee6daea7bcddd0e3a752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if containers are parsed.  <br /></td></tr>
<tr class="separator:ac7ad483d8789ee6daea7bcddd0e3a752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd9912394b62e64189721f25d5a16e8" id="r_adfd9912394b62e64189721f25d5a16e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#adfd9912394b62e64189721f25d5a16e8">createPartitioner</a> () override</td></tr>
<tr class="memdesc:adfd9912394b62e64189721f25d5a16e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create partitioner.  <br /></td></tr>
<tr class="separator:adfd9912394b62e64189721f25d5a16e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d69777f095a892b69c3e4ff85fd5129" id="r_a1d69777f095a892b69c3e4ff85fd5129"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a1d69777f095a892b69c3e4ff85fd5129">runPartitionerInit</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;) override</td></tr>
<tr class="memdesc:a1d69777f095a892b69c3e4ff85fd5129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds interesting things to work on initially.  <br /></td></tr>
<tr class="separator:a1d69777f095a892b69c3e4ff85fd5129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9024f922e4da510563597d09560802df" id="r_a9024f922e4da510563597d09560802df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9024f922e4da510563597d09560802df">runPartitionerRecursive</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;) override</td></tr>
<tr class="memdesc:a9024f922e4da510563597d09560802df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the recursive part of partioning.  <br /></td></tr>
<tr class="separator:a9024f922e4da510563597d09560802df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b2658f7518581ccbddb00060132b7c" id="r_a46b2658f7518581ccbddb00060132b7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a46b2658f7518581ccbddb00060132b7c">runPartitionerFinal</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;) override</td></tr>
<tr class="memdesc:a46b2658f7518581ccbddb00060132b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the final parts of partitioning.  <br /></td></tr>
<tr class="separator:a46b2658f7518581ccbddb00060132b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a07715b94eab6083d62134fd122190d" id="r_a4a07715b94eab6083d62134fd122190d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgProject.html">SgProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a4a07715b94eab6083d62134fd122190d">roseFrontendReplacement</a> (const std::vector&lt; boost::filesystem::path &gt; &amp;fileNames) override</td></tr>
<tr class="separator:a4a07715b94eab6083d62134fd122190d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7578d0b2e81c599a3b4749bad2e54fb5" id="r_a7578d0b2e81c599a3b4749bad2e54fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a7578d0b2e81c599a3b4749bad2e54fb5">frontend</a> (int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a7578d0b2e81c599a3b4749bad2e54fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:a7578d0b2e81c599a3b4749bad2e54fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada804bf70502647031d9bb3cf717d8c2" id="r_ada804bf70502647031d9bb3cf717d8c2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ada804bf70502647031d9bb3cf717d8c2">frontend</a> (const std::vector&lt; std::string &gt; &amp;args, const std::string &amp;purpose, const std::string &amp;description)=0</td></tr>
<tr class="memdesc:ada804bf70502647031d9bb3cf717d8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:ada804bf70502647031d9bb3cf717d8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6774f4a00e3395348580911f20cf7b" id="r_acd6774f4a00e3395348580911f20cf7b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#acd6774f4a00e3395348580911f20cf7b">parseContainers</a> (const std::vector&lt; std::string &gt; &amp;fileNames)=0</td></tr>
<tr class="memdesc:acd6774f4a00e3395348580911f20cf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse specimen binary containers.  <br /></td></tr>
<tr class="separator:acd6774f4a00e3395348580911f20cf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7302b9664b6c6f3736391ff691d10d" id="r_a9c7302b9664b6c6f3736391ff691d10d"><td class="memItemLeft" align="right" valign="top"><a id="a9c7302b9664b6c6f3736391ff691d10d" name="a9c7302b9664b6c6f3736391ff691d10d"></a>
<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parseContainers</b> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a9c7302b9664b6c6f3736391ff691d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4be5fcd45af5fcdfec6df6a416d7d28" id="r_ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae4be5fcd45af5fcdfec6df6a416d7d28">loadSpecimens</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and/or link interpretation.  <br /></td></tr>
<tr class="separator:ae4be5fcd45af5fcdfec6df6a416d7d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc081451bcc8e731855d4fa8feb953c2" id="r_acc081451bcc8e731855d4fa8feb953c2"><td class="memItemLeft" align="right" valign="top"><a id="acc081451bcc8e731855d4fa8feb953c2" name="acc081451bcc8e731855d4fa8feb953c2"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadSpecimens</b> (const std::string &amp;fileName)</td></tr>
<tr class="separator:acc081451bcc8e731855d4fa8feb953c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af906e88cbeeebed28dd5f4250f3da920" id="r_af906e88cbeeebed28dd5f4250f3da920"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#af906e88cbeeebed28dd5f4250f3da920">partition</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:af906e88cbeeebed28dd5f4250f3da920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:af906e88cbeeebed28dd5f4250f3da920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602cb50f4790c6e788288ae7a280f41" id="r_ad602cb50f4790c6e788288ae7a280f41"><td class="memItemLeft" align="right" valign="top"><a id="ad602cb50f4790c6e788288ae7a280f41" name="ad602cb50f4790c6e788288ae7a280f41"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partition</b> (const std::string &amp;fileName)</td></tr>
<tr class="separator:ad602cb50f4790c6e788288ae7a280f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ab3614209149b652b26e2aa24cd064" id="r_ac5ab3614209149b652b26e2aa24cd064"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac5ab3614209149b652b26e2aa24cd064">buildAst</a> (const std::vector&lt; std::string &gt; &amp;fileNames=std::vector&lt; std::string &gt;())=0</td></tr>
<tr class="memdesc:ac5ab3614209149b652b26e2aa24cd064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an abstract syntax tree.  <br /></td></tr>
<tr class="separator:ac5ab3614209149b652b26e2aa24cd064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced447c1be5912055c4229329294360" id="r_acced447c1be5912055c4229329294360"><td class="memItemLeft" align="right" valign="top"><a id="acced447c1be5912055c4229329294360" name="acced447c1be5912055c4229329294360"></a>
<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildAst</b> (const std::string &amp;fileName)</td></tr>
<tr class="separator:acced447c1be5912055c4229329294360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2a9f76100ba8f1fa2837e3923f81843f" id="r_a2a9f76100ba8f1fa2837e3923f81843f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a2a9f76100ba8f1fa2837e3923f81843f">obtainLoader</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> &amp;hint)</td></tr>
<tr class="memdesc:a2a9f76100ba8f1fa2837e3923f81843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a binary loader.  <br /></td></tr>
<tr class="separator:a2a9f76100ba8f1fa2837e3923f81843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76760ff357246c2df5eb4c13facba73" id="r_ac76760ff357246c2df5eb4c13facba73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac76760ff357246c2df5eb4c13facba73">obtainLoader</a> ()</td></tr>
<tr class="memdesc:ac76760ff357246c2df5eb4c13facba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a binary loader.  <br /></td></tr>
<tr class="separator:ac76760ff357246c2df5eb4c13facba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5ce65a7af6140935d253420ccc2ab422" id="r_a5ce65a7af6140935d253420ccc2ab422"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a5ce65a7af6140935d253420ccc2ab422">makeNextPrologueFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, rose_addr_t startVa)</td></tr>
<tr class="memdesc:a5ce65a7af6140935d253420ccc2ab422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make function at prologue pattern.  <br /></td></tr>
<tr class="separator:a5ce65a7af6140935d253420ccc2ab422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fedcd5d7e926f4f15b5e7c2cd8dfc20" id="r_a9fedcd5d7e926f4f15b5e7c2cd8dfc20"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9fedcd5d7e926f4f15b5e7c2cd8dfc20">makeNextPrologueFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, rose_addr_t startVa, rose_addr_t &amp;lastSearchedVa)</td></tr>
<tr class="memdesc:a9fedcd5d7e926f4f15b5e7c2cd8dfc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make function at prologue pattern.  <br /></td></tr>
<tr class="separator:a9fedcd5d7e926f4f15b5e7c2cd8dfc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3ec479f887c60ad89d65eb945a82499" id="r_aa3ec479f887c60ad89d65eb945a82499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa3ec479f887c60ad89d65eb945a82499">binaryLoader</a> () const</td></tr>
<tr class="memdesc:aa3ec479f887c60ad89d65eb945a82499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: binary loader.  <br /></td></tr>
<tr class="separator:aa3ec479f887c60ad89d65eb945a82499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38b7764fd778dd1787ad1b5983ddac4" id="r_ae38b7764fd778dd1787ad1b5983ddac4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae38b7764fd778dd1787ad1b5983ddac4">binaryLoader</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> &amp;)</td></tr>
<tr class="memdesc:ae38b7764fd778dd1787ad1b5983ddac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: binary loader.  <br /></td></tr>
<tr class="separator:ae38b7764fd778dd1787ad1b5983ddac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6789ff99228eb4b4368b1deced2e4a65" id="r_a6789ff99228eb4b4368b1deced2e4a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6789ff99228eb4b4368b1deced2e4a65">functionMatcherThunks</a> () const</td></tr>
<tr class="memdesc:a6789ff99228eb4b4368b1deced2e4a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Predicate for finding functions that are thunks.  <br /></td></tr>
<tr class="separator:a6789ff99228eb4b4368b1deced2e4a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299728e68e77cfcf5432ba84d167ad0e" id="r_a299728e68e77cfcf5432ba84d167ad0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a299728e68e77cfcf5432ba84d167ad0e">functionMatcherThunks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> &amp;)</td></tr>
<tr class="memdesc:a299728e68e77cfcf5432ba84d167ad0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Predicate for finding functions that are thunks.  <br /></td></tr>
<tr class="separator:a299728e68e77cfcf5432ba84d167ad0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea921f6b6e2ec220f1fd440e712726ee" id="r_aea921f6b6e2ec220f1fd440e712726ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aea921f6b6e2ec220f1fd440e712726ee">functionSplittingThunks</a> () const</td></tr>
<tr class="memdesc:aea921f6b6e2ec220f1fd440e712726ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Predicate for finding thunks at the start of functions.  <br /></td></tr>
<tr class="separator:aea921f6b6e2ec220f1fd440e712726ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bad9732a26e4f42e1b367d7e675bc9" id="r_ae5bad9732a26e4f42e1b367d7e675bc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae5bad9732a26e4f42e1b367d7e675bc9">functionSplittingThunks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> &amp;)</td></tr>
<tr class="memdesc:ae5bad9732a26e4f42e1b367d7e675bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Predicate for finding thunks at the start of functions.  <br /></td></tr>
<tr class="separator:ae5bad9732a26e4f42e1b367d7e675bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a></td></tr>
<tr class="memitem:aa9965bfadc44cb954411f3b3e6854669 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aa9965bfadc44cb954411f3b3e6854669"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa9965bfadc44cb954411f3b3e6854669">allCommandLineSwitches</a> ()</td></tr>
<tr class="memdesc:aa9965bfadc44cb954411f3b3e6854669 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of command-line switches for all engines.  <br /></td></tr>
<tr class="separator:aa9965bfadc44cb954411f3b3e6854669 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37280b77d886d4b41e9234494adfff2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a37280b77d886d4b41e9234494adfff2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a37280b77d886d4b41e9234494adfff2b">addToParser</a> (<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a37280b77d886d4b41e9234494adfff2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switches and sections to command-line parser.  <br /></td></tr>
<tr class="separator:a37280b77d886d4b41e9234494adfff2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ae9710eca6a74838e7cf5a8c874c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a215ae9710eca6a74838e7cf5a8c874c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a215ae9710eca6a74838e7cf5a8c874c9">addAllToParser</a> (<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a215ae9710eca6a74838e7cf5a8c874c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switches and sections to command-line parser.  <br /></td></tr>
<tr class="separator:a215ae9710eca6a74838e7cf5a8c874c9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec299a2c212759c27c10d848f65172 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a15ec299a2c212759c27c10d848f65172"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a> (const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a15ec299a2c212759c27c10d848f65172 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a command-line parser.  <br /></td></tr>
<tr class="separator:a15ec299a2c212759c27c10d848f65172 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ba1b48d82005b53a7a917bcd91297a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ab7ba1b48d82005b53a7a917bcd91297a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab7ba1b48d82005b53a7a917bcd91297a">isFactory</a> () const</td></tr>
<tr class="memdesc:ab7ba1b48d82005b53a7a917bcd91297a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is a factory.  <br /></td></tr>
<tr class="separator:ab7ba1b48d82005b53a7a917bcd91297a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc475e28fdf2a920aefc74a3fc687dd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a2fc475e28fdf2a920aefc74a3fc687dd"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>savePartitioner</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;, const boost::filesystem::path &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>=<a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a>)</td></tr>
<tr class="separator:a2fc475e28fdf2a920aefc74a3fc687dd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15494ebc5c7683c9c7eb83e7f74f5a20 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a15494ebc5c7683c9c7eb83e7f74f5a20"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadPartitioner</b> (const boost::filesystem::path &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>=<a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a>)</td></tr>
<tr class="separator:a15494ebc5c7683c9c7eb83e7f74f5a20 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cedac33fe84b58e81691982fd59c044 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a8cedac33fe84b58e81691982fd59c044"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a8cedac33fe84b58e81691982fd59c044">checkSettings</a> ()</td></tr>
<tr class="memdesc:a8cedac33fe84b58e81691982fd59c044 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check settings after command-line is processed.  <br /></td></tr>
<tr class="separator:a8cedac33fe84b58e81691982fd59c044 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c851c4255123937a69bf226fda5cfd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a2c851c4255123937a69bf226fda5cfd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a2c851c4255123937a69bf226fda5cfd4">isRbaFile</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a2c851c4255123937a69bf226fda5cfd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a specimen is an RBA file.  <br /></td></tr>
<tr class="separator:a2c851c4255123937a69bf226fda5cfd4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fe78b82a4d4495b16b273c91b36dd1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a63fe78b82a4d4495b16b273c91b36dd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a> () const</td></tr>
<tr class="memdesc:a63fe78b82a4d4495b16b273c91b36dd1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if specimens are loaded.  <br /></td></tr>
<tr class="separator:a63fe78b82a4d4495b16b273c91b36dd1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dca7dc0c1b3324ffe113cf5e1f2c2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a80dca7dc0c1b3324ffe113cf5e1f2c2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a80dca7dc0c1b3324ffe113cf5e1f2c2b">adjustMemoryMap</a> ()</td></tr>
<tr class="memdesc:a80dca7dc0c1b3324ffe113cf5e1f2c2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust memory map post-loading.  <br /></td></tr>
<tr class="separator:a80dca7dc0c1b3324ffe113cf5e1f2c2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed290482cc798c43c78592e8d44820e3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aed290482cc798c43c78592e8d44820e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed290482cc798c43c78592e8d44820e3">checkCreatePartitionerPrerequisites</a> () const</td></tr>
<tr class="memdesc:aed290482cc798c43c78592e8d44820e3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that we have everything necessary to create a partitioner.  <br /></td></tr>
<tr class="separator:aed290482cc798c43c78592e8d44820e3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0922cec9d5f1f67e5efa9cd5ce965b47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a0922cec9d5f1f67e5efa9cd5ce965b47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a0922cec9d5f1f67e5efa9cd5ce965b47">createBarePartitioner</a> ()</td></tr>
<tr class="memdesc:a0922cec9d5f1f67e5efa9cd5ce965b47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bare partitioner.  <br /></td></tr>
<tr class="separator:a0922cec9d5f1f67e5efa9cd5ce965b47 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed87fa166db4263d0c3efe1b2eb2dead inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aed87fa166db4263d0c3efe1b2eb2dead"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:aed87fa166db4263d0c3efe1b2eb2dead inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:aed87fa166db4263d0c3efe1b2eb2dead inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9300f21efb63affa59ff7aa1cbeb48 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_adc9300f21efb63affa59ff7aa1cbeb48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#adc9300f21efb63affa59ff7aa1cbeb48">labelAddresses</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:adc9300f21efb63affa59ff7aa1cbeb48 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label addresses.  <br /></td></tr>
<tr class="separator:adc9300f21efb63affa59ff7aa1cbeb48 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40871501faf9246979de4e2209129a3b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a40871501faf9246979de4e2209129a3b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a40871501faf9246979de4e2209129a3b">makeConfiguredDataBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:a40871501faf9246979de4e2209129a3b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make data blocks based on configuration.  <br /></td></tr>
<tr class="separator:a40871501faf9246979de4e2209129a3b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e535db9df960aae0490a3ca8537deb4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a7e535db9df960aae0490a3ca8537deb4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7e535db9df960aae0490a3ca8537deb4">makeConfiguredFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;)</td></tr>
<tr class="memdesc:a7e535db9df960aae0490a3ca8537deb4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make functions based on configuration information.  <br /></td></tr>
<tr class="separator:a7e535db9df960aae0490a3ca8537deb4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6053c48791d8c34c6c40ec28d766e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aebc6053c48791d8c34c6c40ec28d766e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aebc6053c48791d8c34c6c40ec28d766e">updateAnalysisResults</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;)</td></tr>
<tr class="memdesc:aebc6053c48791d8c34c6c40ec28d766e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs various analysis passes.  <br /></td></tr>
<tr class="separator:aebc6053c48791d8c34c6c40ec28d766e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ecebed849132c397314472662f9371 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a81ecebed849132c397314472662f9371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a81ecebed849132c397314472662f9371">architecture</a> ()</td></tr>
<tr class="memdesc:a81ecebed849132c397314472662f9371 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>.  <br /></td></tr>
<tr class="separator:a81ecebed849132c397314472662f9371 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7578d0b2e81c599a3b4749bad2e54fb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a7578d0b2e81c599a3b4749bad2e54fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">frontend</a> (int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a7578d0b2e81c599a3b4749bad2e54fb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most basic usage of the partitioner.  <br /></td></tr>
<tr class="separator:a7578d0b2e81c599a3b4749bad2e54fb5 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447357ce51bd95c4ac58c456c9bd9ce8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a447357ce51bd95c4ac58c456c9bd9ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a447357ce51bd95c4ac58c456c9bd9ce8">parseCommandLine</a> (int argc, char *argv[], const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a447357ce51bd95c4ac58c456c9bd9ce8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the command-line.  <br /></td></tr>
<tr class="separator:a447357ce51bd95c4ac58c456c9bd9ce8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed3d22decbdafc35b9c897b14b239a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a7fed3d22decbdafc35b9c897b14b239a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">Sawyer::CommandLine::ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7fed3d22decbdafc35b9c897b14b239a">parseCommandLine</a> (const std::vector&lt; std::string &gt; &amp;args, const std::string &amp;purpose, const std::string &amp;description)</td></tr>
<tr class="memdesc:a7fed3d22decbdafc35b9c897b14b239a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the command-line.  <br /></td></tr>
<tr class="separator:a7fed3d22decbdafc35b9c897b14b239a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced447c1be5912055c4229329294360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_acced447c1be5912055c4229329294360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acced447c1be5912055c4229329294360">buildAst</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:acced447c1be5912055c4229329294360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an abstract syntax tree.  <br /></td></tr>
<tr class="separator:acced447c1be5912055c4229329294360 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7302b9664b6c6f3736391ff691d10d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a9c7302b9664b6c6f3736391ff691d10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9c7302b9664b6c6f3736391ff691d10d">parseContainers</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a9c7302b9664b6c6f3736391ff691d10d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse specimen binary containers.  <br /></td></tr>
<tr class="separator:a9c7302b9664b6c6f3736391ff691d10d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc081451bcc8e731855d4fa8feb953c2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_acc081451bcc8e731855d4fa8feb953c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acc081451bcc8e731855d4fa8feb953c2">loadSpecimens</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:acc081451bcc8e731855d4fa8feb953c2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and/or link interpretation.  <br /></td></tr>
<tr class="separator:acc081451bcc8e731855d4fa8feb953c2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602cb50f4790c6e788288ae7a280f41 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ad602cb50f4790c6e788288ae7a280f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ad602cb50f4790c6e788288ae7a280f41">partition</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:ad602cb50f4790c6e788288ae7a280f41 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition instructions into basic blocks and functions.  <br /></td></tr>
<tr class="separator:ad602cb50f4790c6e788288ae7a280f41 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300676870a43dbd55a4f06f26cebf4c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a300676870a43dbd55a4f06f26cebf4c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a300676870a43dbd55a4f06f26cebf4c3">memoryMap</a> () const</td></tr>
<tr class="memdesc:a300676870a43dbd55a4f06f26cebf4c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: memory map.  <br /></td></tr>
<tr class="separator:a300676870a43dbd55a4f06f26cebf4c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000fe1570b5566a3173053c5f7816289 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a000fe1570b5566a3173053c5f7816289"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a000fe1570b5566a3173053c5f7816289">memoryMap</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;)</td></tr>
<tr class="memdesc:a000fe1570b5566a3173053c5f7816289 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: memory map.  <br /></td></tr>
<tr class="separator:a000fe1570b5566a3173053c5f7816289 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee425610d4789639e5f963bce81f8354 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aee425610d4789639e5f963bce81f8354"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a> ()</td></tr>
<tr class="memdesc:aee425610d4789639e5f963bce81f8354 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the architecture.  <br /></td></tr>
<tr class="separator:aee425610d4789639e5f963bce81f8354 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4950d36daffee4e6b047ae8fe1cccca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ab4950d36daffee4e6b047ae8fe1cccca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab4950d36daffee4e6b047ae8fe1cccca">obtainArchitecture</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;hint)</td></tr>
<tr class="memdesc:ab4950d36daffee4e6b047ae8fe1cccca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the architecture.  <br /></td></tr>
<tr class="separator:ab4950d36daffee4e6b047ae8fe1cccca inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba323f9eb246e9263f6aa55227434fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_acba323f9eb246e9263f6aa55227434fd"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acba323f9eb246e9263f6aa55227434fd">name</a> () const</td></tr>
<tr class="memdesc:acba323f9eb246e9263f6aa55227434fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:acba323f9eb246e9263f6aa55227434fd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842497578115bbfe34b1f3d4b9ab86ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a842497578115bbfe34b1f3d4b9ab86ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a842497578115bbfe34b1f3d4b9ab86ff">name</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a842497578115bbfe34b1f3d4b9ab86ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:a842497578115bbfe34b1f3d4b9ab86ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab999b1599d0e262cb07d859925b188 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_acab999b1599d0e262cb07d859925b188"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a> () const</td></tr>
<tr class="memdesc:acab999b1599d0e262cb07d859925b188 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:acab999b1599d0e262cb07d859925b188 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19421321588268b8d8270c56ae9bdd43 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a19421321588268b8d8270c56ae9bdd43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a19421321588268b8d8270c56ae9bdd43">settings</a> ()</td></tr>
<tr class="memdesc:a19421321588268b8d8270c56ae9bdd43 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:a19421321588268b8d8270c56ae9bdd43 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b51b3ed2d11e9a180f13aa3f72ae8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aa91b51b3ed2d11e9a180f13aa3f72ae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa91b51b3ed2d11e9a180f13aa3f72ae8">settings</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:aa91b51b3ed2d11e9a180f13aa3f72ae8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: All settings.  <br /></td></tr>
<tr class="separator:aa91b51b3ed2d11e9a180f13aa3f72ae8 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd13654a6f74cbe6bf1aaab2b02d4f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ac0cd13654a6f74cbe6bf1aaab2b02d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ac0cd13654a6f74cbe6bf1aaab2b02d4f">basicBlockWorkList</a> () const</td></tr>
<tr class="memdesc:ac0cd13654a6f74cbe6bf1aaab2b02d4f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:ac0cd13654a6f74cbe6bf1aaab2b02d4f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5e841a637fae01e5f67b9bd2d0791 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a3dd5e841a637fae01e5f67b9bd2d0791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a3dd5e841a637fae01e5f67b9bd2d0791">basicBlockWorkList</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">BasicBlockWorkList::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a3dd5e841a637fae01e5f67b9bd2d0791 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:a3dd5e841a637fae01e5f67b9bd2d0791 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1bab30a181f9806cfe919a77c9dc69 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aca1bab30a181f9806cfe919a77c9dc69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aca1bab30a181f9806cfe919a77c9dc69">codeFunctionPointers</a> () const</td></tr>
<tr class="memdesc:aca1bab30a181f9806cfe919a77c9dc69 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Instruction <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> constants.  <br /></td></tr>
<tr class="separator:aca1bab30a181f9806cfe919a77c9dc69 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674052dfc3833ed2146e109949204f3d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a674052dfc3833ed2146e109949204f3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a674052dfc3833ed2146e109949204f3d">codeFunctionPointers</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">CodeConstants::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a674052dfc3833ed2146e109949204f3d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> work list.  <br /></td></tr>
<tr class="separator:a674052dfc3833ed2146e109949204f3d inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f0160caff0aec828f1d3936fc3c672 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a61f0160caff0aec828f1d3936fc3c672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> () const</td></tr>
<tr class="memdesc:a61f0160caff0aec828f1d3936fc3c672 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: interpretation.  <br /></td></tr>
<tr class="separator:a61f0160caff0aec828f1d3936fc3c672 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0facdf97da071420d67bc1f3cba89a66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a0facdf97da071420d67bc1f3cba89a66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a0facdf97da071420d67bc1f3cba89a66">interpretation</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a0facdf97da071420d67bc1f3cba89a66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: interpretation.  <br /></td></tr>
<tr class="separator:a0facdf97da071420d67bc1f3cba89a66 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c0f282763bdfbfe83ca9fe2aae52ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a70c0f282763bdfbfe83ca9fe2aae52ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a70c0f282763bdfbfe83ca9fe2aae52ff">progress</a> () const</td></tr>
<tr class="memdesc:a70c0f282763bdfbfe83ca9fe2aae52ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: progress reporting.  <br /></td></tr>
<tr class="separator:a70c0f282763bdfbfe83ca9fe2aae52ff inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902ca55f8dbf32a33fb6cc4365ac0745 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a902ca55f8dbf32a33fb6cc4365ac0745"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a902ca55f8dbf32a33fb6cc4365ac0745">progress</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">ProgressPtr</a> &amp;)</td></tr>
<tr class="memdesc:a902ca55f8dbf32a33fb6cc4365ac0745 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: progress reporting.  <br /></td></tr>
<tr class="separator:a902ca55f8dbf32a33fb6cc4365ac0745 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cb0f9a5384de07b24893dbbe049428 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a67cb0f9a5384de07b24893dbbe049428"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a> () const</td></tr>
<tr class="memdesc:a67cb0f9a5384de07b24893dbbe049428 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: specimen.  <br /></td></tr>
<tr class="separator:a67cb0f9a5384de07b24893dbbe049428 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d41a99dac587136cb1fe7227efd9ccf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a8d41a99dac587136cb1fe7227efd9ccf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a8d41a99dac587136cb1fe7227efd9ccf">specimen</a> (const std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:a8d41a99dac587136cb1fe7227efd9ccf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: specimen.  <br /></td></tr>
<tr class="separator:a8d41a99dac587136cb1fe7227efd9ccf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedFromThis"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedFromThis')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedFromThis.html">Sawyer::SharedFromThis&lt; Engine &gt;</a></td></tr>
<tr class="memitem:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a5225cf4c7055339254ace1c62005ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; Engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a5225cf4c7055339254ace1c62005ac55">sharedFromThis</a> ()</td></tr>
<tr class="memdesc:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a8b829a965e98f9ccb1b22da4a68a6f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; const Engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a8b829a965e98f9ccb1b22da4a68a6f76">sharedFromThis</a> () const</td></tr>
<tr class="memdesc:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aef732dc81b83ece242126488f91f1961" id="r_aef732dc81b83ece242126488f91f1961"><td class="memItemLeft" align="right" valign="top"><a id="aef732dc81b83ece242126488f91f1961" name="aef732dc81b83ece242126488f91f1961"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae3cf260dd6a68759d388ab2c97e281c6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> ()</td></tr>
<tr class="memdesc:aef732dc81b83ece242126488f91f1961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor. <br /></td></tr>
<tr class="separator:aef732dc81b83ece242126488f91f1961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e74788908a2c93c1d0b42033bfd51a" id="r_ae3e74788908a2c93c1d0b42033bfd51a"><td class="memItemLeft" align="right" valign="top"><a id="ae3e74788908a2c93c1d0b42033bfd51a" name="ae3e74788908a2c93c1d0b42033bfd51a"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae3cf260dd6a68759d388ab2c97e281c6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:ae3e74788908a2c93c1d0b42033bfd51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor with settings. <br /></td></tr>
<tr class="separator:ae3e74788908a2c93c1d0b42033bfd51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa802db1ab4c8b5de80b153177e047494" id="r_aa802db1ab4c8b5de80b153177e047494"><td class="memItemLeft" align="right" valign="top"><a id="aa802db1ab4c8b5de80b153177e047494" name="aa802db1ab4c8b5de80b153177e047494"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae3cf260dd6a68759d388ab2c97e281c6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>factory</b> ()</td></tr>
<tr class="memdesc:aa802db1ab4c8b5de80b153177e047494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a factory. <br /></td></tr>
<tr class="separator:aa802db1ab4c8b5de80b153177e047494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41430c74cdc424ebdf5050a6bf92850f" id="r_a41430c74cdc424ebdf5050a6bf92850f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a41430c74cdc424ebdf5050a6bf92850f">engineSwitches</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html">EngineSettings</a> &amp;)</td></tr>
<tr class="memdesc:a41430c74cdc424ebdf5050a6bf92850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches related to the general engine behavior.  <br /></td></tr>
<tr class="separator:a41430c74cdc424ebdf5050a6bf92850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac436647211541cc5363ec954d656942b" id="r_ac436647211541cc5363ec954d656942b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac436647211541cc5363ec954d656942b">loaderSwitches</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1LoaderSettings.html">LoaderSettings</a> &amp;)</td></tr>
<tr class="memdesc:ac436647211541cc5363ec954d656942b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches related to loading specimen into memory.  <br /></td></tr>
<tr class="separator:ac436647211541cc5363ec954d656942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186061594c9f87df554703bc09d1a7fc" id="r_a186061594c9f87df554703bc09d1a7fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a186061594c9f87df554703bc09d1a7fc">disassemblerSwitches</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DisassemblerSettings.html">DisassemblerSettings</a> &amp;)</td></tr>
<tr class="memdesc:a186061594c9f87df554703bc09d1a7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches related to decoding instructions.  <br /></td></tr>
<tr class="separator:a186061594c9f87df554703bc09d1a7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc355f50eee735c8049a4ec447cde3f" id="r_a9fc355f50eee735c8049a4ec447cde3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9fc355f50eee735c8049a4ec447cde3f">partitionerSwitches</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html">PartitionerSettings</a> &amp;)</td></tr>
<tr class="memdesc:a9fc355f50eee735c8049a4ec447cde3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches related to partitioning instructions.  <br /></td></tr>
<tr class="separator:a9fc355f50eee735c8049a4ec447cde3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85843fe13c9e544c29920803ce31a169" id="r_a85843fe13c9e544c29920803ce31a169"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a85843fe13c9e544c29920803ce31a169">astConstructionSwitches</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;)</td></tr>
<tr class="memdesc:a85843fe13c9e544c29920803ce31a169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command-line switches related to constructing an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from the partitioner.  <br /></td></tr>
<tr class="separator:a85843fe13c9e544c29920803ce31a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a></td></tr>
<tr class="memitem:a13bddfb4b277b18db273c069840be0bb inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a13bddfb4b277b18db273c069840be0bb"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">EngineBinaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> ()</td></tr>
<tr class="separator:a13bddfb4b277b18db273c069840be0bb inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42955b75ee9cd84996ed37bc21e15fe6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a42955b75ee9cd84996ed37bc21e15fe6"><td class="memItemLeft" align="right" valign="top">static std::list&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a42955b75ee9cd84996ed37bc21e15fe6">allSpecimenNameDocumentation</a> ()</td></tr>
<tr class="memdesc:a42955b75ee9cd84996ed37bc21e15fe6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for all specimen specifications.  <br /></td></tr>
<tr class="separator:a42955b75ee9cd84996ed37bc21e15fe6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f09b6e269acd25faa5440211241e16b inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a7f09b6e269acd25faa5440211241e16b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7f09b6e269acd25faa5440211241e16b">registerFactory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;factory)</td></tr>
<tr class="memdesc:a7f09b6e269acd25faa5440211241e16b inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an engine as a factory.  <br /></td></tr>
<tr class="separator:a7f09b6e269acd25faa5440211241e16b inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2e4b809563f44a45c45368e65dcc6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a6ba2e4b809563f44a45c45368e65dcc6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a6ba2e4b809563f44a45c45368e65dcc6">deregisterFactory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &amp;factory)</td></tr>
<tr class="memdesc:a6ba2e4b809563f44a45c45368e65dcc6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a concrete engine factory from the registry.  <br /></td></tr>
<tr class="separator:a6ba2e4b809563f44a45c45368e65dcc6 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f067ece2ed379c79f4bbe336157c9 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_af57f067ece2ed379c79f4bbe336157c9"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af57f067ece2ed379c79f4bbe336157c9">registeredFactories</a> ()</td></tr>
<tr class="memdesc:af57f067ece2ed379c79f4bbe336157c9 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all registered factories.  <br /></td></tr>
<tr class="separator:af57f067ece2ed379c79f4bbe336157c9 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72813aecbbc6fd95879101b6b7f3337 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_af72813aecbbc6fd95879101b6b7f3337"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>disassembleForRoseFrontend</b> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="separator:af72813aecbbc6fd95879101b6b7f3337 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90d4d8152cb5abecef50a2bcad1ead0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_aa90d4d8152cb5abecef50a2bcad1ead0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa90d4d8152cb5abecef50a2bcad1ead0">forge</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>)</td></tr>
<tr class="memdesc:aa90d4d8152cb5abecef50a2bcad1ead0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:aa90d4d8152cb5abecef50a2bcad1ead0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaff42b8cc81375666b980eda02d7d57 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_adaff42b8cc81375666b980eda02d7d57"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#adaff42b8cc81375666b980eda02d7d57">forge</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a67cb0f9a5384de07b24893dbbe049428">specimen</a>)</td></tr>
<tr class="memdesc:adaff42b8cc81375666b980eda02d7d57 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:adaff42b8cc81375666b980eda02d7d57 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d3672eaf562d61ab9b9b15bfbf670 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_af00d3672eaf562d61ab9b9b15bfbf670"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af00d3672eaf562d61ab9b9b15bfbf670">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:af00d3672eaf562d61ab9b9b15bfbf670 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:af00d3672eaf562d61ab9b9b15bfbf670 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66876ae7496f3b458d0c075b5d3162a8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a66876ae7496f3b458d0c075b5d3162a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a66876ae7496f3b458d0c075b5d3162a8">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;)</td></tr>
<tr class="memdesc:a66876ae7496f3b458d0c075b5d3162a8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a66876ae7496f3b458d0c075b5d3162a8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab046f7fa773f082cbb0f711559fbfeb0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ab046f7fa773f082cbb0f711559fbfeb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab046f7fa773f082cbb0f711559fbfeb0">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:ab046f7fa773f082cbb0f711559fbfeb0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ab046f7fa773f082cbb0f711559fbfeb0 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c3b88e4f6949949cc0bc4c395b67b8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a99c3b88e4f6949949cc0bc4c395b67b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a99c3b88e4f6949949cc0bc4c395b67b8">forge</a> (const std::vector&lt; std::string &gt; &amp;arguments, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:a99c3b88e4f6949949cc0bc4c395b67b8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a99c3b88e4f6949949cc0bc4c395b67b8 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade324e5393f7ae45f7be7e53e6e2d4df inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ade324e5393f7ae45f7be7e53e6e2d4df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ade324e5393f7ae45f7be7e53e6e2d4df">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:ade324e5393f7ae45f7be7e53e6e2d4df inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ade324e5393f7ae45f7be7e53e6e2d4df inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dc261d14b5695073763e7766356a8d inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ab8dc261d14b5695073763e7766356a8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ab8dc261d14b5695073763e7766356a8d">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1PositionalArgumentParser.html">PositionalArgumentParser</a> &amp;)</td></tr>
<tr class="memdesc:ab8dc261d14b5695073763e7766356a8d inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ab8dc261d14b5695073763e7766356a8d inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b35e356be7686b6633aae4472b2a00 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a04b35e356be7686b6633aae4472b2a00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a04b35e356be7686b6633aae4472b2a00">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="memdesc:a04b35e356be7686b6633aae4472b2a00 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:a04b35e356be7686b6633aae4472b2a00 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8013243b2c883aaace4648b4f2201c2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ae8013243b2c883aaace4648b4f2201c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae8013243b2c883aaace4648b4f2201c2">forge</a> (int argc, char *argv[], <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a> &amp;)</td></tr>
<tr class="memdesc:ae8013243b2c883aaace4648b4f2201c2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable engine based on the specimen.  <br /></td></tr>
<tr class="separator:ae8013243b2c883aaace4648b4f2201c2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa126ae2af5c262dca9f7e051ea3bfef0" id="r_aa126ae2af5c262dca9f7e051ea3bfef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa126ae2af5c262dca9f7e051ea3bfef0">EngineBinary</a> ()=delete</td></tr>
<tr class="memdesc:aa126ae2af5c262dca9f7e051ea3bfef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:aa126ae2af5c262dca9f7e051ea3bfef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b151f555519da6c1e7740e90740948e" id="r_a8b151f555519da6c1e7740e90740948e"><td class="memItemLeft" align="right" valign="top"><a id="a8b151f555519da6c1e7740e90740948e" name="a8b151f555519da6c1e7740e90740948e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EngineBinary</b> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;)</td></tr>
<tr class="separator:a8b151f555519da6c1e7740e90740948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a></td></tr>
<tr class="memitem:a9051325ca23c62b8035964a4b41fdc59 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a9051325ca23c62b8035964a4b41fdc59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9051325ca23c62b8035964a4b41fdc59">Engine</a> ()=delete</td></tr>
<tr class="memdesc:a9051325ca23c62b8035964a4b41fdc59 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a9051325ca23c62b8035964a4b41fdc59 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079607f269069d05dbe16261f5dac540 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_a079607f269069d05dbe16261f5dac540"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Engine</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;)=delete</td></tr>
<tr class="separator:a079607f269069d05dbe16261f5dac540 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf88e836b7dd11cf54ed71dc7889e4f8 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_acf88e836b7dd11cf54ed71dc7889e4f8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &amp;)=delete</td></tr>
<tr class="separator:acf88e836b7dd11cf54ed71dc7889e4f8 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55f6cfe8aaf65af3a72dd5a9af2b224 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine" id="r_ac55f6cfe8aaf65af3a72dd5a9af2b224"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Engine</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acba323f9eb246e9263f6aa55227434fd">name</a>, const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acab999b1599d0e262cb07d859925b188">settings</a>)</td></tr>
<tr class="memdesc:ac55f6cfe8aaf65af3a72dd5a9af2b224 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating <code>instance</code> constructors are implemented by the non-abstract subclasses. <br /></td></tr>
<tr class="separator:ac55f6cfe8aaf65af3a72dd5a9af2b224 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae3cf260dd6a68759d388ab2c97e281c6" name="ae3cf260dd6a68759d388ab2c97e281c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cf260dd6a68759d388ab2c97e281c6">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ae3cf260dd6a68759d388ab2c97e281c6">Rose::BinaryAnalysis::Partitioner2::EngineBinary::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a09434c6e84f43282c892a559b18da7d4">EngineBinaryPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="EngineBinary_8h_source.html#l00054">54</a> of file <a class="el" href="EngineBinary_8h_source.html">EngineBinary.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa126ae2af5c262dca9f7e051ea3bfef0" name="aa126ae2af5c262dca9f7e051ea3bfef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa126ae2af5c262dca9f7e051ea3bfef0">&#9670;&#160;</a></span>EngineBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::Partitioner2::EngineBinary::EngineBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Deleted, use factory method <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961" title="Allocating constructor.">instance()</a> instead. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41430c74cdc424ebdf5050a6bf92850f" name="a41430c74cdc424ebdf5050a6bf92850f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41430c74cdc424ebdf5050a6bf92850f">&#9670;&#160;</a></span>engineSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::engineSwitches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html">EngineSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches related to the general engine behavior. </p>
<p>The switches are configured to adjust the specified settings object when parsed. </p>

</div>
</div>
<a id="ac436647211541cc5363ec954d656942b" name="ac436647211541cc5363ec954d656942b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac436647211541cc5363ec954d656942b">&#9670;&#160;</a></span>loaderSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::loaderSwitches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1LoaderSettings.html">LoaderSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches related to loading specimen into memory. </p>
<p>The switches are configured to adjust the specified settings object when parsed. </p>

</div>
</div>
<a id="a186061594c9f87df554703bc09d1a7fc" name="a186061594c9f87df554703bc09d1a7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186061594c9f87df554703bc09d1a7fc">&#9670;&#160;</a></span>disassemblerSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::disassemblerSwitches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DisassemblerSettings.html">DisassemblerSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches related to decoding instructions. </p>
<p>The switches are configured to adjust the specified settings object when parsed. </p>

</div>
</div>
<a id="a9fc355f50eee735c8049a4ec447cde3f" name="a9fc355f50eee735c8049a4ec447cde3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc355f50eee735c8049a4ec447cde3f">&#9670;&#160;</a></span>partitionerSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::partitionerSwitches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html">PartitionerSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches related to partitioning instructions. </p>
<p>The switches are configured to adjust the specified settings object when parsed. </p>

</div>
</div>
<a id="a85843fe13c9e544c29920803ce31a169" name="a85843fe13c9e544c29920803ce31a169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85843fe13c9e544c29920803ce31a169">&#9670;&#160;</a></span>astConstructionSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::astConstructionSwitches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AstConstructionSettings.html">AstConstructionSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches related to constructing an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from the partitioner. </p>
<p>The switches are configured to adjust the specified settings object when parsed. </p>

</div>
</div>
<a id="af55fe44a08aacc27646d9c2d0e3b988b" name="af55fe44a08aacc27646d9c2d0e3b988b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55fe44a08aacc27646d9c2d0e3b988b">&#9670;&#160;</a></span>loadVxCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::loadVxCore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a vxcore specification and initializes memory. </p>
<p>Parses a VxWorks core dump in the format defined by Jim Leek and loads the data into ROSE's analysis memory. The argument should be everything after the first colon in the URL "vxcore:[MEMORY_ATTRS]:[FILE_ATTRS]:FILE_NAME". </p>

</div>
</div>
<a id="a2a9f76100ba8f1fa2837e3923f81843f" name="a2a9f76100ba8f1fa2837e3923f81843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9f76100ba8f1fa2837e3923f81843f">&#9670;&#160;</a></span>obtainLoader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::obtainLoader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>hint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a binary loader. </p>
<p>Find a suitable binary loader by one of the following methods (in this order):</p>
<ul>
<li>If this engine's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa3ec479f887c60ad89d65eb945a82499">binaryLoader</a> property is non-null, then return that loader.</li>
</ul>
<ul>
<li>If a binary container was parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">areContainersParsed</a> returns true and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> is non-null) then a loader is chosen based on the interpretation, and configured to map container sections into memory but not perform any linking or relocation fixups.</li>
</ul>
<ul>
<li>If a <code>hint</code> is supplied, use it.</li>
</ul>
<ul>
<li>Fail by throwing an <code>std::runtime_error</code>.</li>
</ul>
<p>In any case, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa3ec479f887c60ad89d65eb945a82499">binaryLoader</a> property is set to this method's return value. </p>

</div>
</div>
<a id="ac76760ff357246c2df5eb4c13facba73" name="ac76760ff357246c2df5eb4c13facba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76760ff357246c2df5eb4c13facba73">&#9670;&#160;</a></span>obtainLoader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::obtainLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a binary loader. </p>
<p>Find a suitable binary loader by one of the following methods (in this order):</p>
<ul>
<li>If this engine's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa3ec479f887c60ad89d65eb945a82499">binaryLoader</a> property is non-null, then return that loader.</li>
</ul>
<ul>
<li>If a binary container was parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">areContainersParsed</a> returns true and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a61f0160caff0aec828f1d3936fc3c672">interpretation</a> is non-null) then a loader is chosen based on the interpretation, and configured to map container sections into memory but not perform any linking or relocation fixups.</li>
</ul>
<ul>
<li>If a <code>hint</code> is supplied, use it.</li>
</ul>
<ul>
<li>Fail by throwing an <code>std::runtime_error</code>.</li>
</ul>
<p>In any case, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aa3ec479f887c60ad89d65eb945a82499">binaryLoader</a> property is set to this method's return value. </p>

</div>
</div>
<a id="afd39c1182056d1aeb6e2ed37cae5f3af" name="afd39c1182056d1aeb6e2ed37cae5f3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39c1182056d1aeb6e2ed37cae5f3af">&#9670;&#160;</a></span>loadContainers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::loadContainers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads memory from binary containers. </p>
<p>If the engine has an interpretation whose memory map is missing or empty, then the engine obtains a binary loader via <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a2a9f76100ba8f1fa2837e3923f81843f">obtainLoader</a> and invokes its <code>load</code> method on the interpretation. It then copies the interpretation's memory map into the engine (if present, or leaves it as is). </p>

</div>
</div>
<a id="ad99c554ea353e806ea2cd06c1cf91e8e" name="ad99c554ea353e806ea2cd06c1cf91e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99c554ea353e806ea2cd06c1cf91e8e">&#9670;&#160;</a></span>loadNonContainers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::loadNonContainers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads memory from non-containers. </p>
<p>Processes each non-container string (as determined by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6b5ab46a4ea34326e3962f12304058e3">isNonContainer</a>) and modifies the memory map according to the string. </p>

</div>
</div>
<a id="adaad4c513ab1367a57efb7020f59809b" name="adaad4c513ab1367a57efb7020f59809b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaad4c513ab1367a57efb7020f59809b">&#9670;&#160;</a></span>createTunedPartitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::createTunedPartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a tuned partitioner. </p>
<p>Returns a partitioner that is tuned to operate on a specific instruction set architecture. A <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a300676870a43dbd55a4f06f26cebf4c3">memoryMap</a> must be assigned already, either explicitly or as the result of earlier steps. </p>

</div>
</div>
<a id="a55935a1a8f329095d67e2db3297885e5" name="a55935a1a8f329095d67e2db3297885e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55935a1a8f329095d67e2db3297885e5">&#9670;&#160;</a></span>createPartitionerFromAst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::createPartitionerFromAst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partitioner from an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>
<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> data structures are often more useful and more efficient for analysis than an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. This method initializes the engine and a new partitioner with information from the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. </p>

</div>
</div>
<a id="a3064f6579ce755107d3068e8722ebbf8" name="a3064f6579ce755107d3068e8722ebbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064f6579ce755107d3068e8722ebbf8">&#9670;&#160;</a></span>partitionCilSections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::partitionCilSections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition any sections containing CIL code. </p>
<p>Decodes and partitions any sections of type <a class="el" href="classSgAsmCliHeader.html" title="CIL Managed Code section.">SgAsmCliHeader</a>. These sections contain CIL byte code.</p>
<p>Returns true if a section containing CIL code was found, false otherwise. </p>

</div>
</div>
<a id="ac920b49b4a35e607662ebe79ef38b684" name="ac920b49b4a35e607662ebe79ef38b684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920b49b4a35e607662ebe79ef38b684">&#9670;&#160;</a></span>hasCilCodeSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::hasCilCodeSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the interpretation header contains a CIL code section. </p>
<p>When the interpretation has a header with a section named "CLR Runtime Header", it contains CIL code. This predicate returns true for such interpretations. </p>

</div>
</div>
<a id="a743bb8de70898a560d3c5631352eb2d7" name="a743bb8de70898a560d3c5631352eb2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743bb8de70898a560d3c5631352eb2d7">&#9670;&#160;</a></span>makeEntryFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeEntryFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions at specimen entry addresses. </p>
<p>A function is created at each specimen entry address for all headers in the specified interpretation and adds them to the specified partitioner's CFG/AUM.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a79868798ac597701302c6eb6a4b8bcee" name="a79868798ac597701302c6eb6a4b8bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79868798ac597701302c6eb6a4b8bcee">&#9670;&#160;</a></span>makeErrorHandlingFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeErrorHandlingFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions at error handling addresses. </p>
<p>Makes a function at each error handling address in the specified interpratation and inserts the function into the specified partitioner's CFG/AUM.</p>
<p>Returns the list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a3aa1c388456e2acfc151b837753c5b95" name="a3aa1c388456e2acfc151b837753c5b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa1c388456e2acfc151b837753c5b95">&#9670;&#160;</a></span>makeImportFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeImportFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions at import trampolines. </p>
<p>Makes a function at each import trampoline and inserts them into the specified partitioner's CFG/AUM. An import trampoline is a thunk that branches to a dynamically loaded/linked function. Since ROSE does not necessarily load/link dynamic functions, they often don't appear in the executable. Therefore, this function can be called to create functions from the trampolines and give them the same name as the function they would have called had the link step been performed.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a0bc7d607787ddbd671d55461654fc9c2" name="a0bc7d607787ddbd671d55461654fc9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc7d607787ddbd671d55461654fc9c2">&#9670;&#160;</a></span>makeExportFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeExportFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions at export addresses. </p>
<p>Makes a function at each address that is indicated as being an exported function, and inserts them into the specified partitioner's CFG/AUM.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a6a6cd542799c775c18a0b1e8224c6f25" name="a6a6cd542799c775c18a0b1e8224c6f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6cd542799c775c18a0b1e8224c6f25">&#9670;&#160;</a></span>makeSymbolFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeSymbolFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions for symbols. </p>
<p>Makes a function for each function symbol in the various symbol tables under the specified interpretation and inserts them into the specified partitioner's CFG/AUM.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a51cd71faaf8267a65bb259ae19fb891d" name="a51cd71faaf8267a65bb259ae19fb891d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cd71faaf8267a65bb259ae19fb891d">&#9670;&#160;</a></span>makeContainerFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeContainerFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions based on specimen container. </p>
<p>Traverses the specified interpretation parsed from, for example, related ELF or PE containers, and make functions at certain addresses that correspond to specimen entry points, imports and exports, symbol tables, etc. This method only calls many of the other "make*Functions" methods and accumulates their results.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="af00eb185edcf2fd1ddc33cdd5c66b74e" name="af00eb185edcf2fd1ddc33cdd5c66b74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00eb185edcf2fd1ddc33cdd5c66b74e">&#9670;&#160;</a></span>makeInterruptVectorFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeInterruptVectorFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions from an interrupt vector. </p>
<p>Reads the interrupt vector and builds functions for its entries. The functions are inserted into the partitioner's CFG/AUM.</p>
<p>Returns the list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a3b3e80597c06b84a64ff67634429b1d3" name="a3b3e80597c06b84a64ff67634429b1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3e80597c06b84a64ff67634429b1d3">&#9670;&#160;</a></span>makeUserFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeUserFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; rose_addr_t &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a function at each specified address. </p>
<p>A function is created at each address and is attached to the partitioner's CFG/AUM. Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="afdc17bce5e5b25955cbe4ba4cf29a11e" name="afdc17bce5e5b25955cbe4ba4cf29a11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc17bce5e5b25955cbe4ba4cf29a11e">&#9670;&#160;</a></span>discoverBasicBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::discoverBasicBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discover as many basic blocks as possible. </p>
<p>Processes the "undiscovered" work list until the list becomes empty. This list is the list of basic block placeholders for which no attempt has been made to discover instructions. This method implements a recursive descent disassembler, although it does not process the control flow edges in any particular order. Subclasses are expected to override this to implement a more directed approach to discovering basic blocks. </p>

</div>
</div>
<a id="a9e884b6892acdfbf4f3e2b2064667ddc" name="a9e884b6892acdfbf4f3e2b2064667ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e884b6892acdfbf4f3e2b2064667ddc">&#9670;&#160;</a></span>makeNextDataReferencedFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextDataReferencedFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t &amp;&#160;</td>
          <td class="paramname"><em>startVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan read-only data to find function pointers. </p>
<p>Scans read-only data beginning at the specified address in order to find pointers to code, and makes a new function at when found. The pointer must be word aligned and located in memory that's mapped read-only (not writable and not executable), and it must not point to an unknown instruction or an instruction that overlaps with any instruction that's already in the CFG/AUM.</p>
<p>Returns a pointer to a newly-allocated function that has not yet been attached to the CFG/AUM, or a null pointer if no function was found. In any case, the startVa is updated so it points to the next read-only address to check.</p>
<p>Functions created in this manner have the <code><a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852caa5d8ffc6d1dd0556b5c44c7c9e73b2bc" title="Address was found in read-only data area by scanning the data.">SgAsmFunction::FUNC_SCAN_RO_DATA</a></code> reason. </p>

</div>
</div>
<a id="a605a091498460bbb92e980d187fbe0dd" name="a605a091498460bbb92e980d187fbe0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605a091498460bbb92e980d187fbe0dd">&#9670;&#160;</a></span>makeNextCodeReferencedFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextCodeReferencedFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan instruction ASTs to function pointers. </p>
<p>Scans each instruction to find pointers to code and makes a new function when found. The pointer must be word aligned and located in memory that's mapped read-only (not writable and not executable), and it most not point to an unknown instruction of an instruction that overlaps with any instruction that's already in the CFG/AUM.</p>
<p>This function requires that the partitioner has been initialized to track instruction ASTs as they are added to and removed from the CFG/AUM.</p>
<p>Returns a pointer to a newly-allocated function that has not yet been attached to the CFG/AUM, or a null pointer if no function was found.</p>
<p>Functions created in this manner have the <code><a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852cad3eef50a85628a15b71d569dc2b72818" title="Address was found in read-only data referenced by an existing instruction.">SgAsmFunction::FUNC_INSN_RO_DATA</a></code> reason. </p>

</div>
</div>
<a id="a01d7f085078536ee5ee83c6af02c4732" name="a01d7f085078536ee5ee83c6af02c4732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d7f085078536ee5ee83c6af02c4732">&#9670;&#160;</a></span>makeCalledFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeCalledFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions for function call edges. </p>
<p>Scans the partitioner's CFG to find edges that are marked as function calls and makes a function at each target address that is concrete. The function is added to the specified partitioner's CFG/AUM.</p>
<p>Returns a list of such functions, some of which may have existed prior to this call. </p>

</div>
</div>
<a id="a5ce65a7af6140935d253420ccc2ab422" name="a5ce65a7af6140935d253420ccc2ab422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce65a7af6140935d253420ccc2ab422">&#9670;&#160;</a></span>makeNextPrologueFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextPrologueFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make function at prologue pattern. </p>
<p>Scans executable memory starting at the specified address and which is not represented in the CFG/AUM and looks for byte patterns and/or instruction patterns that indicate the start of a function. When a pattern is found a function (or multiple functions, depending on the type of matcher) is created and inserted into the specified partitioner's CFG/AUM.</p>
<p>Patterns are found by calling the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a057bdf19279739ae62f719679b9e435e">Partitioner::nextFunctionPrologue</a> method, which most likely invokes a variety of predefined and user-defined callbacks to search for the next pattern.</p>
<p>Returns a vector of non-null function pointers pointer for the newly inserted functions, otherwise returns an empty vector. If the <code>lastSearchedVa</code> is provided, it will be set to the highest address at which a function prologue was searched. </p>

</div>
</div>
<a id="a9fedcd5d7e926f4f15b5e7c2cd8dfc20" name="a9fedcd5d7e926f4f15b5e7c2cd8dfc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fedcd5d7e926f4f15b5e7c2cd8dfc20">&#9670;&#160;</a></span>makeNextPrologueFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextPrologueFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t &amp;&#160;</td>
          <td class="paramname"><em>lastSearchedVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make function at prologue pattern. </p>
<p>Scans executable memory starting at the specified address and which is not represented in the CFG/AUM and looks for byte patterns and/or instruction patterns that indicate the start of a function. When a pattern is found a function (or multiple functions, depending on the type of matcher) is created and inserted into the specified partitioner's CFG/AUM.</p>
<p>Patterns are found by calling the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a057bdf19279739ae62f719679b9e435e">Partitioner::nextFunctionPrologue</a> method, which most likely invokes a variety of predefined and user-defined callbacks to search for the next pattern.</p>
<p>Returns a vector of non-null function pointers pointer for the newly inserted functions, otherwise returns an empty vector. If the <code>lastSearchedVa</code> is provided, it will be set to the highest address at which a function prologue was searched. </p>

</div>
</div>
<a id="a88484e27e70924d65adc2b8f4006930a" name="a88484e27e70924d65adc2b8f4006930a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88484e27e70924d65adc2b8f4006930a">&#9670;&#160;</a></span>makeFunctionFromInterFunctionCalls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeFunctionFromInterFunctionCalls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t &amp;&#160;</td>
          <td class="paramname"><em>startVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make functions from inter-function calls. </p>
<p>This method scans the unused executable areas between existing functions to look for additional function calls and creates new functions for those calls. It starts the scan at <code>startVa</code> which is updated upon return to be the next address that needs to be scanned. The <code>startVa</code> is never incremented past the end of the address space (i.e., it never wraps back around to zero), so care should be taken to not call this in an infinite loop when the end of the address space is reached.</p>
<p>The scanner tries to discover new basic blocks in the unused portion of the address space. These basic blocks are not allowed to overlap with existing, attached basic blocks, data blocks, or functions since that is an indication that we accidentally disassembled non-code. If the basic block looks like a function call and the target address(es) is not pointing into the middle of an existing basic block, data-block, or function then a new function is created at the target address. The basic blocks which were scanned are not explicitly attached to the partitioner's CFG since we cannot be sure we found their starting address, but they might be later attached by following the control flow from the functions we did discover.</p>
<p>Returns the new function(s) for the first basic block that satisfied the requirements outlined above, and updates <code>startVa</code> to be a greater address which is not part of the basic block that was scanned. </p>

</div>
</div>
<a id="a6386ffa19a77f160ab5a50947a25586c" name="a6386ffa19a77f160ab5a50947a25586c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6386ffa19a77f160ab5a50947a25586c">&#9670;&#160;</a></span>discoverFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::discoverFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discover as many functions as possible. </p>
<p>Discover as many functions as possible by discovering as many basic blocks as possible (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#afdc17bce5e5b25955cbe4ba4cf29a11e">discoverBasicBlocks</a>), Each time we run out of basic blocks to try, we look for another function prologue pattern at the lowest possible address and then recursively discover more basic blocks. When this procedure is exhausted a call to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a54bc2eb1026d7dfba09236a887d74e3f">attachBlocksToFunctions</a> tries to attach each basic block to a function. </p>

</div>
</div>
<a id="a09ec9187929c555d19215b2ba685d95e" name="a09ec9187929c555d19215b2ba685d95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ec9187929c555d19215b2ba685d95e">&#9670;&#160;</a></span>attachDeadCodeToFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachDeadCodeToFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach dead code to function. </p>
<p>Examines the ghost edges for the basic blocks that belong to the specified function in order to discover basic blocks that are not reachable according the CFG, adds placeholders for those basic blocks, and causes the function to own those blocks.</p>
<p>If <code>maxIterations</code> is larger than one then multiple iterations are performed. Between each iteration <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a10dc8c48c2006ea3ff9161528ca78bb9">makeNextBasicBlock</a> is called repeatedly to recursively discover instructions for all pending basic blocks, and then the CFG is traversed to add function-reachable basic blocks to the function. The loop terminates when the maximum number of iterations is reached, or when no more dead code can be found within this function.</p>
<p>Returns the set of newly discovered addresses for unreachable code. These are the ghost edge target addresses discovered at each iteration of the loop and do not include addresses of basic blocks that are reachable from the ghost target blocks. </p>

</div>
</div>
<a id="a90fffe1c37d1bb43728945763a249db3" name="a90fffe1c37d1bb43728945763a249db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fffe1c37d1bb43728945763a249db3">&#9670;&#160;</a></span>attachPaddingToFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachPaddingToFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach function padding to function. </p>
<p>Examines the memory immediately prior to the specified function's entry address to determine if it is alignment padding. If so, it creates a data block for the padding and adds it to the function.</p>
<p>Returns the padding data block, which might have existed prior to this call. Returns null if the function apparently has no padding. </p>

</div>
</div>
<a id="a17bda23e985da36fd069fb1bb1f51f22" name="a17bda23e985da36fd069fb1bb1f51f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bda23e985da36fd069fb1bb1f51f22">&#9670;&#160;</a></span>attachPaddingToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachPaddingToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach padding to all functions. </p>
<p>Invokes <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a90fffe1c37d1bb43728945763a249db3">attachPaddingToFunction</a> for each known function and returns the set of data blocks that were returned by the individual calls. </p>

</div>
</div>
<a id="af63799c1787b8fce784cd45edc833e59" name="af63799c1787b8fce784cd45edc833e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63799c1787b8fce784cd45edc833e59">&#9670;&#160;</a></span>attachAllSurroundedCodeToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachAllSurroundedCodeToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach all possible intra-function basic blocks to functions. </p>
<p>This is similar to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a708ab05716aac3a6bf5e6e224f18d116">attachSurroundedCodeToFunctions</a> except it calls that method repeatedly until it cannot do anything more. Between each call it also follows the CFG for the newly discovered blocks to discover as many blocks as possible, creates more functions by looking for function calls, and attaches additional basic blocks to functions by following the CFG for each function.</p>
<p>This method is called automatically by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">Engine::runPartitioner</a> if the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#abe281e33eb3cb28f4e6b3a0b737163f0">PartitionerSettings::findingIntraFunctionCode</a> property is set.</p>
<p>Returns the sum from all the calls to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a708ab05716aac3a6bf5e6e224f18d116">attachSurroundedCodeToFunctions</a>. </p>

</div>
</div>
<a id="a708ab05716aac3a6bf5e6e224f18d116" name="a708ab05716aac3a6bf5e6e224f18d116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708ab05716aac3a6bf5e6e224f18d116">&#9670;&#160;</a></span>attachSurroundedCodeToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachSurroundedCodeToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach intra-function basic blocks to functions. </p>
<p>This method scans the unused address intervals (those addresses that are not represented by the CFG/AUM). For each unused interval, if the interval is immediately surrounded by a single function then a basic block placeholder is created at the beginning of the interval and added to the function.</p>
<p>Returns the number of new placeholders created. </p>

</div>
</div>
<a id="a54bc2eb1026d7dfba09236a887d74e3f" name="a54bc2eb1026d7dfba09236a887d74e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bc2eb1026d7dfba09236a887d74e3f">&#9670;&#160;</a></span>attachBlocksToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachBlocksToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach basic blocks to functions. </p>
<p>Calls <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a689e06c1c1186c02c725d79a9339dd33">Partitioner::discoverFunctionBasicBlocks</a> once for each known function the partitioner's CFG/AUM in a sophomoric attempt to assign existing basic blocks to functions. </p>

</div>
</div>
<a id="a26a887afbd24570491c8188c101ff793" name="a26a887afbd24570491c8188c101ff793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a887afbd24570491c8188c101ff793">&#9670;&#160;</a></span>attachDeadCodeToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachDeadCodeToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach dead code to functions. </p>
<p>Calls <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a09ec9187929c555d19215b2ba685d95e">attachDeadCodeToFunction</a> once for each function that exists in the specified partitioner's CFG/AUM, passing along <code>maxIterations</code> each time.</p>
<p>Returns the union of the dead code addresses discovered for each function. </p>

</div>
</div>
<a id="a3ed1f753963e0afe63ac2e45327e8b19" name="a3ed1f753963e0afe63ac2e45327e8b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed1f753963e0afe63ac2e45327e8b19">&#9670;&#160;</a></span>attachSurroundedDataToFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::attachSurroundedDataToFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach intra-function data to functions. </p>
<p>Looks for addresses that are not part of the partitioner's CFG/AUM and which are surrounded immediately below and above by the same function and add that address interval as a data block to the surrounding function. Returns the list of such data blocks added.</p>

</div>
</div>
<a id="aaa6e22d06ca7e370a24445a5bb941ae1" name="aaa6e22d06ca7e370a24445a5bb941ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6e22d06ca7e370a24445a5bb941ae1">&#9670;&#160;</a></span>makeNextCallReturnEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextCallReturnEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::logic::tribool&#160;</td>
          <td class="paramname"><em>assumeCallReturns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a call-return edge and discover its basic block. </p>
<p>Inserts a call-return (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) edge for some function call that lacks such an edge and for which the callee may return. The <code>assumeCallReturns</code> parameter determines whether a call-return edge should be added or not for callees whose may-return analysis is indeterminate. If <code>assumeCallReturns</code> is true then an indeterminate callee will have a call-return edge added; if false then no call-return edge is added; if indeterminate then no call-return edge is added at this time but the vertex is saved so it can be reprocessed later.</p>
<p>Returns true if a new call-return edge was added to some call, or false if no such edge could be added. A post condition for a false return is that the pendingCallReturn list is empty. </p>

</div>
</div>
<a id="a457b7d7b44f5ed59f362fed9c442fd5c" name="a457b7d7b44f5ed59f362fed9c442fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457b7d7b44f5ed59f362fed9c442fd5c">&#9670;&#160;</a></span>makeNextBasicBlockFromPlaceholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextBasicBlockFromPlaceholder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discover basic block at next placeholder. </p>
<p>Discovers a basic block at some arbitrary placeholder. Returns a pointer to the new basic block if a block was discovered, or null if no block is discovered. A postcondition for a null return is that the CFG has no edges coming into the "undiscovered" vertex. </p>

</div>
</div>
<a id="a10dc8c48c2006ea3ff9161528ca78bb9" name="a10dc8c48c2006ea3ff9161528ca78bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dc8c48c2006ea3ff9161528ca78bb9">&#9670;&#160;</a></span>makeNextBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::makeNextBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discover a basic block. </p>
<p>Discovers another basic block if possible. A variety of methods will be used to determine where to discover the next basic block:</p>
<ul>
<li>Discover a block at a placeholder by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a457b7d7b44f5ed59f362fed9c442fd5c">makeNextBasicBlockFromPlaceholder</a></li>
</ul>
<ul>
<li>Insert a new call-return (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) edge for a function call that may return. Insertion of such an edge may result in a new placeholder for which this method then discovers a basic block. The call-return insertion happens in two passes: the first pass only adds an edge for a callee whose may-return analysis is positive; the second pass relaxes that requirement and inserts an edge for any callee whose may-return is indeterminate (i.e., if ROSE can't prove that a callee never returns then assume it may return).</li>
</ul>
<p>Returns the basic block that was discovered, or the null pointer if there are no pending undiscovered blocks. </p>

</div>
</div>
<a id="aa3ec479f887c60ad89d65eb945a82499" name="aa3ec479f887c60ad89d65eb945a82499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ec479f887c60ad89d65eb945a82499">&#9670;&#160;</a></span>binaryLoader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::binaryLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: binary loader. </p>
<p>The binary loader that maps a binary container's sections into simulated memory and optionally performs dynamic linking and relocation fixups. If none is specified then the engine will choose one based on the container. </p>

</div>
</div>
<a id="ae38b7764fd778dd1787ad1b5983ddac4" name="ae38b7764fd778dd1787ad1b5983ddac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38b7764fd778dd1787ad1b5983ddac4">&#9670;&#160;</a></span>binaryLoader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::binaryLoader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a98bc9978de05a4591c74e83a9b3cd09d">BinaryLoaderPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: binary loader. </p>
<p>The binary loader that maps a binary container's sections into simulated memory and optionally performs dynamic linking and relocation fixups. If none is specified then the engine will choose one based on the container. </p>

</div>
</div>
<a id="a6789ff99228eb4b4368b1deced2e4a65" name="a6789ff99228eb4b4368b1deced2e4a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789ff99228eb4b4368b1deced2e4a65">&#9670;&#160;</a></span>functionMatcherThunks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::functionMatcherThunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Predicate for finding functions that are thunks. </p>
<p>This collective predicate is used when searching for function prologues in order to create new functions. Its purpose is to try to match sequences of instructions that look like thunks and then create a function at that address. A suitable default list of predicates is created when the engine is initialized, and can either be replaced by a new list, an empty list, or the list itself can be adjusted. The list is consulted only when <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#acc692b1cc52dca56480435feebae1a6b">PartitionerSettings::findingThunks</a> is set. </p>

</div>
</div>
<a id="a299728e68e77cfcf5432ba84d167ad0e" name="a299728e68e77cfcf5432ba84d167ad0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299728e68e77cfcf5432ba84d167ad0e">&#9670;&#160;</a></span>functionMatcherThunks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::functionMatcherThunks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Predicate for finding functions that are thunks. </p>
<p>This collective predicate is used when searching for function prologues in order to create new functions. Its purpose is to try to match sequences of instructions that look like thunks and then create a function at that address. A suitable default list of predicates is created when the engine is initialized, and can either be replaced by a new list, an empty list, or the list itself can be adjusted. The list is consulted only when <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#acc692b1cc52dca56480435feebae1a6b">PartitionerSettings::findingThunks</a> is set. </p>

</div>
</div>
<a id="aea921f6b6e2ec220f1fd440e712726ee" name="aea921f6b6e2ec220f1fd440e712726ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea921f6b6e2ec220f1fd440e712726ee">&#9670;&#160;</a></span>functionSplittingThunks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::functionSplittingThunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Predicate for finding thunks at the start of functions. </p>
<p>This collective predicate is used when searching for thunks at the beginnings of existing functions in order to split those thunk instructions into their own separate function. A suitable default list of predicates is created when the engine is initialized, and can either be replaced by a new list, an empty list, or the list itself can be adjusted. The list is consulted only when <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#a3a6974e6827a3d44514e3af1bea33a59">PartitionerSettings::splittingThunks</a> is set. </p>

</div>
</div>
<a id="ae5bad9732a26e4f42e1b367d7e675bc9" name="ae5bad9732a26e4f42e1b367d7e675bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bad9732a26e4f42e1b367d7e675bc9">&#9670;&#160;</a></span>functionSplittingThunks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::functionSplittingThunks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a5314166bb1791357eac01fc00f72fc55">ThunkPredicatesPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Predicate for finding thunks at the start of functions. </p>
<p>This collective predicate is used when searching for thunks at the beginnings of existing functions in order to split those thunk instructions into their own separate function. A suitable default list of predicates is created when the engine is initialized, and can either be replaced by a new list, an empty list, or the list itself can be adjusted. The list is consulted only when <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1PartitionerSettings.html#a3a6974e6827a3d44514e3af1bea33a59">PartitionerSettings::splittingThunks</a> is set. </p>

</div>
</div>
<a id="ad03bd239e6a7015113c65d86c57aae74" name="ad03bd239e6a7015113c65d86c57aae74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03bd239e6a7015113c65d86c57aae74">&#9670;&#160;</a></span>matchFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::matchFactory </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>specimen</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate for matching a concrete engine factory by settings and specimen. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abbcb86e6e754431fc1896eae344f07c0">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a1bb71405fbca62ef852af0e581ef6831" name="a1bb71405fbca62ef852af0e581ef6831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb71405fbca62ef852af0e581ef6831">&#9670;&#160;</a></span>instanceFromFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">EnginePtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::instanceFromFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor for factories. </p>
<p>This creates a new object by calling the class method <code>instance</code> for the class of which <code>this</code> is a type. All arguments are passed to <code>instance</code>. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a76f5b0cd482ce8f8d40647f1f7000e1d">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a3fe27b15b46d801340c5d72886941941" name="a3fe27b15b46d801340c5d72886941941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe27b15b46d801340c5d72886941941">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the engine to its initial state. </p>
<p>This does not reset the settings properties since that can be done easily by constructing a new engine. It only resets the interpretation, binary loader, and memory map so all the top-level steps get executed again. This is a useful way to re-use the same partitioner to process multiple specimens. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ad1c9b0d871777a9bc0e661f2ae02eddd">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a6f07fd60c2747e9367dec98def840779" name="a6f07fd60c2747e9367dec98def840779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f07fd60c2747e9367dec98def840779">&#9670;&#160;</a></span>frontend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::EngineBinary::frontend </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most basic usage of the partitioner. </p>
<p>This method does everything from parsing the command-line to generating an abstract syntax tree. If all is successful, then an abstract syntax tree is returned. The return value is a <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> node that contains all the detected functions. If the specimen consisted of an ELF or PE container then the parent nodes of the returned <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will lead eventually to an <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> node.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The command-line supports a "--help" (or "-h") switch to describe all other switches and arguments, essentially generating output like a Unix man(1) page.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ada804bf70502647031d9bb3cf717d8c2">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a6a131b9a3cb5ab3ae8457023e764187f" name="a6a131b9a3cb5ab3ae8457023e764187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a131b9a3cb5ab3ae8457023e764187f">&#9670;&#160;</a></span>parseContainers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> * Rose::BinaryAnalysis::Partitioner2::EngineBinary::parseContainers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse specimen binary containers. </p>
<p>Parses the ELF and PE binary containers to create an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). If <code>fileNames</code> contains names that are recognized as raw data or other non-containers then they are skipped over at this stage but processed during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a> stage.</p>
<p>This method tries to determine the specimen architecture. It also resets the interpretation to be the return value (see below), and clears the memory map.</p>
<p>Returns a binary interpretation (perhaps one of many). ELF files have only one interpretation; PE files have a DOS and a PE interpretation and this method will return the PE interpretation. The user may, at this point, select a different interpretation. If the list of names has nothing suitable for ROSE's <code>frontend</code> function (the thing that does the container parsing) then the null pointer is returned.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="ab4418f0c2482653d053a9968311de0f3" name="ab4418f0c2482653d053a9968311de0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4418f0c2482653d053a9968311de0f3">&#9670;&#160;</a></span>loadSpecimens() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::loadSpecimens </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and/or link interpretation. </p>
<p>Loads and/or links the engine's interpretation according to the engine's binary loader with these steps:</p>
<ul>
<li>Clears any existing memory map in the engine.</li>
</ul>
<ul>
<li>If the binary containers have not been parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">areContainersParsed</a> returns false, i.e., engine has a null binary interpretation) then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a131b9a3cb5ab3ae8457023e764187f">parseContainers</a> is called with the same arguments.</li>
</ul>
<ul>
<li>If binary containers are present but the chosen binary interpretation's memory map is null or empty, then initialize the memory map.</li>
</ul>
<ul>
<li>Continue initializing the memory map by processing all non-container arguments.</li>
</ul>
<p>Returns a reference to the engine's memory map.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a9adf0374e582f86a3cd0b03a007a73c8" name="a9adf0374e582f86a3cd0b03a007a73c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adf0374e582f86a3cd0b03a007a73c8">&#9670;&#160;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition instructions into basic blocks and functions. </p>
<p>Disassembles and organizes instructions into basic blocks and functions with these steps:</p>
<ul>
<li>If the specimen is not loaded (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a>) then call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a>. The no-argument version of this function requires that specimens have already been loaded.</li>
</ul>
<ul>
<li>Determine the architecture for the specimen by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a>.</li>
</ul>
<ul>
<li>Create a partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#adfd9912394b62e64189721f25d5a16e8">createPartitioner</a>.</li>
</ul>
<ul>
<li>Run the partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a>.</li>
</ul>
<p>Returns the partitioner that was used and which contains the results.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a38b30b8e67b6837e20622f5b6589e97d" name="a38b30b8e67b6837e20622f5b6589e97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b30b8e67b6837e20622f5b6589e97d">&#9670;&#160;</a></span>buildAst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::EngineBinary::buildAst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain an abstract syntax tree. </p>
<p>Constructs a new abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) from partitioner information with these steps:</p>
<ul>
<li>If the partitioner has not been run yet, then do that now with the same arguments. The zero-argument version invokes the zero-argument <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9adf0374e582f86a3cd0b03a007a73c8">partition</a>, which requires that the specimen has already been loaded by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a>.</li>
</ul>
<ul>
<li>Call <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af774642c835f58878dfe39a06c23184c" title="Builds an AST from the CFG.">Modules::buildAst</a> to build the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.</li>
</ul>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ac5ab3614209149b652b26e2aa24cd064">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a2bf97876fddae32fcdbf921acdac5ad3" name="a2bf97876fddae32fcdbf921acdac5ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf97876fddae32fcdbf921acdac5ad3">&#9670;&#160;</a></span>commandLineSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a> &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::commandLineSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command-line switches for a particular engine. </p>
<p>Returns the list of switch groups that declare the command-line switches specific to a particular engine. Since every <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html" title="Base class for engines driving the partitioner.">Engine</a></code> subclass needs its own particular switches (possibly in addition to the base class switches), this is implemented in each subclass that needs switches. The base class returns a list of switch groups that are applicable to all engines, although the subclasses can refine this list, and the subclass implementations should augment what the base implementation returns.</p>
<p>In order to implement the "--help" switch to show the man page, we need a way to include the switch documentation for all possible engine subclasses at once. Therefore, the returned command line switch groups must have names and prefixes that are unique across all subclasses, and the descriptions should refer to the name of the subclass. For instance, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html">EngineBinary</a> class, which returns many switch groups, will name the switch groups like "binary-load", "binary-dis", "binary-part", "binary-ast", etc. and will make it clear in each group description that these switches are intended for the binary engine.</p>
<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa9965bfadc44cb954411f3b3e6854669">allCommandLineSwitches</a> for details about how the "--help" man page is constructed. </p>

<p>Reimplemented from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#abffbe6a56926af17bdab6884678e7f41">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="aebd369fe7e4baa7949c16c6209994f88" name="aebd369fe7e4baa7949c16c6209994f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd369fe7e4baa7949c16c6209994f88">&#9670;&#160;</a></span>specimenNameDocumentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; std::string, std::string &gt; Rose::BinaryAnalysis::Partitioner2::EngineBinary::specimenNameDocumentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Documentation about how the specimen is specified. </p>
<p>The documentation string that's returned is expected to be used in a command-line parser description and thus may contain special formatting constructs. For most engine subclasses, this will be a description of those command-line positional arguments that describe the specimen. For instance, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineJvm.html">EngineJvm</a> subclass would probably document that the specimen consists of one or more file names ending with the string ".class".</p>
<p>In order to support the &ndash;help switch that generates the man page, it must be possible to include the documentation for all subclasses concurrently. Therefore, each subclass returns both a section title and the section documentation string. The section title and documentation string should make it clear that this part of the documentation applies only to that particular subclass. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a38bce2bee37696e1401bfb11a671302b">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a6b5ab46a4ea34326e3962f12304058e3" name="a6b5ab46a4ea34326e3962f12304058e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ab46a4ea34326e3962f12304058e3">&#9670;&#160;</a></span>isNonContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::isNonContainer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a specimen name is a non-container. </p>
<p>Certain strings are recognized as special instructions for how to adjust a memory map and are not intended to be passed to ROSE's <code>frontend</code> function. This predicate returns true for such strings. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acac7e86f89e17c2157d282fa93ea677b">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="ac7ad483d8789ee6daea7bcddd0e3a752" name="ac7ad483d8789ee6daea7bcddd0e3a752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ad483d8789ee6daea7bcddd0e3a752">&#9670;&#160;</a></span>areContainersParsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Partitioner2::EngineBinary::areContainersParsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if containers are parsed. </p>
<p>Specifically, returns true if the engine has a non-null interpretation. If it has a null interpretation then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a131b9a3cb5ab3ae8457023e764187f">parseContainers</a> might have already been called but no binary containers specified, in which case calling it again with the same file names will have no effect. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a72aa2d53efe401584ac697a0e7c904eb">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="adfd9912394b62e64189721f25d5a16e8" name="adfd9912394b62e64189721f25d5a16e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd9912394b62e64189721f25d5a16e8">&#9670;&#160;</a></span>createPartitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::EngineBinary::createPartitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create partitioner. </p>
<p>This is the method usually called to create a new partitioner. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aa12a693635a6ec60ec512263070f6c01">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a1d69777f095a892b69c3e4ff85fd5129" name="a1d69777f095a892b69c3e4ff85fd5129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d69777f095a892b69c3e4ff85fd5129">&#9670;&#160;</a></span>runPartitionerInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::runPartitionerInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds interesting things to work on initially. </p>
<p>Seeds the partitioner with addresses and functions where recursive disassembly should begin. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a9b274b6cd96d876c4e5813ba9967b572">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a9024f922e4da510563597d09560802df" name="a9024f922e4da510563597d09560802df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9024f922e4da510563597d09560802df">&#9670;&#160;</a></span>runPartitionerRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::runPartitionerRecursive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the recursive part of partioning. </p>
<p>This is the long-running guts of the partitioner. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a33f8fda7a63fde3b1a080972d66f99c8">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a46b2658f7518581ccbddb00060132b7c" name="a46b2658f7518581ccbddb00060132b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b2658f7518581ccbddb00060132b7c">&#9670;&#160;</a></span>runPartitionerFinal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Partitioner2::EngineBinary::runPartitionerFinal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the final parts of partitioning. </p>
<p>This does anything necessary after the main part of partitioning is finished. For instance, it might give names to some functions that don't have names yet. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a71e3e5118b7540c0734a5dd692fd2a45">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a4a07715b94eab6083d62134fd122190d" name="a4a07715b94eab6083d62134fd122190d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a07715b94eab6083d62134fd122190d">&#9670;&#160;</a></span>roseFrontendReplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgProject.html">SgProject</a> * Rose::BinaryAnalysis::Partitioner2::EngineBinary::roseFrontendReplacement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; boost::filesystem::path &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="a7578d0b2e81c599a3b4749bad2e54fb5" name="a7578d0b2e81c599a3b4749bad2e54fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7578d0b2e81c599a3b4749bad2e54fb5">&#9670;&#160;</a></span>frontend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::frontend </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most basic usage of the partitioner. </p>
<p>This method does everything from parsing the command-line to generating an abstract syntax tree. If all is successful, then an abstract syntax tree is returned. The return value is a <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> node that contains all the detected functions. If the specimen consisted of an ELF or PE container then the parent nodes of the returned <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will lead eventually to an <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> node.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The command-line supports a "--help" (or "-h") switch to describe all other switches and arguments, essentially generating output like a Unix man(1) page.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

</div>
</div>
<a id="ada804bf70502647031d9bb3cf717d8c2" name="ada804bf70502647031d9bb3cf717d8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada804bf70502647031d9bb3cf717d8c2">&#9670;&#160;</a></span>frontend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::frontend </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most basic usage of the partitioner. </p>
<p>This method does everything from parsing the command-line to generating an abstract syntax tree. If all is successful, then an abstract syntax tree is returned. The return value is a <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> node that contains all the detected functions. If the specimen consisted of an ELF or PE container then the parent nodes of the returned <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> will lead eventually to an <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> node.</p>
<p>The command-line can be provided as a typical <code>argc</code> and <code>argv</code> pair, or as a vector of arguments. In the latter case, the vector should not include <code>argv[0]</code> or <code>argv[argc]</code> (which is always a null pointer).</p>
<p>The command-line supports a "--help" (or "-h") switch to describe all other switches and arguments, essentially generating output like a Unix man(1) page.</p>
<p>The <code>purpose</code> should be a single line string that will be shown in the title of the man page and should not start with an upper-case letter, a hyphen, white space, or the name of the command. E.g., a disassembler tool might specify the purpose as "disassembles a binary specimen".</p>
<p>The <code>description</code> is a full, multi-line description written in the <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> markup language where "@" characters have special meaning.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ada804bf70502647031d9bb3cf717d8c2">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="acd6774f4a00e3395348580911f20cf7b" name="acd6774f4a00e3395348580911f20cf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6774f4a00e3395348580911f20cf7b">&#9670;&#160;</a></span>parseContainers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> * Rose::BinaryAnalysis::Partitioner2::Engine::parseContainers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse specimen binary containers. </p>
<p>Parses the ELF and PE binary containers to create an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). If <code>fileNames</code> contains names that are recognized as raw data or other non-containers then they are skipped over at this stage but processed during the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a> stage.</p>
<p>This method tries to determine the specimen architecture. It also resets the interpretation to be the return value (see below), and clears the memory map.</p>
<p>Returns a binary interpretation (perhaps one of many). ELF files have only one interpretation; PE files have a DOS and a PE interpretation and this method will return the PE interpretation. The user may, at this point, select a different interpretation. If the list of names has nothing suitable for ROSE's <code>frontend</code> function (the thing that does the container parsing) then the null pointer is returned.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#acd6774f4a00e3395348580911f20cf7b">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="ae4be5fcd45af5fcdfec6df6a416d7d28" name="ae4be5fcd45af5fcdfec6df6a416d7d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4be5fcd45af5fcdfec6df6a416d7d28">&#9670;&#160;</a></span>loadSpecimens() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::loadSpecimens </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;std::string&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and/or link interpretation. </p>
<p>Loads and/or links the engine's interpretation according to the engine's binary loader with these steps:</p>
<ul>
<li>Clears any existing memory map in the engine.</li>
</ul>
<ul>
<li>If the binary containers have not been parsed (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ac7ad483d8789ee6daea7bcddd0e3a752">areContainersParsed</a> returns false, i.e., engine has a null binary interpretation) then <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a6a131b9a3cb5ab3ae8457023e764187f">parseContainers</a> is called with the same arguments.</li>
</ul>
<ul>
<li>If binary containers are present but the chosen binary interpretation's memory map is null or empty, then initialize the memory map.</li>
</ul>
<ul>
<li>Continue initializing the memory map by processing all non-container arguments.</li>
</ul>
<p>Returns a reference to the engine's memory map.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="af906e88cbeeebed28dd5f4250f3da920" name="af906e88cbeeebed28dd5f4250f3da920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af906e88cbeeebed28dd5f4250f3da920">&#9670;&#160;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Engine::partition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;std::string&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition instructions into basic blocks and functions. </p>
<p>Disassembles and organizes instructions into basic blocks and functions with these steps:</p>
<ul>
<li>If the specimen is not loaded (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a63fe78b82a4d4495b16b273c91b36dd1">areSpecimensLoaded</a>) then call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a>. The no-argument version of this function requires that specimens have already been loaded.</li>
</ul>
<ul>
<li>Determine the architecture for the specimen by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aee425610d4789639e5f963bce81f8354">obtainArchitecture</a>.</li>
</ul>
<ul>
<li>Create a partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#adfd9912394b62e64189721f25d5a16e8">createPartitioner</a>.</li>
</ul>
<ul>
<li>Run the partitioner by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#aed87fa166db4263d0c3efe1b2eb2dead">runPartitioner</a>.</li>
</ul>
<p>Returns the partitioner that was used and which contains the results.</p>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<a id="ac5ab3614209149b652b26e2aa24cd064" name="ac5ab3614209149b652b26e2aa24cd064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ab3614209149b652b26e2aa24cd064">&#9670;&#160;</a></span>buildAst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Rose::BinaryAnalysis::Partitioner2::Engine::buildAst </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em> = <code>std::vector&lt;std::string&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain an abstract syntax tree. </p>
<p>Constructs a new abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) from partitioner information with these steps:</p>
<ul>
<li>If the partitioner has not been run yet, then do that now with the same arguments. The zero-argument version invokes the zero-argument <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#a9adf0374e582f86a3cd0b03a007a73c8">partition</a>, which requires that the specimen has already been loaded by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#ab4418f0c2482653d053a9968311de0f3">loadSpecimens</a>.</li>
</ul>
<ul>
<li>Call <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Modules.html#af774642c835f58878dfe39a06c23184c" title="Builds an AST from the CFG.">Modules::buildAst</a> to build the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.</li>
</ul>
<p>If an <code>std::runtime_exception</code> occurs and the <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineSettings.html#ad1af66373bc6ddeff5ce696f311710b4">EngineSettings::exitOnError</a> property is set, then the exception is caught, its text is emitted to the partitioner's fatal error stream, and <code>exit(1)</code> is invoked. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ac5ab3614209149b652b26e2aa24cd064">Rose::BinaryAnalysis::Partitioner2::Engine</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="EngineBinary_8h_source.html">EngineBinary.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
