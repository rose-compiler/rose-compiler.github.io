<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class V = Nothing, class E = Nothing, class VKey = GraphVertexNoKey&lt;V&gt;, class EKey = GraphEdgeNoKey&lt;E&gt;, class Alloc = DefaultAllocator&gt;<br />
class Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;</div><p>Graph containing user-defined vertices and edges. </p>
<h1><a class="anchor" id="nodes"></a>
Vertices and Edges</h1>
<p>This container stores user-defined data at each vertex and edge, along with information about the connectivity of vertices through edges. Semantics with respect to storing of user-defined data is similar to the STL's <code>std::list</code> type; namely, user values are copied into the container when they are inserted, and not copied thereafter. Accessors return references to those values. Edges are always directed and have source and target vertices. Self edges (an edge whose source and target vertex are the same) and parallel edges (two edges both having the same source vertex and both having the same target vertex) are supported.</p>
<p>Here's an example of declaring a graph that stores a string name for each vertex and a floating point weight for each edge:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;std::string, double&gt;</a> MyGraph;</div>
<div class="line">MyGraph graph;</div>
<div class="line">MyGraph::VertexIterator v1 = graph.<a class="code hl_function" href="classSawyer_1_1Container_1_1Graph.html#a5b2a6067898bbf9bdb5f8fc6936d79ff">insertVertex</a>(<span class="stringliteral">&quot;first vertex&quot;</span>);</div>
<div class="line">MyGraph::VertexIterator v2 = graph.insertVertex(<span class="stringliteral">&quot;second vertex&quot;</span>);</div>
<div class="line">graph.insertEdge(v1, v2, 1.2); <span class="comment">// v1 and v2 are the source and target vertices</span></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Graph_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a></div><div class="ttdoc">Graph containing user-defined vertices and edges.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8h_source.html#l00634">Graph.h:634</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Graph_html_a5b2a6067898bbf9bdb5f8fc6936d79ff"><div class="ttname"><a href="classSawyer_1_1Container_1_1Graph.html#a5b2a6067898bbf9bdb5f8fc6936d79ff">Sawyer::Container::Graph::insertVertex</a></div><div class="ttdeci">VertexIterator insertVertex(const VertexValue &amp;value=VertexValue())</div><div class="ttdoc">Insert a new vertex.</div><div class="ttdef"><b>Definition</b> <a href="Graph_8h_source.html#l01790">Graph.h:1790</a></div></div>
</div><!-- fragment --><p>This example shows a few features of the design: First, like STL containers, there is a clear separation of concerns related to managing the storage and connectivity versus managing the user-defined data stored in the container. Just as an STL container like <code>std::list</code> is reponsible for managing the list's vertices and the linear connectivity between those vertices, Sawyer is responsible for managing the vertex storage and the connectivity (edges) between the vertices, and the user is responsible for their data (the first two graph template arguments).</p>
<p>Another feature of the design is that iterators serve a dual purpose. Just like an <code>int*</code> pointing into an array of integers can be used as a pointer to a single element or incremented to iterate through elements, Sawyer graph iterators are both pointers to a particular vertex or edge and at other times incremented to iterate over vertices and edges. Oftentimes incrementing an iterator that's being used as a pointer doesn't really make much sense, just as incrementing an <code>int*</code> for an array implementation of a lattice/heap/tree/etc might not make much sense.</p>
<p>In this documentation, the term "node" refers to the unit of storage for an edge or vertex, which contains the user-defined value for the edge or vertex, plus an ID number and connectivity information. Within this documentation, the term "vertex" is always used as the name of a graph component (i.e., a graph has vertices and edges), and the term "node" always refers to a unit of storage.</p>
<p>A graph doesn't necessarily need to store data at each vertex or edge. The vertex and edge types default to <a class="el" href="classSawyer_1_1Nothing.html">Nothing</a>, which is similar to <code>void</code>.</p>
<h1><a class="anchor" id="iterators"></a>
Iterators</h1>
<p>Vertices and edges are referenced via iterators, which are stable across insertion and erasure. That is, an iterator will continue to point to the same vertex or edge even when other vertices or edges are added or removed from the graph. Iterators are the preferred mechanism for referring to a vertex or edge, and are lightweight objects. Iterators, as their name suggests, are also used for iterating over a list of vertices or edges, and "end" iterators indicate the list termination&ndash;they point to one-past-the-end of the list. End iterators are generally specific to each list, so any two end iterators from two different lists will typically compare as unequal.</p>
<p>Iterators can refer to just the user-defined value, or the entire storage node. A storage node contains the user-defined value, an ID number, and graph connectivity information and can be implicitly converted to a value iterator. Orthogonally, iterator's referent can be constant or mutable. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> iterator names are:</p>
<ul>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a> refers to user-defined mutable values </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a> refers to user-defined constant values </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> refers to mutable vertex storage nodes </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> refers to constant vertex storage nodes</li>
</ul>
<p>A const-iterator points to information that is const qualified. Const-iterators can be converted to non-const iterators in linear time if one has the non-const graph available:</p>
<div class="fragment"><div class="line">MyGraph graph = ...</div>
<div class="line">MyGraph::ConstVertexIterator constVertex = ...; <span class="comment">// not the end iterator</span></div>
<div class="line">MyGraph::VertexIterator vertex = graph.findVertex(constVertex-&gt;id());</div>
</div><!-- fragment --><p><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterators are similar.</p>
<p>The previous example (using vertex iterators to refer to newly-inserted vertices) should make more sense now. Here's an example using iterators to actually iterate over something:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;Vertex names:\n&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (MyGraph::ConstVertexIterator vertex=graph.vertices().begin(); vertex!=graph.vertices().end(); ++vertex)</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;  &quot;</span> &lt;&lt; vertex-&gt;value() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>The graph maintains a graph-wide list of vertices and edges, iterators to which are returned by the <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a58086bea7e522519a91e13814fe072c2">vertices</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a296815ac85514fc4c707133e5ce89a16">edges</a> methods. The <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa1b9efc1386d4775cefc5b0543e802ad">vertexValues</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#af8d207cfbfde993a795a0c75b3e8b94b">edgeValues</a> methods are related, but return iterators which, when dereferenced, return a reference to the user-defined value for that vertex or edge. The "value" iterators are equality-comparable (<code>==</code> and <code>!=</code>) with their "node" iterator counterparts and implicitly constructed from them, but are unable to return information about vertex and edge connectivity (only user-defined values).</p>
<p>Here's a couple easier ways to do the same thing as the previous example:</p>
<div class="fragment"><div class="line">BOOST_FOREACH (<span class="keyword">const</span> MyGraph::Vertex &amp;vertex, graph.vertices())</div>
<div class="line">    std::cout &lt;&lt;&quot;  &quot; &lt;&lt;vertex.value() &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><div class="fragment"><div class="line">BOOST_FOREACH (<span class="keyword">const</span> std::string &amp;name, graph.vertexValues())</div>
<div class="line">    std::cout &lt;&lt;&quot;  &quot; &lt;&lt;name &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><p>Sawyer also defines numerous graph traversals that can traverse vertices or edges in certain orders by following the graph connectivity. See <a class="el" href="classSawyer_1_1Container_1_1Algorithm_1_1GraphTraversal.html">Sawyer::Container::Algorithm::GraphTraversal</a>.</p>
<h1><a class="anchor" id="ids"></a>
Identification Numbers</h1>
<p>Vertices and edges are also given small, consecutive ID numbers beginning at zero&ndash;one set for vertices and another set for edges. ID numbers are stable across insertion but not erasure. That is, if an edge is erased from the container then the ID numbers for other edges in the same container may change. Similarly for vertices. An ID number can be converted to an iterator in constant time, and vice versa. Inserting or erasing a vertex or edge is a constant-time operation.</p>
<p>Here's an example that lists all the edges in order of edge ID:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> edgeId=0; edgeId&lt;graph.nEdges(); ++edgeId) {</div>
<div class="line">    MyGraph::ConstEdgeIterator edge = graph.findEdge(edgeId);</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;Edge &quot;</span> &lt;&lt;edgeId</div>
<div class="line">              &lt;&lt;<span class="stringliteral">&quot; from vertex &quot;</span> &lt;&lt;edge-&gt;source()-&gt;id()</div>
<div class="line">              &lt;&lt;<span class="stringliteral">&quot; to vertex &quot;</span> &lt;&lt;edge-&gt;target()-&gt;id() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>One very useful side effect of having small, consecutive identification numbers is that they can be used as constant time indexing into auxiliary tables. For instance, here's how one might construct a table that contains hash values for all the vertex names:</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned long&gt; vertexHashes(graph.nVertices());</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> MyGraph::Vertex &amp;vertex, graph.vertices())</div>
<div class="line">    vertexHashes[vertex.<span class="keywordtype">id</span>()] = hash(vertex.value());</div>
</div><!-- fragment --><h1><a class="anchor" id="connectivity"></a>
Graph connectivity</h1>
<p>Each vertex has two additional edge lists: a list of incoming edges where this vertex serves as the edges' target, and a list of outgoing edges where this vertex serves as the edges' source. The lists are returned by the <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a3723c78463b56264f13e66d06a8089d8">Vertex::inEdges</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#a49f327e83676c52cd1f069ece7e125fe">Vertex::outEdges</a> methods. These lists are sublists of the graph-wide edge list and iterators are equality-comparable and return references to the same underlying edges. However, the "end" iterators for these sublists are all distinct from one another and distinct from the graph-wide edge list. (footnote: Actually, the "end" iterators for the in-coming and out-going lists of a single vertex are equal to each other, but don't depend on this.)</p>
<p>Each edge has two methods, <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a5dc33497d8a92aba8159d366e1583014">Edge::source</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#a17e39f16257895d357dc344271e74464">Edge::target</a> that return iterators to the source and target vertices for that edge.</p>
<p>Here's an example similar to the previous edge ID iteration except it presents the graph in terms of vertices:</p>
<div class="fragment"><div class="line">BOOST_FOREACH (<span class="keyword">const</span> MyGraph::Vertex &amp;vertex, graph.vertices()) {</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;vertex &quot;</span> &lt;&lt;vertex.id() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    BOOST_FOREACH (<span class="keyword">const</span> MyGraph::Edge &amp;edge, vertex.outEdges()) {</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;  edge &quot;</span> &lt;&lt;edge.id() &lt;&lt;<span class="stringliteral">&quot; to vertex &quot;</span> &lt;&lt;edge.target()-&gt;id() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="graph_indexing"></a>
Indexing</h1>
<p>Users should make every effort to use iterators or ID numbers to point to vertices and edges since these have constant-time performance. However, a drawback of iterators is that if you have a data structure that contains a graph and some iterators your copy constructor will need to update all its iterators so they point to the copied graph rather than the original graph. On the other hand, the drawback of using ID numbers is that erasing vertices and edges might change the ID numbers of other vertices and edges. Therefore, graphs also optionally provide a vertex index and/or edge index that can be used to look up a vertex or edge if you know its key. Keys are anything you want as long as they're computed from the value stored in a vertex or edge. By default, graphs have neither vertex nor edge indexes&ndash;they must be enabled by supplying extra template arguments. A graph that has an index does not have the same level of performance as a graph without an index.</p>
<p>Indexing works the same for vertices and edges, although it's most commonly used with vertices. By default, the graph implements a vertex index as a balanced binary tree that maps keys to vertices in O(log) time. Therefore the key type must have a copy constructor and a less-than operator. The library also implements hash-based indexing, in which case the key must satisfy the requirements for <code>boost::unordered_map</code> instead.</p>
<p>In addition, regardless of what kind of index the graph uses, all keys must be (explicitly) constructable from a vertex value. In practice it's often the case that the vertex values and the keys are the same type. For instance, if a vertex stores <code>std::string</code> then the key can also be an <code>std::string</code> since that type has all the properties we need. Distinguishing between vertex value type and vertex key types allows the graph to store larger data structures at the vertices, a small part of which becomes the key. In fact, the key need not be a particular data member of the value as long as the key generator always produces the same key for the same data.</p>
<p>For example, lets say the vertex type is information about a city and that it's quite large.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>City {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keyword">const</span> State *state;</div>
<div class="line">    <span class="keywordtype">unsigned</span> population;</div>
<div class="line">    std::vector&lt;std::string&gt; zipCodes;</div>
<div class="line">    std::vector&lt;std::string&gt; areaCodes;</div>
<div class="line">    PhoneBook phoneBook;</div>
<div class="line">    <span class="comment">// Pretend there are lots more...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Every city has a unique name + state pair and we'd like to be able to look up cities in the graph by that pair. So we define a lookup key for cities:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CityKey {</div>
<div class="line">    std::string key_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CityKey(<span class="keyword">const</span> City &amp;city) {</div>
<div class="line">        key_ = city.name + <span class="stringliteral">&quot;, &quot;</span> + city.state-&gt;abbreviation();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> CityKey &amp;other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> key_ &lt; other.key_;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Lets say that the edges between cities represent things like travel time by various modes and we keep this information in a type named <code>TravelTime</code>. Here's how our graph would be declared:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;City, TravelTime, CityKey&gt;</a> CityGraph;</div>
</div><!-- fragment --><p>The only new thing we added is the third template argument, which this causes the graph to contain a vertex index and gives us the ability to look up a city by value or key. The following two lines assume you've added the appropriate constructors to the <code>City</code> and <code>CityKey</code> types.</p>
<div class="fragment"><div class="line">CityGraph::VertexIterator boston = cityGraph.findVertexValue(City(<span class="stringliteral">&quot;boston&quot;</span>, MA));</div>
<div class="line">CityGraph::VertexIterator boston = cityGraph.findVertexKey(CityKey(<span class="stringliteral">&quot;boston&quot;</span>, MA));</div>
</div><!-- fragment --><p>The other thing a vertex index does is prevent us from adding two vertices having the same key&ndash;we'd get an <a class="el" href="classSawyer_1_1Exception_1_1AlreadyExists.html">Exception::AlreadyExists</a> error. And finally a word of warning: if you define a vertex key and index then the values you store at each vertex (at least the parts from which a key is created) <em>must not change</em>, since doing so will give the vertex a new key without ever updating the index. The only way to change the key fields of a vertex is to insert a new vertex and erase the old one. This happens to be how many indexed containers work, including <code>std::unordered_map</code>. The same is true for edges.</p>
<p>Some indexed graph demos can be found <a class="el" href="group__sawyer__indexed__graph__examples.html">here</a>.</p>
<h1><a class="anchor" id="bgl"></a>
BGL Compatibility</h1>
<p>The Boost Graph Library (<a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html">BGL</a>) defines an API suitable for operating on a wide variety of graph implementations when the appropriate graph and property traits are defined. In order to operate on a Sawyer graph using the BGL API, the <a class="el" href="GraphBoost_8h_source.html">GraphBoost.h</a> header file should be included. See the <a class="el" href="namespaceSawyer_1_1Boost.html">Sawyer::Boost</a> name space for details.</p>
<p>The main philosophical difference between Sawyer graphs and Boost Graphs is how internal and external properties are stored. Sawyer stores internal properties as user-defined value members within the vertex and edge storage nodes, and uses the small, contiguous vertex and edge ID numbers to look up vector-stored external properties in constant time. BGL graphs abstract internal and external properties to property maps (property maps are a separate part of the Boost library but originated as part of BGL). The Sawyer approach tends to be easier for users to understand because of its similarity to STL containers and its much lighter use of C++ templates in its public API.</p>
<p>The <a href="https://github.com/matzke1/Sawyer/blob/master/tests/Container/graphBoost.C"><code>tests/Container/graphBoost.C</code></a> file in the Sawyer source tree exemplifies the differences between the Sawyer and BGL approaches and gives examples of using the BGL API on Sawyer graphs.</p>
<h1><a class="anchor" id="allocators"></a>
Custom allocators</h1>
<p>Because a graph allocates memory in terms of vertex and edge nodes, and because these nodes can be quite small, a graph can often benefit by using a memory pool allocation scheme. The third template argument provides the type for the allocator, and the graph constructors take an allocator argument which is copied into the graph. The allocator must implement the <a class="el" href="classSawyer_1_1DefaultAllocator.html">Sawyer::DefaultAllocator</a> API (essentially an allocate and a deallocate method), which happens to use the normal C++ global <code>new</code> and <code>delete</code> allocators. A couple possibilities are <a class="el" href="namespaceSawyer.html#acb97daf593e6c229322229d001a43784">Sawyer::SynchronizedPoolAllocator</a> and <a class="el" href="namespaceSawyer.html#af48ae867b94e1567c379562a73d7ce87">Sawyer::UnsynchronizedPoolAllocator</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt;std::string, double, Sawyer::PoolAllocator&gt;</a> MyGraphFast;</div>
<div class="line">MyGraphFast graph; <span class="comment">//uses a default-constructed pool allocator</span></div>
</div><!-- fragment --><p>Here's a mechanism by which the same pool can be used by multiple graphs. A proxy is needed because allocators are copied by value, but we want all the graphs to share the same pool:</p>
<div class="fragment"><div class="line">Sawyer::PoolAllocator pool;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1ProxyAllocator.html">Sawyer::ProxyAllocator&lt;Sawyer::PoolAllocator&gt;</a> PoolProxy;</div>
<div class="line">MyGraphFast g1(PoolProxy(pool));</div>
<div class="line">MyGraphFast g2(PoolProxy(pool));</div>
<div class="ttc" id="aclassSawyer_1_1ProxyAllocator_html"><div class="ttname"><a href="classSawyer_1_1ProxyAllocator.html">Sawyer::ProxyAllocator</a></div><div class="ttdoc">Allocator proxy.</div><div class="ttdef"><b>Definition</b> <a href="DefaultAllocator_8h_source.html#l00060">DefaultAllocator.h:60</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="complexity"></a>
Complexity guarantees</h1>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity guarantees for graphs without indexes:</p>
<ul>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> insertion: amortized constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> insertion: amortized constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> iterator dereference: constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> iterator dereference: constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> erasure: O(|Ev|), where |Ev| is the number of edges incident to the vertex. </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> erasure: constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> lookup by ID: constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> lookup by ID: constant </li>
<li>Graph vertex list: constant </li>
<li>Graph edge list: constant </li>
<li><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> in/out edge list: constant </li>
<li>Count graph vertices: constant </li>
<li>Count graph edges: constant </li>
<li>Count in/out edges: constant </li>
<li>Graph deletion: O(|V|+|E|) </li>
<li>Graph copy: O(|V|+|E|)</li>
</ul>
<p>Insertion is amortized constant time due to a vector-based ID map that may require reallocation. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00634">634</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Graph_8h_source.html">Sawyer/Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1Graph__inherit__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1Graph_3_01V_00_01E_00_01VKey_00_01EKey_00_01Alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Container_1_1Graph_3_01V_00_01E_00_01VKey_00_01EKey_00_01Alloc_01_4_inherit__map" id="aSawyer_1_1Container_1_1Graph_3_01V_00_01E_00_01VKey_00_01EKey_00_01Alloc_01_4_inherit__map">
<area shape="rect" title="Graph containing user&#45;defined vertices and edges." alt="" coords="5,110,181,165"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html" title=" " alt="" coords="375,5,573,45"/>
<area shape="poly" title=" " alt="" coords="148,101,204,75,290,50,374,35,375,40,292,56,206,80,150,106"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html" title=" " alt="" coords="389,70,559,125"/>
<area shape="poly" title=" " alt="" coords="195,124,388,104,388,109,195,129"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html" title=" " alt="" coords="405,149,543,203"/>
<area shape="poly" title=" " alt="" coords="196,152,206,153,404,170,404,175,205,159,195,157"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Graph.html" title=" " alt="" coords="386,227,562,282"/>
<area shape="poly" title=" " alt="" coords="145,170,206,202,298,228,386,243,386,249,297,233,204,206,143,175"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional edge node iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeValueIterator.html">ConstEdgeValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional edge value iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional vertex node iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional vertex value iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> node.  <a href="classSawyer_1_1Container_1_1Graph_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeBaseIterator.html">EdgeBaseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for edge iterators.  <a href="classSawyer_1_1Container_1_1Graph_1_1EdgeBaseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional edge node iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeValueIterator.html">EdgeValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional edge value iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1EdgeValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> node.  <a href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexBaseIterator.html">VertexBaseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for vertex iterators.  <a href="classSawyer_1_1Container_1_1Graph_1_1VertexBaseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional vertex node iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional vertex value iterator.  <a href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab6aa43dd305f98d4cdcaee4defe11c94" id="r_ab6aa43dd305f98d4cdcaee4defe11c94"><td class="memItemLeft" align="right" valign="top">typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a></td></tr>
<tr class="memdesc:ab6aa43dd305f98d4cdcaee4defe11c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-level data associated with vertices.  <br /></td></tr>
<tr class="separator:ab6aa43dd305f98d4cdcaee4defe11c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01453c8fabdf45adf07e5319c2d46c43" id="r_a01453c8fabdf45adf07e5319c2d46c43"><td class="memItemLeft" align="right" valign="top">typedef E&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a></td></tr>
<tr class="memdesc:a01453c8fabdf45adf07e5319c2d46c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-level data associated with edges.  <br /></td></tr>
<tr class="separator:a01453c8fabdf45adf07e5319c2d46c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d6faa766f41f6dd7bf10ff5cfc426e" id="r_a46d6faa766f41f6dd7bf10ff5cfc426e"><td class="memItemLeft" align="right" valign="top">typedef VKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a46d6faa766f41f6dd7bf10ff5cfc426e">VertexKey</a></td></tr>
<tr class="memdesc:a46d6faa766f41f6dd7bf10ff5cfc426e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for looking up a vertex.  <br /></td></tr>
<tr class="separator:a46d6faa766f41f6dd7bf10ff5cfc426e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1358a18e3697cb3351d66c1003caeb0d" id="r_a1358a18e3697cb3351d66c1003caeb0d"><td class="memItemLeft" align="right" valign="top">typedef EKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a1358a18e3697cb3351d66c1003caeb0d">EdgeKey</a></td></tr>
<tr class="memdesc:a1358a18e3697cb3351d66c1003caeb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for looking up an edge.  <br /></td></tr>
<tr class="separator:a1358a18e3697cb3351d66c1003caeb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5c48e017a07038f6aa475f1d1807dc" id="r_a8d5c48e017a07038f6aa475f1d1807dc"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a></td></tr>
<tr class="memdesc:a8d5c48e017a07038f6aa475f1d1807dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for vertex and edge nodes.  <br /></td></tr>
<tr class="separator:a8d5c48e017a07038f6aa475f1d1807dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c7df802217620448f7368466921b69" id="r_a35c7df802217620448f7368466921b69"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html">Edge</a> EdgeNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a35c7df802217620448f7368466921b69">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:a35c7df802217620448f7368466921b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76b83b4c571f5ab97033598b22ab20a" id="r_ac76b83b4c571f5ab97033598b22ab20a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html">Vertex</a> VertexNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac76b83b4c571f5ab97033598b22ab20a">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:ac76b83b4c571f5ab97033598b22ab20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae827d9cd700442b16b8135950670d10e" id="r_ae827d9cd700442b16b8135950670d10e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> EdgeNodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae827d9cd700442b16b8135950670d10e">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:ae827d9cd700442b16b8135950670d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f97b6bc1c9f6ad272b685599260fe2a" id="r_a3f97b6bc1c9f6ad272b685599260fe2a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> ConstEdgeNodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f97b6bc1c9f6ad272b685599260fe2a">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:a3f97b6bc1c9f6ad272b685599260fe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa467f2a6882f0c7003f1fed01e37349e" id="r_aa467f2a6882f0c7003f1fed01e37349e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> VertexNodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa467f2a6882f0c7003f1fed01e37349e">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:aa467f2a6882f0c7003f1fed01e37349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15191fb351ad121f9cf7a68ae7afdaea" id="r_a15191fb351ad121f9cf7a68ae7afdaea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> ConstVertexNodeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a15191fb351ad121f9cf7a68ae7afdaea">__attribute__</a>((deprecated))</td></tr>
<tr class="separator:a15191fb351ad121f9cf7a68ae7afdaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4e5d2a01a21c5193f29c9d52f3d040a" id="r_ac4e5d2a01a21c5193f29c9d52f3d040a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac4e5d2a01a21c5193f29c9d52f3d040a">Graph</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa7e18e9c9006efd78973d78aefd04127">allocator</a>=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a>())</td></tr>
<tr class="memdesc:ac4e5d2a01a21c5193f29c9d52f3d040a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ac4e5d2a01a21c5193f29c9d52f3d040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd837cfa032d1cb3f46d8c412dba464" id="r_affd837cfa032d1cb3f46d8c412dba464"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#affd837cfa032d1cb3f46d8c412dba464">Graph</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;other)</td></tr>
<tr class="memdesc:affd837cfa032d1cb3f46d8c412dba464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:affd837cfa032d1cb3f46d8c412dba464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0c025ca16317bcbaaf87203b501237" id="r_adb0c025ca16317bcbaaf87203b501237"><td class="memTemplParams" colspan="2">template&lt;class V2 , class E2 , class VKey2 , class EKey2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:adb0c025ca16317bcbaaf87203b501237"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#adb0c025ca16317bcbaaf87203b501237">Graph</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V2, E2, VKey2, EKey2, Alloc2 &gt; &amp;other, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp;<a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa7e18e9c9006efd78973d78aefd04127">allocator</a>=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a>())</td></tr>
<tr class="memdesc:adb0c025ca16317bcbaaf87203b501237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:adb0c025ca16317bcbaaf87203b501237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d91b94447f1680a2e14240dc2d3e8" id="r_ab22d91b94447f1680a2e14240dc2d3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab22d91b94447f1680a2e14240dc2d3e8">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;other)</td></tr>
<tr class="memdesc:ab22d91b94447f1680a2e14240dc2d3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:ab22d91b94447f1680a2e14240dc2d3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95b202d6bcfc3d9e0eb736fa5652021" id="r_ab95b202d6bcfc3d9e0eb736fa5652021"><td class="memTemplParams" colspan="2">template&lt;class V2 , class E2 , class VKey2 , class EKey2 , class Alloc2 &gt; </td></tr>
<tr class="memitem:ab95b202d6bcfc3d9e0eb736fa5652021"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab95b202d6bcfc3d9e0eb736fa5652021">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V2, E2, VKey2, EKey2, Alloc2 &gt; &amp;other)</td></tr>
<tr class="memdesc:ab95b202d6bcfc3d9e0eb736fa5652021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:ab95b202d6bcfc3d9e0eb736fa5652021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e18e9c9006efd78973d78aefd04127" id="r_aa7e18e9c9006efd78973d78aefd04127"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa7e18e9c9006efd78973d78aefd04127">allocator</a> ()</td></tr>
<tr class="memdesc:aa7e18e9c9006efd78973d78aefd04127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator.  <br /></td></tr>
<tr class="separator:aa7e18e9c9006efd78973d78aefd04127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c8eef7ec4d3399518437f5dd22b68" id="r_a7f5c8eef7ec4d3399518437f5dd22b68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a7f5c8eef7ec4d3399518437f5dd22b68">isValidVertex</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;vertex) const</td></tr>
<tr class="memdesc:a7f5c8eef7ec4d3399518437f5dd22b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the vertex iterator is valid.  <br /></td></tr>
<tr class="separator:a7f5c8eef7ec4d3399518437f5dd22b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113a33fdc000dd6071a918f1c0e1e264" id="r_a113a33fdc000dd6071a918f1c0e1e264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a113a33fdc000dd6071a918f1c0e1e264">isValidEdge</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &amp;edge) const</td></tr>
<tr class="memdesc:a113a33fdc000dd6071a918f1c0e1e264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the edge iterator is valid.  <br /></td></tr>
<tr class="separator:a113a33fdc000dd6071a918f1c0e1e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5244b7dddd1f511a0a9350fc79e182" id="r_a4c5244b7dddd1f511a0a9350fc79e182"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a4c5244b7dddd1f511a0a9350fc79e182">nVertices</a> () const</td></tr>
<tr class="memdesc:a4c5244b7dddd1f511a0a9350fc79e182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of vertices.  <br /></td></tr>
<tr class="separator:a4c5244b7dddd1f511a0a9350fc79e182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae324cd7b2cc9b5d100d5d9b3960a931b" id="r_ae324cd7b2cc9b5d100d5d9b3960a931b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae324cd7b2cc9b5d100d5d9b3960a931b">nEdges</a> () const</td></tr>
<tr class="memdesc:ae324cd7b2cc9b5d100d5d9b3960a931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of edges.  <br /></td></tr>
<tr class="separator:ae324cd7b2cc9b5d100d5d9b3960a931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d56d6c421b427eea9c7e29d3f1963ee" id="r_a8d56d6c421b427eea9c7e29d3f1963ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d56d6c421b427eea9c7e29d3f1963ee">isEmpty</a> () const</td></tr>
<tr class="memdesc:a8d56d6c421b427eea9c7e29d3f1963ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if graph is empty.  <br /></td></tr>
<tr class="separator:a8d56d6c421b427eea9c7e29d3f1963ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2a6067898bbf9bdb5f8fc6936d79ff" id="r_a5b2a6067898bbf9bdb5f8fc6936d79ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a5b2a6067898bbf9bdb5f8fc6936d79ff">insertVertex</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;value=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a>())</td></tr>
<tr class="memdesc:a5b2a6067898bbf9bdb5f8fc6936d79ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new vertex.  <br /></td></tr>
<tr class="separator:a5b2a6067898bbf9bdb5f8fc6936d79ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ba2d89c2a7ff2288da6545149691d" id="r_ac26ba2d89c2a7ff2288da6545149691d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac26ba2d89c2a7ff2288da6545149691d">insertVertexMaybe</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;value)</td></tr>
<tr class="memdesc:ac26ba2d89c2a7ff2288da6545149691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally insert a new vertex.  <br /></td></tr>
<tr class="separator:ac26ba2d89c2a7ff2288da6545149691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29cc5745a368250b493ec3ba420e30b" id="r_aa29cc5745a368250b493ec3ba420e30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa29cc5745a368250b493ec3ba420e30b">insertEdgeWithVertices</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;sourceValue, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;targetValue, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;edgeValue=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>())</td></tr>
<tr class="memdesc:aa29cc5745a368250b493ec3ba420e30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an edge and its vertex end points.  <br /></td></tr>
<tr class="separator:aa29cc5745a368250b493ec3ba420e30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31179f8150d5e4f5c36d83236b0bc06" id="r_ab31179f8150d5e4f5c36d83236b0bc06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab31179f8150d5e4f5c36d83236b0bc06">eraseEdgeWithVertices</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &amp;edge)</td></tr>
<tr class="memdesc:ab31179f8150d5e4f5c36d83236b0bc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases and edge and possibly vertices.  <br /></td></tr>
<tr class="separator:ab31179f8150d5e4f5c36d83236b0bc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b297aca54604550573383420874b78a" id="r_a0b297aca54604550573383420874b78a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a0b297aca54604550573383420874b78a">clearEdges</a> ()</td></tr>
<tr class="memdesc:a0b297aca54604550573383420874b78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges, but leave all vertices.  <br /></td></tr>
<tr class="separator:a0b297aca54604550573383420874b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2174d35bc17a91f5de25a8cf2e1c4b51" id="r_a2174d35bc17a91f5de25a8cf2e1c4b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a2174d35bc17a91f5de25a8cf2e1c4b51">clear</a> ()</td></tr>
<tr class="memdesc:a2174d35bc17a91f5de25a8cf2e1c4b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertices and edges.  <br /></td></tr>
<tr class="separator:a2174d35bc17a91f5de25a8cf2e1c4b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a58086bea7e522519a91e13814fe072c2" id="r_a58086bea7e522519a91e13814fe072c2"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a58086bea7e522519a91e13814fe072c2">vertices</a> ()</td></tr>
<tr class="memdesc:a58086bea7e522519a91e13814fe072c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all vertices.  <br /></td></tr>
<tr class="separator:a58086bea7e522519a91e13814fe072c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fb72d4dcb36052fd73bed928fd320f" id="r_af0fb72d4dcb36052fd73bed928fd320f"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#af0fb72d4dcb36052fd73bed928fd320f">vertices</a> () const</td></tr>
<tr class="memdesc:af0fb72d4dcb36052fd73bed928fd320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all vertices.  <br /></td></tr>
<tr class="separator:af0fb72d4dcb36052fd73bed928fd320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa1b9efc1386d4775cefc5b0543e802ad" id="r_aa1b9efc1386d4775cefc5b0543e802ad"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa1b9efc1386d4775cefc5b0543e802ad">vertexValues</a> ()</td></tr>
<tr class="memdesc:aa1b9efc1386d4775cefc5b0543e802ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all vertices.  <br /></td></tr>
<tr class="separator:aa1b9efc1386d4775cefc5b0543e802ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa69c148065a1187649e02423a2920df" id="r_afa69c148065a1187649e02423a2920df"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#afa69c148065a1187649e02423a2920df">vertexValues</a> () const</td></tr>
<tr class="memdesc:afa69c148065a1187649e02423a2920df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all vertices.  <br /></td></tr>
<tr class="separator:afa69c148065a1187649e02423a2920df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3f256b70a465482d53478b84941dc8b5" id="r_a3f256b70a465482d53478b84941dc8b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5">findVertex</a> (size_t id)</td></tr>
<tr class="memdesc:a3f256b70a465482d53478b84941dc8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the vertex with specified ID number.  <br /></td></tr>
<tr class="separator:a3f256b70a465482d53478b84941dc8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59deb04723cc6c696ce86365d442d46d" id="r_a59deb04723cc6c696ce86365d442d46d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a59deb04723cc6c696ce86365d442d46d">findVertex</a> (size_t id) const</td></tr>
<tr class="memdesc:a59deb04723cc6c696ce86365d442d46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the vertex with specified ID number.  <br /></td></tr>
<tr class="separator:a59deb04723cc6c696ce86365d442d46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1f51ceb13e6e717fb9278ca721c1a5a" id="r_ae1f51ceb13e6e717fb9278ca721c1a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a46d6faa766f41f6dd7bf10ff5cfc426e">VertexKey</a> &amp;key)</td></tr>
<tr class="memdesc:ae1f51ceb13e6e717fb9278ca721c1a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex given its key.  <br /></td></tr>
<tr class="separator:ae1f51ceb13e6e717fb9278ca721c1a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9bfb0025a374089f646f97c19bd5e6" id="r_a7e9bfb0025a374089f646f97c19bd5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a7e9bfb0025a374089f646f97c19bd5e6">findVertexKey</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a46d6faa766f41f6dd7bf10ff5cfc426e">VertexKey</a> &amp;key) const</td></tr>
<tr class="memdesc:a7e9bfb0025a374089f646f97c19bd5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex given its key.  <br /></td></tr>
<tr class="separator:a7e9bfb0025a374089f646f97c19bd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa8f5d6dd7c5c10b74a3454f02fdcfbc8" id="r_aa8f5d6dd7c5c10b74a3454f02fdcfbc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">findVertexValue</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;value)</td></tr>
<tr class="memdesc:aa8f5d6dd7c5c10b74a3454f02fdcfbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex given its value.  <br /></td></tr>
<tr class="separator:aa8f5d6dd7c5c10b74a3454f02fdcfbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b7694754718fe632bdd66c837d5e8b" id="r_aa9b7694754718fe632bdd66c837d5e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa9b7694754718fe632bdd66c837d5e8b">findVertexValue</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;value) const</td></tr>
<tr class="memdesc:aa9b7694754718fe632bdd66c837d5e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex given its value.  <br /></td></tr>
<tr class="separator:aa9b7694754718fe632bdd66c837d5e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a296815ac85514fc4c707133e5ce89a16" id="r_a296815ac85514fc4c707133e5ce89a16"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a296815ac85514fc4c707133e5ce89a16">edges</a> ()</td></tr>
<tr class="memdesc:a296815ac85514fc4c707133e5ce89a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all edges.  <br /></td></tr>
<tr class="separator:a296815ac85514fc4c707133e5ce89a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cf5b36294a35d36003a976d9aa79b" id="r_ad90cf5b36294a35d36003a976d9aa79b"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ad90cf5b36294a35d36003a976d9aa79b">edges</a> () const</td></tr>
<tr class="memdesc:ad90cf5b36294a35d36003a976d9aa79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all edges.  <br /></td></tr>
<tr class="separator:ad90cf5b36294a35d36003a976d9aa79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af8d207cfbfde993a795a0c75b3e8b94b" id="r_af8d207cfbfde993a795a0c75b3e8b94b"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeValueIterator.html">EdgeValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#af8d207cfbfde993a795a0c75b3e8b94b">edgeValues</a> ()</td></tr>
<tr class="memdesc:af8d207cfbfde993a795a0c75b3e8b94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all edges.  <br /></td></tr>
<tr class="separator:af8d207cfbfde993a795a0c75b3e8b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3f693a716479dcc3d3f9e105478ae7" id="r_a8d3f693a716479dcc3d3f9e105478ae7"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeValueIterator.html">ConstEdgeValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d3f693a716479dcc3d3f9e105478ae7">edgeValues</a> () const</td></tr>
<tr class="memdesc:a8d3f693a716479dcc3d3f9e105478ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for all edges.  <br /></td></tr>
<tr class="separator:a8d3f693a716479dcc3d3f9e105478ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3989ef4e9f30d9210e80a1cb36acfe7b" id="r_a3989ef4e9f30d9210e80a1cb36acfe7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3989ef4e9f30d9210e80a1cb36acfe7b">findEdge</a> (size_t id)</td></tr>
<tr class="memdesc:a3989ef4e9f30d9210e80a1cb36acfe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the edge with specified ID number.  <br /></td></tr>
<tr class="separator:a3989ef4e9f30d9210e80a1cb36acfe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acc64c6664e3215606769b9745fde7d" id="r_a7acc64c6664e3215606769b9745fde7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a7acc64c6664e3215606769b9745fde7d">findEdge</a> (size_t id) const</td></tr>
<tr class="memdesc:a7acc64c6664e3215606769b9745fde7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the edge with specified ID number.  <br /></td></tr>
<tr class="separator:a7acc64c6664e3215606769b9745fde7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5569c71660bdf0732250ba5eb5b0c18" id="r_aa5569c71660bdf0732250ba5eb5b0c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a1358a18e3697cb3351d66c1003caeb0d">EdgeKey</a> &amp;key)</td></tr>
<tr class="memdesc:aa5569c71660bdf0732250ba5eb5b0c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an edge given its key.  <br /></td></tr>
<tr class="separator:aa5569c71660bdf0732250ba5eb5b0c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2987cf08d2a047de160514ba995adfb8" id="r_a2987cf08d2a047de160514ba995adfb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a2987cf08d2a047de160514ba995adfb8">findEdgeKey</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a1358a18e3697cb3351d66c1003caeb0d">EdgeKey</a> &amp;key) const</td></tr>
<tr class="memdesc:a2987cf08d2a047de160514ba995adfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an edge given its key.  <br /></td></tr>
<tr class="separator:a2987cf08d2a047de160514ba995adfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6d66baadd85921a0ddffeb28fb7f693b" id="r_a6d66baadd85921a0ddffeb28fb7f693b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a6d66baadd85921a0ddffeb28fb7f693b">findEdgeValue</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value)</td></tr>
<tr class="memdesc:a6d66baadd85921a0ddffeb28fb7f693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an edge given its value.  <br /></td></tr>
<tr class="separator:a6d66baadd85921a0ddffeb28fb7f693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819df2739b81bfdb288a884681dcd4d7" id="r_a819df2739b81bfdb288a884681dcd4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a819df2739b81bfdb288a884681dcd4d7">findEdgeValue</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value) const</td></tr>
<tr class="memdesc:a819df2739b81bfdb288a884681dcd4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an edge given its value.  <br /></td></tr>
<tr class="separator:a819df2739b81bfdb288a884681dcd4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0c3a2fe3c55de1001e0ae8e7508a86f0" id="r_a0c3a2fe3c55de1001e0ae8e7508a86f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a0c3a2fe3c55de1001e0ae8e7508a86f0">insertEdge</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;sourceVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;targetVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>())</td></tr>
<tr class="memdesc:a0c3a2fe3c55de1001e0ae8e7508a86f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge.  <br /></td></tr>
<tr class="separator:a0c3a2fe3c55de1001e0ae8e7508a86f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca47cbae60d1de95c7e0fcf97ea0b868" id="r_aca47cbae60d1de95c7e0fcf97ea0b868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#aca47cbae60d1de95c7e0fcf97ea0b868">insertEdge</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;sourceVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;targetVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>())</td></tr>
<tr class="memdesc:aca47cbae60d1de95c7e0fcf97ea0b868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge.  <br /></td></tr>
<tr class="separator:aca47cbae60d1de95c7e0fcf97ea0b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09c4669b9bf3c8809ea9ebd6d2ad9b4a" id="r_a09c4669b9bf3c8809ea9ebd6d2ad9b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a09c4669b9bf3c8809ea9ebd6d2ad9b4a">insertEdgeMaybe</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;sourceVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;targetVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>())</td></tr>
<tr class="memdesc:a09c4669b9bf3c8809ea9ebd6d2ad9b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally insert a new edge.  <br /></td></tr>
<tr class="separator:a09c4669b9bf3c8809ea9ebd6d2ad9b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5619eaf28c45c31baf8082da17bfea15" id="r_a5619eaf28c45c31baf8082da17bfea15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a5619eaf28c45c31baf8082da17bfea15">insertEdgeMaybe</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;sourceVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;targetVertex, const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;value=<a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>())</td></tr>
<tr class="memdesc:a5619eaf28c45c31baf8082da17bfea15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally insert a new edge.  <br /></td></tr>
<tr class="separator:a5619eaf28c45c31baf8082da17bfea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5126c672c46a466ea78d7a2bd05b366d" id="r_a5126c672c46a466ea78d7a2bd05b366d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a5126c672c46a466ea78d7a2bd05b366d">eraseEdge</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &amp;edge)</td></tr>
<tr class="memdesc:a5126c672c46a466ea78d7a2bd05b366d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an edge.  <br /></td></tr>
<tr class="separator:a5126c672c46a466ea78d7a2bd05b366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e1ecad8cca312af99e7aba32df9d2c" id="r_ab0e1ecad8cca312af99e7aba32df9d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab0e1ecad8cca312af99e7aba32df9d2c">eraseEdge</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &amp;edge)</td></tr>
<tr class="memdesc:ab0e1ecad8cca312af99e7aba32df9d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an edge.  <br /></td></tr>
<tr class="separator:ab0e1ecad8cca312af99e7aba32df9d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac256ec051a8f4131b7c9c69714440132" id="r_ac256ec051a8f4131b7c9c69714440132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac256ec051a8f4131b7c9c69714440132">eraseEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;source, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;target)</td></tr>
<tr class="memdesc:ac256ec051a8f4131b7c9c69714440132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all edges connecting two vertices.  <br /></td></tr>
<tr class="separator:ac256ec051a8f4131b7c9c69714440132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d771b9e66adc81409c37ed44486752" id="r_a84d771b9e66adc81409c37ed44486752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a84d771b9e66adc81409c37ed44486752">eraseEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;source, const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;target)</td></tr>
<tr class="memdesc:a84d771b9e66adc81409c37ed44486752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all edges connecting two vertices.  <br /></td></tr>
<tr class="separator:a84d771b9e66adc81409c37ed44486752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae86b2b0fa4d18f2e2b26163abc2bc049" id="r_ae86b2b0fa4d18f2e2b26163abc2bc049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae86b2b0fa4d18f2e2b26163abc2bc049">eraseVertex</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:ae86b2b0fa4d18f2e2b26163abc2bc049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a vertex and its incident edges.  <br /></td></tr>
<tr class="separator:ae86b2b0fa4d18f2e2b26163abc2bc049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de3fd4c85547af9ff084e75e629639d" id="r_a8de3fd4c85547af9ff084e75e629639d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8de3fd4c85547af9ff084e75e629639d">eraseVertex</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a8de3fd4c85547af9ff084e75e629639d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a vertex and its incident edges.  <br /></td></tr>
<tr class="separator:a8de3fd4c85547af9ff084e75e629639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3c2a7e3310845a5f217adae63df7ae08" id="r_a3c2a7e3310845a5f217adae63df7ae08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3c2a7e3310845a5f217adae63df7ae08">clearEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a3c2a7e3310845a5f217adae63df7ae08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges incident to a vertex.  <br /></td></tr>
<tr class="separator:a3c2a7e3310845a5f217adae63df7ae08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a1c9705e8b1af12156e2834bb44330" id="r_a53a1c9705e8b1af12156e2834bb44330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a53a1c9705e8b1af12156e2834bb44330">clearEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a53a1c9705e8b1af12156e2834bb44330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges incident to a vertex.  <br /></td></tr>
<tr class="separator:a53a1c9705e8b1af12156e2834bb44330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d972c5a458cb735299f620f1c431558" id="r_a3d972c5a458cb735299f620f1c431558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3d972c5a458cb735299f620f1c431558">clearOutEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a3d972c5a458cb735299f620f1c431558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges emanating from a vertex.  <br /></td></tr>
<tr class="separator:a3d972c5a458cb735299f620f1c431558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63591a0d0e8aea3baab9909d2fc5cd96" id="r_a63591a0d0e8aea3baab9909d2fc5cd96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a63591a0d0e8aea3baab9909d2fc5cd96">clearOutEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a63591a0d0e8aea3baab9909d2fc5cd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges emanating from a vertex.  <br /></td></tr>
<tr class="separator:a63591a0d0e8aea3baab9909d2fc5cd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36cb4f69c729552dcbd8a530eacec8ce" id="r_a36cb4f69c729552dcbd8a530eacec8ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a36cb4f69c729552dcbd8a530eacec8ce">clearInEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a36cb4f69c729552dcbd8a530eacec8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges targeting a vertex.  <br /></td></tr>
<tr class="separator:a36cb4f69c729552dcbd8a530eacec8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559edbf837b87f8022e93500bdc300a9" id="r_a559edbf837b87f8022e93500bdc300a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a559edbf837b87f8022e93500bdc300a9">clearInEdges</a> (const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;vertex)</td></tr>
<tr class="memdesc:a559edbf837b87f8022e93500bdc300a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all edges targeting a vertex.  <br /></td></tr>
<tr class="separator:a559edbf837b87f8022e93500bdc300a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab6aa43dd305f98d4cdcaee4defe11c94" name="ab6aa43dd305f98d4cdcaee4defe11c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6aa43dd305f98d4cdcaee4defe11c94">&#9670;&#160;</a></span>VertexValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef V <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::VertexValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-level data associated with vertices. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00636">636</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a01453c8fabdf45adf07e5319c2d46c43" name="a01453c8fabdf45adf07e5319c2d46c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01453c8fabdf45adf07e5319c2d46c43">&#9670;&#160;</a></span>EdgeValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef E <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::EdgeValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-level data associated with edges. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00637">637</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a46d6faa766f41f6dd7bf10ff5cfc426e" name="a46d6faa766f41f6dd7bf10ff5cfc426e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d6faa766f41f6dd7bf10ff5cfc426e">&#9670;&#160;</a></span>VertexKey</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VKey <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::VertexKey</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for looking up a vertex. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00638">638</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a1358a18e3697cb3351d66c1003caeb0d" name="a1358a18e3697cb3351d66c1003caeb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1358a18e3697cb3351d66c1003caeb0d">&#9670;&#160;</a></span>EdgeKey</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EKey <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::EdgeKey</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for looking up an edge. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00639">639</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a8d5c48e017a07038f6aa475f1d1807dc" name="a8d5c48e017a07038f6aa475f1d1807dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5c48e017a07038f6aa475f1d1807dc">&#9670;&#160;</a></span>Allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator for vertex and edge nodes. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l00640">640</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a35c7df802217620448f7368466921b69" name="a35c7df802217620448f7368466921b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c7df802217620448f7368466921b69">&#9670;&#160;</a></span>__attribute__ <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html">Edge</a> EdgeNode <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02128">2128</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="ac76b83b4c571f5ab97033598b22ab20a" name="ac76b83b4c571f5ab97033598b22ab20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76b83b4c571f5ab97033598b22ab20a">&#9670;&#160;</a></span>__attribute__ <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html">Vertex</a> VertexNode <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02129">2129</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="ae827d9cd700442b16b8135950670d10e" name="ae827d9cd700442b16b8135950670d10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae827d9cd700442b16b8135950670d10e">&#9670;&#160;</a></span>__attribute__ <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> EdgeNodeIterator <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02130">2130</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a3f97b6bc1c9f6ad272b685599260fe2a" name="a3f97b6bc1c9f6ad272b685599260fe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f97b6bc1c9f6ad272b685599260fe2a">&#9670;&#160;</a></span>__attribute__ <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> ConstEdgeNodeIterator <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02131">2131</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="aa467f2a6882f0c7003f1fed01e37349e" name="aa467f2a6882f0c7003f1fed01e37349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa467f2a6882f0c7003f1fed01e37349e">&#9670;&#160;</a></span>__attribute__ <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> VertexNodeIterator <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02132">2132</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a15191fb351ad121f9cf7a68ae7afdaea" name="a15191fb351ad121f9cf7a68ae7afdaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15191fb351ad121f9cf7a68ae7afdaea">&#9670;&#160;</a></span>__attribute__ <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> ConstVertexNodeIterator <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::__attribute__((deprecated))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02133">2133</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac4e5d2a01a21c5193f29c9d52f3d040a" name="ac4e5d2a01a21c5193f29c9d52f3d040a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e5d2a01a21c5193f29c9d52f3d040a">&#9670;&#160;</a></span>Graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty graph.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01450">1450</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="affd837cfa032d1cb3f46d8c412dba464" name="affd837cfa032d1cb3f46d8c412dba464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd837cfa032d1cb3f46d8c412dba464">&#9670;&#160;</a></span>Graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V, E, VKey, EKey, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Initializes this graph by copying all node and edge data from the <code>other</code> graph and initializing the same vertex connectivity. Vertices and edges in this new graph will have the same ID numbers as the <code>other</code> graph, but the order of vertex and edges traversals is not expected to be the same.</p>
<p>The new graph's allocator is copy constructed from the source graph's allocator, which results in the new allocator having the same settings but sharing none of the original data.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the total number of vertices and edges in <code>other</code>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01462">1462</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="adb0c025ca16317bcbaaf87203b501237" name="adb0c025ca16317bcbaaf87203b501237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0c025ca16317bcbaaf87203b501237">&#9670;&#160;</a></span>Graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<div class="memtemplate">
template&lt;class V2 , class E2 , class VKey2 , class EKey2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V2, E2, VKey2, EKey2, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Initializes this graph by copying all node and edge data from the <code>other</code> graph and initializing the same vertex connectivity. The vertices and edges of <code>other</code> must be convertible to the types of vertices and edges in this graph, and the will have the same ID numbers as in the <code>other</code> graph. The order of vertex and edge traversals is not expected to be identical between the two graphs.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the total number of vertices and edges in <code>other</code>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01476">1476</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab22d91b94447f1680a2e14240dc2d3e8" name="ab22d91b94447f1680a2e14240dc2d3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d91b94447f1680a2e14240dc2d3e8">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V, E, VKey, EKey, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment. </p>
<p>Causes this graph to look like <code>other</code> in that this graph will have copies of all the <code>other</code> vertex and edge data and the same vertex connectivity as <code>other</code>. The vertices and edges will have the same ID numbers as in <code>other</code>. The order of vertex and edge traversals is not expected to be identical between the two graphs.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the sum of the number of vertices and edges in this graph and <code>other</code>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01488">1488</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="ab95b202d6bcfc3d9e0eb736fa5652021" name="ab95b202d6bcfc3d9e0eb736fa5652021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95b202d6bcfc3d9e0eb736fa5652021">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<div class="memtemplate">
template&lt;class V2 , class E2 , class VKey2 , class EKey2 , class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Graph</a>&lt; V2, E2, VKey2, EKey2, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment. </p>
<p>Causes this graph to look like <code>other</code> in that this graph will have copies of all the <code>other</code> vertex and edge data and the same vertex connectivity as <code>other</code>. The vertices and edges of <code>other</code> must be convertible to the types of vertices and edges in this graph, and they will have the same ID numbers as in <code>other</code>. The order of vertex and edge traversals is not expected to be identical between the two graphs.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the sum of the number of vertices and edges in this graph and <code>other</code>.</p>
<p><b>Warning:</b> Assignment is not currently exception safe. If an exception occurs (e.g., OOM) then the destination graph could be left in an inconsistent state. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01504">1504</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l02074">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clear()</a>, <a class="el" href="Graph_8h_source.html#l01694">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdge()</a>, <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01820">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, <a class="el" href="Graph_8h_source.html#l01790">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertVertex()</a>, <a class="el" href="Graph_8h_source.html#l01764">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nEdges()</a>, <a class="el" href="Graph_8h_source.html#l01754">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, <a class="el" href="Graph_8h_source.html#l01162">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::source()</a>, <a class="el" href="Graph_8h_source.html#l01174">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>, <a class="el" href="Graph_8h_source.html#l01188">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::value()</a>, and <a class="el" href="Graph_8h_source.html#l01301">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::value()</a>.</p>

</div>
</div>
<a id="aa7e18e9c9006efd78973d78aefd04127" name="aa7e18e9c9006efd78973d78aefd04127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e18e9c9006efd78973d78aefd04127">&#9670;&#160;</a></span>allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a8d5c48e017a07038f6aa475f1d1807dc">Allocator</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator. </p>
<p>Returns the allocator used for vertices (and probably edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01523">1523</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a58086bea7e522519a91e13814fe072c2" name="a58086bea7e522519a91e13814fe072c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58086bea7e522519a91e13814fe072c2">&#9670;&#160;</a></span>vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all vertices. </p>
<p>Returns a pair of vertex node iterators that deliniate the list of all vertices of this graph. The traversal of this list is in no particular order.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01538">1538</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01998">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, <a class="el" href="Graph_8h_source.html#l02061">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l02041">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Partitioner2_2DataFlow_8h_source.html#l00174">Rose::BinaryAnalysis::Partitioner2::DataFlow::findReturnVertex()</a>, <a class="el" href="Graph_8h_source.html#l01603">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey()</a>, <a class="el" href="Graph_8h_source.html#l01608">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey()</a>, <a class="el" href="GraphTraversal_8h_source.html#l01449">Sawyer::Container::Algorithm::graphAllVertices()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01263">Sawyer::Container::Algorithm::graphDirectedDominators()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00255">Sawyer::Container::Algorithm::graphEraseParallelEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>.</p>

</div>
</div>
<a id="af0fb72d4dcb36052fd73bed928fd320f" name="af0fb72d4dcb36052fd73bed928fd320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fb72d4dcb36052fd73bed928fd320f">&#9670;&#160;</a></span>vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all vertices. </p>
<p>Returns a pair of vertex node iterators that deliniate the list of all vertices of this graph. The traversal of this list is in no particular order.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01542">1542</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="aa1b9efc1386d4775cefc5b0543e802ad" name="aa1b9efc1386d4775cefc5b0543e802ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b9efc1386d4775cefc5b0543e802ad">&#9670;&#160;</a></span>vertexValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexValueIterator.html">VertexValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::vertexValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all vertices. </p>
<p>Returns a pair of vertex value iterators that deliniate the list of all vertices of the graph. The traversal of this list is in no particular order.</p>
<p>Although vertex node iterators are implicitly convertible to vertex value iterators, this method proves useful in conjuction with "foreach" loops:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;std::string, ...&gt; graph = ...;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> std::string &amp;vertexName, graph.vertexValues())</div>
<div class="line">    std::cout &lt;&lt;&quot;name = &quot; &lt;&lt;*vertexName &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01565">1565</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionCallGraph_8h_source.html#l00066">Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::functions()</a>.</p>

</div>
</div>
<a id="afa69c148065a1187649e02423a2920df" name="afa69c148065a1187649e02423a2920df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa69c148065a1187649e02423a2920df">&#9670;&#160;</a></span>vertexValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexValueIterator.html">ConstVertexValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::vertexValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all vertices. </p>
<p>Returns a pair of vertex value iterators that deliniate the list of all vertices of the graph. The traversal of this list is in no particular order.</p>
<p>Although vertex node iterators are implicitly convertible to vertex value iterators, this method proves useful in conjuction with "foreach" loops:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;std::string, ...&gt; graph = ...;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> std::string &amp;vertexName, graph.vertexValues())</div>
<div class="line">    std::cout &lt;&lt;&quot;name = &quot; &lt;&lt;*vertexName &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01569">1569</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a3f256b70a465482d53478b84941dc8b5" name="a3f256b70a465482d53478b84941dc8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f256b70a465482d53478b84941dc8b5">&#9670;&#160;</a></span>findVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the vertex with specified ID number. </p>
<p>Returns a vertex node iterator for the vertex with the specified ID. ID numbers are consecutive integers beginning at zero. Do not call this method with an ID number greater than or equal to the number of vertices contained in this graph.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">findVertexValue</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01585">1585</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02061">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l02041">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l01955">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>, <a class="el" href="Graph_8h_source.html#l01986">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="Graph_8h_source.html#l01603">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00086">Sawyer::Container::Algorithm::graphBreakCycles()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00048">Sawyer::Container::Algorithm::graphContainsCycle()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00286">Sawyer::Container::Algorithm::graphDependentOrder()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01263">Sawyer::Container::Algorithm::graphDirectedDominators()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00176">Sawyer::Container::Algorithm::graphFindConnectedComponents()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>, <a class="el" href="Graph_8h_source.html#l01824">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, <a class="el" href="Graph_8h_source.html#l01846">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe()</a>, <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a59deb04723cc6c696ce86365d442d46d" name="a59deb04723cc6c696ce86365d442d46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59deb04723cc6c696ce86365d442d46d">&#9670;&#160;</a></span>findVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the vertex with specified ID number. </p>
<p>Returns a vertex node iterator for the vertex with the specified ID. ID numbers are consecutive integers beginning at zero. Do not call this method with an ID number greater than or equal to the number of vertices contained in this graph.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">findVertexValue</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01588">1588</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="ae1f51ceb13e6e717fb9278ca721c1a5a" name="ae1f51ceb13e6e717fb9278ca721c1a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f51ceb13e6e717fb9278ca721c1a5a">&#9670;&#160;</a></span>findVertexKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a46d6faa766f41f6dd7bf10ff5cfc426e">VertexKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a vertex given its key. </p>
<p>Finds a vertex having the specified key and returns an itertor pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no vertex index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity depends on the vertex index type, but is usually logarithmic in the number of vertices.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5">findVertex</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">findVertexValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01603">1603</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01623">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexValue()</a>, and <a class="el" href="Graph_8h_source.html#l01626">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexValue()</a>.</p>

</div>
</div>
<a id="a7e9bfb0025a374089f646f97c19bd5e6" name="a7e9bfb0025a374089f646f97c19bd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9bfb0025a374089f646f97c19bd5e6">&#9670;&#160;</a></span>findVertexKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a46d6faa766f41f6dd7bf10ff5cfc426e">VertexKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a vertex given its key. </p>
<p>Finds a vertex having the specified key and returns an itertor pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no vertex index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity depends on the vertex index type, but is usually logarithmic in the number of vertices.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5">findVertex</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">findVertexValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01608">1608</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

</div>
</div>
<a id="aa8f5d6dd7c5c10b74a3454f02fdcfbc8" name="aa8f5d6dd7c5c10b74a3454f02fdcfbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f5d6dd7c5c10b74a3454f02fdcfbc8">&#9670;&#160;</a></span>findVertexValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertexValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a vertex given its value. </p>
<p>Finds a vertex having the specified value and returns an iterator pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no vertex index. This method is just a wrapper around a vertex key constructor followed by a call to <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a> for the convenience of the user that doesn't what to remember how to construct a key.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5">findVertex</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01623">1623</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01603">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey()</a>.</p>

</div>
</div>
<a id="aa9b7694754718fe632bdd66c837d5e8b" name="aa9b7694754718fe632bdd66c837d5e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b7694754718fe632bdd66c837d5e8b">&#9670;&#160;</a></span>findVertexValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findVertexValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a vertex given its value. </p>
<p>Finds a vertex having the specified value and returns an iterator pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no vertex index. This method is just a wrapper around a vertex key constructor followed by a call to <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a> for the convenience of the user that doesn't what to remember how to construct a key.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3f256b70a465482d53478b84941dc8b5">findVertex</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae1f51ceb13e6e717fb9278ca721c1a5a">findVertexKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01626">1626</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01603">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertexKey()</a>.</p>

</div>
</div>
<a id="a7f5c8eef7ec4d3399518437f5dd22b68" name="a7f5c8eef7ec4d3399518437f5dd22b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5c8eef7ec4d3399518437f5dd22b68">&#9670;&#160;</a></span>isValidVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the vertex iterator is valid. </p>
<p>Returns true if and only if the specified iterator is not this graph's end iterator and the iterator points to a vertex in this graph. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01635">1635</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01754">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nVertices()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01955">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>, <a class="el" href="Graph_8h_source.html#l01932">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>, <a class="el" href="Graph_8h_source.html#l01986">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="Graph_8h_source.html#l01978">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01263">Sawyer::Container::Algorithm::graphDirectedDominators()</a>, <a class="el" href="Graph_8h_source.html#l01824">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01846">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe()</a>.</p>

</div>
</div>
<a id="a296815ac85514fc4c707133e5ce89a16" name="a296815ac85514fc4c707133e5ce89a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296815ac85514fc4c707133e5ce89a16">&#9670;&#160;</a></span>edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all edges. </p>
<p>Returns a pair of edge node iterators that deliniate the list of all edges of this graph. The traversal of this list is in no particular order.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01647">1647</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01712">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey()</a>, <a class="el" href="Graph_8h_source.html#l01717">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey()</a>, <a class="el" href="GraphTraversal_8h_source.html#l01461">Sawyer::Container::Algorithm::graphAllEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>.</p>

</div>
</div>
<a id="ad90cf5b36294a35d36003a976d9aa79b" name="ad90cf5b36294a35d36003a976d9aa79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90cf5b36294a35d36003a976d9aa79b">&#9670;&#160;</a></span>edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all edges. </p>
<p>Returns a pair of edge node iterators that deliniate the list of all edges of this graph. The traversal of this list is in no particular order.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01651">1651</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="af8d207cfbfde993a795a0c75b3e8b94b" name="af8d207cfbfde993a795a0c75b3e8b94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d207cfbfde993a795a0c75b3e8b94b">&#9670;&#160;</a></span>edgeValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeValueIterator.html">EdgeValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::edgeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all edges. </p>
<p>Returns a pair of edge value iterators that deliniate the list of all edges of the graph. The traversal of this list is in no particular order.</p>
<p>Although edge node iterators are implicitly convertible to edge value iterators, this method proves useful in conjuction with "foreach" loops:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;..., std::string&gt; graph = ...;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> std::string &amp;edgeName, graph.edgeValues())</div>
<div class="line">    std::cout &lt;&lt;&quot;name = &quot; &lt;&lt;*edgeName &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01674">1674</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a8d3f693a716479dcc3d3f9e105478ae7" name="a8d3f693a716479dcc3d3f9e105478ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3f693a716479dcc3d3f9e105478ae7">&#9670;&#160;</a></span>edgeValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeValueIterator.html">ConstEdgeValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::edgeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for all edges. </p>
<p>Returns a pair of edge value iterators that deliniate the list of all edges of the graph. The traversal of this list is in no particular order.</p>
<p>Although edge node iterators are implicitly convertible to edge value iterators, this method proves useful in conjuction with "foreach" loops:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;..., std::string&gt; graph = ...;</div>
<div class="line">BOOST_FOREACH (<span class="keyword">const</span> std::string &amp;edgeName, graph.edgeValues())</div>
<div class="line">    std::cout &lt;&lt;&quot;name = &quot; &lt;&lt;*edgeName &lt;&lt;&quot;\n&quot;;</div>
</div><!-- fragment --><p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01678">1678</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="a3989ef4e9f30d9210e80a1cb36acfe7b" name="a3989ef4e9f30d9210e80a1cb36acfe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3989ef4e9f30d9210e80a1cb36acfe7b">&#9670;&#160;</a></span>findEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdge </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the edge with specified ID number. </p>
<p>Returns an edge node iterator for the edge with the specified ID. ID numbers are consecutive integers beginning at zero. Do not call this method with an ID number greater than or equal to the number of edges contained in this graph.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a6d66baadd85921a0ddffeb28fb7f693b">findEdgeValue</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01694">1694</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01891">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01712">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey()</a>, <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a7acc64c6664e3215606769b9745fde7d" name="a7acc64c6664e3215606769b9745fde7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc64c6664e3215606769b9745fde7d">&#9670;&#160;</a></span>findEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdge </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the edge with specified ID number. </p>
<p>Returns an edge node iterator for the edge with the specified ID. ID numbers are consecutive integers beginning at zero. Do not call this method with an ID number greater than or equal to the number of edges contained in this graph.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a6d66baadd85921a0ddffeb28fb7f693b">findEdgeValue</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01697">1697</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

</div>
</div>
<a id="aa5569c71660bdf0732250ba5eb5b0c18" name="aa5569c71660bdf0732250ba5eb5b0c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5569c71660bdf0732250ba5eb5b0c18">&#9670;&#160;</a></span>findEdgeKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a1358a18e3697cb3351d66c1003caeb0d">EdgeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an edge given its key. </p>
<p>Finds an edge having the specified key and returns an iterator pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no edge index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity depends on the edge index type, but is usually logarithmic in the number of edges.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3989ef4e9f30d9210e80a1cb36acfe7b">findEdge</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a6d66baadd85921a0ddffeb28fb7f693b">findEdgeValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01712">1712</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01647">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::edges()</a>, and <a class="el" href="Graph_8h_source.html#l01694">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01732">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeValue()</a>.</p>

</div>
</div>
<a id="a2987cf08d2a047de160514ba995adfb8" name="a2987cf08d2a047de160514ba995adfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2987cf08d2a047de160514ba995adfb8">&#9670;&#160;</a></span>findEdgeKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a1358a18e3697cb3351d66c1003caeb0d">EdgeKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an edge given its key. </p>
<p>Finds an edge having the specified key and returns an iterator pointing to it, or the end iterator if such a vertex does not exist. The end iterator is always returned for graphs that have no edge index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity depends on the edge index type, but is usually logarithmic in the number of edges.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3989ef4e9f30d9210e80a1cb36acfe7b">findEdge</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a6d66baadd85921a0ddffeb28fb7f693b">findEdgeValue</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01717">1717</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01647">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::edges()</a>.</p>

</div>
</div>
<a id="a6d66baadd85921a0ddffeb28fb7f693b" name="a6d66baadd85921a0ddffeb28fb7f693b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d66baadd85921a0ddffeb28fb7f693b">&#9670;&#160;</a></span>findEdgeValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an edge given its value. </p>
<p>Finds an edge having the specified value and returns an iterator pointing to it, or the end iterator if such an edge does not exist. The end iterator is always returned for graphs that have no edge index. This method is just a wrapper around an edge key constructor followed by a call to <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a> for the convenience of the user that doesn't what to remember how to construct a key.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3989ef4e9f30d9210e80a1cb36acfe7b">findEdge</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01732">1732</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01712">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeKey()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01735">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeValue()</a>.</p>

</div>
</div>
<a id="a819df2739b81bfdb288a884681dcd4d7" name="a819df2739b81bfdb288a884681dcd4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819df2739b81bfdb288a884681dcd4d7">&#9670;&#160;</a></span>findEdgeValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an edge given its value. </p>
<p>Finds an edge having the specified value and returns an iterator pointing to it, or the end iterator if such an edge does not exist. The end iterator is always returned for graphs that have no edge index. This method is just a wrapper around an edge key constructor followed by a call to <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a> for the convenience of the user that doesn't what to remember how to construct a key.</p>
<p>See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3989ef4e9f30d9210e80a1cb36acfe7b">findEdge</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#aa5569c71660bdf0732250ba5eb5b0c18">findEdgeKey</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01735">1735</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01732">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdgeValue()</a>.</p>

</div>
</div>
<a id="a113a33fdc000dd6071a918f1c0e1e264" name="a113a33fdc000dd6071a918f1c0e1e264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113a33fdc000dd6071a918f1c0e1e264">&#9670;&#160;</a></span>isValidEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the edge iterator is valid. </p>
<p>Returns true if and only if the specified iterator is not this graph's end iterator and the iterator points to an edge in this graph. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01744">1744</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01647">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::edges()</a>, <a class="el" href="Graph_8h_source.html#l01694">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdge()</a>, <a class="el" href="Graph_8h_source.html#l01152">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::id()</a>, and <a class="el" href="Graph_8h_source.html#l01764">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::nEdges()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01891">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01906">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdgeWithVertices()</a>.</p>

</div>
</div>
<a id="a4c5244b7dddd1f511a0a9350fc79e182" name="a4c5244b7dddd1f511a0a9350fc79e182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5244b7dddd1f511a0a9350fc79e182">&#9670;&#160;</a></span>nVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::nVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of vertices. </p>
<p>Returns the total number of vertices in the graph. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Vertex.html" title="Vertex node.">Vertex</a> ID numbers are guaranteed to be less than this value and greater than or equal to zero.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01754">1754</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphTraversal_8h_source.html#l01449">Sawyer::Container::Algorithm::graphAllVertices()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00086">Sawyer::Container::Algorithm::graphBreakCycles()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00048">Sawyer::Container::Algorithm::graphContainsCycle()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00286">Sawyer::Container::Algorithm::graphDependentOrder()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l01263">Sawyer::Container::Algorithm::graphDirectedDominators()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00176">Sawyer::Container::Algorithm::graphFindConnectedComponents()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>, <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ae324cd7b2cc9b5d100d5d9b3960a931b" name="ae324cd7b2cc9b5d100d5d9b3960a931b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae324cd7b2cc9b5d100d5d9b3960a931b">&#9670;&#160;</a></span>nEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::nEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of edges. </p>
<p>Returns the total number of edges in the graph. <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1Edge.html" title="Edge node.">Edge</a> ID numbers are guaranteed to be less than this value and greater than or equal to zero.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01764">1764</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphTraversal_8h_source.html#l01461">Sawyer::Container::Algorithm::graphAllEdges()</a>, <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a8d56d6c421b427eea9c7e29d3f1963ee" name="a8d56d6c421b427eea9c7e29d3f1963ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d56d6c421b427eea9c7e29d3f1963ee">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if graph is empty. </p>
<p>Returns true if this graph contains no vertices (and therefore no edges).</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01773">1773</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00136">Sawyer::Container::Algorithm::graphIsConnected()</a>.</p>

</div>
</div>
<a id="a5b2a6067898bbf9bdb5f8fc6936d79ff" name="a5b2a6067898bbf9bdb5f8fc6936d79ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2a6067898bbf9bdb5f8fc6936d79ff">&#9670;&#160;</a></span>insertVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new vertex. </p>
<p>Inserts a new vertex and copies <code>value</code> (if specified, or else default-constructed) into the vertex node. Returns an iterator that points to the new vertex. All other vertex iterators that were not already positioned at the one-past-last vertex will eventually traverse this new vertex; no iterators, vertex or edge, are invalidated. The new vertex is given the higest vertex ID number; no other ID numbers, vertex or edge, change.</p>
<p>If this graph has a vertex index and a vertex with the same key already exists then an <a class="el" href="classSawyer_1_1Exception_1_1AlreadyExists.html">Exception::AlreadyExists</a> is thrown. See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac26ba2d89c2a7ff2288da6545149691d">insertVertexMaybe</a>.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without a vertex index. Looking up the vertex in the index has time complexity depending on the type of index (usually logarithmic in the number of vertices). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01790">1790</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ac26ba2d89c2a7ff2288da6545149691d" name="ac26ba2d89c2a7ff2288da6545149691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ba2d89c2a7ff2288da6545149691d">&#9670;&#160;</a></span>insertVertexMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertVertexMaybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally insert a new vertex. </p>
<p>Same as <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a5b2a6067898bbf9bdb5f8fc6936d79ff">insertVertex</a> except if this graph has a vertex index and a vertex already exists with the same key then a new vertex is not inserted and the iterator of the existing vertex is returned instead. This function always inserts a new vertex for graphs that do not have a vertex index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without a vertex index. Looking up the vertex in the index has time complexity depending on the type of index (usually logarithmic in the number of vertices). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01802">1802</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01858">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeWithVertices()</a>.</p>

</div>
</div>
<a id="a0c3a2fe3c55de1001e0ae8e7508a86f0" name="a0c3a2fe3c55de1001e0ae8e7508a86f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3a2fe3c55de1001e0ae8e7508a86f0">&#9670;&#160;</a></span>insertEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>targetVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge. </p>
<p>Inserts a new edge and copies <code>value</code> (if specified, or else default-constructed) into the edge node. Returns an iterator that points to the new edge. All other edge iterators that were not already positioned at the one-past-last edge will eventually traverse this new edge; no iterators, edge or vertex, are invalidated. The new edge is given the highest edge ID number; no other ID numbers, edge or vertex, change.</p>
<p>If this graph has an edge index and an edge with the same key already exists then an <a class="el" href="classSawyer_1_1Exception_1_1AlreadyExists.html">Exception::AlreadyExists</a> is thrown. See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a09c4669b9bf3c8809ea9ebd6d2ad9b4a">insertEdgeMaybe</a>.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without an edge index. Looking up the edge in the index has time complexity depending on the type of index (usually logirithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01820">1820</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GraphAlgorithm_8h_source.html#l00221">Sawyer::Container::Algorithm::graphCopySubgraph()</a>, <a class="el" href="Graph_8h_source.html#l01824">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, <a class="el" href="Graph_8h_source.html#l01858">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeWithVertices()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<a id="aca47cbae60d1de95c7e0fcf97ea0b868" name="aca47cbae60d1de95c7e0fcf97ea0b868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca47cbae60d1de95c7e0fcf97ea0b868">&#9670;&#160;</a></span>insertEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>targetVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge. </p>
<p>Inserts a new edge and copies <code>value</code> (if specified, or else default-constructed) into the edge node. Returns an iterator that points to the new edge. All other edge iterators that were not already positioned at the one-past-last edge will eventually traverse this new edge; no iterators, edge or vertex, are invalidated. The new edge is given the highest edge ID number; no other ID numbers, edge or vertex, change.</p>
<p>If this graph has an edge index and an edge with the same key already exists then an <a class="el" href="classSawyer_1_1Exception_1_1AlreadyExists.html">Exception::AlreadyExists</a> is thrown. See also <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a09c4669b9bf3c8809ea9ebd6d2ad9b4a">insertEdgeMaybe</a>.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without an edge index. Looking up the edge in the index has time complexity depending on the type of index (usually logirithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01824">1824</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01820">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>.</p>

</div>
</div>
<a id="a09c4669b9bf3c8809ea9ebd6d2ad9b4a" name="a09c4669b9bf3c8809ea9ebd6d2ad9b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c4669b9bf3c8809ea9ebd6d2ad9b4a">&#9670;&#160;</a></span>insertEdgeMaybe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>targetVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally insert a new edge. </p>
<p>Same as <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a0c3a2fe3c55de1001e0ae8e7508a86f0">insertEdge</a> except if this graph has an edge index and an edge already exists with the same key then a new edge is not inserted and the iterator of the existing edge is returned instead. This function always inserts a new edge for graphs that do not have an edge index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without an edge index. Looking up the edge in the index has time complexity depending on the type of index (usually logirithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01842">1842</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01846">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe()</a>.</p>

</div>
</div>
<a id="a5619eaf28c45c31baf8082da17bfea15" name="a5619eaf28c45c31baf8082da17bfea15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5619eaf28c45c31baf8082da17bfea15">&#9670;&#160;</a></span>insertEdgeMaybe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>targetVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally insert a new edge. </p>
<p>Same as <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a0c3a2fe3c55de1001e0ae8e7508a86f0">insertEdge</a> except if this graph has an edge index and an edge already exists with the same key then a new edge is not inserted and the iterator of the existing edge is returned instead. This function always inserts a new edge for graphs that do not have an edge index.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant for graphs without an edge index. Looking up the edge in the index has time complexity depending on the type of index (usually logirithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01846">1846</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, <a class="el" href="Graph_8h_source.html#l01842">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeMaybe()</a>, and <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>.</p>

</div>
</div>
<a id="aa29cc5745a368250b493ec3ba420e30b" name="aa29cc5745a368250b493ec3ba420e30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29cc5745a368250b493ec3ba420e30b">&#9670;&#160;</a></span>insertEdgeWithVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::insertEdgeWithVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ab6aa43dd305f98d4cdcaee4defe11c94">VertexValue</a> &amp;&#160;</td>
          <td class="paramname"><em>targetValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeValue</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Graph.html#a01453c8fabdf45adf07e5319c2d46c43">EdgeValue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an edge and its vertex end points. </p>
<p>Invoke <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac26ba2d89c2a7ff2288da6545149691d">insertVertexMaybe</a> for both given vertex values, and then invokes <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a0c3a2fe3c55de1001e0ae8e7508a86f0">insertEdge</a> to connect the two vertices with an edge. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01858">1858</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01820">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01802">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::insertVertexMaybe()</a>.</p>

</div>
</div>
<a id="a5126c672c46a466ea78d7a2bd05b366d" name="a5126c672c46a466ea78d7a2bd05b366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5126c672c46a466ea78d7a2bd05b366d">&#9670;&#160;</a></span>eraseEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an edge. </p>
<p>The edge specified by the iterator (which must not be a one-past-last iterator) is erased from the graph. The term "erasure" is Standard Template Library terminology for the withdrawal and deletion of an object from a container, and differs from the term "remove", which means to move an object to some near-the-end position in a container. Any edge iterator that was pointing at the erased edge becomes invalid and should not be subsequently dereferenced, incremented, decremented, or compared; other iterators, edge and vertex, are unaffected. The edge with the highest ID number will be given the ID of the edge that was erased in order to fill the gap left in the ID sequence. This method returns an iterator for the edge following the one that was erased (possibly the one-past-last iterator if the last edge was erased).</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant unless the graph has an edge index, in which case time complexity is dependent on the index type (usually logarithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01880">1880</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>, and <a class="el" href="Graph_8h_source.html#l01188">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l01891">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01932">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>, <a class="el" href="Graph_8h_source.html#l01906">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdgeWithVertices()</a>, <a class="el" href="GraphAlgorithm_8h_source.html#l00086">Sawyer::Container::Algorithm::graphBreakCycles()</a>, and <a class="el" href="GraphAlgorithm_8h_source.html#l00255">Sawyer::Container::Algorithm::graphEraseParallelEdges()</a>.</p>

</div>
</div>
<a id="ab0e1ecad8cca312af99e7aba32df9d2c" name="ab0e1ecad8cca312af99e7aba32df9d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e1ecad8cca312af99e7aba32df9d2c">&#9670;&#160;</a></span>eraseEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstEdgeIterator.html">ConstEdgeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an edge. </p>
<p>The edge specified by the iterator (which must not be a one-past-last iterator) is erased from the graph. The term "erasure" is Standard Template Library terminology for the withdrawal and deletion of an object from a container, and differs from the term "remove", which means to move an object to some near-the-end position in a container. Any edge iterator that was pointing at the erased edge becomes invalid and should not be subsequently dereferenced, incremented, decremented, or compared; other iterators, edge and vertex, are unaffected. The edge with the highest ID number will be given the ID of the edge that was erased in order to fill the gap left in the ID sequence. This method returns an iterator for the edge following the one that was erased (possibly the one-past-last iterator if the last edge was erased).</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is constant unless the graph has an edge index, in which case time complexity is dependent on the index type (usually logarithmic in the number of edges). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01891">1891</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01694">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findEdge()</a>, <a class="el" href="Graph_8h_source.html#l01152">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::id()</a>, and <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>.</p>

</div>
</div>
<a id="ab31179f8150d5e4f5c36d83236b0bc06" name="ab31179f8150d5e4f5c36d83236b0bc06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31179f8150d5e4f5c36d83236b0bc06">&#9670;&#160;</a></span>eraseEdgeWithVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdgeWithVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1EdgeIterator.html">EdgeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases and edge and possibly vertices. </p>
<p>Erases the specified edge. If this results in the source vertex having no incoming or outgoing edges then the source vertex is also erased. Similarly for the target vertex when the edge is not a self edge. Erasing of the vertices and edges has the semantics of <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ae86b2b0fa4d18f2e2b26163abc2bc049">eraseVertex</a> and <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac256ec051a8f4131b7c9c69714440132">eraseEdges</a>, including the affects on iterators and ID numbers, and time complexity.</p>
<p>Returns an iterator for the edge following the one that was erased (possibly the on-past-last iterator if the last edge was erased). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01906">1906</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01978">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="Graph_8h_source.html#l01744">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidEdge()</a>, <a class="el" href="Graph_8h_source.html#l01162">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::source()</a>, and <a class="el" href="Graph_8h_source.html#l01174">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>.</p>

</div>
</div>
<a id="ac256ec051a8f4131b7c9c69714440132" name="ac256ec051a8f4131b7c9c69714440132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac256ec051a8f4131b7c9c69714440132">&#9670;&#160;</a></span>eraseEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all edges connecting two vertices. </p>
<p>Given two vertex iterators, erase all edges whose source is the first vertex and whose target is the second vertex.</p>
<p>For graphs without an edge index, time complexity is linear in the number of incoming or outgoing edges (whichever is smaller). If an edge index is present then time complexity depends on the type of edge index (most indexes have logarithmic lookup time). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01932">1932</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, <a class="el" href="Graph_8h_source.html#l01162">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::source()</a>, and <a class="el" href="Graph_8h_source.html#l01174">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Edge::target()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01955">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>.</p>

</div>
</div>
<a id="a84d771b9e66adc81409c37ed44486752" name="a84d771b9e66adc81409c37ed44486752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d771b9e66adc81409c37ed44486752">&#9670;&#160;</a></span>eraseEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all edges connecting two vertices. </p>
<p>Given two vertex iterators, erase all edges whose source is the first vertex and whose target is the second vertex.</p>
<p>For graphs without an edge index, time complexity is linear in the number of incoming or outgoing edges (whichever is smaller). If an edge index is present then time complexity depends on the type of edge index (most indexes have logarithmic lookup time). </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01955">1955</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01932">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdges()</a>, <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>.</p>

</div>
</div>
<a id="ae86b2b0fa4d18f2e2b26163abc2bc049" name="ae86b2b0fa4d18f2e2b26163abc2bc049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86b2b0fa4d18f2e2b26163abc2bc049">&#9670;&#160;</a></span>eraseVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a vertex and its incident edges. </p>
<p>The vertex specified by the iterator (which must not be a one-past-last iterator) is erased from the graph along with all edges that originate from or terminate at that vertex. The term "erasure" is Standard Template Library terminology for the withdrawal and deletion of an object from a container, and differs from the term "remove", which means to move an object to some near-the-end position in a container. Any iterator that was pointing at the erased vertex or any of its incident edges becomes invalid and should not be subsequently dereferenced, incremented, decremented, or compared; other iterators, edge and vertex, are unaffected. The vertex with the highest ID number will be given the ID of the vertex that was erased in order to fill the gap left in the ID sequence. This method returns an iterator for the vertex following the one that was erased (possibly the one-past-last iterator if the last vertex was erased).</p>
<p>For a vertex with no incident edges, time complexity is constant unless the graph has a vertex index in which case it depends on the type of index (most vertex indexes have logarithmic lookup/erase time). If the vertex being erased has incoming or outgoing edges then the implementation also calls <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac256ec051a8f4131b7c9c69714440132">eraseEdges</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01978">1978</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01998">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>, and <a class="el" href="Graph_8h_source.html#l01301">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01906">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdgeWithVertices()</a>, and <a class="el" href="Graph_8h_source.html#l01986">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>.</p>

</div>
</div>
<a id="a8de3fd4c85547af9ff084e75e629639d" name="a8de3fd4c85547af9ff084e75e629639d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de3fd4c85547af9ff084e75e629639d">&#9670;&#160;</a></span>eraseVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a vertex and its incident edges. </p>
<p>The vertex specified by the iterator (which must not be a one-past-last iterator) is erased from the graph along with all edges that originate from or terminate at that vertex. The term "erasure" is Standard Template Library terminology for the withdrawal and deletion of an object from a container, and differs from the term "remove", which means to move an object to some near-the-end position in a container. Any iterator that was pointing at the erased vertex or any of its incident edges becomes invalid and should not be subsequently dereferenced, incremented, decremented, or compared; other iterators, edge and vertex, are unaffected. The vertex with the highest ID number will be given the ID of the vertex that was erased in order to fill the gap left in the ID sequence. This method returns an iterator for the vertex following the one that was erased (possibly the one-past-last iterator if the last vertex was erased).</p>
<p>For a vertex with no incident edges, time complexity is constant unless the graph has a vertex index in which case it depends on the type of index (most vertex indexes have logarithmic lookup/erase time). If the vertex being erased has incoming or outgoing edges then the implementation also calls <a class="el" href="classSawyer_1_1Container_1_1Graph.html#ac256ec051a8f4131b7c9c69714440132">eraseEdges</a>. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01986">1986</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01978">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>, <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, and <a class="el" href="Graph_8h_source.html#l01635">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::isValidVertex()</a>.</p>

</div>
</div>
<a id="a0b297aca54604550573383420874b78a" name="a0b297aca54604550573383420874b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b297aca54604550573383420874b78a">&#9670;&#160;</a></span>clearEdges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges, but leave all vertices. </p>
<p>This method erases (withdraws and deletes) all edges but leaves all vertices. It is logically equivalent to calling <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a5126c672c46a466ea78d7a2bd05b366d">eraseEdge</a> for each edge, but is more efficient.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l01998">1998</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l01978">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseVertex()</a>.</p>

</div>
</div>
<a id="a3c2a7e3310845a5f217adae63df7ae08" name="a3c2a7e3310845a5f217adae63df7ae08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a7e3310845a5f217adae63df7ae08">&#9670;&#160;</a></span>clearEdges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges incident to a vertex. </p>
<p>This method erases (withdraws and deletes) all edges that are incident to the specified vertex. That is, all edges whose source or target is the vertex. It is logically equivalent to calling <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3d972c5a458cb735299f620f1c431558">clearOutEdges</a> followed by <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a36cb4f69c729552dcbd8a530eacec8ce">clearInEdges</a>, and has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02017">2017</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, and <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>.</p>

</div>
</div>
<a id="a53a1c9705e8b1af12156e2834bb44330" name="a53a1c9705e8b1af12156e2834bb44330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a1c9705e8b1af12156e2834bb44330">&#9670;&#160;</a></span>clearEdges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges incident to a vertex. </p>
<p>This method erases (withdraws and deletes) all edges that are incident to the specified vertex. That is, all edges whose source or target is the vertex. It is logically equivalent to calling <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a3d972c5a458cb735299f620f1c431558">clearOutEdges</a> followed by <a class="el" href="classSawyer_1_1Container_1_1Graph.html#a36cb4f69c729552dcbd8a530eacec8ce">clearInEdges</a>, and has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02021">2021</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, and <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>.</p>

</div>
</div>
<a id="a3d972c5a458cb735299f620f1c431558" name="a3d972c5a458cb735299f620f1c431558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d972c5a458cb735299f620f1c431558">&#9670;&#160;</a></span>clearOutEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges emanating from a vertex. </p>
<p>This method erases (withdraws and deletes) all edges whose source is the specified vertex. It has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02036">2036</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01257">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::outEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02021">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, <a class="el" href="Graph_8h_source.html#l02017">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, and <a class="el" href="Graph_8h_source.html#l02041">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>.</p>

</div>
</div>
<a id="a63591a0d0e8aea3baab9909d2fc5cd96" name="a63591a0d0e8aea3baab9909d2fc5cd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63591a0d0e8aea3baab9909d2fc5cd96">&#9670;&#160;</a></span>clearOutEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges emanating from a vertex. </p>
<p>This method erases (withdraws and deletes) all edges whose source is the specified vertex. It has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02041">2041</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l02036">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearOutEdges()</a>, <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

</div>
</div>
<a id="a36cb4f69c729552dcbd8a530eacec8ce" name="a36cb4f69c729552dcbd8a530eacec8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cb4f69c729552dcbd8a530eacec8ce">&#9670;&#160;</a></span>clearInEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1VertexIterator.html">VertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges targeting a vertex. </p>
<p>This method erases (withdraws and deletes) all edges whose target is the specified vertex. It has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time.. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02056">2056</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01880">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::eraseEdge()</a>, <a class="el" href="Graph_8h_source.html#l01236">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::inEdges()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Graph_8h_source.html#l02021">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, <a class="el" href="Graph_8h_source.html#l02017">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearEdges()</a>, and <a class="el" href="Graph_8h_source.html#l02061">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>.</p>

</div>
</div>
<a id="a559edbf837b87f8022e93500bdc300a9" name="a559edbf837b87f8022e93500bdc300a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559edbf837b87f8022e93500bdc300a9">&#9670;&#160;</a></span>clearInEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Graph_1_1ConstVertexIterator.html">ConstVertexIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all edges targeting a vertex. </p>
<p>This method erases (withdraws and deletes) all edges whose target is the specified vertex. It has the same effects on iterators and edge ID numbers as erasing edges individually.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of edges erased, multiplied by the time complexity for edge index lookups if any. Most edge indexes have logarithmic lookup time.. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02061">2061</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l02056">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::clearInEdges()</a>, <a class="el" href="Graph_8h_source.html#l01585">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::findVertex()</a>, <a class="el" href="Graph_8h_source.html#l01225">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::Vertex::id()</a>, and <a class="el" href="Graph_8h_source.html#l01538">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertices()</a>.</p>

</div>
</div>
<a id="a2174d35bc17a91f5de25a8cf2e1c4b51" name="a2174d35bc17a91f5de25a8cf2e1c4b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2174d35bc17a91f5de25a8cf2e1c4b51">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V  = Nothing, class E  = Nothing, class VKey  = GraphVertexNoKey&lt;V&gt;, class EKey  = GraphEdgeNoKey&lt;E&gt;, class Alloc  = DefaultAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; V, E, VKey, EKey, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all vertices and edges. </p>
<p>This method has the same effect as erasing edges and vertices individually until the container is empty, but is more efficient. All iterators to vertices and edges in this container become invalid and should not be dereferenced, incremented, decremented, or compared.</p>
<p><a class="el" href="classSawyer_1_1Time.html" title="Represents an ISO 8601 time point.">Time</a> complexity is linear in the number of vertices and edges erased. </p>

<p class="definition">Definition at line <a class="el" href="Graph_8h_source.html#l02074">2074</a> of file <a class="el" href="Graph_8h_source.html">Graph.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataFlowSemantics_8h_source.html#l00130">Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::RiscOperators::clearGraph()</a>, and <a class="el" href="Graph_8h_source.html#l01504">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::operator=()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
