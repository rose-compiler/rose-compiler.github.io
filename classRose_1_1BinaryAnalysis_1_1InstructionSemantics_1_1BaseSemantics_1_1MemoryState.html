<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html">BaseSemantics</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html">MemoryState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Represents all memory in the state. </p>
<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> objects are allocated on the heap and reference counted. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">BaseSemantics::MemoryState</a> is an abstract class that defines the interface. See the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics.html" title="Binary instruction semantics.">Rose::BinaryAnalysis::InstructionSemantics</a> namespace for an overview of how the parts fit together. </p>

<p class="definition">Definition at line <a class="el" href="MemoryState_8h_source.html#l00027">27</a> of file <a class="el" href="MemoryState_8h_source.html">MemoryState.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="MemoryState_8h_source.html">Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/MemoryState.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_inherit__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_inherit__map">
<area shape="rect" title="Represents all memory in the state." alt="" coords="239,124,447,179"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellState.html" title="Cell&#45;based memory state." alt="" coords="495,5,725,60"/>
<area shape="poly" title=" " alt="" coords="401,115,494,69,522,58,524,63,496,74,403,120"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html" title="Purely symbolic memory state." alt="" coords="495,84,725,139"/>
<area shape="poly" title=" " alt="" coords="460,131,494,126,495,131,461,136"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html" title="Byte&#45;addressable memory." alt="" coords="495,163,725,217"/>
<area shape="poly" title=" " alt="" coords="461,166,495,171,494,176,460,171"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html" title="Null memory." alt="" coords="509,241,711,296"/>
<area shape="poly" title=" " alt="" coords="404,183,496,228,524,239,522,244,494,232,402,188"/>
<area shape="rect" title=" " alt="" coords="5,131,191,171"/>
<area shape="poly" title=" " alt="" coords="204,149,238,149,238,154,204,154"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_coll__map" id="aRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_coll__map">
<area shape="rect" title="Represents all memory in the state." alt="" coords="5,93,213,148"/>
<area shape="rect" title=" " alt="" coords="17,5,202,45"/>
<area shape="poly" title=" " alt="" coords="112,59,112,93,107,93,107,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> with formatter.  <a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac023fe18293bb0a84f86bf2844208693" id="r_ac023fe18293bb0a84f86bf2844208693"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ac023fe18293bb0a84f86bf2844208693">Ptr</a></td></tr>
<tr class="memdesc:ac023fe18293bb0a84f86bf2844208693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:ac023fe18293bb0a84f86bf2844208693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c45efb83bdbf6941c9e74385a2a8b6e" id="r_a3c45efb83bdbf6941c9e74385a2a8b6e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a3c45efb83bdbf6941c9e74385a2a8b6e">create</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;addrProtoval, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;valProtoval) const =0</td></tr>
<tr class="memdesc:a3c45efb83bdbf6941c9e74385a2a8b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual allocating constructor.  <br /></td></tr>
<tr class="separator:a3c45efb83bdbf6941c9e74385a2a8b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90f49e85d0362915c1c1885ad4ae5ea" id="r_ab90f49e85d0362915c1c1885ad4ae5ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ab90f49e85d0362915c1c1885ad4ae5ea">clone</a> () const =0</td></tr>
<tr class="memdesc:ab90f49e85d0362915c1c1885ad4ae5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual allocating copy constructor.  <br /></td></tr>
<tr class="separator:ab90f49e85d0362915c1c1885ad4ae5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b8e4993625b726836602e9aa557542" id="r_ac1b8e4993625b726836602e9aa557542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ac1b8e4993625b726836602e9aa557542">get_addr_protoval</a> () const</td></tr>
<tr class="memdesc:ac1b8e4993625b726836602e9aa557542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address protoval.  <br /></td></tr>
<tr class="separator:ac1b8e4993625b726836602e9aa557542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de509fdb791f0189d3a3e0dfa2cf18e" id="r_a6de509fdb791f0189d3a3e0dfa2cf18e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a6de509fdb791f0189d3a3e0dfa2cf18e">get_val_protoval</a> () const</td></tr>
<tr class="memdesc:a6de509fdb791f0189d3a3e0dfa2cf18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value protoval.  <br /></td></tr>
<tr class="separator:a6de509fdb791f0189d3a3e0dfa2cf18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0fa2a3e4839a85def435f00d05d007" id="r_acc0fa2a3e4839a85def435f00d05d007"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#acc0fa2a3e4839a85def435f00d05d007">clear</a> ()=0</td></tr>
<tr class="memdesc:acc0fa2a3e4839a85def435f00d05d007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear memory.  <br /></td></tr>
<tr class="separator:acc0fa2a3e4839a85def435f00d05d007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af3eefb5236f4ec384263f274f4f401" id="r_a2af3eefb5236f4ec384263f274f4f401"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a2af3eefb5236f4ec384263f274f4f401">merge</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> &amp;other, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *addrOps, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *valOps)=0</td></tr>
<tr class="memdesc:a2af3eefb5236f4ec384263f274f4f401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge memory states for data flow analysis.  <br /></td></tr>
<tr class="separator:a2af3eefb5236f4ec384263f274f4f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd8d5213b8cf08b34d9a2fad6fd625" id="r_ae0cd8d5213b8cf08b34d9a2fad6fd625"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ae0cd8d5213b8cf08b34d9a2fad6fd625">readMemory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;address, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;dflt, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *addrOps, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *valOps)=0</td></tr>
<tr class="memdesc:ae0cd8d5213b8cf08b34d9a2fad6fd625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from memory.  <br /></td></tr>
<tr class="separator:ae0cd8d5213b8cf08b34d9a2fad6fd625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519df4e74060b80660b74e81a980ddce" id="r_a519df4e74060b80660b74e81a980ddce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a519df4e74060b80660b74e81a980ddce">peekMemory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;address, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;dflt, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *addrOps, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *valOps)=0</td></tr>
<tr class="memdesc:a519df4e74060b80660b74e81a980ddce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from memory without side effects.  <br /></td></tr>
<tr class="separator:a519df4e74060b80660b74e81a980ddce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6a228a48f3b3e1c4ea4e9c5e95bb9" id="r_a85f6a228a48f3b3e1c4ea4e9c5e95bb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a85f6a228a48f3b3e1c4ea4e9c5e95bb9">writeMemory</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;value, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *addrOps, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *valOps)=0</td></tr>
<tr class="memdesc:a85f6a228a48f3b3e1c4ea4e9c5e95bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to memory.  <br /></td></tr>
<tr class="separator:a85f6a228a48f3b3e1c4ea4e9c5e95bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad470253daecf73ba4245b6e974e6e7a2" id="r_ad470253daecf73ba4245b6e974e6e7a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ad470253daecf73ba4245b6e974e6e7a2">hash</a> (<a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *addrOps, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *valOps) const =0</td></tr>
<tr class="memdesc:ad470253daecf73ba4245b6e974e6e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a hash for this memory state.  <br /></td></tr>
<tr class="separator:ad470253daecf73ba4245b6e974e6e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a862484d725b1866f53f79f821869909c" id="r_a862484d725b1866f53f79f821869909c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a093ec60edf7a66377a0c1aeeb0177f5e">MergerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a862484d725b1866f53f79f821869909c">merger</a> () const</td></tr>
<tr class="memdesc:a862484d725b1866f53f79f821869909c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Merger.html" title="Controls state merge operations.">Merger</a>.  <br /></td></tr>
<tr class="separator:a862484d725b1866f53f79f821869909c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de90fcdbc833ff0f96578aa69afa32b" id="r_a6de90fcdbc833ff0f96578aa69afa32b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a6de90fcdbc833ff0f96578aa69afa32b">merger</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a093ec60edf7a66377a0c1aeeb0177f5e">MergerPtr</a> &amp;)</td></tr>
<tr class="memdesc:a6de90fcdbc833ff0f96578aa69afa32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Merger.html" title="Controls state merge operations.">Merger</a>.  <br /></td></tr>
<tr class="separator:a6de90fcdbc833ff0f96578aa69afa32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad42ba885559198de9771cb546ded32da" id="r_ad42ba885559198de9771cb546ded32da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ad42ba885559198de9771cb546ded32da">byteRestricted</a> () const</td></tr>
<tr class="memdesc:ad42ba885559198de9771cb546ded32da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether memory cell values are required to be eight bits wide.  <br /></td></tr>
<tr class="separator:ad42ba885559198de9771cb546ded32da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35fa5af5d94dc2af96bfef3ced6543b" id="r_af35fa5af5d94dc2af96bfef3ced6543b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#af35fa5af5d94dc2af96bfef3ced6543b">byteRestricted</a> (bool)</td></tr>
<tr class="memdesc:af35fa5af5d94dc2af96bfef3ced6543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether memory cell values are required to be eight bits wide.  <br /></td></tr>
<tr class="separator:af35fa5af5d94dc2af96bfef3ced6543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9170a5dd2e9004917683abdffc52b0f1" id="r_a9170a5dd2e9004917683abdffc52b0f1"><td class="memItemLeft" align="right" valign="top"><a id="a9170a5dd2e9004917683abdffc52b0f1" name="a9170a5dd2e9004917683abdffc52b0f1"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_byteOrder</b> () const</td></tr>
<tr class="memdesc:a9170a5dd2e9004917683abdffc52b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory byte order. <br /></td></tr>
<tr class="separator:a9170a5dd2e9004917683abdffc52b0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00349ce475126a9641e70c45f62e97f2" id="r_a00349ce475126a9641e70c45f62e97f2"><td class="memItemLeft" align="right" valign="top"><a id="a00349ce475126a9641e70c45f62e97f2" name="a00349ce475126a9641e70c45f62e97f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_byteOrder</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>)</td></tr>
<tr class="memdesc:a00349ce475126a9641e70c45f62e97f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory byte order. <br /></td></tr>
<tr class="separator:a00349ce475126a9641e70c45f62e97f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54f061f3db7266df6b28f527986bfc23" id="r_a54f061f3db7266df6b28f527986bfc23"><td class="memItemLeft" align="right" valign="top"><a id="a54f061f3db7266df6b28f527986bfc23" name="a54f061f3db7266df6b28f527986bfc23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (std::ostream &amp;, const std::string prefix=&quot;&quot;) const</td></tr>
<tr class="memdesc:a54f061f3db7266df6b28f527986bfc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a memory state to more than one line of output. <br /></td></tr>
<tr class="separator:a54f061f3db7266df6b28f527986bfc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f7a5bc66cc55e6ca6de98a9a84d4e" id="r_a451f7a5bc66cc55e6ca6de98a9a84d4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a451f7a5bc66cc55e6ca6de98a9a84d4e">print</a> (std::ostream &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;) const =0</td></tr>
<tr class="memdesc:a451f7a5bc66cc55e6ca6de98a9a84d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a memory state to more than one line of output.  <br /></td></tr>
<tr class="separator:a451f7a5bc66cc55e6ca6de98a9a84d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0090bc7736107b0dd31cb8b9df11e1a7" id="r_a0090bc7736107b0dd31cb8b9df11e1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a0090bc7736107b0dd31cb8b9df11e1a7">with_format</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;)</td></tr>
<tr class="memdesc:a0090bc7736107b0dd31cb8b9df11e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing memory states with formatting.  <br /></td></tr>
<tr class="separator:a0090bc7736107b0dd31cb8b9df11e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada029f0a005bf9839f751bf5a362e216" id="r_ada029f0a005bf9839f751bf5a362e216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ada029f0a005bf9839f751bf5a362e216">operator+</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;)</td></tr>
<tr class="memdesc:ada029f0a005bf9839f751bf5a362e216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing memory states with formatting.  <br /></td></tr>
<tr class="separator:ada029f0a005bf9839f751bf5a362e216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac793787fe66d317ffb323703dc1e5f" id="r_a0ac793787fe66d317ffb323703dc1e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a0ac793787fe66d317ffb323703dc1e5f">operator+</a> (const std::string &amp;linePrefix)</td></tr>
<tr class="memdesc:a0ac793787fe66d317ffb323703dc1e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for printing memory states with formatting.  <br /></td></tr>
<tr class="separator:a0ac793787fe66d317ffb323703dc1e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2c82fad97f1b92b507fcb66ea3f48e18" id="r_a2c82fad97f1b92b507fcb66ea3f48e18"><td class="memItemLeft" align="right" valign="top"><a id="a2c82fad97f1b92b507fcb66ea3f48e18" name="a2c82fad97f1b92b507fcb66ea3f48e18"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>promote</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> &amp;)</td></tr>
<tr class="separator:a2c82fad97f1b92b507fcb66ea3f48e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae31e09c55df46c89f52c06fdc6d96832" id="r_ae31e09c55df46c89f52c06fdc6d96832"><td class="memItemLeft" align="right" valign="top"><a id="ae31e09c55df46c89f52c06fdc6d96832" name="ae31e09c55df46c89f52c06fdc6d96832"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryState</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;addrProtoval, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;valProtoval)</td></tr>
<tr class="separator:ae31e09c55df46c89f52c06fdc6d96832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b4cc3d86889f62b4b88561dcd99696" id="r_a92b4cc3d86889f62b4b88561dcd99696"><td class="memItemLeft" align="right" valign="top"><a id="a92b4cc3d86889f62b4b88561dcd99696" name="a92b4cc3d86889f62b4b88561dcd99696"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryState</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> &amp;other)</td></tr>
<tr class="separator:a92b4cc3d86889f62b4b88561dcd99696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac023fe18293bb0a84f86bf2844208693" name="ac023fe18293bb0a84f86bf2844208693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac023fe18293bb0a84f86bf2844208693">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ac023fe18293bb0a84f86bf2844208693">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="MemoryState_8h_source.html#l00030">30</a> of file <a class="el" href="MemoryState_8h_source.html">MemoryState.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c45efb83bdbf6941c9e74385a2a8b6e" name="a3c45efb83bdbf6941c9e74385a2a8b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c45efb83bdbf6941c9e74385a2a8b6e">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>addrProtoval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>valProtoval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual allocating constructor. </p>
<p>Allocates and constructs a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> object having the same dynamic type as this object. A prototypical <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html" title="Base class for semantic values.">SValue</a> must be supplied and will be used to construct any additional <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html" title="Base class for semantic values.">SValue</a> objects needed during the operation of a <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a>. Two prototypical values are supplied, one for addresses and another for values stored at those addresses, although they will almost always be the same. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#ad926da87db20826381d5cc52f1e83f1f">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics_1_1MemoryState.html#afe41e98c013e7c13fde2842d90e234c2">Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a00f03f319e18e532c2affba1490adf63">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryListState.html#a61f38b81aa18de585f056824cd3dcc7d">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryListState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryMapState.html#a2d89d38823b11999f7304741cfd504ce">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryMapState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#a6ea360b4d1598814b82907b1518fbda1">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#aab4b6d24a0b2e3ab043b763d6347a39b">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#afa0dc420f8df6bce778c4264e9f84f1a">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="ab90f49e85d0362915c1c1885ad4ae5ea" name="ab90f49e85d0362915c1c1885ad4ae5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90f49e85d0362915c1c1885ad4ae5ea">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual allocating copy constructor. </p>
<p>Creates a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> object which is a copy of this object. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#ac42b3f198611335aa466aad78c654ae6">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#a3bac8213d745f65cfcb75d31b84b90f4">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#a7a1a982e4277ba0d66831afe8a5893a1">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics_1_1MemoryState.html#aeb67972210b9536f4ff724c46ee35f19">Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a588e5109ef39a694d0fc9c5aff2d9322">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryListState.html#a3ada13252aef1bd706e14a52150ce724">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryListState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryMapState.html#ae285c9c78c737aa785e90849ca0ab3a6">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryMapState</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#abe301d42a28b7fbcc720db872abfd571">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>.</p>

</div>
</div>
<a id="a862484d725b1866f53f79f821869909c" name="a862484d725b1866f53f79f821869909c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862484d725b1866f53f79f821869909c">&#9670;&#160;</a></span>merger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a093ec60edf7a66377a0c1aeeb0177f5e">MergerPtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::merger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Merger.html" title="Controls state merge operations.">Merger</a>. </p>
<p>This property is optional details about how to merge two states. It is passed down to the register and memory state merge operation and to the semantic value merge operation. Users can subclass this to hold whatever information is necessary for merging. Unless the user overrides merge functions to do something else, all merging will use the same merger object &ndash; the one set for this property. </p>

</div>
</div>
<a id="a6de90fcdbc833ff0f96578aa69afa32b" name="a6de90fcdbc833ff0f96578aa69afa32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de90fcdbc833ff0f96578aa69afa32b">&#9670;&#160;</a></span>merger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::merger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a093ec60edf7a66377a0c1aeeb0177f5e">MergerPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Merger.html" title="Controls state merge operations.">Merger</a>. </p>
<p>This property is optional details about how to merge two states. It is passed down to the register and memory state merge operation and to the semantic value merge operation. Users can subclass this to hold whatever information is necessary for merging. Unless the user overrides merge functions to do something else, all merging will use the same merger object &ndash; the one set for this property. </p>

</div>
</div>
<a id="ac1b8e4993625b726836602e9aa557542" name="ac1b8e4993625b726836602e9aa557542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b8e4993625b726836602e9aa557542">&#9670;&#160;</a></span>get_addr_protoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::get_addr_protoval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the address protoval. </p>
<p>The address protoval is used to construct other memory addresses via its virtual constructors. </p>

</div>
</div>
<a id="a6de509fdb791f0189d3a3e0dfa2cf18e" name="a6de509fdb791f0189d3a3e0dfa2cf18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de509fdb791f0189d3a3e0dfa2cf18e">&#9670;&#160;</a></span>get_val_protoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::get_val_protoval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value protoval. </p>
<p>The value protoval is used to construct other stored values via its virtual constructors. </p>

</div>
</div>
<a id="acc0fa2a3e4839a85def435f00d05d007" name="acc0fa2a3e4839a85def435f00d05d007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0fa2a3e4839a85def435f00d05d007">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear memory. </p>
<p>Removes all memory cells from this memory state. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#a0b6dfe572ddb10b0233cda6b1064b2f9">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#a8aa71e52c9df2ec6a0dd18566fe0db50">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellState.html#ada67b33bfe88d2cda09141fe5f9814c9">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#abb8a2c80079c5579f8574537146a096d">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#a1e934d60a83e120d98f3cd42268c2e58">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a903026466cee7537182001e6013503a7">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>.</p>

</div>
</div>
<a id="ad42ba885559198de9771cb546ded32da" name="ad42ba885559198de9771cb546ded32da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42ba885559198de9771cb546ded32da">&#9670;&#160;</a></span>byteRestricted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::byteRestricted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether memory cell values are required to be eight bits wide. </p>
<p>The default is true since this simplifies the calculations for whether two memory cells are alias and how to combine the value from two or more aliasing cells. A memory that contains only eight-bit values requires that the caller concatenate/extract individual bytes when reading/writing multi-byte values. </p>

</div>
</div>
<a id="af35fa5af5d94dc2af96bfef3ced6543b" name="af35fa5af5d94dc2af96bfef3ced6543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35fa5af5d94dc2af96bfef3ced6543b">&#9670;&#160;</a></span>byteRestricted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::byteRestricted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether memory cell values are required to be eight bits wide. </p>
<p>The default is true since this simplifies the calculations for whether two memory cells are alias and how to combine the value from two or more aliasing cells. A memory that contains only eight-bit values requires that the caller concatenate/extract individual bytes when reading/writing multi-byte values. </p>

</div>
</div>
<a id="a2af3eefb5236f4ec384263f274f4f401" name="a2af3eefb5236f4ec384263f274f4f401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af3eefb5236f4ec384263f274f4f401">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>addrOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>valOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge memory states for data flow analysis. </p>
<p>Merges the <code>other</code> state into this state, returning true if this state changed. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a0503fa9a242d2ddf6f02185777f5972c">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#ace650b8f72a1947e7d86c9c330c3ae38">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#ac2bc8959b83a233c9ed9e66ee2184758">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#abb4853034973f2aad1c2ea732bcad65f">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#a4525f041eb371d3bd95fd529e8907beb">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="ae0cd8d5213b8cf08b34d9a2fad6fd625" name="ae0cd8d5213b8cf08b34d9a2fad6fd625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd8d5213b8cf08b34d9a2fad6fd625">&#9670;&#160;</a></span>readMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::readMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>addrOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>valOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value from memory. </p>
<p>Consults the memory represented by this <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> object and returns a semantic value. Depending on the semantic domain, the value can be a value that is already stored in the memory state, a supplied default value, a new value constructed from some combination of existing values and/or the default value, or anything else. For instance, in a symbolic domain the <code>address</code> could alias multiple existing memory locations and the implementation may choose to return a McCarthy expression. Additional data (such as SMT solvers) may be passed via the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html" title="Base class for most instruction semantics RISC operators.">RiscOperators</a> argument.</p>
<p>The size of the value being read does not necessarily need to be equal to the size of values stored in the memory state, though it typically is(1). For instance, an implementation may allow reading a 32-bit little endian value from a memory state that stores only bytes. A <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html" title="Base class for most instruction semantics RISC operators.">RiscOperators</a> object is provided for use in these situations.</p>
<p>In order to support cases where an address does not match any existing location, the <code>dflt</code> value can be used to initialize a new memory location. The manner in which the default is used depends on the implementation. In any case, the width of the <code>dflt</code> value determines how much to read.</p>
<p>Footnote 1: A <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ae0cd8d5213b8cf08b34d9a2fad6fd625" title="Read a value from memory.">MemoryState::readMemory()</a> call is the last in a sequence of delegations starting with <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#aac89759cf1f5d01161a9fae309ce1c32" title="Reads a value from memory.">RiscOperators::readMemory()</a>. The designers of the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html" title="Base class for semantics machine states.">State</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html" title="Base class for most instruction semantics RISC operators.">RiscOperators</a> subclasses will need to coordinate to decide which layer should handle concatenating values from individual memory locations. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#ae7430623086410bccb4461f016c930cf">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#a4703ad17e78df6e2c92dad30b8330596">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics_1_1MemoryState.html#a8d0f3bf655bb055a3ced4e4d8f92105d">Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryListState.html#a58ffc4b796c3b7905a669a5a34dfd78a">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryListState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#ad2ebee9aa58aaec6d5dbac80a2b225f4">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#aa633bcb8e4ae27f86f563979e505d263">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#ab6890bd0d79a704467903bc9b8f40a73">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#ad36bca71e5c2540326a19b14dd5c3a77">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="a519df4e74060b80660b74e81a980ddce" name="a519df4e74060b80660b74e81a980ddce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519df4e74060b80660b74e81a980ddce">&#9670;&#160;</a></span>peekMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::peekMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>addrOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>valOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value from memory without side effects. </p>
<p>This is similar to <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#ae0cd8d5213b8cf08b34d9a2fad6fd625">readMemory</a> except there are no side effects. The memory state is not modified by this function. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a0d4411149713d287f9e897a4ee7c6777">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#a9ec1590acebcd1873818a61ac26d9ff9">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics_1_1MemoryState.html#a5590933fdce7a622293fbd68d780a4f4">Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryListState.html#a7078af194213aa0d795634ed2ff00961">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryListState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#af7b8b9dd5c1fecd973b98654d17f50e5">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#a26ae43599ac1597465d51f15a135a7a5">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#ae35833310cd515bcacf3930f78e6a537">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#a4c2b260c56386945bd406a7be71e2ff7">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="a85f6a228a48f3b3e1c4ea4e9c5e95bb9" name="a85f6a228a48f3b3e1c4ea4e9c5e95bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f6a228a48f3b3e1c4ea4e9c5e95bb9">&#9670;&#160;</a></span>writeMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::writeMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>addrOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>valOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a value to memory. </p>
<p>Consults the memory represented by this <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a> object and possibly inserts the specified value. The details of how a value is inserted into a memory state depends entirely on the implementation in a subclass and will probably be different for each semantic domain.</p>
<p>A <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html#a85f6a228a48f3b3e1c4ea4e9c5e95bb9" title="Write a value to memory.">MemoryState::writeMemory()</a> call is the last in a sequence of delegations starting with <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html#a1d972c261aab66405c46f711c191a369" title="Writes a value to memory.">RiscOperators::writeMemory()</a>. The designers of the <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState.html" title="Represents all memory in the state.">MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1State.html" title="Base class for semantics machine states.">State</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html" title="Base class for most instruction semantics RISC operators.">RiscOperators</a> will need to coordinate to decide which layer (if any) should handle splitting a multi-byte value into multiple memory locations. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a9544e64aeae45d5d956f81bf443094ff">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#aaa1b7303582a135c7827431bcf1d55cc">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics_1_1MemoryState.html#af1667cda54a32eab48f474b6fb261125">Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics_1_1MemoryListState.html#a16ddb1f66e69d84058a8c84de461c3dd">Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::MemoryListState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#a1b7fadb2652effe0a612d97417d07bab">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#a9a01e3c64b3a16910c6c96525a879033">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#a3bd2bcb09fbfc9e1daf04ace191756f0">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#a90851acf4388459c750906c046475a6e">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="ad470253daecf73ba4245b6e974e6e7a2" name="ad470253daecf73ba4245b6e974e6e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad470253daecf73ba4245b6e974e6e7a2">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Combinatorics_1_1Hasher.html">Combinatorics::Hasher</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>addrOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1RiscOperators.html">RiscOperators</a> *&#160;</td>
          <td class="paramname"><em>valOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a hash for this memory state. </p>
<p>This hashes the addresses and values stored in memory. The goal is to be able to identify when two memory states are the "same". An analysis might be able to take shortcuts if it encounters a state that it has seen before. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#ad2968713beae17039be35e5fb7da964e">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#a1797af0b8f9cf421ee2fbaa14ca40f7b">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#a90e9842d1a86200c1951e454e350a867">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#a87c85a44525ce06ab03c1d13f0e7d53e">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#a8a72bcfab95dad199fd0defa6938acad">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>.</p>

</div>
</div>
<a id="a451f7a5bc66cc55e6ca6de98a9a84d4e" name="a451f7a5bc66cc55e6ca6de98a9a84d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451f7a5bc66cc55e6ca6de98a9a84d4e">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a memory state to more than one line of output. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1MemoryState.html#a8913c16f93d37cf419b8440dfaa0eaa5">Rose::BinaryAnalysis::InstructionSemantics::NullSemantics::MemoryState</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellList.html#ad0a80f961b527c72db03cf96fc18c426">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellList</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCellMap.html#a349ee5cfb67f7d069384d3e9e8b147ae">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryCellMap</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SymbolicMemory.html#ae15fc0b01a9bf2aa8bef274d42eca5da">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SymbolicMemory</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1ConcreteSemantics_1_1MemoryState.html#ae47587502d60877870c3d971ec93c5dc">Rose::BinaryAnalysis::InstructionSemantics::ConcreteSemantics::MemoryState</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics_1_1MemoryState.html#a577af6eb975a89057a2fb3f8b6cc2408">Rose::BinaryAnalysis::Partitioner2::Semantics::MemoryState&lt; Super &gt;</a>.</p>

</div>
</div>
<a id="a0090bc7736107b0dd31cb8b9df11e1a7" name="a0090bc7736107b0dd31cb8b9df11e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0090bc7736107b0dd31cb8b9df11e1a7">&#9670;&#160;</a></span>with_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::with_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for printing memory states with formatting. </p>
<p>The usual way to use this is: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> obj = ...;</div>
<div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> fmt = ...;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;The value is: &quot;</span> &lt;&lt;(*obj+fmt) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::Formatter</a></div><div class="ttdoc">Format for printing things.</div><div class="ttdef"><b>Definition</b> <a href="Formatter_8h_source.html#l00019">Formatter.h:19</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_html_a0e041dec7b5ca22d15dd473f0c4fd825"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryStatePtr</a></div><div class="ttdeci">boost::shared_ptr&lt; MemoryState &gt; MemoryStatePtr</div><div class="ttdoc">Shared-ownership pointer to a memory state.</div><div class="ttdef"><b>Definition</b> <a href="Rose_2BinaryAnalysis_2InstructionSemantics_2BaseSemantics_2BasicTypes_8h_source.html#l00057">Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h:57</a></div></div>
</div><!-- fragment --><p>Since specifying a line prefix string for indentation purposes is such a common use case, the indentation can be given instead of a format, as in the following code that indents the prefixes each line of the expression with four spaces.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;Memory state:\n&quot;</span> &lt;&lt;*(obj + <span class="stringliteral">&quot;    &quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ada029f0a005bf9839f751bf5a362e216" name="ada029f0a005bf9839f751bf5a362e216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada029f0a005bf9839f751bf5a362e216">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for printing memory states with formatting. </p>
<p>The usual way to use this is: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> obj = ...;</div>
<div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> fmt = ...;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;The value is: &quot;</span> &lt;&lt;(*obj+fmt) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>Since specifying a line prefix string for indentation purposes is such a common use case, the indentation can be given instead of a format, as in the following code that indents the prefixes each line of the expression with four spaces.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;Memory state:\n&quot;</span> &lt;&lt;*(obj + <span class="stringliteral">&quot;    &quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0ac793787fe66d317ffb323703dc1e5f" name="a0ac793787fe66d317ffb323703dc1e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac793787fe66d317ffb323703dc1e5f">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryState_1_1WithFormatter.html">WithFormatter</a> Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::MemoryState::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>linePrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for printing memory states with formatting. </p>
<p>The usual way to use this is: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0e041dec7b5ca22d15dd473f0c4fd825">MemoryStatePtr</a> obj = ...;</div>
<div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Formatter.html">Formatter</a> fmt = ...;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;The value is: &quot;</span> &lt;&lt;(*obj+fmt) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p>Since specifying a line prefix string for indentation purposes is such a common use case, the indentation can be given instead of a format, as in the following code that indents the prefixes each line of the expression with four spaces.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;Memory state:\n&quot;</span> &lt;&lt;*(obj + <span class="stringliteral">&quot;    &quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MemoryState_8h_source.html">MemoryState.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
