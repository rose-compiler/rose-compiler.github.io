<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::CodeInserter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html">CodeInserter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1CodeInserter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::CodeInserter Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Insert new code in place of existing instructions. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00026">26</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="CodeInserter_8h_source.html">Rose/BinaryAnalysis/CodeInserter.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::CodeInserter:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1CodeInserter__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1CodeInserter_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1CodeInserter_coll__map" id="aRose_1_1BinaryAnalysis_1_1CodeInserter_coll__map">
<area shape="rect" title="Insert new code in place of existing instructions." alt="" coords="399,125,547,165"/>
<area shape="rect" href="classSawyer_1_1SharedPointer.html" title=" " alt="" coords="27,5,183,45"/>
<area shape="poly" title=" " alt="" coords="198,36,285,55,376,84,413,103,446,123,443,127,410,107,374,89,284,60,197,41"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Interval.html" title=" " alt="" coords="36,69,175,109"/>
<area shape="poly" title=" " alt="" coords="189,97,375,124,399,128,398,133,374,129,188,102"/>
<area shape="rect" title=" " alt="" coords="65,134,145,159"/>
<area shape="poly" title=" " alt="" coords="159,144,398,143,398,148,159,149"/>
<area shape="rect" href="classSawyer_1_1Container_1_1IntervalSet.html" title=" " alt="" coords="5,185,205,225"/>
<area shape="poly" title=" " alt="" coords="219,199,296,192,374,179,425,163,426,168,375,184,296,197,219,205"/>
<area shape="rect" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams." alt="" coords="17,250,194,275"/>
<area shape="poly" title=" " alt="" coords="208,256,291,244,333,233,374,219,417,193,452,163,455,167,420,197,376,224,335,239,292,249,209,262"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1InstructionInfo.html">InstructionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an instruction within the basic block being modified.  <a href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1InstructionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html" title="Relocation record.">Relocation</a> record.  <a href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5e55e25fb70e6cdcaca3f2de3fc25e4f" id="r_a5e55e25fb70e6cdcaca3f2de3fc25e4f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4f">AggregationDirection</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4fa3f311dbf274156da8dad45562d5276fb">AGGREGATE_PREDECESSORS</a> = 0x00000001
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4fa0bbca926f3844788d3cf913c366e0c6c">AGGREGATE_SUCCESSORS</a> = 0x00000002
<br />
 }</td></tr>
<tr class="memdesc:a5e55e25fb70e6cdcaca3f2de3fc25e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">What other instructions can be moved to make room.  <a href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4f">More...</a><br /></td></tr>
<tr class="separator:a5e55e25fb70e6cdcaca3f2de3fc25e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8f0df9f2de216471130f90ce67f61d" id="r_a8c8f0df9f2de216471130f90ce67f61d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61daf6c3c213d6a1654a60359cb47ca12b08">PAD_NOP_BACK</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61dac15b387cfa1df0814aa4d82f7484a5d6">PAD_NOP_FRONT</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61dabcf44f2be0d29c4000e56c022724d04a">PAD_RANDOM_BACK</a>
<br />
 }</td></tr>
<tr class="memdesc:a8c8f0df9f2de216471130f90ce67f61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to pad with no-ops.  <a href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">More...</a><br /></td></tr>
<tr class="separator:a8c8f0df9f2de216471130f90ce67f61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20b82d2d88881de074a41808872b103" id="r_ad20b82d2d88881de074a41808872b103"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103">RelocType</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103a11133d481e3ad918ed8055b512e8a8ab">RELOC_INDEX_ABS_LE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103a077b7af4fc47b6142ac6cbd0a19619cf">RELOC_INDEX_ABS_LE32HI</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103aa69bc36e88956e09764aefdf308d8bf2">RELOC_INDEX_ABS_BE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103aa267b543851282ab2325979679d5d65a">RELOC_ADDR_REL_LE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103a8df47c70429ebac4d54b9be9ba15877c">RELOC_ADDR_REL_BE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103aaaae609ba1503a23e343c90e9c5737bb">RELOC_INSN_ABS_LE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103abdfef0adbd8df9435577061728c6aaf5">RELOC_INSN_REL_LE32</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103aff2b61ceb1e3a111ac3cd0ae3fa589b2">RELOC_INSN_REL_BE32</a>
<br />
 }</td></tr>
<tr class="memdesc:ad20b82d2d88881de074a41808872b103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of relocation to perform.  <a href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103">More...</a><br /></td></tr>
<tr class="separator:ad20b82d2d88881de074a41808872b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2368a6ecbe2231517b40d0ebb27d5a" id="r_a1c2368a6ecbe2231517b40d0ebb27d5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; int, <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1InstructionInfo.html">InstructionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a></td></tr>
<tr class="memdesc:a1c2368a6ecbe2231517b40d0ebb27d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about instructions within the basic block being modified.  <br /></td></tr>
<tr class="separator:a1c2368a6ecbe2231517b40d0ebb27d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4854bc8adec968b39a8520a390eb8791" id="r_a4854bc8adec968b39a8520a390eb8791"><td class="memItemLeft" align="right" valign="top"><a id="a4854bc8adec968b39a8520a390eb8791" name="a4854bc8adec968b39a8520a390eb8791"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CodeInserter</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;)</td></tr>
<tr class="separator:a4854bc8adec968b39a8520a390eb8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1471008a5db8291bf0d6dc17fb33f663" id="r_a1471008a5db8291bf0d6dc17fb33f663"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1471008a5db8291bf0d6dc17fb33f663">allocatedChunks</a> () const</td></tr>
<tr class="memdesc:a1471008a5db8291bf0d6dc17fb33f663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parts of the virtual address space that were allocated for new instructions.  <br /></td></tr>
<tr class="separator:a1471008a5db8291bf0d6dc17fb33f663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc9f912a1af3efb08585dfa014ef7a3" id="r_adcc9f912a1af3efb08585dfa014ef7a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adcc9f912a1af3efb08585dfa014ef7a3">replaceBlockInsns</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, size_t startIdx, size_t nInsns, std::vector&lt; uint8_t &gt; replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:adcc9f912a1af3efb08585dfa014ef7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace instructions in basic block.  <br /></td></tr>
<tr class="separator:adcc9f912a1af3efb08585dfa014ef7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9770d280f2fd5f30b014daec02117" id="r_af1d9770d280f2fd5f30b014daec02117"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#af1d9770d280f2fd5f30b014daec02117">replaceInsnsAtFront</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, size_t nInsns, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:af1d9770d280f2fd5f30b014daec02117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace instructions at front of basic block.  <br /></td></tr>
<tr class="separator:af1d9770d280f2fd5f30b014daec02117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedca33fa8c18cab5e3573d01b7ce66a" id="r_aaedca33fa8c18cab5e3573d01b7ce66a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aaedca33fa8c18cab5e3573d01b7ce66a">replaceInsnsAtBack</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, size_t nInsns, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:aaedca33fa8c18cab5e3573d01b7ce66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace instructions at back of basic block.  <br /></td></tr>
<tr class="separator:aaedca33fa8c18cab5e3573d01b7ce66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69ca03a7f018c2f2a15cba47d51b221" id="r_ad69ca03a7f018c2f2a15cba47d51b221"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad69ca03a7f018c2f2a15cba47d51b221">prependInsns</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:ad69ca03a7f018c2f2a15cba47d51b221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend code to a basic block.  <br /></td></tr>
<tr class="separator:ad69ca03a7f018c2f2a15cba47d51b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e20d72ae9349d972f6e22a898049d" id="r_a416e20d72ae9349d972f6e22a898049d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a416e20d72ae9349d972f6e22a898049d">appendInsns</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:a416e20d72ae9349d972f6e22a898049d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append code to a basic block.  <br /></td></tr>
<tr class="separator:a416e20d72ae9349d972f6e22a898049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1422566a9afb3c135e8bbcf02322c0" id="r_aee1422566a9afb3c135e8bbcf02322c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aee1422566a9afb3c135e8bbcf02322c0">replaceInsns</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;toReplace, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations=std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt;())</td></tr>
<tr class="memdesc:aee1422566a9afb3c135e8bbcf02322c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace exactly the specified instructions with some other encoding.  <br /></td></tr>
<tr class="separator:aee1422566a9afb3c135e8bbcf02322c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465867daa832f056804eb96fb8dcb505" id="r_a465867daa832f056804eb96fb8dcb505"><td class="memItemLeft" align="right" valign="top"><a id="a465867daa832f056804eb96fb8dcb505" name="a465867daa832f056804eb96fb8dcb505"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fillWithNops</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;where)</td></tr>
<tr class="memdesc:a465867daa832f056804eb96fb8dcb505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified memory with no-op instructions. <br /></td></tr>
<tr class="separator:a465867daa832f056804eb96fb8dcb505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3bb6c9d98399c0f07453f3d96e3007" id="r_a4e3bb6c9d98399c0f07453f3d96e3007"><td class="memItemLeft" align="right" valign="top"><a id="a4e3bb6c9d98399c0f07453f3d96e3007" name="a4e3bb6c9d98399c0f07453f3d96e3007"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fillWithRandom</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;where)</td></tr>
<tr class="memdesc:a4e3bb6c9d98399c0f07453f3d96e3007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified memory with random data. <br /></td></tr>
<tr class="separator:a4e3bb6c9d98399c0f07453f3d96e3007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420334a56b1fd0b35a5a05d89126eaf9" id="r_a420334a56b1fd0b35a5a05d89126eaf9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a420334a56b1fd0b35a5a05d89126eaf9">encodeJump</a> (rose_addr_t srcVa, rose_addr_t tgtVa)</td></tr>
<tr class="memdesc:a420334a56b1fd0b35a5a05d89126eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an unconditional branch.  <br /></td></tr>
<tr class="separator:a420334a56b1fd0b35a5a05d89126eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad449116bcfe94576f9b7b4845b5310b3" id="r_ad449116bcfe94576f9b7b4845b5310b3"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad449116bcfe94576f9b7b4845b5310b3">applyRelocations</a> (rose_addr_t startVa, std::vector&lt; uint8_t &gt; replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations, size_t relocStart, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;insnInfoMap)</td></tr>
<tr class="memdesc:ad449116bcfe94576f9b7b4845b5310b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply relocations to create a new encoding.  <br /></td></tr>
<tr class="separator:ad449116bcfe94576f9b7b4845b5310b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa356d6b49e1a9af0335378e72cd640b8" id="r_aa356d6b49e1a9af0335378e72cd640b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aa356d6b49e1a9af0335378e72cd640b8">allocateMemory</a> (size_t nBytes, rose_addr_t jmpTargetVa, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20">Commit::Boolean</a> commit=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20a4055dc49e2936aa5c563ac1301844b78">Commit::YES</a>)</td></tr>
<tr class="memdesc:aa356d6b49e1a9af0335378e72cd640b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate virtual memory in the partitioner memory map.  <br /></td></tr>
<tr class="separator:aa356d6b49e1a9af0335378e72cd640b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c596b483c6da62c90804505716a9f" id="r_a523c596b483c6da62c90804505716a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a523c596b483c6da62c90804505716a9f">commitAllocation</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;where, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20">Commit::Boolean</a> commit=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20a4055dc49e2936aa5c563ac1301844b78">Commit::YES</a>)</td></tr>
<tr class="memdesc:a523c596b483c6da62c90804505716a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html" title="Whether to commit memory allocations.">Commit</a> previous allocation.  <br /></td></tr>
<tr class="separator:a523c596b483c6da62c90804505716a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdc4694dd47c058fac8aa65c4e2f3b8" id="r_aabdc4694dd47c058fac8aa65c4e2f3b8"><td class="memItemLeft" align="right" valign="top"><a id="aabdc4694dd47c058fac8aa65c4e2f3b8" name="aabdc4694dd47c058fac8aa65c4e2f3b8"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instructionLocations</b> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:aabdc4694dd47c058fac8aa65c4e2f3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of functions, return all addresses that the instructions occupy. <br /></td></tr>
<tr class="separator:aabdc4694dd47c058fac8aa65c4e2f3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7312ea878204b21c7ed9f4a0cb2f7f" id="r_afa7312ea878204b21c7ed9f4a0cb2f7f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#afa7312ea878204b21c7ed9f4a0cb2f7f">replaceByOverwrite</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;toReplaceVas, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;entryInterval, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations, size_t relocStart, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;insnInfoMap)</td></tr>
<tr class="memdesc:afa7312ea878204b21c7ed9f4a0cb2f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new code by overwriting existing instructions.  <br /></td></tr>
<tr class="separator:afa7312ea878204b21c7ed9f4a0cb2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178009fd263a94ffc7941d3561dce6cd" id="r_a178009fd263a94ffc7941d3561dce6cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a178009fd263a94ffc7941d3561dce6cd">replaceByTransfer</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;toReplaceVas, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;entryInterval, const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;toReplace, const std::vector&lt; uint8_t &gt; &amp;replacement, const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;relocations, size_t relocStart, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;insnInfoMap)</td></tr>
<tr class="memdesc:a178009fd263a94ffc7941d3561dce6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new code in allocated area.  <br /></td></tr>
<tr class="separator:a178009fd263a94ffc7941d3561dce6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2704ec84549a73bcd444cf63c64cafc" id="r_ac2704ec84549a73bcd444cf63c64cafc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ac2704ec84549a73bcd444cf63c64cafc">computeInstructionInfoMap</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, size_t startIdx, size_t nDeleted)</td></tr>
<tr class="memdesc:ac2704ec84549a73bcd444cf63c64cafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain info about instructions for the basic block being modified.  <br /></td></tr>
<tr class="separator:ac2704ec84549a73bcd444cf63c64cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6c2374f1cbe142d95d0a9a3c3181f861" id="r_a6c2374f1cbe142d95d0a9a3c3181f861"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a6c2374f1cbe142d95d0a9a3c3181f861">chunkAllocationRegion</a> () const</td></tr>
<tr class="memdesc:a6c2374f1cbe142d95d0a9a3c3181f861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Where chunks are allocated.  <br /></td></tr>
<tr class="separator:a6c2374f1cbe142d95d0a9a3c3181f861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e07bf10281f0113f6ddaa605de3d79" id="r_a68e07bf10281f0113f6ddaa605de3d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a68e07bf10281f0113f6ddaa605de3d79">chunkAllocationRegion</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;i)</td></tr>
<tr class="memdesc:a68e07bf10281f0113f6ddaa605de3d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Where chunks are allocated.  <br /></td></tr>
<tr class="separator:a68e07bf10281f0113f6ddaa605de3d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9a5ab4a5793579e663f98b5b2d82baa4" id="r_a9a5ab4a5793579e663f98b5b2d82baa4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a9a5ab4a5793579e663f98b5b2d82baa4">mappedFreeSpace</a> () const</td></tr>
<tr class="memdesc:a9a5ab4a5793579e663f98b5b2d82baa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Mapped free-space chunks.  <br /></td></tr>
<tr class="separator:a9a5ab4a5793579e663f98b5b2d82baa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289776dc557fe946b3c50b1be1198e0" id="r_aa289776dc557fe946b3c50b1be1198e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aa289776dc557fe946b3c50b1be1198e0">mappedFreeSpace</a> ()</td></tr>
<tr class="memdesc:aa289776dc557fe946b3c50b1be1198e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Mapped free-space chunks.  <br /></td></tr>
<tr class="separator:aa289776dc557fe946b3c50b1be1198e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913c66ef519620e0a2346f03e20866ac" id="r_a913c66ef519620e0a2346f03e20866ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a913c66ef519620e0a2346f03e20866ac">mappedFreeSpace</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;x)</td></tr>
<tr class="memdesc:a913c66ef519620e0a2346f03e20866ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Mapped free-space chunks.  <br /></td></tr>
<tr class="separator:a913c66ef519620e0a2346f03e20866ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff25d113cbe9673b62937bc179ff0175" id="r_aff25d113cbe9673b62937bc179ff0175"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aff25d113cbe9673b62937bc179ff0175">minChunkAllocationSize</a> () const</td></tr>
<tr class="memdesc:aff25d113cbe9673b62937bc179ff0175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Minimum size of allocated chunks.  <br /></td></tr>
<tr class="separator:aff25d113cbe9673b62937bc179ff0175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cb69783e60a141bbc9169f4b56a8d9" id="r_a60cb69783e60a141bbc9169f4b56a8d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a60cb69783e60a141bbc9169f4b56a8d9">minChunkAllocationSize</a> (size_t n)</td></tr>
<tr class="memdesc:a60cb69783e60a141bbc9169f4b56a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Minimum size of allocated chunks.  <br /></td></tr>
<tr class="separator:a60cb69783e60a141bbc9169f4b56a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adf8ebb49127875ec88a54b335e1608fa" id="r_adf8ebb49127875ec88a54b335e1608fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adf8ebb49127875ec88a54b335e1608fa">chunkAllocationAlignment</a> () const</td></tr>
<tr class="memdesc:adf8ebb49127875ec88a54b335e1608fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for large allocated chunks.  <br /></td></tr>
<tr class="separator:adf8ebb49127875ec88a54b335e1608fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351d8495bf53af0c99e573b0db003624" id="r_a351d8495bf53af0c99e573b0db003624"><td class="memItemLeft" align="right" valign="top"><a id="a351d8495bf53af0c99e573b0db003624" name="a351d8495bf53af0c99e573b0db003624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>chunkAllocationAlignment</b> (size_t n)</td></tr>
<tr class="memdesc:a351d8495bf53af0c99e573b0db003624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for large allocated chunks. <br /></td></tr>
<tr class="separator:a351d8495bf53af0c99e573b0db003624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aba41f1ab6101262aa54cf7f9a99ec4e2" id="r_aba41f1ab6101262aa54cf7f9a99ec4e2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aba41f1ab6101262aa54cf7f9a99ec4e2">chunkAllocationName</a> () const</td></tr>
<tr class="memdesc:aba41f1ab6101262aa54cf7f9a99ec4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name for newly allocated regions of memory.  <br /></td></tr>
<tr class="separator:aba41f1ab6101262aa54cf7f9a99ec4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababcdce75df2512c78e77b0c700219e9" id="r_ababcdce75df2512c78e77b0c700219e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ababcdce75df2512c78e77b0c700219e9">chunkAllocationName</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ababcdce75df2512c78e77b0c700219e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name for newly allocated regions of memory.  <br /></td></tr>
<tr class="separator:ababcdce75df2512c78e77b0c700219e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2dfe46d189d172ea38e9ba7f2931b65b" id="r_a2dfe46d189d172ea38e9ba7f2931b65b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a2dfe46d189d172ea38e9ba7f2931b65b">aggregationDirection</a> () const</td></tr>
<tr class="memdesc:a2dfe46d189d172ea38e9ba7f2931b65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether additional instructions can be moved.  <br /></td></tr>
<tr class="separator:a2dfe46d189d172ea38e9ba7f2931b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a35fc712a93b089bdae6ddd87a1bb46" id="r_a0a35fc712a93b089bdae6ddd87a1bb46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a0a35fc712a93b089bdae6ddd87a1bb46">aggregationDirection</a> (unsigned d)</td></tr>
<tr class="memdesc:a0a35fc712a93b089bdae6ddd87a1bb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether additional instructions can be moved.  <br /></td></tr>
<tr class="separator:a0a35fc712a93b089bdae6ddd87a1bb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab614496a807038890a6b69b811213f23" id="r_ab614496a807038890a6b69b811213f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ab614496a807038890a6b69b811213f23">nopPadding</a> () const</td></tr>
<tr class="memdesc:ab614496a807038890a6b69b811213f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Where to add no-ops when padding.  <br /></td></tr>
<tr class="separator:ab614496a807038890a6b69b811213f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f93f6e2442c026ad8067719bd3879f" id="r_a26f93f6e2442c026ad8067719bd3879f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a26f93f6e2442c026ad8067719bd3879f">nopPadding</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a> p)</td></tr>
<tr class="memdesc:a26f93f6e2442c026ad8067719bd3879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Where to add no-ops when padding.  <br /></td></tr>
<tr class="separator:a26f93f6e2442c026ad8067719bd3879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a385e4d154055acbf327099c5ac541ec7" id="r_a385e4d154055acbf327099c5ac541ec7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a385e4d154055acbf327099c5ac541ec7">initDiagnostics</a> ()</td></tr>
<tr class="memdesc:a385e4d154055acbf327099c5ac541ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostic streams.  <br /></td></tr>
<tr class="separator:a385e4d154055acbf327099c5ac541ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a30c03f6cae2be0878ef71a32ef8c8146" id="r_a30c03f6cae2be0878ef71a32ef8c8146"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a30c03f6cae2be0878ef71a32ef8c8146">mlog</a></td></tr>
<tr class="memdesc:a30c03f6cae2be0878ef71a32ef8c8146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facility for emitting diagnostics.  <br /></td></tr>
<tr class="separator:a30c03f6cae2be0878ef71a32ef8c8146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae3f3ac34bd2f5275c15682a28c09ac32" id="r_ae3f3ac34bd2f5275c15682a28c09ac32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ae3f3ac34bd2f5275c15682a28c09ac32">partitioner_</a></td></tr>
<tr class="separator:ae3f3ac34bd2f5275c15682a28c09ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477578c15f915818e43e7e6e1486b2e8" id="r_a477578c15f915818e43e7e6e1486b2e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a477578c15f915818e43e7e6e1486b2e8">chunkAllocationRegion_</a></td></tr>
<tr class="separator:a477578c15f915818e43e7e6e1486b2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f0a2c64f2efad2e54646b37a2b54dc" id="r_a60f0a2c64f2efad2e54646b37a2b54dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a60f0a2c64f2efad2e54646b37a2b54dc">minChunkAllocationSize_</a></td></tr>
<tr class="separator:a60f0a2c64f2efad2e54646b37a2b54dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad687db5510ccc8328bdf249e29c47cd1" id="r_ad687db5510ccc8328bdf249e29c47cd1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad687db5510ccc8328bdf249e29c47cd1">chunkAllocationAlignment_</a></td></tr>
<tr class="separator:ad687db5510ccc8328bdf249e29c47cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b1123448a2be4915edbd75fe8dfbb" id="r_aa75b1123448a2be4915edbd75fe8dfbb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aa75b1123448a2be4915edbd75fe8dfbb">chunkAllocationName_</a></td></tr>
<tr class="separator:aa75b1123448a2be4915edbd75fe8dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb5941af3e16967901fec1e51600cda" id="r_a0bb5941af3e16967901fec1e51600cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a0bb5941af3e16967901fec1e51600cda">allocatedChunks_</a></td></tr>
<tr class="separator:a0bb5941af3e16967901fec1e51600cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7090d4e40b40c52922d49dfb9cda75c1" id="r_a7090d4e40b40c52922d49dfb9cda75c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a7090d4e40b40c52922d49dfb9cda75c1">freeSpace_</a></td></tr>
<tr class="separator:a7090d4e40b40c52922d49dfb9cda75c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8b0ed6ffdf7f3c36775f8ab3c4142a" id="r_acf8b0ed6ffdf7f3c36775f8ab3c4142a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#acf8b0ed6ffdf7f3c36775f8ab3c4142a">aggregationDirection_</a></td></tr>
<tr class="separator:acf8b0ed6ffdf7f3c36775f8ab3c4142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a84bf8524d8d323f20878bf0d3b2088" id="r_a4a84bf8524d8d323f20878bf0d3b2088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a4a84bf8524d8d323f20878bf0d3b2088">nopPadding_</a></td></tr>
<tr class="separator:a4a84bf8524d8d323f20878bf0d3b2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1c2368a6ecbe2231517b40d0ebb27d5a" name="a1c2368a6ecbe2231517b40d0ebb27d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2368a6ecbe2231517b40d0ebb27d5a">&#9670;&#160;</a></span>InstructionInfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;int, <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1InstructionInfo.html">InstructionInfo</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">Rose::BinaryAnalysis::CodeInserter::InstructionInfoMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about instructions within the basic block being modified. </p>
<p>The instructions are numbered relative to their position with the insertion point and deleted instructions. Negative keys refer to instructions that appear before the insertion point, and non-negative keys refer to instructions starting one past the last deleted instruction or, if no instructions are deleted, the instruction originally at the insertion point. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00145">145</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5e55e25fb70e6cdcaca3f2de3fc25e4f" name="a5e55e25fb70e6cdcaca3f2de3fc25e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e55e25fb70e6cdcaca3f2de3fc25e4f">&#9670;&#160;</a></span>AggregationDirection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4f">Rose::BinaryAnalysis::CodeInserter::AggregationDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What other instructions can be moved to make room. </p>
<p>These are bit flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e55e25fb70e6cdcaca3f2de3fc25e4fa3f311dbf274156da8dad45562d5276fb" name="a5e55e25fb70e6cdcaca3f2de3fc25e4fa3f311dbf274156da8dad45562d5276fb"></a>AGGREGATE_PREDECESSORS&#160;</td><td class="fielddoc"><p>Move preceding instructions in CFG. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e55e25fb70e6cdcaca3f2de3fc25e4fa0bbca926f3844788d3cf913c366e0c6c" name="a5e55e25fb70e6cdcaca3f2de3fc25e4fa0bbca926f3844788d3cf913c366e0c6c"></a>AGGREGATE_SUCCESSORS&#160;</td><td class="fielddoc"><p>Move succeeding instructions in CFG. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00029">29</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a8c8f0df9f2de216471130f90ce67f61d" name="a8c8f0df9f2de216471130f90ce67f61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8f0df9f2de216471130f90ce67f61d">&#9670;&#160;</a></span>NopPadding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">Rose::BinaryAnalysis::CodeInserter::NopPadding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How to pad with no-ops. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c8f0df9f2de216471130f90ce67f61daf6c3c213d6a1654a60359cb47ca12b08" name="a8c8f0df9f2de216471130f90ce67f61daf6c3c213d6a1654a60359cb47ca12b08"></a>PAD_NOP_BACK&#160;</td><td class="fielddoc"><p>Add no-ops to the end of replacements. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8f0df9f2de216471130f90ce67f61dac15b387cfa1df0814aa4d82f7484a5d6" name="a8c8f0df9f2de216471130f90ce67f61dac15b387cfa1df0814aa4d82f7484a5d6"></a>PAD_NOP_FRONT&#160;</td><td class="fielddoc"><p>Add no-ops to the front of replacements. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c8f0df9f2de216471130f90ce67f61dabcf44f2be0d29c4000e56c022724d04a" name="a8c8f0df9f2de216471130f90ce67f61dabcf44f2be0d29c4000e56c022724d04a"></a>PAD_RANDOM_BACK&#160;</td><td class="fielddoc"><p>Add random data to the end of replacements. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00035">35</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="ad20b82d2d88881de074a41808872b103" name="ad20b82d2d88881de074a41808872b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20b82d2d88881de074a41808872b103">&#9670;&#160;</a></span>RelocType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ad20b82d2d88881de074a41808872b103">Rose::BinaryAnalysis::CodeInserter::RelocType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of relocation to perform. </p>
<p>Each enum constant identifies a function whose description is given below. In those descriptions, the following variables are used:</p>
<ul>
<li><code>input</code> is a vector of bytes that was specified by the user as the new code to be inserted.</li>
</ul>
<ul>
<li><code>reloc_value</code> is the value data member of the relocation record. It has various interpretations depending on the relocation function.</li>
</ul>
<ul>
<li>@ addend is the value currerntly stored at the destination bytes of the input interpretted as a signed value in the byte order and width specified by the function name.</li>
</ul>
<p>The last word of the function name specifies the format used to write the computed value back to the output:</p>
<ul>
<li><code>LE32</code> writes the low-order 32 bits of the computed value as a 32-bit integer in little-endian order.</li>
</ul>
<ul>
<li><code>LE32HI</code> writes the high-order 32 bits of the computed value as a 32-bit integer in little-endian order. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103a11133d481e3ad918ed8055b512e8a8ab" name="ad20b82d2d88881de074a41808872b103a11133d481e3ad918ed8055b512e8a8ab"></a>RELOC_INDEX_ABS_LE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an index of some byte in the <code>input</code>, and computes that byte's virtual address. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103a077b7af4fc47b6142ac6cbd0a19619cf" name="ad20b82d2d88881de074a41808872b103a077b7af4fc47b6142ac6cbd0a19619cf"></a>RELOC_INDEX_ABS_LE32HI&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an index of some byte in the <code>input</code>, and computes that byte's virtual address. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103aa69bc36e88956e09764aefdf308d8bf2" name="ad20b82d2d88881de074a41808872b103aa69bc36e88956e09764aefdf308d8bf2"></a>RELOC_INDEX_ABS_BE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an index of some byte in the <code>input</code>, and computes that byte's virtual address. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103aa267b543851282ab2325979679d5d65a" name="ad20b82d2d88881de074a41808872b103aa267b543851282ab2325979679d5d65a"></a>RELOC_ADDR_REL_LE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as a virtual address and computes the offset from the output virtual address to that specified virtual address, adjusted with the addend. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103a8df47c70429ebac4d54b9be9ba15877c" name="ad20b82d2d88881de074a41808872b103a8df47c70429ebac4d54b9be9ba15877c"></a>RELOC_ADDR_REL_BE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as a virtual address and computes the offset from the output virtual address to that specified virtual address, adjusted with the addend. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103aaaae609ba1503a23e343c90e9c5737bb" name="ad20b82d2d88881de074a41808872b103aaaae609ba1503a23e343c90e9c5737bb"></a>RELOC_INSN_ABS_LE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an instruction relative index for some instruction of the original basic block. </p>
<p>Negative indexes are measured backward from the insertion point, and non-negative indexes are measured forward from one past the last deleted instruction (or insertion point if no deletions). This relocation function calculates the address of the specified instruction. This accounts for cases when the referenced instruction has been moved. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103abdfef0adbd8df9435577061728c6aaf5" name="ad20b82d2d88881de074a41808872b103abdfef0adbd8df9435577061728c6aaf5"></a>RELOC_INSN_REL_LE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an instruction relative index for some instruction of the original basic block. </p>
<p>Negative indexes are measured backward from the insertion point, and non-negative indexes are measured forward from one past the last deleted instruction (or insertion point if no deletions). This relocation function calculates the offset from the output virtual address to that instructions virtual address, adjusted with the addend. This accounts for cases when the referenced instruction has been moved. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad20b82d2d88881de074a41808872b103aff2b61ceb1e3a111ac3cd0ae3fa589b2" name="ad20b82d2d88881de074a41808872b103aff2b61ceb1e3a111ac3cd0ae3fa589b2"></a>RELOC_INSN_REL_BE32&#160;</td><td class="fielddoc"><p>Interprets the <code>reloc_value</code> as an instruction relative index for some instruction of the original basic block. </p>
<p>Negative indexes are measured backward from the insertion point, and non-negative indexes are measured forward from one past the last deleted instruction (or insertion point if no deletions). This relocation function calculates the offset from the output virtual address to that instructions virtual address, adjusted with the addend. This accounts for cases when the referenced instruction has been moved. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00059">59</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a385e4d154055acbf327099c5ac541ec7" name="a385e4d154055acbf327099c5ac541ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385e4d154055acbf327099c5ac541ec7">&#9670;&#160;</a></span>initDiagnostics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::CodeInserter::initDiagnostics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize diagnostic streams. </p>
<p>This is called automatically by <a class="el" href="namespaceRose_1_1Diagnostics.html#af73708983cca75ce5a3bb8f9928b6e2c">Rose::Diagnostics::initialize</a>. </p>

</div>
</div>
<a id="a6c2374f1cbe142d95d0a9a3c3181f861" name="a6c2374f1cbe142d95d0a9a3c3181f861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2374f1cbe142d95d0a9a3c3181f861">&#9670;&#160;</a></span>chunkAllocationRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp; Rose::BinaryAnalysis::CodeInserter::chunkAllocationRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Where chunks are allocated. </p>
<p>This region defines the part of the memory map where new free space chunks will be mapped in order to hold replacement code that doesn't fit into the same space as the instructions its replacing. The default is the part of the address space immediately after the last mapped address in the partitioner passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00178">178</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a68e07bf10281f0113f6ddaa605de3d79" name="a68e07bf10281f0113f6ddaa605de3d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e07bf10281f0113f6ddaa605de3d79">&#9670;&#160;</a></span>chunkAllocationRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::chunkAllocationRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Where chunks are allocated. </p>
<p>This region defines the part of the memory map where new free space chunks will be mapped in order to hold replacement code that doesn't fit into the same space as the instructions its replacing. The default is the part of the address space immediately after the last mapped address in the partitioner passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00179">179</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a9a5ab4a5793579e663f98b5b2d82baa4" name="a9a5ab4a5793579e663f98b5b2d82baa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5ab4a5793579e663f98b5b2d82baa4">&#9670;&#160;</a></span>mappedFreeSpace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp; Rose::BinaryAnalysis::CodeInserter::mappedFreeSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Mapped free-space chunks. </p>
<p>This is the set of mapped regions that are considered to be free space. The allocator will prefer to obtain memory from these already mapped regions before it tries to map additional free chunks within the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a6c2374f1cbe142d95d0a9a3c3181f861">chunkAllocationRegion</a>. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00188">188</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="aa289776dc557fe946b3c50b1be1198e0" name="aa289776dc557fe946b3c50b1be1198e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289776dc557fe946b3c50b1be1198e0">&#9670;&#160;</a></span>mappedFreeSpace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp; Rose::BinaryAnalysis::CodeInserter::mappedFreeSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Mapped free-space chunks. </p>
<p>This is the set of mapped regions that are considered to be free space. The allocator will prefer to obtain memory from these already mapped regions before it tries to map additional free chunks within the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a6c2374f1cbe142d95d0a9a3c3181f861">chunkAllocationRegion</a>. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00189">189</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a913c66ef519620e0a2346f03e20866ac" name="a913c66ef519620e0a2346f03e20866ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913c66ef519620e0a2346f03e20866ac">&#9670;&#160;</a></span>mappedFreeSpace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::mappedFreeSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Mapped free-space chunks. </p>
<p>This is the set of mapped regions that are considered to be free space. The allocator will prefer to obtain memory from these already mapped regions before it tries to map additional free chunks within the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a6c2374f1cbe142d95d0a9a3c3181f861">chunkAllocationRegion</a>. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00190">190</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a1471008a5db8291bf0d6dc17fb33f663" name="a1471008a5db8291bf0d6dc17fb33f663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1471008a5db8291bf0d6dc17fb33f663">&#9670;&#160;</a></span>allocatedChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp; Rose::BinaryAnalysis::CodeInserter::allocatedChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parts of the virtual address space that were allocated for new instructions. </p>
<p>The returned value will be a subset of the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a6c2374f1cbe142d95d0a9a3c3181f861">chunkAllocationRegion</a>. The return value indicates where large chunks of memory were allocated, but not what bytes within that memory were actually used for new instructions. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00196">196</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="aff25d113cbe9673b62937bc179ff0175" name="aff25d113cbe9673b62937bc179ff0175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff25d113cbe9673b62937bc179ff0175">&#9670;&#160;</a></span>minChunkAllocationSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CodeInserter::minChunkAllocationSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Minimum size of allocated chunks. </p>
<p>When allocating space for replacement code, never allocate less than this many bytes at a time. Note that multiple replacement codes can be written to a single chunk since we maintain a free list within chunks. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00204">204</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a60cb69783e60a141bbc9169f4b56a8d9" name="a60cb69783e60a141bbc9169f4b56a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cb69783e60a141bbc9169f4b56a8d9">&#9670;&#160;</a></span>minChunkAllocationSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::minChunkAllocationSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Minimum size of allocated chunks. </p>
<p>When allocating space for replacement code, never allocate less than this many bytes at a time. Note that multiple replacement codes can be written to a single chunk since we maintain a free list within chunks. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00205">205</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="adf8ebb49127875ec88a54b335e1608fa" name="adf8ebb49127875ec88a54b335e1608fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8ebb49127875ec88a54b335e1608fa">&#9670;&#160;</a></span>chunkAllocationAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CodeInserter::chunkAllocationAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for large allocated chunks. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00211">211</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="aba41f1ab6101262aa54cf7f9a99ec4e2" name="aba41f1ab6101262aa54cf7f9a99ec4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba41f1ab6101262aa54cf7f9a99ec4e2">&#9670;&#160;</a></span>chunkAllocationName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::CodeInserter::chunkAllocationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Name for newly allocated regions of memory. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00218">218</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="ababcdce75df2512c78e77b0c700219e9" name="ababcdce75df2512c78e77b0c700219e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababcdce75df2512c78e77b0c700219e9">&#9670;&#160;</a></span>chunkAllocationName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::chunkAllocationName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Name for newly allocated regions of memory. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00219">219</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a2dfe46d189d172ea38e9ba7f2931b65b" name="a2dfe46d189d172ea38e9ba7f2931b65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfe46d189d172ea38e9ba7f2931b65b">&#9670;&#160;</a></span>aggregationDirection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Rose::BinaryAnalysis::CodeInserter::aggregationDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether additional instructions can be moved. </p>
<p>This property controls which additional instructions can be moved by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adcc9f912a1af3efb08585dfa014ef7a3">replaceBlockInsns</a> method in order to make room for the replacement. It is a bit vector of <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4f">AggregationDirection</a> bits and defaults to both successors and predecessors. When both are present, successors are added first (all the way to the end of the block) and then predecessors are also added (all the way to the beginning of the block). </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00230">230</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a0a35fc712a93b089bdae6ddd87a1bb46" name="a0a35fc712a93b089bdae6ddd87a1bb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a35fc712a93b089bdae6ddd87a1bb46">&#9670;&#160;</a></span>aggregationDirection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::aggregationDirection </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether additional instructions can be moved. </p>
<p>This property controls which additional instructions can be moved by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adcc9f912a1af3efb08585dfa014ef7a3">replaceBlockInsns</a> method in order to make room for the replacement. It is a bit vector of <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a5e55e25fb70e6cdcaca3f2de3fc25e4f">AggregationDirection</a> bits and defaults to both successors and predecessors. When both are present, successors are added first (all the way to the end of the block) and then predecessors are also added (all the way to the beginning of the block). </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00231">231</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="ab614496a807038890a6b69b811213f23" name="ab614496a807038890a6b69b811213f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab614496a807038890a6b69b811213f23">&#9670;&#160;</a></span>nopPadding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a> Rose::BinaryAnalysis::CodeInserter::nopPadding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Where to add no-ops when padding. </p>
<p>When to-be-replaced instructions are overwritten with a replacement and the replacement is smaller than the replaced instructions, then the replacement is padded with no-op instructions according to this property. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00240">240</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a26f93f6e2442c026ad8067719bd3879f" name="a26f93f6e2442c026ad8067719bd3879f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f93f6e2442c026ad8067719bd3879f">&#9670;&#160;</a></span>nopPadding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::nopPadding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Where to add no-ops when padding. </p>
<p>When to-be-replaced instructions are overwritten with a replacement and the replacement is smaller than the replaced instructions, then the replacement is padded with no-op instructions according to this property. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00241">241</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="adcc9f912a1af3efb08585dfa014ef7a3" name="adcc9f912a1af3efb08585dfa014ef7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc9f912a1af3efb08585dfa014ef7a3">&#9670;&#160;</a></span>replaceBlockInsns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::replaceBlockInsns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInsns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace instructions in basic block. </p>
<p>This replaces <code>nInsns</code> instructions in the basic block starting at instruction number <code>startIdx</code>. The <code>nInsns</code> may be zero, in which case the replacement is inserted before the <code>startIdx</code> instruction. The new code is inserted either by overwriting the to-be-replaced instructions with the <code>replacement</code> padded at the end by no-ops if necessary (so called "overwrite" mode), or the replacement is written to some other part of the address space and unconditional branches are inserted to branch to the replacement and then back again (so called "branch-aside" mode).</p>
<p>If the neither the replacement (in overwrite mode) nor the unconditional branch (in branch-aside mode) fit in the area vacated by the to-be-replaced instructions, then the to-be-replaced instructions are extended by moving a neighboring instruction into the <code>replacement</code>. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a2dfe46d189d172ea38e9ba7f2931b65b">aggregationDirection</a> property controls which instructions can be joined. This often works for branch-aside mode, but can even sometimes work for overwrite mode if the basic block instructions are not executed in address order. The overwrite situation can work when a subsequent or earlier instruction fills in a hole in the to-be-replaced address set.</p>
<p>This method assumes that the <code>replacement</code> is entered at the first byte and exits to one past the last byte. Since some instruction encodings depend on the location of the replacement in virtual memory, the <code>relocations</code> can be used to patch the replacement as it's written to memory.</p>
<p>Inserting code in this manner is not without risk. For instance, enlarging the to-be-replaced set might mean that additional instructions are moved to a different address without changing their encoding. Examples are moving instructions that reference global variables relative to the instruction's address, branches that span the branch-aside gap, etc.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="af1d9770d280f2fd5f30b014daec02117" name="af1d9770d280f2fd5f30b014daec02117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d9770d280f2fd5f30b014daec02117">&#9670;&#160;</a></span>replaceInsnsAtFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::CodeInserter::replaceInsnsAtFront </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInsns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace instructions at front of basic block. </p>
<p>This is just a convenience for <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adcc9f912a1af3efb08585dfa014ef7a3">replaceBlockInsns</a> that replaces <code>nInsns</code> instructions at the beginning of the specified basic block. If <code>nInsns</code> is zero, then the <code>replacement</code> is inserted at the front of the basic block without removing any instructions. </p>

</div>
</div>
<a id="aaedca33fa8c18cab5e3573d01b7ce66a" name="aaedca33fa8c18cab5e3573d01b7ce66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedca33fa8c18cab5e3573d01b7ce66a">&#9670;&#160;</a></span>replaceInsnsAtBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::replaceInsnsAtBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInsns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace instructions at back of basic block. </p>
<p>This is just a convenience for <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#adcc9f912a1af3efb08585dfa014ef7a3">replaceBlockInsns</a> that replaces <code>nInsns</code> instructions at the end of the specified basic block. If <code>nInsns</code> is zero, then the <code>replacement</code> is appended to the end of the basic block without removing any instructions. </p>

</div>
</div>
<a id="ad69ca03a7f018c2f2a15cba47d51b221" name="ad69ca03a7f018c2f2a15cba47d51b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69ca03a7f018c2f2a15cba47d51b221">&#9670;&#160;</a></span>prependInsns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::prependInsns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend code to a basic block. </p>
<p>This is a convenience for <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#af1d9770d280f2fd5f30b014daec02117">replaceInsnsAtFront</a>. It inserts the <code>replacement</code> at the front of the basic block by writing the <code>replacement</code> followed by the first instruction(s) of the block to some other area of memory, overwriting the first part of the basic block with an unconditional branch to the replacement, and following the replacement with an unconditional branch back to the rest of the basic block. </p>

</div>
</div>
<a id="a416e20d72ae9349d972f6e22a898049d" name="a416e20d72ae9349d972f6e22a898049d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e20d72ae9349d972f6e22a898049d">&#9670;&#160;</a></span>appendInsns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::appendInsns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append code to a basic block. </p>
<p>This is a convenience for <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aaedca33fa8c18cab5e3573d01b7ce66a">replaceInsnsAtBack</a>. It appends the <code>replacement</code> to the end of the basic block by moving the last instruction(s) of the block to some other memory followed by the replacement. The original final instructions are overwritten with an unconditional branch to that other memory, which is followed by a branch back to the rest of the basic block. </p>

</div>
</div>
<a id="aee1422566a9afb3c135e8bbcf02322c0" name="aee1422566a9afb3c135e8bbcf02322c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1422566a9afb3c135e8bbcf02322c0">&#9670;&#160;</a></span>replaceInsns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::replaceInsns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>toReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em> = <code>std::vector&lt;&#160;<a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace exactly the specified instructions with some other encoding. </p>
<p>The <code>replacement</code> instructions either overwrite the <code>toReplace</code> instructions or the <code>replacement</code> is written to a newly allocated area and unconditional branches connect it to the main control flow. The assumption is that control flow enters at the beginning of <code>toReplace</code> and the replacement will exit to the first address after the last instruction in <code>toReplace</code>. Likewise, control enters at the beginning of <code>replacement</code> and exits to the first address after the end of the <code>replacement</code>.</p>
<p>If <code>relocations</code> are specified, then parts of the <code>replacement</code> are rewritten based on its final address. <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html" title="Relocation record.">Relocation</a> records that refer to instructions rather than bytes are not permitted since this function doesn't have access to the basic block in which the replacement is occuring.</p>
<p>Returns true if the replacement could be inserted, false otherwise. The only time this returns false is when the addresses of the original instructions starting with the first instruction do not occupy a contiguous region of memory large enough to hold either the replacement or a jump to the relocated replacement. This algorithm correctly handles the general case when the <code>toReplace</code> instructions are not in address order or are not contiguous. </p>

</div>
</div>
<a id="a420334a56b1fd0b35a5a05d89126eaf9" name="a420334a56b1fd0b35a5a05d89126eaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420334a56b1fd0b35a5a05d89126eaf9">&#9670;&#160;</a></span>encodeJump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; uint8_t &gt; Rose::BinaryAnalysis::CodeInserter::encodeJump </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>srcVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>tgtVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode an unconditional branch. </p>
<p>This encodes an unconditional branch instruction at <code>srcVa</code> that causes control to flow to <code>tgtVa</code>. The caller should not assume that a particular size encoding will be returned. E.g., on x86, jumps to targets that are further away require more bytes to encode than jumps to nearby targets. </p>

</div>
</div>
<a id="ad449116bcfe94576f9b7b4845b5310b3" name="ad449116bcfe94576f9b7b4845b5310b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad449116bcfe94576f9b7b4845b5310b3">&#9670;&#160;</a></span>applyRelocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; uint8_t &gt; Rose::BinaryAnalysis::CodeInserter::applyRelocations </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>relocStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>insnInfoMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply relocations to create a new encoding. </p>
<p>The <code>relocations</code> are applied to the <code>replacement</code> bytes which are assumed to be mapped in virtual memory starting at <code>startVa</code>. The <code>relocStart</code> is a byte offset for all the relocations; i.e., the actual offset in the <code>replacement</code> where the relocation is applied is the relocation's offset plus the <code>relocStart</code> value. </p>

</div>
</div>
<a id="aa356d6b49e1a9af0335378e72cd640b8" name="aa356d6b49e1a9af0335378e72cd640b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa356d6b49e1a9af0335378e72cd640b8">&#9670;&#160;</a></span>allocateMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::CodeInserter::allocateMemory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>jmpTargetVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20">Commit::Boolean</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20a4055dc49e2936aa5c563ac1301844b78">Commit::YES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate virtual memory in the partitioner memory map. </p>
<p>The second argument is the target address of an unconditional jump that will be added to the end of the allocated memory but which is not included in the <code>nBytes</code> argument (it is however included in the return value).</p>
<p>If the third argument is yes, then memory is actually allocated and removed from the free list. If no, then all steps are completed except removing it from the free list. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a523c596b483c6da62c90804505716a9f">commitAllocation</a> function can be called later to remove it from the free list. If you don't remove it from the free list, a subsequent allocation request might return the same addresses. </p>

</div>
</div>
<a id="a523c596b483c6da62c90804505716a9f" name="a523c596b483c6da62c90804505716a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523c596b483c6da62c90804505716a9f">&#9670;&#160;</a></span>commitAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CodeInserter::commitAllocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20">Commit::Boolean</a>&#160;</td>
          <td class="paramname"><em>commit</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html#a6a0e84b47cfc2f0878bf9b0bc97edc20a4055dc49e2936aa5c563ac1301844b78">Commit::YES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Commit.html" title="Whether to commit memory allocations.">Commit</a> previous allocation. </p>
<p>This commits the allocation returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aa356d6b49e1a9af0335378e72cd640b8">allocateMemory</a> by removing it from the free list (if the <code>commit</code> argument is true). We do this as a separate step from the allocation so that we don't have to deallocate in all the error handling locations. Failing to commit an allocation will be easier to spot than failing to release an unused block because the former case causes nonsense disassembly whereas the latter looks like either unreachable code or static data. </p>

</div>
</div>
<a id="afa7312ea878204b21c7ed9f4a0cb2f7f" name="afa7312ea878204b21c7ed9f4a0cb2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7312ea878204b21c7ed9f4a0cb2f7f">&#9670;&#160;</a></span>replaceByOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::replaceByOverwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>toReplaceVas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>entryInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>relocStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>insnInfoMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new code by overwriting existing instructions. </p>
<p>The <code>toReplaceVas</code> are the addresses occupied by the to-be-replaced instructions. Since the to-be-replaced instructions are not necessarily in address order or contiguous, the <code>entryInterval</code> describes the largest contiguous subset of <code>toReplaceVas</code> starting at the entry address. Since the <code>replacement</code> is assumed to be entered at its first byte, the <code>replacement</code> will be written into the <code>entryInterval</code> (if it fits). The <code>replacement</code> is padded if necessary according to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#ab614496a807038890a6b69b811213f23">nopPadding</a> property. All other addresses in <code>toReplaceVas</code> are filled with no-op instructions. </p>

</div>
</div>
<a id="a178009fd263a94ffc7941d3561dce6cd" name="a178009fd263a94ffc7941d3561dce6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178009fd263a94ffc7941d3561dce6cd">&#9670;&#160;</a></span>replaceByTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::CodeInserter::replaceByTransfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>toReplaceVas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>entryInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>toReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1CodeInserter_1_1Relocation.html">Relocation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>relocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>relocStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>insnInfoMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new code in allocated area. </p>
<p>This inserts the <code>replacement</code> code in a newly allocated area (by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#aa356d6b49e1a9af0335378e72cd640b8">allocateMemory</a>). The <code>toReplaceVas</code> are the addresses of all the instruction bytes that are to be replaced. Note that this is all addresses of the instructions, not just the first addresses. The <code>entryInterval</code> is a contiguous subset of <code>toReplaceVas</code> and represents the entry point of <code>toReplaceVas</code> and as many subsequent contiguous addresses as possible. This function writes an unconditional branch in the <code>entryInterval</code> (padding it with no-ops according to <code>nopPadding</code>) that jumps to the replacement code. It appends an unconditional branch to the end of the replacement that jumps to the first address after the end of the <code>toReplaceVas</code>. All other bytes of <code>toReplaceVas</code> are overwritten with no-ops. </p>

</div>
</div>
<a id="ac2704ec84549a73bcd444cf63c64cafc" name="ac2704ec84549a73bcd444cf63c64cafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2704ec84549a73bcd444cf63c64cafc">&#9670;&#160;</a></span>computeInstructionInfoMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> Rose::BinaryAnalysis::CodeInserter::computeInstructionInfoMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDeleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain info about instructions for the basic block being modified. </p>
<p>Given a basic block, an insertion point, and the number of instructions that will be deleted starting at that insertion point, return information about the remaining instructions. See documentation for <a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a1c2368a6ecbe2231517b40d0ebb27d5a">InstructionInfoMap</a> for details about how the instructions are indexed in this map. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae3f3ac34bd2f5275c15682a28c09ac32" name="ae3f3ac34bd2f5275c15682a28c09ac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f3ac34bd2f5275c15682a28c09ac32">&#9670;&#160;</a></span>partitioner_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> Rose::BinaryAnalysis::CodeInserter::partitioner_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00148">148</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a477578c15f915818e43e7e6e1486b2e8" name="a477578c15f915818e43e7e6e1486b2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477578c15f915818e43e7e6e1486b2e8">&#9670;&#160;</a></span>chunkAllocationRegion_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::CodeInserter::chunkAllocationRegion_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00149">149</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a60f0a2c64f2efad2e54646b37a2b54dc" name="a60f0a2c64f2efad2e54646b37a2b54dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f0a2c64f2efad2e54646b37a2b54dc">&#9670;&#160;</a></span>minChunkAllocationSize_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CodeInserter::minChunkAllocationSize_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00150">150</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="ad687db5510ccc8328bdf249e29c47cd1" name="ad687db5510ccc8328bdf249e29c47cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad687db5510ccc8328bdf249e29c47cd1">&#9670;&#160;</a></span>chunkAllocationAlignment_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CodeInserter::chunkAllocationAlignment_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00151">151</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="aa75b1123448a2be4915edbd75fe8dfbb" name="aa75b1123448a2be4915edbd75fe8dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b1123448a2be4915edbd75fe8dfbb">&#9670;&#160;</a></span>chunkAllocationName_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::CodeInserter::chunkAllocationName_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00152">152</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a0bb5941af3e16967901fec1e51600cda" name="a0bb5941af3e16967901fec1e51600cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb5941af3e16967901fec1e51600cda">&#9670;&#160;</a></span>allocatedChunks_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::CodeInserter::allocatedChunks_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00153">153</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a7090d4e40b40c52922d49dfb9cda75c1" name="a7090d4e40b40c52922d49dfb9cda75c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7090d4e40b40c52922d49dfb9cda75c1">&#9670;&#160;</a></span>freeSpace_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::CodeInserter::freeSpace_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00154">154</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="acf8b0ed6ffdf7f3c36775f8ab3c4142a" name="acf8b0ed6ffdf7f3c36775f8ab3c4142a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8b0ed6ffdf7f3c36775f8ab3c4142a">&#9670;&#160;</a></span>aggregationDirection_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Rose::BinaryAnalysis::CodeInserter::aggregationDirection_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00155">155</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a4a84bf8524d8d323f20878bf0d3b2088" name="a4a84bf8524d8d323f20878bf0d3b2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a84bf8524d8d323f20878bf0d3b2088">&#9670;&#160;</a></span>nopPadding_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CodeInserter.html#a8c8f0df9f2de216471130f90ce67f61d">NopPadding</a> Rose::BinaryAnalysis::CodeInserter::nopPadding_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00156">156</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<a id="a30c03f6cae2be0878ef71a32ef8c8146" name="a30c03f6cae2be0878ef71a32ef8c8146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c03f6cae2be0878ef71a32ef8c8146">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Rose::BinaryAnalysis::CodeInserter::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Facility for emitting diagnostics. </p>

<p class="definition">Definition at line <a class="el" href="CodeInserter_8h_source.html#l00160">160</a> of file <a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CodeInserter_8h_source.html">CodeInserter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
