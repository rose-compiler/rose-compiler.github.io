<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::SymbolicExpression Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html">SymbolicExpression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::SymbolicExpression Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Namespace supplying types and functions for symbolic expressions. </p>
<p>These are used by certain instruction semantics policies and satisfiability modulo theory (SMT) solvers. These expressions are tailored to bit-vector and integer difference logics, whereas the expression nodes in other parts of ROSE have different goals. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1TypeStyle" id="r_namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1TypeStyle"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1TypeStyle.html">TypeStyle</a></td></tr>
<tr class="memdesc:namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1TypeStyle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to use abbreviated or full output. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1AddSimplifier.html">AddSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1AndSimplifier.html">AndSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1AsrSimplifier.html">AsrSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ConcatSimplifier.html">ConcatSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ConvertSimplifier.html">ConvertSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1EqSimplifier.html">EqSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptions for symbolic expressions.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExpressionLessp.html">ExpressionLessp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions for STL containers.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExpressionLessp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from expression to expression.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMapCompare.html">ExprExprHashMapCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMapHasher.html">ExprExprHashMapHasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExtractSimplifier.html">ExtractSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls formatting of expression trees when printing.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node of an expression tree for instruction semantics.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1InvertSimplifier.html">InvertSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1IteSimplifier.html">IteSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> node of an expression tree for instruction semantics.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1LssbSimplifier.html">LssbSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1MssbSimplifier.html">MssbSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1NegateSimplifier.html">NegateSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for symbolic expression nodes.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1NoopSimplifier.html">NoopSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1OrSimplifier.html">OrSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ReinterpretSimplifier.html">ReinterpretSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1RolSimplifier.html">RolSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1RorSimplifier.html">RorSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SdivSimplifier.html">SdivSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SetSimplifier.html">SetSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SextendSimplifier.html">SextendSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SgeSimplifier.html">SgeSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SgtSimplifier.html">SgtSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ShiftSimplifier.html">ShiftSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ShlSimplifier.html">ShlSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ShrSimplifier.html">ShrSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html">Simplifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator-specific simplification methods.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SleSimplifier.html">SleSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SltSimplifier.html">SltSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SmodSimplifier.html">SmodSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1SmulSimplifier.html">SmulSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html" title="Type of symbolic expression.">Type</a> of symbolic expression.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UdivSimplifier.html">UdivSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UextendSimplifier.html">UextendSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UgeSimplifier.html">UgeSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UgtSimplifier.html">UgtSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UleSimplifier.html">UleSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UltSimplifier.html">UltSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UmodSimplifier.html">UmodSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1UmulSimplifier.html">UmulSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for visiting nodes during expression traversal.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1XorSimplifier.html">XorSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ZeropSimplifier.html">ZeropSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a259906bede9e5aba6e7e09400d5cd481" id="r_a259906bede9e5aba6e7e09400d5cd481"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a> &gt;</td></tr>
<tr class="memdesc:a259906bede9e5aba6e7e09400d5cd481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:a259906bede9e5aba6e7e09400d5cd481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d5bbc5fcd4c7d776264c9c83b804e5" id="r_ae9d5bbc5fcd4c7d776264c9c83b804e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a> &gt;</td></tr>
<tr class="memdesc:ae9d5bbc5fcd4c7d776264c9c83b804e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:ae9d5bbc5fcd4c7d776264c9c83b804e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357a1787c84ab11ac04ffa566345e57c" id="r_a357a1787c84ab11ac04ffa566345e57c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> &gt;</td></tr>
<tr class="memdesc:a357a1787c84ab11ac04ffa566345e57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:a357a1787c84ab11ac04ffa566345e57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a9738645925dedda68638d9cab3369" id="r_a07a9738645925dedda68638d9cab3369"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a07a9738645925dedda68638d9cab3369">Nodes</a> = std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt;</td></tr>
<tr class="separator:a07a9738645925dedda68638d9cab3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daaf63033de03062e2418ee317be7f6" id="r_a0daaf63033de03062e2418ee317be7f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a0daaf63033de03062e2418ee317be7f6">RenameMap</a> = <a class="el" href="classMap.html">Map</a>&lt; uint64_t, uint64_t &gt;</td></tr>
<tr class="separator:a0daaf63033de03062e2418ee317be7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fee57f9f5e5cd95ab678fd2853d7735" id="r_a2fee57f9f5e5cd95ab678fd2853d7735"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a> = uint64_t</td></tr>
<tr class="memdesc:a2fee57f9f5e5cd95ab678fd2853d7735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash of symbolic expression.  <br /></td></tr>
<tr class="separator:a2fee57f9f5e5cd95ab678fd2853d7735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38f38d6cc7e0cbe6264711af79f7a5" id="r_a3b38f38d6cc7e0cbe6264711af79f7a5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExpressionLessp.html">ExpressionLessp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a3b38f38d6cc7e0cbe6264711af79f7a5">ExpressionSet</a></td></tr>
<tr class="memdesc:a3b38f38d6cc7e0cbe6264711af79f7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of expressions ordered by hash.  <br /></td></tr>
<tr class="separator:a3b38f38d6cc7e0cbe6264711af79f7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7a317419dcb8e9c29864a71d6bbe90b2" id="r_a7a317419dcb8e9c29864a71d6bbe90b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ad0a99911efbdde5f3323aaacb89c2f1c">OP_ADD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2abba92edf9ea6219ea36f8c202e1669ea">OP_AND</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a647aa826d1ade4d51bfd640daaa570f7">OP_ASR</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a01b202f8dd18ef1e7d46fa77a69506d8">OP_CONCAT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a017db9797ab52e01e8b0482e6dd231a8">OP_EQ</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a19b87e44a74f9bcafd2c46960817b33f">OP_EXTRACT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aa2d069e2a1eaa9c27b56458af3d4289e">OP_INVERT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a8f5091ed5bd7ce53f99ea7f81bf7263d">OP_ITE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a89e9065691a4661624bb9324fc2439a5">OP_LET</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a4b68d350d7af82cdf5f1d244814a4f86">OP_LSSB</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a9f16dfdbebc4c5ea8e08bb4b6f1c480e">OP_MSSB</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ace8f525d5ea8c2ab7121abebc13d0d7f">OP_NE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aa9a8f75b5b542567633076dc88401026">OP_NEGATE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a43d403c95f2848c831e25fddcb9ecbc2">OP_NOOP</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a0528f5a1d1a617ae9e4eb5197d3b9bfc">OP_OR</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a592c9db0511c68b9afb11afd9f4ae7bc">OP_READ</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2af9cebc886215e76b6d7ada476b25844d">OP_ROL</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a8ef1a3da7f741750781fd6c3fcca27a9">OP_ROR</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2adb3a083ea94c9c4703fe210a6995d498">OP_SDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ab96c14e28cc4b681997430bf108e9fa9">OP_SET</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2af469c8ccd437d74fd6d133dafcefa293">OP_SEXTEND</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a0574228c15698bca0162c00be8492e53">OP_SGE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a1b4548db657df03861770e59313dbe4d">OP_SGT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a4d63d68464b2450e02e2ce68982c0652">OP_SHL0</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a5b1f86d085dde699eb04a0472441a32d">OP_SHL1</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a6ac95163478bdf061393a6a094bd2be2">OP_SHR0</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a4d369fd5c6a833752c8f09556ae58f89">OP_SHR1</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a4b2fa7539a7ba96f2ca91c04819b2497">OP_SLE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aa5c1960bb4b0a9058c84f1d0a8a9a949">OP_SLT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ae3f875728a0587b030de47333de536f6">OP_SMOD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a51be33a0121e0fcedf3967530f2dd034">OP_SMUL</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a6f9f5733f164a4beed3f504cdfd1d7a6">OP_UDIV</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a5a7221b26761e600af0ee569bced841c">OP_UEXTEND</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ad40c9fa5c7628c17a03e97c2ac8e714d">OP_UGE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ae97ac7cde18fab970b47237061fc6b55">OP_UGT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a140452dfbd66bdf4ab433d6bde91c455">OP_ULE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aa709fa706eaf7a737a828a08ddcf9857">OP_ULT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ae9e0ddcd79763f605f7747d4b314aef3">OP_UMOD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2abe17b96618c721f650d4248a97166021">OP_UMUL</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a1bdd0739ff85d7117dead19ef51af3bc">OP_WRITE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a574255970cda4be2c8d5eacbacf9d0ba">OP_XOR</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a07e5670c681b813ab16e30d583bd9baa">OP_ZEROP</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a77936b2548a16169fc239135a2ad83a4">OP_FP_ABS</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a2515f119954c1ff26fe4decb92c0d25b">OP_FP_NEGATE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a40d77db61f4c503678aba42b283701f0">OP_FP_ADD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a99b4230971cc0a9d779b86e265cae9ff">OP_FP_MUL</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a2c3808b4ea03b82c197bffc0f9ac75c8">OP_FP_DIV</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a9834bb5872b68c527855e4519af9cdfe">OP_FP_MULADD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a7564d0dd2381a988801f57ccb516fe37">OP_FP_SQRT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a3517ede771a3101258283ea8f80b33f2">OP_FP_MOD</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a29cb6638f9a5ccd6a43392f96b85ef05">OP_FP_ROUND</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a5469eda1713c9f2e03c80bebbd493372">OP_FP_MIN</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a18a9ba15f0ea4a8e1bb6b0973881c02d">OP_FP_MAX</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a35bba10bdd2b73deee5e8c90d93ff228">OP_FP_LE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aacaa628ced92c033f787f092f991274f">OP_FP_LT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a21c3050ee9d1f2a103ff950a995df26b">OP_FP_GE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a467f7d1aef51e98c4210745337418505">OP_FP_GT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a2e0013d4657f415e5a6a005c2165e20c">OP_FP_EQ</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a71a9557ffda630e6d8f8481670132c21">OP_FP_ISNORM</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2aaf2e66143fe1eac6ab140c8aed99ace0">OP_FP_ISSUBNORM</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ab82b246745f9cfa8e5ff293de576e797">OP_FP_ISZERO</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2af8882ffb10c851ee8da52ceb12d3cae1">OP_FP_ISINFINITE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a0316d25b5169101bbb7853e6c03c0610">OP_FP_ISNAN</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a0cf723fb19e6fac4ecd13fff168c3a8d">OP_FP_ISNEG</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a74518285cc15932b6e2e3d67c67e3748">OP_FP_ISPOS</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2afc020b8bfbb56d538043105f0d18222e">OP_CONVERT</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2ad2fa42256486c31126575759ccb061c4">OP_REINTERPRET</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a26e45d8a426be8586e6f5964a328306c">OP_NONE</a>
<br />
 }</td></tr>
<tr class="memdesc:a7a317419dcb8e9c29864a71d6bbe90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators for interior nodes of the expression tree.  <a href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">More...</a><br /></td></tr>
<tr class="separator:a7a317419dcb8e9c29864a71d6bbe90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9c2fafec1e169be6d367ed8d5c1a8" id="r_abed9c2fafec1e169be6d367ed8d5c1a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">VisitAction</a> { <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8a2b6b55ee87a5643ca50cf725cbb27de5">CONTINUE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8a1f33f2f319e768f686c359f3fe809edf">TRUNCATE</a>
, <br />
&#160;&#160;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8a070a0b50efcc6e69dc76ef58db74eaeb">TERMINATE</a>
<br />
 }</td></tr>
<tr class="memdesc:abed9c2fafec1e169be6d367ed8d5c1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for visitors.  <a href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">More...</a><br /></td></tr>
<tr class="separator:abed9c2fafec1e169be6d367ed8d5c1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a255fb8e6830c2fd0f8b3c37d324124d2" id="r_a255fb8e6830c2fd0f8b3c37d324124d2"><td class="memItemLeft" align="right" valign="top"><a id="a255fb8e6830c2fd0f8b3c37d324124d2" name="a255fb8e6830c2fd0f8b3c37d324124d2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStr</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a>)</td></tr>
<tr class="separator:a255fb8e6830c2fd0f8b3c37d324124d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5113d3b2258b6b06943d3f60f3f32bf" id="r_ad5113d3b2258b6b06943d3f60f3f32bf"><td class="memItemLeft" align="right" valign="top"><a id="ad5113d3b2258b6b06943d3f60f3f32bf" name="ad5113d3b2258b6b06943d3f60f3f32bf"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> &amp;)</td></tr>
<tr class="separator:ad5113d3b2258b6b06943d3f60f3f32bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5b7b096f6c5fab4cfd734755b9acd" id="r_a06f5b7b096f6c5fab4cfd734755b9acd"><td class="memItemLeft" align="right" valign="top"><a id="a06f5b7b096f6c5fab4cfd734755b9acd" name="a06f5b7b096f6c5fab4cfd734755b9acd"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">Node::WithFormatter</a> &amp;)</td></tr>
<tr class="separator:a06f5b7b096f6c5fab4cfd734755b9acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7891edf73e002c4571198fe2f95d1576" id="r_a7891edf73e002c4571198fe2f95d1576"><td class="memItemLeft" align="right" valign="top"><a id="a7891edf73e002c4571198fe2f95d1576" name="a7891edf73e002c4571198fe2f95d1576"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setToIte</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;var=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>())</td></tr>
<tr class="memdesc:a7891edf73e002c4571198fe2f95d1576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set to an ite expression. <br /></td></tr>
<tr class="separator:a7891edf73e002c4571198fe2f95d1576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86976fbdf5d2570451256f78c324f772" id="r_a86976fbdf5d2570451256f78c324f772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a86976fbdf5d2570451256f78c324f772">hash</a> (const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a86976fbdf5d2570451256f78c324f772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash zero or more expressions.  <br /></td></tr>
<tr class="separator:a86976fbdf5d2570451256f78c324f772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82505edb1e6c7f7131a6f9f9fa5c9da6" id="r_a82505edb1e6c7f7131a6f9f9fa5c9da6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a82505edb1e6c7f7131a6f9f9fa5c9da6"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a82505edb1e6c7f7131a6f9f9fa5c9da6">nNodes</a> (InputIterator begin, InputIterator end)</td></tr>
<tr class="memdesc:a82505edb1e6c7f7131a6f9f9fa5c9da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes.  <br /></td></tr>
<tr class="separator:a82505edb1e6c7f7131a6f9f9fa5c9da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cff9e5d7595f13d31d4039a97755c21" id="r_a8cff9e5d7595f13d31d4039a97755c21"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a8cff9e5d7595f13d31d4039a97755c21"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a8cff9e5d7595f13d31d4039a97755c21">nNodesUnique</a> (InputIterator begin, InputIterator end)</td></tr>
<tr class="memdesc:a8cff9e5d7595f13d31d4039a97755c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of unique nodes.  <br /></td></tr>
<tr class="separator:a8cff9e5d7595f13d31d4039a97755c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4502c29e487ba74487b929e67e525c0" id="r_af4502c29e487ba74487b929e67e525c0"><td class="memTemplParams" colspan="2">template&lt;class Substitution &gt; </td></tr>
<tr class="memitem:af4502c29e487ba74487b929e67e525c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#af4502c29e487ba74487b929e67e525c0">substitute</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;src, Substitution &amp;subber, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:af4502c29e487ba74487b929e67e525c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-the-fly substitutions.  <br /></td></tr>
<tr class="separator:af4502c29e487ba74487b929e67e525c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28ea3e40486a05ca9f64e9b7f9151ff0" id="r_a28ea3e40486a05ca9f64e9b7f9151ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a28ea3e40486a05ca9f64e9b7f9151ff0">makeVariable</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a28ea3e40486a05ca9f64e9b7f9151ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a28ea3e40486a05ca9f64e9b7f9151ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afdd036dfb4211a5fabf83dba9f2e79" id="r_a5afdd036dfb4211a5fabf83dba9f2e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a5afdd036dfb4211a5fabf83dba9f2e79">makeVariable</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;, uint64_t id, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a5afdd036dfb4211a5fabf83dba9f2e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a5afdd036dfb4211a5fabf83dba9f2e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4e0c51e4fd916f3f2a21cfa2171c8" id="r_a76f4e0c51e4fd916f3f2a21cfa2171c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a76f4e0c51e4fd916f3f2a21cfa2171c8">makeConstant</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a76f4e0c51e4fd916f3f2a21cfa2171c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a76f4e0c51e4fd916f3f2a21cfa2171c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac8924f20d95bb3f7e7ddf90987279" id="r_a65ac8924f20d95bb3f7e7ddf90987279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a65ac8924f20d95bb3f7e7ddf90987279">makeIntegerVariable</a> (size_t nBits, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a65ac8924f20d95bb3f7e7ddf90987279"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a65ac8924f20d95bb3f7e7ddf90987279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989f48b7439c3539e06051bbe85e99b" id="r_ae989f48b7439c3539e06051bbe85e99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae989f48b7439c3539e06051bbe85e99b">makeIntegerVariable</a> (size_t nBits, uint64_t id, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ae989f48b7439c3539e06051bbe85e99b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:ae989f48b7439c3539e06051bbe85e99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bd22ad2a0e0fd5984bc175abde22b7" id="r_a37bd22ad2a0e0fd5984bc175abde22b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a37bd22ad2a0e0fd5984bc175abde22b7">makeIntegerConstant</a> (size_t nBits, uint64_t value, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a37bd22ad2a0e0fd5984bc175abde22b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a37bd22ad2a0e0fd5984bc175abde22b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7f00cd9ad5460dabcb66835d55999a" id="r_a6a7f00cd9ad5460dabcb66835d55999a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a6a7f00cd9ad5460dabcb66835d55999a">makeIntegerConstant</a> (const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a6a7f00cd9ad5460dabcb66835d55999a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a6a7f00cd9ad5460dabcb66835d55999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106c46b295fb30748912dab369c08cb" id="r_a5106c46b295fb30748912dab369c08cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a5106c46b295fb30748912dab369c08cb">makeBooleanConstant</a> (bool, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a5106c46b295fb30748912dab369c08cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a5106c46b295fb30748912dab369c08cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45738a2615a7bd7ca268ceb5b1fda16" id="r_ae45738a2615a7bd7ca268ceb5b1fda16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae45738a2615a7bd7ca268ceb5b1fda16">makeMemoryVariable</a> (size_t addressWidth, size_t valueWidth, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ae45738a2615a7bd7ca268ceb5b1fda16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:ae45738a2615a7bd7ca268ceb5b1fda16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e4c4f98c2c25043a36bf0c1829640c" id="r_a88e4c4f98c2c25043a36bf0c1829640c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a88e4c4f98c2c25043a36bf0c1829640c">makeMemoryVariable</a> (size_t addressWidth, size_t valueWidth, uint64_t id, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a88e4c4f98c2c25043a36bf0c1829640c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a88e4c4f98c2c25043a36bf0c1829640c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31126f80e6aae1a920e0bd15b2d45ea" id="r_aa31126f80e6aae1a920e0bd15b2d45ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aa31126f80e6aae1a920e0bd15b2d45ea">makeFloatingPointVariable</a> (size_t eb, size_t sb, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aa31126f80e6aae1a920e0bd15b2d45ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:aa31126f80e6aae1a920e0bd15b2d45ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc30b46a7f613a7f46fec2eb6c05b20" id="r_a7cc30b46a7f613a7f46fec2eb6c05b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7cc30b46a7f613a7f46fec2eb6c05b20">makeFloatingPointVariable</a> (size_t eb, size_t sb, uint64_t id, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a7cc30b46a7f613a7f46fec2eb6c05b20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a7cc30b46a7f613a7f46fec2eb6c05b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51371119d7f59db3f06f638c648d8584" id="r_a51371119d7f59db3f06f638c648d8584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a51371119d7f59db3f06f638c648d8584">makeFloatingPointConstant</a> (float, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a51371119d7f59db3f06f638c648d8584"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a51371119d7f59db3f06f638c648d8584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f864d25bf0c944b379f7d89a392cc1" id="r_a78f864d25bf0c944b379f7d89a392cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a78f864d25bf0c944b379f7d89a392cc1">makeFloatingPointConstant</a> (double, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a78f864d25bf0c944b379f7d89a392cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a78f864d25bf0c944b379f7d89a392cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2de6385c1702890e9a7196c4115f62" id="r_a3f2de6385c1702890e9a7196c4115f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a3f2de6385c1702890e9a7196c4115f62">makeFloatingPointNan</a> (size_t eb, size_t sb, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a3f2de6385c1702890e9a7196c4115f62"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor.  <br /></td></tr>
<tr class="separator:a3f2de6385c1702890e9a7196c4115f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5ceeb4b30f5e41fc1b1385025794280" id="r_ae5ceeb4b30f5e41fc1b1385025794280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae5ceeb4b30f5e41fc1b1385025794280">makeAdd</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ae5ceeb4b30f5e41fc1b1385025794280"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ae5ceeb4b30f5e41fc1b1385025794280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c61746ed5dffc5e5f1c0df6628c0e" id="r_a327c61746ed5dffc5e5f1c0df6628c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a327c61746ed5dffc5e5f1c0df6628c0e">makeAsr</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a327c61746ed5dffc5e5f1c0df6628c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a327c61746ed5dffc5e5f1c0df6628c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b65e446dbd3fc12259c8570d209e2f" id="r_ab5b65e446dbd3fc12259c8570d209e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ab5b65e446dbd3fc12259c8570d209e2f">makeAnd</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ab5b65e446dbd3fc12259c8570d209e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ab5b65e446dbd3fc12259c8570d209e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebab91385566a4afed4b856f5f4e17c" id="r_aaebab91385566a4afed4b856f5f4e17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aaebab91385566a4afed4b856f5f4e17c">makeOr</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aaebab91385566a4afed4b856f5f4e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:aaebab91385566a4afed4b856f5f4e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4111daecd344dbbd6ce262288428d9" id="r_a1a4111daecd344dbbd6ce262288428d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a1a4111daecd344dbbd6ce262288428d9">makeXor</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a1a4111daecd344dbbd6ce262288428d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a1a4111daecd344dbbd6ce262288428d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680c40275ab124849520b2c4ad9a5521" id="r_a680c40275ab124849520b2c4ad9a5521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a680c40275ab124849520b2c4ad9a5521">makeConcat</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;hi, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;lo, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a680c40275ab124849520b2c4ad9a5521"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a680c40275ab124849520b2c4ad9a5521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970c64aa9a52ec57aaa7af5998453359" id="r_a970c64aa9a52ec57aaa7af5998453359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a970c64aa9a52ec57aaa7af5998453359">makeConvert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a970c64aa9a52ec57aaa7af5998453359"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a970c64aa9a52ec57aaa7af5998453359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae371b3253c7e63fbbe833e159d5a6471" id="r_ae371b3253c7e63fbbe833e159d5a6471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae371b3253c7e63fbbe833e159d5a6471">makeEq</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ae371b3253c7e63fbbe833e159d5a6471"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ae371b3253c7e63fbbe833e159d5a6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec5907b58cbb04e9485ba5cc621b8c9" id="r_a9ec5907b58cbb04e9485ba5cc621b8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a9ec5907b58cbb04e9485ba5cc621b8c9">makeExtract</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;begin, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;end, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a9ec5907b58cbb04e9485ba5cc621b8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a9ec5907b58cbb04e9485ba5cc621b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e1c2f7eb2c84d7ea9f8e2eccf31e7" id="r_ad64e1c2f7eb2c84d7ea9f8e2eccf31e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ad64e1c2f7eb2c84d7ea9f8e2eccf31e7">makeInvert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ad64e1c2f7eb2c84d7ea9f8e2eccf31e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ad64e1c2f7eb2c84d7ea9f8e2eccf31e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d58bcbd7c02bc940cbf6857bf556c9" id="r_a34d58bcbd7c02bc940cbf6857bf556c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a34d58bcbd7c02bc940cbf6857bf556c9">makeIsInfinite</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a34d58bcbd7c02bc940cbf6857bf556c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a34d58bcbd7c02bc940cbf6857bf556c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086fd8d57b7658485ed4bdb5bbe6d9e7" id="r_a086fd8d57b7658485ed4bdb5bbe6d9e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a086fd8d57b7658485ed4bdb5bbe6d9e7">makeIsNan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a086fd8d57b7658485ed4bdb5bbe6d9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a086fd8d57b7658485ed4bdb5bbe6d9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0672ebead4d95d654bba44443f21fc" id="r_a9a0672ebead4d95d654bba44443f21fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a9a0672ebead4d95d654bba44443f21fc">makeIsNeg</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a9a0672ebead4d95d654bba44443f21fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a9a0672ebead4d95d654bba44443f21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6809737ad248735d53e2d689d9608073" id="r_a6809737ad248735d53e2d689d9608073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a6809737ad248735d53e2d689d9608073">makeIsNorm</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a6809737ad248735d53e2d689d9608073"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a6809737ad248735d53e2d689d9608073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af416332c1a21676337bbccb07806ceb7" id="r_af416332c1a21676337bbccb07806ceb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#af416332c1a21676337bbccb07806ceb7">makeIsPos</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:af416332c1a21676337bbccb07806ceb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:af416332c1a21676337bbccb07806ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca16f31d73f2fcb54f4ba6636b98e026" id="r_aca16f31d73f2fcb54f4ba6636b98e026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aca16f31d73f2fcb54f4ba6636b98e026">makeIsSubnorm</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aca16f31d73f2fcb54f4ba6636b98e026"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:aca16f31d73f2fcb54f4ba6636b98e026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e43e302cfe572aa87bd78294f416c" id="r_a9f9e43e302cfe572aa87bd78294f416c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a9f9e43e302cfe572aa87bd78294f416c">makeIte</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;cond, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a9f9e43e302cfe572aa87bd78294f416c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a9f9e43e302cfe572aa87bd78294f416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae190d4721063895361df284687a07285" id="r_ae190d4721063895361df284687a07285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae190d4721063895361df284687a07285">makeLet</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;c, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ae190d4721063895361df284687a07285"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ae190d4721063895361df284687a07285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada915745c2978a6f0e53f4d5fc23a65c" id="r_ada915745c2978a6f0e53f4d5fc23a65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ada915745c2978a6f0e53f4d5fc23a65c">makeLssb</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ada915745c2978a6f0e53f4d5fc23a65c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ada915745c2978a6f0e53f4d5fc23a65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8872ae927eee8697d9002b45260389d9" id="r_a8872ae927eee8697d9002b45260389d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a8872ae927eee8697d9002b45260389d9">makeMax</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a8872ae927eee8697d9002b45260389d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a8872ae927eee8697d9002b45260389d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ff862cc17dd1edeb218b63306b417b" id="r_ab2ff862cc17dd1edeb218b63306b417b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ab2ff862cc17dd1edeb218b63306b417b">makeMin</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ab2ff862cc17dd1edeb218b63306b417b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ab2ff862cc17dd1edeb218b63306b417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68a56ddad947c011bf66b408bb4d80" id="r_a6a68a56ddad947c011bf66b408bb4d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a6a68a56ddad947c011bf66b408bb4d80">makeMssb</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a6a68a56ddad947c011bf66b408bb4d80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a6a68a56ddad947c011bf66b408bb4d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe44c2e192d7ce9d4a68e1e25b0fb9dd" id="r_abe44c2e192d7ce9d4a68e1e25b0fb9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abe44c2e192d7ce9d4a68e1e25b0fb9dd">makeMultiplyAdd</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;c, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:abe44c2e192d7ce9d4a68e1e25b0fb9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:abe44c2e192d7ce9d4a68e1e25b0fb9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03650f1c38adaecfe0f77bf54c9a7943" id="r_a03650f1c38adaecfe0f77bf54c9a7943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a03650f1c38adaecfe0f77bf54c9a7943">makeNe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a03650f1c38adaecfe0f77bf54c9a7943"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a03650f1c38adaecfe0f77bf54c9a7943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5e2721b1fde838837c217eadd5d7c7" id="r_a2f5e2721b1fde838837c217eadd5d7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2f5e2721b1fde838837c217eadd5d7c7">makeNegate</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a2f5e2721b1fde838837c217eadd5d7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a2f5e2721b1fde838837c217eadd5d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9d7684299b4838b1e2047d54eacf94" id="r_a1d9d7684299b4838b1e2047d54eacf94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a1d9d7684299b4838b1e2047d54eacf94">makeRead</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;mem, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a1d9d7684299b4838b1e2047d54eacf94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a1d9d7684299b4838b1e2047d54eacf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7ad379d6489c20f1e7f04c0085fd6" id="r_a8cc7ad379d6489c20f1e7f04c0085fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a8cc7ad379d6489c20f1e7f04c0085fd6">makeReinterpret</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a8cc7ad379d6489c20f1e7f04c0085fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a8cc7ad379d6489c20f1e7f04c0085fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51e7cdabe634319cc2c3c8a0274a6d" id="r_abb51e7cdabe634319cc2c3c8a0274a6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abb51e7cdabe634319cc2c3c8a0274a6d">makeRol</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:abb51e7cdabe634319cc2c3c8a0274a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:abb51e7cdabe634319cc2c3c8a0274a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb9433a22f6d029fcaa02ef30127c15" id="r_aefb9433a22f6d029fcaa02ef30127c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aefb9433a22f6d029fcaa02ef30127c15">makeRor</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aefb9433a22f6d029fcaa02ef30127c15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:aefb9433a22f6d029fcaa02ef30127c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cab59038d000af3f722ceb05d07cfe" id="r_a38cab59038d000af3f722ceb05d07cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a38cab59038d000af3f722ceb05d07cfe">makeRound</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a38cab59038d000af3f722ceb05d07cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a38cab59038d000af3f722ceb05d07cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e26ba8ecb9aa6eee0c036ce97b72238" id="r_a9e26ba8ecb9aa6eee0c036ce97b72238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a9e26ba8ecb9aa6eee0c036ce97b72238">makeSet</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a9e26ba8ecb9aa6eee0c036ce97b72238"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a9e26ba8ecb9aa6eee0c036ce97b72238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8215b84bd3a0d9e4f977ccc575d768" id="r_a0e8215b84bd3a0d9e4f977ccc575d768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a0e8215b84bd3a0d9e4f977ccc575d768">makeSet</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;c, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a0e8215b84bd3a0d9e4f977ccc575d768"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a0e8215b84bd3a0d9e4f977ccc575d768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19682e3b3e098dab372ac710f3cd7352" id="r_a19682e3b3e098dab372ac710f3cd7352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a19682e3b3e098dab372ac710f3cd7352">makeSignedDiv</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a19682e3b3e098dab372ac710f3cd7352"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a19682e3b3e098dab372ac710f3cd7352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822549e36a2eb9de040fdd66e8e89e86" id="r_a822549e36a2eb9de040fdd66e8e89e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a822549e36a2eb9de040fdd66e8e89e86">makeSignExtend</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;newSize, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a822549e36a2eb9de040fdd66e8e89e86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a822549e36a2eb9de040fdd66e8e89e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52205f68410928d7e9fd9f46c645e99c" id="r_a52205f68410928d7e9fd9f46c645e99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a52205f68410928d7e9fd9f46c645e99c">makeSignedGe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a52205f68410928d7e9fd9f46c645e99c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a52205f68410928d7e9fd9f46c645e99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bd1708650ff5504e857a0d915f601c" id="r_a68bd1708650ff5504e857a0d915f601c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a68bd1708650ff5504e857a0d915f601c">makeSignedGt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a68bd1708650ff5504e857a0d915f601c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a68bd1708650ff5504e857a0d915f601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab57037f4980692cae6909acc03a706" id="r_a5ab57037f4980692cae6909acc03a706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a5ab57037f4980692cae6909acc03a706">makeShl0</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a5ab57037f4980692cae6909acc03a706"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a5ab57037f4980692cae6909acc03a706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c385dbffc9e110d2e85fa680af4b026" id="r_a8c385dbffc9e110d2e85fa680af4b026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a8c385dbffc9e110d2e85fa680af4b026">makeShl1</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a8c385dbffc9e110d2e85fa680af4b026"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a8c385dbffc9e110d2e85fa680af4b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe406ca3cd19d8ad0763a7c942f445e4" id="r_abe406ca3cd19d8ad0763a7c942f445e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abe406ca3cd19d8ad0763a7c942f445e4">makeShr0</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:abe406ca3cd19d8ad0763a7c942f445e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:abe406ca3cd19d8ad0763a7c942f445e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dceac275b48cd62cd83a0933705722" id="r_aa3dceac275b48cd62cd83a0933705722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aa3dceac275b48cd62cd83a0933705722">makeShr1</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;sa, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aa3dceac275b48cd62cd83a0933705722"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:aa3dceac275b48cd62cd83a0933705722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c967d3e6950a5acf01536318a3a346" id="r_a18c967d3e6950a5acf01536318a3a346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a18c967d3e6950a5acf01536318a3a346">makeIsSignedPos</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a18c967d3e6950a5acf01536318a3a346"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a18c967d3e6950a5acf01536318a3a346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d4b41da8f5fd90983f4cb87d17e200" id="r_a00d4b41da8f5fd90983f4cb87d17e200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a00d4b41da8f5fd90983f4cb87d17e200">makeSignedLe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a00d4b41da8f5fd90983f4cb87d17e200"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a00d4b41da8f5fd90983f4cb87d17e200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6413112b14225fbfa70a946cb8b3eb" id="r_aac6413112b14225fbfa70a946cb8b3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#aac6413112b14225fbfa70a946cb8b3eb">makeSignedLt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:aac6413112b14225fbfa70a946cb8b3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:aac6413112b14225fbfa70a946cb8b3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a42b0aa6a75ab4933973295d59dd94" id="r_ad7a42b0aa6a75ab4933973295d59dd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ad7a42b0aa6a75ab4933973295d59dd94">makeSignedMax</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ad7a42b0aa6a75ab4933973295d59dd94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ad7a42b0aa6a75ab4933973295d59dd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec6449681d66b68904043b3e4a32afa" id="r_a9ec6449681d66b68904043b3e4a32afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a9ec6449681d66b68904043b3e4a32afa">makeSignedMin</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a9ec6449681d66b68904043b3e4a32afa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a9ec6449681d66b68904043b3e4a32afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad436c9a316a419ba3a3fd28ccaabc99b" id="r_ad436c9a316a419ba3a3fd28ccaabc99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ad436c9a316a419ba3a3fd28ccaabc99b">makeSignedMod</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ad436c9a316a419ba3a3fd28ccaabc99b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ad436c9a316a419ba3a3fd28ccaabc99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7100d58565211efc6202eea6547336" id="r_a8a7100d58565211efc6202eea6547336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a8a7100d58565211efc6202eea6547336">makeSignedMul</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a8a7100d58565211efc6202eea6547336"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a8a7100d58565211efc6202eea6547336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63281193fde848694d4988aa066180c" id="r_ac63281193fde848694d4988aa066180c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ac63281193fde848694d4988aa066180c">makeSqrt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ac63281193fde848694d4988aa066180c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ac63281193fde848694d4988aa066180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e5cbbcb0cafa067befe02813e0fb3c" id="r_ab0e5cbbcb0cafa067befe02813e0fb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ab0e5cbbcb0cafa067befe02813e0fb3c">makeDiv</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ab0e5cbbcb0cafa067befe02813e0fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ab0e5cbbcb0cafa067befe02813e0fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db50e5f6b1f341453c0d57cbdf4e34" id="r_a40db50e5f6b1f341453c0d57cbdf4e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a40db50e5f6b1f341453c0d57cbdf4e34">makeExtend</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;newSize, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a40db50e5f6b1f341453c0d57cbdf4e34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a40db50e5f6b1f341453c0d57cbdf4e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673feccdef7f890355c708c5a83cb47e" id="r_a673feccdef7f890355c708c5a83cb47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a673feccdef7f890355c708c5a83cb47e">makeGe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a673feccdef7f890355c708c5a83cb47e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a673feccdef7f890355c708c5a83cb47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f726fa91af72b61a331c7093631d5" id="r_ad40f726fa91af72b61a331c7093631d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ad40f726fa91af72b61a331c7093631d5">makeGt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ad40f726fa91af72b61a331c7093631d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ad40f726fa91af72b61a331c7093631d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cdc8d0c1920de445b142665522a035" id="r_a57cdc8d0c1920de445b142665522a035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a57cdc8d0c1920de445b142665522a035">makeLe</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a57cdc8d0c1920de445b142665522a035"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a57cdc8d0c1920de445b142665522a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbe37a90f2ae569b14ae3598b2d699" id="r_a79fbe37a90f2ae569b14ae3598b2d699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a79fbe37a90f2ae569b14ae3598b2d699">makeLt</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a79fbe37a90f2ae569b14ae3598b2d699"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a79fbe37a90f2ae569b14ae3598b2d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ad8aa835451a974c6ddf92ab3d179d" id="r_a46ad8aa835451a974c6ddf92ab3d179d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a46ad8aa835451a974c6ddf92ab3d179d">makeMod</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a46ad8aa835451a974c6ddf92ab3d179d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a46ad8aa835451a974c6ddf92ab3d179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f67bec6731821a787d82fdf283475" id="r_a795f67bec6731821a787d82fdf283475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a795f67bec6731821a787d82fdf283475">makeMul</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:a795f67bec6731821a787d82fdf283475"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:a795f67bec6731821a787d82fdf283475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac899e4effbc98c929b3770cd10aa21d6" id="r_ac899e4effbc98c929b3770cd10aa21d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ac899e4effbc98c929b3770cd10aa21d6">makeWrite</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;mem, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;addr, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ac899e4effbc98c929b3770cd10aa21d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ac899e4effbc98c929b3770cd10aa21d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99ed01a83ef6e2fdfc505f7ac53145c" id="r_ac99ed01a83ef6e2fdfc505f7ac53145c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ac99ed01a83ef6e2fdfc505f7ac53145c">makeZerop</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</td></tr>
<tr class="memdesc:ac99ed01a83ef6e2fdfc505f7ac53145c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor.  <br /></td></tr>
<tr class="separator:ac99ed01a83ef6e2fdfc505f7ac53145c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:affe5d278bc4c7cda4a0336b04eb36c2f" id="r_affe5d278bc4c7cda4a0336b04eb36c2f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#affe5d278bc4c7cda4a0336b04eb36c2f">findCommonSubexpressions</a> (const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:affe5d278bc4c7cda4a0336b04eb36c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find common subexpressions.  <br /></td></tr>
<tr class="separator:affe5d278bc4c7cda4a0336b04eb36c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7513beee55125b0061353a9b20fa5b3a" id="r_a7513beee55125b0061353a9b20fa5b3a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a7513beee55125b0061353a9b20fa5b3a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7513beee55125b0061353a9b20fa5b3a">findCommonSubexpressions</a> (InputIterator begin, InputIterator end)</td></tr>
<tr class="memdesc:a7513beee55125b0061353a9b20fa5b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find common subexpressions.  <br /></td></tr>
<tr class="separator:a7513beee55125b0061353a9b20fa5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad45aae9df42d8cee4894fa751b8cd153" id="r_ad45aae9df42d8cee4894fa751b8cd153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ad45aae9df42d8cee4894fa751b8cd153">serializeVariableIds</a></td></tr>
<tr class="memdesc:ad45aae9df42d8cee4894fa751b8cd153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to serialize variable IDs.  <br /></td></tr>
<tr class="separator:ad45aae9df42d8cee4894fa751b8cd153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3324ec137e999a2aa28b48ae4230cc4a" id="r_a3324ec137e999a2aa28b48ae4230cc4a"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a3324ec137e999a2aa28b48ae4230cc4a">MAX_NNODES</a></td></tr>
<tr class="memdesc:a3324ec137e999a2aa28b48ae4230cc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of nodes that can be reported.  <br /></td></tr>
<tr class="separator:a3324ec137e999a2aa28b48ae4230cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a259906bede9e5aba6e7e09400d5cd481" name="a259906bede9e5aba6e7e09400d5cd481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259906bede9e5aba6e7e09400d5cd481">&#9670;&#160;</a></span>InteriorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">Rose::BinaryAnalysis::SymbolicExpression::InteriorPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html#l00105">105</a> of file <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/BasicTypes.h</a>.</p>

</div>
</div>
<a id="ae9d5bbc5fcd4c7d776264c9c83b804e5" name="ae9d5bbc5fcd4c7d776264c9c83b804e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d5bbc5fcd4c7d776264c9c83b804e5">&#9670;&#160;</a></span>LeafPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">Rose::BinaryAnalysis::SymbolicExpression::LeafPtr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html#l00107">107</a> of file <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a357a1787c84ab11ac04ffa566345e57c" name="a357a1787c84ab11ac04ffa566345e57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a1787c84ab11ac04ffa566345e57c">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Rose::BinaryAnalysis::SymbolicExpression::Ptr</a> = typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html#l00109">109</a> of file <a class="el" href="Rose_2BinaryAnalysis_2BasicTypes_8h_source.html">Rose/BinaryAnalysis/BasicTypes.h</a>.</p>

</div>
</div>
<a id="a07a9738645925dedda68638d9cab3369" name="a07a9738645925dedda68638d9cab3369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a9738645925dedda68638d9cab3369">&#9670;&#160;</a></span>Nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Rose::BinaryAnalysis::SymbolicExpression::Nodes = typedef std::vector&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00153">153</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a0daaf63033de03062e2418ee317be7f6" name="a0daaf63033de03062e2418ee317be7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daaf63033de03062e2418ee317be7f6">&#9670;&#160;</a></span>RenameMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMap.html">Rose::BinaryAnalysis::SymbolicExpression::RenameMap</a> = typedef <a class="el" href="classMap.html">Map</a>&lt;uint64_t, uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00154">154</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a2fee57f9f5e5cd95ab678fd2853d7735" name="a2fee57f9f5e5cd95ab678fd2853d7735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fee57f9f5e5cd95ab678fd2853d7735">&#9670;&#160;</a></span>Hash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Rose::BinaryAnalysis::SymbolicExpression::Hash</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash of symbolic expression. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00157">157</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a3b38f38d6cc7e0cbe6264711af79f7a5" name="a3b38f38d6cc7e0cbe6264711af79f7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38f38d6cc7e0cbe6264711af79f7a5">&#9670;&#160;</a></span>ExpressionSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExpressionLessp.html">ExpressionLessp</a>&gt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a3b38f38d6cc7e0cbe6264711af79f7a5">Rose::BinaryAnalysis::SymbolicExpression::ExpressionSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of expressions ordered by hash. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00927">927</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7a317419dcb8e9c29864a71d6bbe90b2" name="a7a317419dcb8e9c29864a71d6bbe90b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a317419dcb8e9c29864a71d6bbe90b2">&#9670;&#160;</a></span>Operator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Rose::BinaryAnalysis::SymbolicExpression::Operator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operators for interior nodes of the expression tree. </p>
<p>Commutative operators generally take one or more operands. Operators such as shifting, extending, and truncating have the size operand appearing before the bit vector on which to operate (this makes the output more human-readable since the size operand is often a constant). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ad0a99911efbdde5f3323aaacb89c2f1c" name="a7a317419dcb8e9c29864a71d6bbe90b2ad0a99911efbdde5f3323aaacb89c2f1c"></a>OP_ADD&#160;</td><td class="fielddoc"><p>Addition. </p>
<p>One or more operands, all the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2abba92edf9ea6219ea36f8c202e1669ea" name="a7a317419dcb8e9c29864a71d6bbe90b2abba92edf9ea6219ea36f8c202e1669ea"></a>OP_AND&#160;</td><td class="fielddoc"><p>Bitwise conjunction. </p>
<p>One or more operands all the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a647aa826d1ade4d51bfd640daaa570f7" name="a7a317419dcb8e9c29864a71d6bbe90b2a647aa826d1ade4d51bfd640daaa570f7"></a>OP_ASR&#160;</td><td class="fielddoc"><p>Arithmetic shift right. </p>
<p>Operand B shifted by A bits; 0 &lt;= A &lt; width(B). A is unsigned. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a01b202f8dd18ef1e7d46fa77a69506d8" name="a7a317419dcb8e9c29864a71d6bbe90b2a01b202f8dd18ef1e7d46fa77a69506d8"></a>OP_CONCAT&#160;</td><td class="fielddoc"><p>Concatenation. </p>
<p>Operand A becomes high-order bits. Any number of operands. Result is integer type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a017db9797ab52e01e8b0482e6dd231a8" name="a7a317419dcb8e9c29864a71d6bbe90b2a017db9797ab52e01e8b0482e6dd231a8"></a>OP_EQ&#160;</td><td class="fielddoc"><p>Equality. </p>
<p>Two operands, both the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a19b87e44a74f9bcafd2c46960817b33f" name="a7a317419dcb8e9c29864a71d6bbe90b2a19b87e44a74f9bcafd2c46960817b33f"></a>OP_EXTRACT&#160;</td><td class="fielddoc"><p>Extract subsequence of bits. </p>
<p>Extract bits [A..B) of C. 0 &lt;= A &lt; B &lt;= width(C). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aa2d069e2a1eaa9c27b56458af3d4289e" name="a7a317419dcb8e9c29864a71d6bbe90b2aa2d069e2a1eaa9c27b56458af3d4289e"></a>OP_INVERT&#160;</td><td class="fielddoc"><p>Bitwise inversion. </p>
<p>One operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a8f5091ed5bd7ce53f99ea7f81bf7263d" name="a7a317419dcb8e9c29864a71d6bbe90b2a8f5091ed5bd7ce53f99ea7f81bf7263d"></a>OP_ITE&#160;</td><td class="fielddoc"><p>If-then-else. </p>
<p>A must be one bit. Returns B if A is set, C otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a89e9065691a4661624bb9324fc2439a5" name="a7a317419dcb8e9c29864a71d6bbe90b2a89e9065691a4661624bb9324fc2439a5"></a>OP_LET&#160;</td><td class="fielddoc"><p>Let expression. </p>
<p>Deferred substitution. Substitutes A for B in C. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a4b68d350d7af82cdf5f1d244814a4f86" name="a7a317419dcb8e9c29864a71d6bbe90b2a4b68d350d7af82cdf5f1d244814a4f86"></a>OP_LSSB&#160;</td><td class="fielddoc"><p>Least significant set bit or zero. </p>
<p>One operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a9f16dfdbebc4c5ea8e08bb4b6f1c480e" name="a7a317419dcb8e9c29864a71d6bbe90b2a9f16dfdbebc4c5ea8e08bb4b6f1c480e"></a>OP_MSSB&#160;</td><td class="fielddoc"><p>Most significant set bit or zero. </p>
<p>One operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ace8f525d5ea8c2ab7121abebc13d0d7f" name="a7a317419dcb8e9c29864a71d6bbe90b2ace8f525d5ea8c2ab7121abebc13d0d7f"></a>OP_NE&#160;</td><td class="fielddoc"><p>Inequality. </p>
<p>Two operands, both the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aa9a8f75b5b542567633076dc88401026" name="a7a317419dcb8e9c29864a71d6bbe90b2aa9a8f75b5b542567633076dc88401026"></a>OP_NEGATE&#160;</td><td class="fielddoc"><p>Arithmetic negation. </p>
<p>One operand. For Booleans, use OP_INVERT (2's complement is a no-op). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a43d403c95f2848c831e25fddcb9ecbc2" name="a7a317419dcb8e9c29864a71d6bbe90b2a43d403c95f2848c831e25fddcb9ecbc2"></a>OP_NOOP&#160;</td><td class="fielddoc"><p>No operation. </p>
<p>Used only by the default constructor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a0528f5a1d1a617ae9e4eb5197d3b9bfc" name="a7a317419dcb8e9c29864a71d6bbe90b2a0528f5a1d1a617ae9e4eb5197d3b9bfc"></a>OP_OR&#160;</td><td class="fielddoc"><p>Bitwise disjunction. </p>
<p>One or more operands all the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a592c9db0511c68b9afb11afd9f4ae7bc" name="a7a317419dcb8e9c29864a71d6bbe90b2a592c9db0511c68b9afb11afd9f4ae7bc"></a>OP_READ&#160;</td><td class="fielddoc"><p>Read a value from memory. </p>
<p>Arguments are the memory state and the address expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2af9cebc886215e76b6d7ada476b25844d" name="a7a317419dcb8e9c29864a71d6bbe90b2af9cebc886215e76b6d7ada476b25844d"></a>OP_ROL&#160;</td><td class="fielddoc"><p>Rotate left. </p>
<p>Rotate bits of B left by A bits. 0 &lt;= A &lt; width(B). A is unsigned. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a8ef1a3da7f741750781fd6c3fcca27a9" name="a7a317419dcb8e9c29864a71d6bbe90b2a8ef1a3da7f741750781fd6c3fcca27a9"></a>OP_ROR&#160;</td><td class="fielddoc"><p>Rotate right. </p>
<p>Rotate bits of B right by A bits. 0 &lt;= B &lt; width(B). A is unsigned. <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2adb3a083ea94c9c4703fe210a6995d498" name="a7a317419dcb8e9c29864a71d6bbe90b2adb3a083ea94c9c4703fe210a6995d498"></a>OP_SDIV&#160;</td><td class="fielddoc"><p>Signed division. </p>
<p>Two operands, A/B. Result width is width(A). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ab96c14e28cc4b681997430bf108e9fa9" name="a7a317419dcb8e9c29864a71d6bbe90b2ab96c14e28cc4b681997430bf108e9fa9"></a>OP_SET&#160;</td><td class="fielddoc"><p>Set of expressions. </p>
<p>Any number of operands in any order. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2af469c8ccd437d74fd6d133dafcefa293" name="a7a317419dcb8e9c29864a71d6bbe90b2af469c8ccd437d74fd6d133dafcefa293"></a>OP_SEXTEND&#160;</td><td class="fielddoc"><p>Signed extension at msb. </p>
<p>Extend B to A bits by replicating B's most significant bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a0574228c15698bca0162c00be8492e53" name="a7a317419dcb8e9c29864a71d6bbe90b2a0574228c15698bca0162c00be8492e53"></a>OP_SGE&#160;</td><td class="fielddoc"><p>Signed greater-than-or-equal. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a1b4548db657df03861770e59313dbe4d" name="a7a317419dcb8e9c29864a71d6bbe90b2a1b4548db657df03861770e59313dbe4d"></a>OP_SGT&#160;</td><td class="fielddoc"><p>Signed greater-than. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a4d63d68464b2450e02e2ce68982c0652" name="a7a317419dcb8e9c29864a71d6bbe90b2a4d63d68464b2450e02e2ce68982c0652"></a>OP_SHL0&#160;</td><td class="fielddoc"><p>Shift left, introducing zeros at lsb. </p>
<p>Bits of B are shifted by A, where 0 &lt;=A &lt; width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a5b1f86d085dde699eb04a0472441a32d" name="a7a317419dcb8e9c29864a71d6bbe90b2a5b1f86d085dde699eb04a0472441a32d"></a>OP_SHL1&#160;</td><td class="fielddoc"><p>Shift left, introducing ones at lsb. </p>
<p>Bits of B are shifted by A, where 0 &lt;=A &lt; width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a6ac95163478bdf061393a6a094bd2be2" name="a7a317419dcb8e9c29864a71d6bbe90b2a6ac95163478bdf061393a6a094bd2be2"></a>OP_SHR0&#160;</td><td class="fielddoc"><p>Shift right, introducing zeros at msb. </p>
<p>Bits of B are shifted by A, where 0 &lt;=A &lt;width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a4d369fd5c6a833752c8f09556ae58f89" name="a7a317419dcb8e9c29864a71d6bbe90b2a4d369fd5c6a833752c8f09556ae58f89"></a>OP_SHR1&#160;</td><td class="fielddoc"><p>Shift right, introducing ones at msb. </p>
<p>Bits of B are shifted by A, where 0 &lt;=A &lt;width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a4b2fa7539a7ba96f2ca91c04819b2497" name="a7a317419dcb8e9c29864a71d6bbe90b2a4b2fa7539a7ba96f2ca91c04819b2497"></a>OP_SLE&#160;</td><td class="fielddoc"><p>Signed less-than-or-equal. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aa5c1960bb4b0a9058c84f1d0a8a9a949" name="a7a317419dcb8e9c29864a71d6bbe90b2aa5c1960bb4b0a9058c84f1d0a8a9a949"></a>OP_SLT&#160;</td><td class="fielddoc"><p>Signed less-than. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ae3f875728a0587b030de47333de536f6" name="a7a317419dcb8e9c29864a71d6bbe90b2ae3f875728a0587b030de47333de536f6"></a>OP_SMOD&#160;</td><td class="fielddoc"><p>Signed modulus. </p>
<p>Two operands, AB. Result width is width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a51be33a0121e0fcedf3967530f2dd034" name="a7a317419dcb8e9c29864a71d6bbe90b2a51be33a0121e0fcedf3967530f2dd034"></a>OP_SMUL&#160;</td><td class="fielddoc"><p>Signed multiplication. </p>
<p>Two operands A*B. Result width is width(A)+width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a6f9f5733f164a4beed3f504cdfd1d7a6" name="a7a317419dcb8e9c29864a71d6bbe90b2a6f9f5733f164a4beed3f504cdfd1d7a6"></a>OP_UDIV&#160;</td><td class="fielddoc"><p>Signed division. </p>
<p>Two operands, A/B. Result width is width(A). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a5a7221b26761e600af0ee569bced841c" name="a7a317419dcb8e9c29864a71d6bbe90b2a5a7221b26761e600af0ee569bced841c"></a>OP_UEXTEND&#160;</td><td class="fielddoc"><p>Unsigned extention at msb. </p>
<p>Extend B to A bits by introducing zeros at the msb of B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ad40c9fa5c7628c17a03e97c2ac8e714d" name="a7a317419dcb8e9c29864a71d6bbe90b2ad40c9fa5c7628c17a03e97c2ac8e714d"></a>OP_UGE&#160;</td><td class="fielddoc"><p>Unsigned greater-than-or-equal. </p>
<p>Two operands of equal width. Boolean result. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ae97ac7cde18fab970b47237061fc6b55" name="a7a317419dcb8e9c29864a71d6bbe90b2ae97ac7cde18fab970b47237061fc6b55"></a>OP_UGT&#160;</td><td class="fielddoc"><p>Unsigned greater-than. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a140452dfbd66bdf4ab433d6bde91c455" name="a7a317419dcb8e9c29864a71d6bbe90b2a140452dfbd66bdf4ab433d6bde91c455"></a>OP_ULE&#160;</td><td class="fielddoc"><p>Unsigned less-than-or-equal. </p>
<p>Two operands of equal width. Result is Boolean. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aa709fa706eaf7a737a828a08ddcf9857" name="a7a317419dcb8e9c29864a71d6bbe90b2aa709fa706eaf7a737a828a08ddcf9857"></a>OP_ULT&#160;</td><td class="fielddoc"><p>Unsigned less-than. </p>
<p>Two operands of equal width. Result is Boolean (1-bit vector). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ae9e0ddcd79763f605f7747d4b314aef3" name="a7a317419dcb8e9c29864a71d6bbe90b2ae9e0ddcd79763f605f7747d4b314aef3"></a>OP_UMOD&#160;</td><td class="fielddoc"><p>Unsigned modulus. </p>
<p>Two operands, AB. Result width is width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2abe17b96618c721f650d4248a97166021" name="a7a317419dcb8e9c29864a71d6bbe90b2abe17b96618c721f650d4248a97166021"></a>OP_UMUL&#160;</td><td class="fielddoc"><p>Unsigned multiplication. </p>
<p>Two operands, A*B. Result width is width(A)+width(B). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a1bdd0739ff85d7117dead19ef51af3bc" name="a7a317419dcb8e9c29864a71d6bbe90b2a1bdd0739ff85d7117dead19ef51af3bc"></a>OP_WRITE&#160;</td><td class="fielddoc"><p>Write (update) memory with a new value. </p>
<p>Arguments are memory, address and value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a574255970cda4be2c8d5eacbacf9d0ba" name="a7a317419dcb8e9c29864a71d6bbe90b2a574255970cda4be2c8d5eacbacf9d0ba"></a>OP_XOR&#160;</td><td class="fielddoc"><p>Bitwise exclusive disjunction. </p>
<p>One or more operands, all the same width. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a07e5670c681b813ab16e30d583bd9baa" name="a7a317419dcb8e9c29864a71d6bbe90b2a07e5670c681b813ab16e30d583bd9baa"></a>OP_ZEROP&#160;</td><td class="fielddoc"><p>Equal to zero. </p>
<p>One operand. Result is a single bit, set iff A is equal to zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a77936b2548a16169fc239135a2ad83a4" name="a7a317419dcb8e9c29864a71d6bbe90b2a77936b2548a16169fc239135a2ad83a4"></a>OP_FP_ABS&#160;</td><td class="fielddoc"><p>Floating-point absolute value. </p>
<p>Argument is FP value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a2515f119954c1ff26fe4decb92c0d25b" name="a7a317419dcb8e9c29864a71d6bbe90b2a2515f119954c1ff26fe4decb92c0d25b"></a>OP_FP_NEGATE&#160;</td><td class="fielddoc"><p>Floating-point negation. </p>
<p>Argument is FP value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a40d77db61f4c503678aba42b283701f0" name="a7a317419dcb8e9c29864a71d6bbe90b2a40d77db61f4c503678aba42b283701f0"></a>OP_FP_ADD&#160;</td><td class="fielddoc"><p>Floating-point addition. </p>
<p>Args are the FP addends. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a99b4230971cc0a9d779b86e265cae9ff" name="a7a317419dcb8e9c29864a71d6bbe90b2a99b4230971cc0a9d779b86e265cae9ff"></a>OP_FP_MUL&#160;</td><td class="fielddoc"><p>Floating-point multiply. </p>
<p>Args are the FP factors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a2c3808b4ea03b82c197bffc0f9ac75c8" name="a7a317419dcb8e9c29864a71d6bbe90b2a2c3808b4ea03b82c197bffc0f9ac75c8"></a>OP_FP_DIV&#160;</td><td class="fielddoc"><p>Floating-point division. </p>
<p>Args are FP dividend and FP divisor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a9834bb5872b68c527855e4519af9cdfe" name="a7a317419dcb8e9c29864a71d6bbe90b2a9834bb5872b68c527855e4519af9cdfe"></a>OP_FP_MULADD&#160;</td><td class="fielddoc"><p>Floating-point multiply-add. </p>
<p>For xy+z, args are x, y, z. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a7564d0dd2381a988801f57ccb516fe37" name="a7a317419dcb8e9c29864a71d6bbe90b2a7564d0dd2381a988801f57ccb516fe37"></a>OP_FP_SQRT&#160;</td><td class="fielddoc"><p>Floating-point square root. </p>
<p>Argument is the FP square. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a3517ede771a3101258283ea8f80b33f2" name="a7a317419dcb8e9c29864a71d6bbe90b2a3517ede771a3101258283ea8f80b33f2"></a>OP_FP_MOD&#160;</td><td class="fielddoc"><p>Floating-point remainder. </p>
<p>Args are FP dividend and FP divisor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a29cb6638f9a5ccd6a43392f96b85ef05" name="a7a317419dcb8e9c29864a71d6bbe90b2a29cb6638f9a5ccd6a43392f96b85ef05"></a>OP_FP_ROUND&#160;</td><td class="fielddoc"><p>Floating-point round to integer as FP type. </p>
<p>Argument and result are both FP values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a5469eda1713c9f2e03c80bebbd493372" name="a7a317419dcb8e9c29864a71d6bbe90b2a5469eda1713c9f2e03c80bebbd493372"></a>OP_FP_MIN&#160;</td><td class="fielddoc"><p>Floating-point minimum. </p>
<p>Args are one or more FP values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a18a9ba15f0ea4a8e1bb6b0973881c02d" name="a7a317419dcb8e9c29864a71d6bbe90b2a18a9ba15f0ea4a8e1bb6b0973881c02d"></a>OP_FP_MAX&#160;</td><td class="fielddoc"><p>Floating-point maximum. </p>
<p>Args are one or more FP values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a35bba10bdd2b73deee5e8c90d93ff228" name="a7a317419dcb8e9c29864a71d6bbe90b2a35bba10bdd2b73deee5e8c90d93ff228"></a>OP_FP_LE&#160;</td><td class="fielddoc"><p>Floating-point less-than or equal. </p>
<p>Args are the two FP values to compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aacaa628ced92c033f787f092f991274f" name="a7a317419dcb8e9c29864a71d6bbe90b2aacaa628ced92c033f787f092f991274f"></a>OP_FP_LT&#160;</td><td class="fielddoc"><p>Floating-point less-than. </p>
<p>Args are the two FP values to compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a21c3050ee9d1f2a103ff950a995df26b" name="a7a317419dcb8e9c29864a71d6bbe90b2a21c3050ee9d1f2a103ff950a995df26b"></a>OP_FP_GE&#160;</td><td class="fielddoc"><p>Floating-point greater-than or equal. </p>
<p>Args are the two FP values to compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a467f7d1aef51e98c4210745337418505" name="a7a317419dcb8e9c29864a71d6bbe90b2a467f7d1aef51e98c4210745337418505"></a>OP_FP_GT&#160;</td><td class="fielddoc"><p>Floating-point greater than. </p>
<p>Args are the two FP values to compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a2e0013d4657f415e5a6a005c2165e20c" name="a7a317419dcb8e9c29864a71d6bbe90b2a2e0013d4657f415e5a6a005c2165e20c"></a>OP_FP_EQ&#160;</td><td class="fielddoc"><p>Floating-point equality. </p>
<p>Args are the two FP values to compare. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a71a9557ffda630e6d8f8481670132c21" name="a7a317419dcb8e9c29864a71d6bbe90b2a71a9557ffda630e6d8f8481670132c21"></a>OP_FP_ISNORM&#160;</td><td class="fielddoc"><p>Floating-point normal class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2aaf2e66143fe1eac6ab140c8aed99ace0" name="a7a317419dcb8e9c29864a71d6bbe90b2aaf2e66143fe1eac6ab140c8aed99ace0"></a>OP_FP_ISSUBNORM&#160;</td><td class="fielddoc"><p>Floating-point subnormal class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ab82b246745f9cfa8e5ff293de576e797" name="a7a317419dcb8e9c29864a71d6bbe90b2ab82b246745f9cfa8e5ff293de576e797"></a>OP_FP_ISZERO&#160;</td><td class="fielddoc"><p>Floating-point zero class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2af8882ffb10c851ee8da52ceb12d3cae1" name="a7a317419dcb8e9c29864a71d6bbe90b2af8882ffb10c851ee8da52ceb12d3cae1"></a>OP_FP_ISINFINITE&#160;</td><td class="fielddoc"><p>Floating-point infinity class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a0316d25b5169101bbb7853e6c03c0610" name="a7a317419dcb8e9c29864a71d6bbe90b2a0316d25b5169101bbb7853e6c03c0610"></a>OP_FP_ISNAN&#160;</td><td class="fielddoc"><p>Floating-point NaN class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a0cf723fb19e6fac4ecd13fff168c3a8d" name="a7a317419dcb8e9c29864a71d6bbe90b2a0cf723fb19e6fac4ecd13fff168c3a8d"></a>OP_FP_ISNEG&#160;</td><td class="fielddoc"><p>Floating-point negative class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a74518285cc15932b6e2e3d67c67e3748" name="a7a317419dcb8e9c29864a71d6bbe90b2a74518285cc15932b6e2e3d67c67e3748"></a>OP_FP_ISPOS&#160;</td><td class="fielddoc"><p>Floating-point positive class. </p>
<p>Argument is the FP value to check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2afc020b8bfbb56d538043105f0d18222e" name="a7a317419dcb8e9c29864a71d6bbe90b2afc020b8bfbb56d538043105f0d18222e"></a>OP_CONVERT&#160;</td><td class="fielddoc"><p>Convert from one type to another. </p>
<p>Argument is the source value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2ad2fa42256486c31126575759ccb061c4" name="a7a317419dcb8e9c29864a71d6bbe90b2ad2fa42256486c31126575759ccb061c4"></a>OP_REINTERPRET&#160;</td><td class="fielddoc"><p>Interpret the value as a different type without converting. </p>
<p>Argument is the source value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a317419dcb8e9c29864a71d6bbe90b2a26e45d8a426be8586e6f5964a328306c" name="a7a317419dcb8e9c29864a71d6bbe90b2a26e45d8a426be8586e6f5964a328306c"></a>OP_NONE&#160;</td><td class="fielddoc"><p>No operation. </p>
<p>Result of getOperator on a node that doesn't have an operator. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00077">77</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="abed9c2fafec1e169be6d367ed8d5c1a8" name="abed9c2fafec1e169be6d367ed8d5c1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed9c2fafec1e169be6d367ed8d5c1a8">&#9670;&#160;</a></span>VisitAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">Rose::BinaryAnalysis::SymbolicExpression::VisitAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type for visitors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abed9c2fafec1e169be6d367ed8d5c1a8a2b6b55ee87a5643ca50cf725cbb27de5" name="abed9c2fafec1e169be6d367ed8d5c1a8a2b6b55ee87a5643ca50cf725cbb27de5"></a>CONTINUE&#160;</td><td class="fielddoc"><p>Continue the traversal as normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="abed9c2fafec1e169be6d367ed8d5c1a8a1f33f2f319e768f686c359f3fe809edf" name="abed9c2fafec1e169be6d367ed8d5c1a8a1f33f2f319e768f686c359f3fe809edf"></a>TRUNCATE&#160;</td><td class="fielddoc"><p>For a pre-order depth-first visit, do not descend into children. </p>
</td></tr>
<tr><td class="fieldname"><a id="abed9c2fafec1e169be6d367ed8d5c1a8a070a0b50efcc6e69dc76ef58db74eaeb" name="abed9c2fafec1e169be6d367ed8d5c1a8a070a0b50efcc6e69dc76ef58db74eaeb"></a>TERMINATE&#160;</td><td class="fielddoc"><p>Terminate the traversal. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00183">183</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a28ea3e40486a05ca9f64e9b7f9151ff0" name="a28ea3e40486a05ca9f64e9b7f9151ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ea3e40486a05ca9f64e9b7f9151ff0">&#9670;&#160;</a></span>makeVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a5afdd036dfb4211a5fabf83dba9f2e79" name="a5afdd036dfb4211a5fabf83dba9f2e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afdd036dfb4211a5fabf83dba9f2e79">&#9670;&#160;</a></span>makeVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a76f4e0c51e4fd916f3f2a21cfa2171c8" name="a76f4e0c51e4fd916f3f2a21cfa2171c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4e0c51e4fd916f3f2a21cfa2171c8">&#9670;&#160;</a></span>makeConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a65ac8924f20d95bb3f7e7ddf90987279" name="a65ac8924f20d95bb3f7e7ddf90987279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac8924f20d95bb3f7e7ddf90987279">&#9670;&#160;</a></span>makeIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

<p class="reference">Referenced by <a class="el" href="TaintSemantics_8h_source.html#l00097">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance()</a>, <a class="el" href="TaintSemantics_8h_source.html#l00106">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_bottom()</a>, <a class="el" href="TaintSemantics_8h_source.html#l00111">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_undefined()</a>, and <a class="el" href="TaintSemantics_8h_source.html#l00116">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_unspecified()</a>.</p>

</div>
</div>
<a id="ae989f48b7439c3539e06051bbe85e99b" name="ae989f48b7439c3539e06051bbe85e99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae989f48b7439c3539e06051bbe85e99b">&#9670;&#160;</a></span>makeIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a37bd22ad2a0e0fd5984bc175abde22b7" name="a37bd22ad2a0e0fd5984bc175abde22b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bd22ad2a0e0fd5984bc175abde22b7">&#9670;&#160;</a></span>makeIntegerConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIntegerConstant </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

<p class="reference">Referenced by <a class="el" href="TaintSemantics_8h_source.html#l00121">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_integer()</a>.</p>

</div>
</div>
<a id="a6a7f00cd9ad5460dabcb66835d55999a" name="a6a7f00cd9ad5460dabcb66835d55999a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7f00cd9ad5460dabcb66835d55999a">&#9670;&#160;</a></span>makeIntegerConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIntegerConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a5106c46b295fb30748912dab369c08cb" name="a5106c46b295fb30748912dab369c08cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106c46b295fb30748912dab369c08cb">&#9670;&#160;</a></span>makeBooleanConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeBooleanConstant </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="ae45738a2615a7bd7ca268ceb5b1fda16" name="ae45738a2615a7bd7ca268ceb5b1fda16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45738a2615a7bd7ca268ceb5b1fda16">&#9670;&#160;</a></span>makeMemoryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMemoryVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addressWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a88e4c4f98c2c25043a36bf0c1829640c" name="a88e4c4f98c2c25043a36bf0c1829640c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e4c4f98c2c25043a36bf0c1829640c">&#9670;&#160;</a></span>makeMemoryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMemoryVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addressWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="aa31126f80e6aae1a920e0bd15b2d45ea" name="aa31126f80e6aae1a920e0bd15b2d45ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31126f80e6aae1a920e0bd15b2d45ea">&#9670;&#160;</a></span>makeFloatingPointVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeFloatingPointVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a7cc30b46a7f613a7f46fec2eb6c05b20" name="a7cc30b46a7f613a7f46fec2eb6c05b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc30b46a7f613a7f46fec2eb6c05b20">&#9670;&#160;</a></span>makeFloatingPointVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeFloatingPointVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a51371119d7f59db3f06f638c648d8584" name="a51371119d7f59db3f06f638c648d8584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51371119d7f59db3f06f638c648d8584">&#9670;&#160;</a></span>makeFloatingPointConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeFloatingPointConstant </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a78f864d25bf0c944b379f7d89a392cc1" name="a78f864d25bf0c944b379f7d89a392cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f864d25bf0c944b379f7d89a392cc1">&#9670;&#160;</a></span>makeFloatingPointConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeFloatingPointConstant </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="a3f2de6385c1702890e9a7196c4115f62" name="a3f2de6385c1702890e9a7196c4115f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2de6385c1702890e9a7196c4115f62">&#9670;&#160;</a></span>makeFloatingPointNan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::makeFloatingPointNan </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> constructor. </p>
<p>Constructs an expression leaf node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a>. </p>

</div>
</div>
<a id="ae5ceeb4b30f5e41fc1b1385025794280" name="ae5ceeb4b30f5e41fc1b1385025794280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ceeb4b30f5e41fc1b1385025794280">&#9670;&#160;</a></span>makeAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a327c61746ed5dffc5e5f1c0df6628c0e" name="a327c61746ed5dffc5e5f1c0df6628c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c61746ed5dffc5e5f1c0df6628c0e">&#9670;&#160;</a></span>makeAsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeAsr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ab5b65e446dbd3fc12259c8570d209e2f" name="ab5b65e446dbd3fc12259c8570d209e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b65e446dbd3fc12259c8570d209e2f">&#9670;&#160;</a></span>makeAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeAnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="aaebab91385566a4afed4b856f5f4e17c" name="aaebab91385566a4afed4b856f5f4e17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebab91385566a4afed4b856f5f4e17c">&#9670;&#160;</a></span>makeOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeOr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a1a4111daecd344dbbd6ce262288428d9" name="a1a4111daecd344dbbd6ce262288428d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4111daecd344dbbd6ce262288428d9">&#9670;&#160;</a></span>makeXor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeXor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a680c40275ab124849520b2c4ad9a5521" name="a680c40275ab124849520b2c4ad9a5521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680c40275ab124849520b2c4ad9a5521">&#9670;&#160;</a></span>makeConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a970c64aa9a52ec57aaa7af5998453359" name="a970c64aa9a52ec57aaa7af5998453359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970c64aa9a52ec57aaa7af5998453359">&#9670;&#160;</a></span>makeConvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeConvert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ae371b3253c7e63fbbe833e159d5a6471" name="ae371b3253c7e63fbbe833e159d5a6471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae371b3253c7e63fbbe833e159d5a6471">&#9670;&#160;</a></span>makeEq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeEq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a9ec5907b58cbb04e9485ba5cc621b8c9" name="a9ec5907b58cbb04e9485ba5cc621b8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec5907b58cbb04e9485ba5cc621b8c9">&#9670;&#160;</a></span>makeExtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeExtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ad64e1c2f7eb2c84d7ea9f8e2eccf31e7" name="ad64e1c2f7eb2c84d7ea9f8e2eccf31e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64e1c2f7eb2c84d7ea9f8e2eccf31e7">&#9670;&#160;</a></span>makeInvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeInvert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a34d58bcbd7c02bc940cbf6857bf556c9" name="a34d58bcbd7c02bc940cbf6857bf556c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d58bcbd7c02bc940cbf6857bf556c9">&#9670;&#160;</a></span>makeIsInfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a086fd8d57b7658485ed4bdb5bbe6d9e7" name="a086fd8d57b7658485ed4bdb5bbe6d9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086fd8d57b7658485ed4bdb5bbe6d9e7">&#9670;&#160;</a></span>makeIsNan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsNan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a9a0672ebead4d95d654bba44443f21fc" name="a9a0672ebead4d95d654bba44443f21fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0672ebead4d95d654bba44443f21fc">&#9670;&#160;</a></span>makeIsNeg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsNeg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a6809737ad248735d53e2d689d9608073" name="a6809737ad248735d53e2d689d9608073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6809737ad248735d53e2d689d9608073">&#9670;&#160;</a></span>makeIsNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="af416332c1a21676337bbccb07806ceb7" name="af416332c1a21676337bbccb07806ceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af416332c1a21676337bbccb07806ceb7">&#9670;&#160;</a></span>makeIsPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="aca16f31d73f2fcb54f4ba6636b98e026" name="aca16f31d73f2fcb54f4ba6636b98e026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca16f31d73f2fcb54f4ba6636b98e026">&#9670;&#160;</a></span>makeIsSubnorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsSubnorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a9f9e43e302cfe572aa87bd78294f416c" name="a9f9e43e302cfe572aa87bd78294f416c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9e43e302cfe572aa87bd78294f416c">&#9670;&#160;</a></span>makeIte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ae190d4721063895361df284687a07285" name="ae190d4721063895361df284687a07285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae190d4721063895361df284687a07285">&#9670;&#160;</a></span>makeLet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeLet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ada915745c2978a6f0e53f4d5fc23a65c" name="ada915745c2978a6f0e53f4d5fc23a65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada915745c2978a6f0e53f4d5fc23a65c">&#9670;&#160;</a></span>makeLssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeLssb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a8872ae927eee8697d9002b45260389d9" name="a8872ae927eee8697d9002b45260389d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8872ae927eee8697d9002b45260389d9">&#9670;&#160;</a></span>makeMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ab2ff862cc17dd1edeb218b63306b417b" name="ab2ff862cc17dd1edeb218b63306b417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ff862cc17dd1edeb218b63306b417b">&#9670;&#160;</a></span>makeMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a6a68a56ddad947c011bf66b408bb4d80" name="a6a68a56ddad947c011bf66b408bb4d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a68a56ddad947c011bf66b408bb4d80">&#9670;&#160;</a></span>makeMssb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMssb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="abe44c2e192d7ce9d4a68e1e25b0fb9dd" name="abe44c2e192d7ce9d4a68e1e25b0fb9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe44c2e192d7ce9d4a68e1e25b0fb9dd">&#9670;&#160;</a></span>makeMultiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMultiplyAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a03650f1c38adaecfe0f77bf54c9a7943" name="a03650f1c38adaecfe0f77bf54c9a7943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03650f1c38adaecfe0f77bf54c9a7943">&#9670;&#160;</a></span>makeNe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeNe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a2f5e2721b1fde838837c217eadd5d7c7" name="a2f5e2721b1fde838837c217eadd5d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5e2721b1fde838837c217eadd5d7c7">&#9670;&#160;</a></span>makeNegate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeNegate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a1d9d7684299b4838b1e2047d54eacf94" name="a1d9d7684299b4838b1e2047d54eacf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9d7684299b4838b1e2047d54eacf94">&#9670;&#160;</a></span>makeRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a8cc7ad379d6489c20f1e7f04c0085fd6" name="a8cc7ad379d6489c20f1e7f04c0085fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7ad379d6489c20f1e7f04c0085fd6">&#9670;&#160;</a></span>makeReinterpret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeReinterpret </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="abb51e7cdabe634319cc2c3c8a0274a6d" name="abb51e7cdabe634319cc2c3c8a0274a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb51e7cdabe634319cc2c3c8a0274a6d">&#9670;&#160;</a></span>makeRol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeRol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="aefb9433a22f6d029fcaa02ef30127c15" name="aefb9433a22f6d029fcaa02ef30127c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb9433a22f6d029fcaa02ef30127c15">&#9670;&#160;</a></span>makeRor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeRor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a38cab59038d000af3f722ceb05d07cfe" name="a38cab59038d000af3f722ceb05d07cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cab59038d000af3f722ceb05d07cfe">&#9670;&#160;</a></span>makeRound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeRound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a9e26ba8ecb9aa6eee0c036ce97b72238" name="a9e26ba8ecb9aa6eee0c036ce97b72238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e26ba8ecb9aa6eee0c036ce97b72238">&#9670;&#160;</a></span>makeSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a0e8215b84bd3a0d9e4f977ccc575d768" name="a0e8215b84bd3a0d9e4f977ccc575d768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8215b84bd3a0d9e4f977ccc575d768">&#9670;&#160;</a></span>makeSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a19682e3b3e098dab372ac710f3cd7352" name="a19682e3b3e098dab372ac710f3cd7352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19682e3b3e098dab372ac710f3cd7352">&#9670;&#160;</a></span>makeSignedDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a822549e36a2eb9de040fdd66e8e89e86" name="a822549e36a2eb9de040fdd66e8e89e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822549e36a2eb9de040fdd66e8e89e86">&#9670;&#160;</a></span>makeSignExtend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignExtend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a52205f68410928d7e9fd9f46c645e99c" name="a52205f68410928d7e9fd9f46c645e99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52205f68410928d7e9fd9f46c645e99c">&#9670;&#160;</a></span>makeSignedGe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedGe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a68bd1708650ff5504e857a0d915f601c" name="a68bd1708650ff5504e857a0d915f601c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bd1708650ff5504e857a0d915f601c">&#9670;&#160;</a></span>makeSignedGt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedGt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a5ab57037f4980692cae6909acc03a706" name="a5ab57037f4980692cae6909acc03a706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab57037f4980692cae6909acc03a706">&#9670;&#160;</a></span>makeShl0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeShl0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a8c385dbffc9e110d2e85fa680af4b026" name="a8c385dbffc9e110d2e85fa680af4b026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c385dbffc9e110d2e85fa680af4b026">&#9670;&#160;</a></span>makeShl1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeShl1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="abe406ca3cd19d8ad0763a7c942f445e4" name="abe406ca3cd19d8ad0763a7c942f445e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe406ca3cd19d8ad0763a7c942f445e4">&#9670;&#160;</a></span>makeShr0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeShr0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="aa3dceac275b48cd62cd83a0933705722" name="aa3dceac275b48cd62cd83a0933705722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dceac275b48cd62cd83a0933705722">&#9670;&#160;</a></span>makeShr1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeShr1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a18c967d3e6950a5acf01536318a3a346" name="a18c967d3e6950a5acf01536318a3a346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c967d3e6950a5acf01536318a3a346">&#9670;&#160;</a></span>makeIsSignedPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeIsSignedPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a00d4b41da8f5fd90983f4cb87d17e200" name="a00d4b41da8f5fd90983f4cb87d17e200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d4b41da8f5fd90983f4cb87d17e200">&#9670;&#160;</a></span>makeSignedLe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedLe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="aac6413112b14225fbfa70a946cb8b3eb" name="aac6413112b14225fbfa70a946cb8b3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6413112b14225fbfa70a946cb8b3eb">&#9670;&#160;</a></span>makeSignedLt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedLt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ad7a42b0aa6a75ab4933973295d59dd94" name="ad7a42b0aa6a75ab4933973295d59dd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a42b0aa6a75ab4933973295d59dd94">&#9670;&#160;</a></span>makeSignedMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a9ec6449681d66b68904043b3e4a32afa" name="a9ec6449681d66b68904043b3e4a32afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec6449681d66b68904043b3e4a32afa">&#9670;&#160;</a></span>makeSignedMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ad436c9a316a419ba3a3fd28ccaabc99b" name="ad436c9a316a419ba3a3fd28ccaabc99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad436c9a316a419ba3a3fd28ccaabc99b">&#9670;&#160;</a></span>makeSignedMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a8a7100d58565211efc6202eea6547336" name="a8a7100d58565211efc6202eea6547336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7100d58565211efc6202eea6547336">&#9670;&#160;</a></span>makeSignedMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSignedMul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ac63281193fde848694d4988aa066180c" name="ac63281193fde848694d4988aa066180c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63281193fde848694d4988aa066180c">&#9670;&#160;</a></span>makeSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeSqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ab0e5cbbcb0cafa067befe02813e0fb3c" name="ab0e5cbbcb0cafa067befe02813e0fb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e5cbbcb0cafa067befe02813e0fb3c">&#9670;&#160;</a></span>makeDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a40db50e5f6b1f341453c0d57cbdf4e34" name="a40db50e5f6b1f341453c0d57cbdf4e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40db50e5f6b1f341453c0d57cbdf4e34">&#9670;&#160;</a></span>makeExtend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeExtend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a673feccdef7f890355c708c5a83cb47e" name="a673feccdef7f890355c708c5a83cb47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673feccdef7f890355c708c5a83cb47e">&#9670;&#160;</a></span>makeGe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeGe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ad40f726fa91af72b61a331c7093631d5" name="ad40f726fa91af72b61a331c7093631d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40f726fa91af72b61a331c7093631d5">&#9670;&#160;</a></span>makeGt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeGt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a57cdc8d0c1920de445b142665522a035" name="a57cdc8d0c1920de445b142665522a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cdc8d0c1920de445b142665522a035">&#9670;&#160;</a></span>makeLe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeLe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a79fbe37a90f2ae569b14ae3598b2d699" name="a79fbe37a90f2ae569b14ae3598b2d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbe37a90f2ae569b14ae3598b2d699">&#9670;&#160;</a></span>makeLt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeLt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a46ad8aa835451a974c6ddf92ab3d179d" name="a46ad8aa835451a974c6ddf92ab3d179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ad8aa835451a974c6ddf92ab3d179d">&#9670;&#160;</a></span>makeMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a795f67bec6731821a787d82fdf283475" name="a795f67bec6731821a787d82fdf283475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795f67bec6731821a787d82fdf283475">&#9670;&#160;</a></span>makeMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeMul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ac899e4effbc98c929b3770cd10aa21d6" name="ac899e4effbc98c929b3770cd10aa21d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac899e4effbc98c929b3770cd10aa21d6">&#9670;&#160;</a></span>makeWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeWrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="ac99ed01a83ef6e2fdfc505f7ac53145c" name="ac99ed01a83ef6e2fdfc505f7ac53145c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99ed01a83ef6e2fdfc505f7ac53145c">&#9670;&#160;</a></span>makeZerop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::makeZerop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node constructor. </p>
<p>Constructs an interior node. This is a wrapper around one of the "create" factory methods in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a>. It interprets its operands as unsigned values unless the method has "Signed" in its name. </p>

</div>
</div>
<a id="a86976fbdf5d2570451256f78c324f772" name="a86976fbdf5d2570451256f78c324f772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86976fbdf5d2570451256f78c324f772">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a> Rose::BinaryAnalysis::SymbolicExpression::hash </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash zero or more expressions. </p>
<p>Computes the hash for each expression, then returns a single has which is a function of the individual hashes. The order of the expressions does not affect the returned hash. </p>

<p class="reference">References <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a86976fbdf5d2570451256f78c324f772">hash()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a86976fbdf5d2570451256f78c324f772">hash()</a>.</p>

</div>
</div>
<a id="a82505edb1e6c7f7131a6f9f9fa5c9da6" name="a82505edb1e6c7f7131a6f9f9fa5c9da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82505edb1e6c7f7131a6f9f9fa5c9da6">&#9670;&#160;</a></span>nNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Rose::BinaryAnalysis::SymbolicExpression::nNodes </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes. </p>
<p>Counts the total number of nodes in multiple expressions. The return value is a saturated sum, returning MAX_NNODES if an overflow occurs. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01540">1540</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a3324ec137e999a2aa28b48ae4230cc4a">MAX_NNODES</a>.</p>

</div>
</div>
<a id="a8cff9e5d7595f13d31d4039a97755c21" name="a8cff9e5d7595f13d31d4039a97755c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cff9e5d7595f13d31d4039a97755c21">&#9670;&#160;</a></span>nNodesUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Rose::BinaryAnalysis::SymbolicExpression::nNodesUnique </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of unique nodes. </p>
<p>Counts the number of unique nodes across a number of expressions. Nodes shared between two expressions are counted only one time, whereas the Node::nnodes virtual method counts shared nodes multiple times. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01559">1559</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00184">CONTINUE</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00186">TERMINATE</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00185">TRUNCATE</a>.</p>

</div>
</div>
<a id="affe5d278bc4c7cda4a0336b04eb36c2f" name="affe5d278bc4c7cda4a0336b04eb36c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe5d278bc4c7cda4a0336b04eb36c2f">&#9670;&#160;</a></span>findCommonSubexpressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; Rose::BinaryAnalysis::SymbolicExpression::findCommonSubexpressions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find common subexpressions. </p>
<p>This is similar to <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae606f125a10a3787b5c8d615c25a1445">Node::findCommonSubexpressions</a> except the analysis is over a collection of expressions rather than a single expression. </p>

</div>
</div>
<a id="a7513beee55125b0061353a9b20fa5b3a" name="a7513beee55125b0061353a9b20fa5b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7513beee55125b0061353a9b20fa5b3a">&#9670;&#160;</a></span>findCommonSubexpressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; Rose::BinaryAnalysis::SymbolicExpression::findCommonSubexpressions </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find common subexpressions. </p>
<p>This is similar to <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae606f125a10a3787b5c8d615c25a1445">Node::findCommonSubexpressions</a> except the analysis is over a collection of expressions rather than a single expression. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01600">1600</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00184">CONTINUE</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00185">TRUNCATE</a>.</p>

</div>
</div>
<a id="af4502c29e487ba74487b929e67e525c0" name="af4502c29e487ba74487b929e67e525c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4502c29e487ba74487b929e67e525c0">&#9670;&#160;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Substitution &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Substitution &amp;&#160;</td>
          <td class="paramname"><em>subber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On-the-fly substitutions. </p>
<p>This function uses a user-defined substitutor to generate values that are substituted into the specified expression. This operates by performing a depth-first search of the specified expression and calling the <code>subber</code> at each node. The <code>subber</code> is invoked with two arguments: an expression to be replaced, and an optional SMT solver for simplifications. It should return either the expression unmodified, or a new expression. The return value of the <code>substitute</code> function as a whole is either the original expression (if no substitutions were performed) or a new expression. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01633">1633</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l01140">Rose::BinaryAnalysis::SymbolicExpression::Interior::children()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00698">Rose::BinaryAnalysis::SymbolicExpression::Node::comment()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00732">Rose::BinaryAnalysis::SymbolicExpression::Node::flags()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l01141">Rose::BinaryAnalysis::SymbolicExpression::Interior::getOperator()</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a974a14e7e92ebc4d87dc771050fb0093">Rose::BinaryAnalysis::SymbolicExpression::Interior::instance()</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aaca4b0d89020fd62390ae12d88231f1a">Rose::BinaryAnalysis::SymbolicExpression::Node::isInteriorNodeRaw()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l01142">Rose::BinaryAnalysis::SymbolicExpression::Interior::nChildren()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l01633">substitute()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">substitute()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad45aae9df42d8cee4894fa751b8cd153" name="ad45aae9df42d8cee4894fa751b8cd153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45aae9df42d8cee4894fa751b8cd153">&#9670;&#160;</a></span>serializeVariableIds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::serializeVariableIds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to serialize variable IDs. </p>
<p>If set, then all threads will coordinate so that variable IDs are allocated in a monotonic fashion. This should only be set when necessary in order to make test results more deterministic. The default is to clear, which means variable IDs are allocated from some number of pools in order to reduce lock contention.</p>
<p>Thread safety: This property is not thread safe. If reproducible results are desired, it should be set before any analysis begins. </p>

</div>
</div>
<a id="a3324ec137e999a2aa28b48ae4230cc4a" name="a3324ec137e999a2aa28b48ae4230cc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3324ec137e999a2aa28b48ae4230cc4a">&#9670;&#160;</a></span>MAX_NNODES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t Rose::BinaryAnalysis::SymbolicExpression::MAX_NNODES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of nodes that can be reported. </p>
<p>If <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a82505edb1e6c7f7131a6f9f9fa5c9da6">nNodes</a> returns this value then the size of the expressions could not be counted. This can happens when the expression contains a large number of common subexpressions. </p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01540">nNodes()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
