<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: SageInterface::Ada Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSageInterface.html">SageInterface</a></li><li class="navelem"><a class="el" href="namespaceSageInterface_1_1Ada.html">Ada</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SageInterface::Ada Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Contains Ada-specific functionality. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1AggregateInfo.html">AggregateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1DominantArgInfo.html">DominantArgInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1FlatArrayType.html">FlatArrayType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a branch in an if elsif else context (either statement or expression).  <a href="structSageInterface_1_1Ada_1_1IfInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1ImportedUnitResult.html">ImportedUnitResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1OperatorScopeInfo.html">OperatorScopeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveSignatureElementsDesc.html">PrimitiveSignatureElementsDesc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1RecordField.html">RecordField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1ScopePath.html">ScopePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a path from an innermost scope to the global scope (not part of the path) in form of a sequence of Sage nodes that represent scopes (SgScopeStatements or SgDeclarationStatements).  <a href="structSageInterface_1_1Ada_1_1ScopePath.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a39ed43f025178691dd0a7ed797fb7a53" id="r_a39ed43f025178691dd0a7ed797fb7a53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a39ed43f025178691dd0a7ed797fb7a53">StatementRange</a> = std::pair&lt; SgDeclarationStatementPtrList::iterator, SgDeclarationStatementPtrList::iterator &gt;</td></tr>
<tr class="separator:a39ed43f025178691dd0a7ed797fb7a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6548c20f85b05fb5dfc6a5fd8014ea6d" id="r_a6548c20f85b05fb5dfc6a5fd8014ea6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a6548c20f85b05fb5dfc6a5fd8014ea6d">FlatArrayTypeBase</a> = std::tuple&lt; <a class="el" href="classSgArrayType.html">SgArrayType</a> *, std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &gt;</td></tr>
<tr class="memdesc:a6548c20f85b05fb5dfc6a5fd8014ea6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the result type for <a class="el" href="namespaceSageInterface_1_1Ada.html#a13d519022548c649c679d3265dc6daf8">getArrayTypeInfo</a>  <br /></td></tr>
<tr class="separator:a6548c20f85b05fb5dfc6a5fd8014ea6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4252fcab8fb06f59ca5b0b18c3247" id="r_ab5f4252fcab8fb06f59ca5b0b18c3247"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ab5f4252fcab8fb06f59ca5b0b18c3247">RecordFieldBase</a> = std::tuple&lt; const <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt;</td></tr>
<tr class="separator:ab5f4252fcab8fb06f59ca5b0b18c3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39e794e02d47f7b208fdf5a7426319f" id="r_ab39e794e02d47f7b208fdf5a7426319f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ab39e794e02d47f7b208fdf5a7426319f">IfExpressionInfo</a> = <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfInfo</a>&lt; <a class="el" href="classSgExpression.html">SgExpression</a> &gt;</td></tr>
<tr class="memdesc:ab39e794e02d47f7b208fdf5a7426319f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a sequence of if (x) then value the last else does not have  <br /></td></tr>
<tr class="separator:ab39e794e02d47f7b208fdf5a7426319f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc60b817b86878e52fd7c3414f65f43" id="r_afcc60b817b86878e52fd7c3414f65f43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#afcc60b817b86878e52fd7c3414f65f43">IfStatementInfo</a> = <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfInfo</a>&lt; <a class="el" href="classSgStatement.html">SgStatement</a> &gt;</td></tr>
<tr class="separator:afcc60b817b86878e52fd7c3414f65f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9e7583bb754823bde7a34f74aeb022" id="r_aae9e7583bb754823bde7a34f74aeb022"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aae9e7583bb754823bde7a34f74aeb022">TypeDescriptionBase</a> = std::tuple&lt; <a class="el" href="classSgType.html">SgType</a> *, bool, std::vector&lt; <a class="el" href="classSgAdaTypeConstraint.html">SgAdaTypeConstraint</a> * &gt; &gt;</td></tr>
<tr class="separator:aae9e7583bb754823bde7a34f74aeb022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79edadfdbe63f0a0b9934bdf4b813763" id="r_a79edadfdbe63f0a0b9934bdf4b813763"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a79edadfdbe63f0a0b9934bdf4b813763">DominantArgInfoBase</a> = std::tuple&lt; const <a class="el" href="classSgType.html">SgType</a> *, std::size_t &gt;</td></tr>
<tr class="separator:a79edadfdbe63f0a0b9934bdf4b813763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af782e1f4fc3c807078f99d1c19ce98c3" id="r_af782e1f4fc3c807078f99d1c19ce98c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#af782e1f4fc3c807078f99d1c19ce98c3">OperatorScopeInfoBase</a> = std::tuple&lt; <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *, std::size_t &gt;</td></tr>
<tr class="separator:af782e1f4fc3c807078f99d1c19ce98c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a72892d9db8da2f0bca0e42b9b325d" id="r_a99a72892d9db8da2f0bca0e42b9b325d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a99a72892d9db8da2f0bca0e42b9b325d">ImportedUnitResultBase</a> = std::tuple&lt; std::string, const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *, const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> *, const <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;</td></tr>
<tr class="memdesc:a99a72892d9db8da2f0bca0e42b9b325d"><td class="mdescLeft">&#160;</td><td class="mdescRight">describes properties of imported units  <br /></td></tr>
<tr class="separator:a99a72892d9db8da2f0bca0e42b9b325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216e92709b73977d9503c4ffabd49040" id="r_a216e92709b73977d9503c4ffabd49040"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a216e92709b73977d9503c4ffabd49040">AggregateInfoBase</a> = std::tuple&lt; <a class="el" href="classSgAdaAncestorInitializer.html">SgAdaAncestorInitializer</a> *, SgExpressionPtrList::const_iterator, SgExpressionPtrList::const_iterator &gt;</td></tr>
<tr class="memdesc:a216e92709b73977d9503c4ffabd49040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of expression aggregates.  <br /></td></tr>
<tr class="separator:a216e92709b73977d9503c4ffabd49040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f97940b7aa0be08a83e90ee66634d3d" id="r_a5f97940b7aa0be08a83e90ee66634d3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a5f97940b7aa0be08a83e90ee66634d3d">PrimitiveParameterDescBase</a> = std::tuple&lt; size_t, const <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *, const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt;</td></tr>
<tr class="separator:a5f97940b7aa0be08a83e90ee66634d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1497394bca37288a880aa4e54faffe0e" id="r_a1497394bca37288a880aa4e54faffe0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a1497394bca37288a880aa4e54faffe0e">PrimitiveSignatureElementsDescBase</a> = std::tuple&lt; const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *, std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; &gt;</td></tr>
<tr class="separator:a1497394bca37288a880aa4e54faffe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1996f0b925ab7c494f5be9a840af0083" id="r_a1996f0b925ab7c494f5be9a840af0083"><td class="memItemLeft" align="right" valign="top"><a id="a1996f0b925ab7c494f5be9a840af0083" name="a1996f0b925ab7c494f5be9a840af0083"></a>
<a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>declOf</b> (const <a class="el" href="classSgEnumVal.html">SgEnumVal</a> &amp;)</td></tr>
<tr class="memdesc:a1996f0b925ab7c494f5be9a840af0083"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration of the enum value <br /></td></tr>
<tr class="separator:a1996f0b925ab7c494f5be9a840af0083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f4088bc7dd9035b8a747c7a10b586" id="r_a286f4088bc7dd9035b8a747c7a10b586"><td class="memItemLeft" align="right" valign="top"><a id="a286f4088bc7dd9035b8a747c7a10b586" name="a286f4088bc7dd9035b8a747c7a10b586"></a>
std::vector&lt; <a class="el" href="namespaceSageInterface_1_1Ada.html#ab39e794e02d47f7b208fdf5a7426319f">IfExpressionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>flattenIfExpressions</b> (const <a class="el" href="classSgConditionalExp.html">SgConditionalExp</a> &amp;n)</td></tr>
<tr class="memdesc:a286f4088bc7dd9035b8a747c7a10b586"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flat representation of if expressions <br /></td></tr>
<tr class="separator:a286f4088bc7dd9035b8a747c7a10b586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e974cf29582e59c77f3bb28be3136e0" id="r_a9e974cf29582e59c77f3bb28be3136e0"><td class="memItemLeft" align="right" valign="top"><a id="a9e974cf29582e59c77f3bb28be3136e0" name="a9e974cf29582e59c77f3bb28be3136e0"></a>
std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfStatementInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>flattenIfStatements</b> (const <a class="el" href="classSgIfStmt.html">SgIfStmt</a> &amp;n)</td></tr>
<tr class="memdesc:a9e974cf29582e59c77f3bb28be3136e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flat representation of if-elsif-else statements <br /></td></tr>
<tr class="separator:a9e974cf29582e59c77f3bb28be3136e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f038b25d6131023783344583145c4f" id="r_af6f038b25d6131023783344583145c4f"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#af6f038b25d6131023783344583145c4f">staticIntegralValue</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *n)</td></tr>
<tr class="memdesc:af6f038b25d6131023783344583145c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer constant folding  <br /></td></tr>
<tr class="separator:af6f038b25d6131023783344583145c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed72b22f1015cf95d31d04eebe29a4a" id="r_a3ed72b22f1015cf95d31d04eebe29a4a"><td class="memItemLeft" align="right" valign="top"><a id="a3ed72b22f1015cf95d31d04eebe29a4a" name="a3ed72b22f1015cf95d31d04eebe29a4a"></a>
<a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>underlyingExpr</b> (const <a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>
<tr class="memdesc:a3ed72b22f1015cf95d31d04eebe29a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the expression of an expression statement, or nullptr if s is some other node <br /></td></tr>
<tr class="separator:a3ed72b22f1015cf95d31d04eebe29a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade17c71e72b49bb8af4af5351125d9e7" id="r_ade17c71e72b49bb8af4af5351125d9e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ade17c71e72b49bb8af4af5351125d9e7">correspondingBody</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>
<tr class="memdesc:ade17c71e72b49bb8af4af5351125d9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the body scope (aka definition) of a task, package, or protected object.  <br /></td></tr>
<tr class="separator:ade17c71e72b49bb8af4af5351125d9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf229b421ad27ce7bdb3d689ba3a618" id="r_accf229b421ad27ce7bdb3d689ba3a618"><td class="memItemLeft" align="right" valign="top"><a id="accf229b421ad27ce7bdb3d689ba3a618" name="accf229b421ad27ce7bdb3d689ba3a618"></a>
<a class="el" href="structSageInterface_1_1Ada_1_1DominantArgInfo.html">DominantArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operatorArgumentWithNamedRootIfAvail</b> (const SgTypePtrList &amp;argtypes)</td></tr>
<tr class="separator:accf229b421ad27ce7bdb3d689ba3a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666b446147ccf3900b57445ab9d700ed" id="r_a666b446147ccf3900b57445ab9d700ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1OperatorScopeInfo.html">OperatorScopeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a666b446147ccf3900b57445ab9d700ed">operatorScope</a> (const std::string &amp;opname, const SgTypePtrList &amp;argtypes)</td></tr>
<tr class="memdesc:a666b446147ccf3900b57445ab9d700ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scope where an operator with name opname and argument types in argtypes shall be declared.  <br /></td></tr>
<tr class="separator:a666b446147ccf3900b57445ab9d700ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea781509b597632d66296e2a9bf13034" id="r_aea781509b597632d66296e2a9bf13034"><td class="memItemLeft" align="right" valign="top"><a id="aea781509b597632d66296e2a9bf13034" name="aea781509b597632d66296e2a9bf13034"></a>
std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1ImportedUnitResult.html">ImportedUnitResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>importedUnits</b> (const <a class="el" href="classSgImportStatement.html">SgImportStatement</a> &amp;impdcl)</td></tr>
<tr class="memdesc:aea781509b597632d66296e2a9bf13034"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries properties of all units in an import statement <br /></td></tr>
<tr class="separator:aea781509b597632d66296e2a9bf13034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421635578b633976a995e893348cf80d" id="r_a421635578b633976a995e893348cf80d"><td class="memItemLeft" align="right" valign="top"><a id="a421635578b633976a995e893348cf80d" name="a421635578b633976a995e893348cf80d"></a>
<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pkgStandardScope</b> ()</td></tr>
<tr class="memdesc:a421635578b633976a995e893348cf80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not use, this is temporary <br /></td></tr>
<tr class="separator:a421635578b633976a995e893348cf80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3da93712b3ff8241449970492506b5" id="r_afb3da93712b3ff8241449970492506b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#afb3da93712b3ff8241449970492506b5">convertRoseOperatorNameToAdaName</a> (const std::string &amp;nameInRose)</td></tr>
<tr class="memdesc:afb3da93712b3ff8241449970492506b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes a function name as used in ROSE and converts it to a name in <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> (i.e., '"' + operator_text + '"').  <br /></td></tr>
<tr class="separator:afb3da93712b3ff8241449970492506b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03100a789221c2132c9f86639bcd75b0" id="r_a03100a789221c2132c9f86639bcd75b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a03100a789221c2132c9f86639bcd75b0">convertRoseOperatorNameToAdaOperator</a> (const std::string &amp;nameInRose)</td></tr>
<tr class="memdesc:a03100a789221c2132c9f86639bcd75b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes a function name as used in ROSE and converts it to an operator in <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> (i.e., operator_text).  <br /></td></tr>
<tr class="separator:a03100a789221c2132c9f86639bcd75b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2569a904245da73749a35028e90f0cec" id="r_a2569a904245da73749a35028e90f0cec"><td class="memItemLeft" align="right" valign="top">SgExpressionPtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a2569a904245da73749a35028e90f0cec">normalizedCallArguments2</a> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;n, const <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> &amp;arglist, bool withDefaultArguments=false)</td></tr>
<tr class="memdesc:a2569a904245da73749a35028e90f0cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a list of arguments with named arguments placed at the correct position by taking into account the supplied argument list.  <br /></td></tr>
<tr class="separator:a2569a904245da73749a35028e90f0cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7b4fc1dc863cc824e14a8607c3847" id="r_ac5a7b4fc1dc863cc824e14a8607c3847"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ac5a7b4fc1dc863cc824e14a8607c3847">normalizedArgumentPosition</a> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;call, const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;arg)</td></tr>
<tr class="memdesc:ac5a7b4fc1dc863cc824e14a8607c3847"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parameter position of arg in the callee, after the parameters have been normalized.  <br /></td></tr>
<tr class="separator:ac5a7b4fc1dc863cc824e14a8607c3847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec43bef5ee4d41fcc89cd4f137b62f3" id="r_a7ec43bef5ee4d41fcc89cd4f137b62f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a7ec43bef5ee4d41fcc89cd4f137b62f3">canonicalScope</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>
<tr class="memdesc:a7ec43bef5ee4d41fcc89cd4f137b62f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the canonical scope of some <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> scope scope.  <br /></td></tr>
<tr class="separator:a7ec43bef5ee4d41fcc89cd4f137b62f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39468d93a4f8a48c79e3dd705fa305" id="r_a9b39468d93a4f8a48c79e3dd705fa305"><td class="memItemLeft" align="right" valign="top"><a id="a9b39468d93a4f8a48c79e3dd705fa305" name="a9b39468d93a4f8a48c79e3dd705fa305"></a>
const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>canonicalScope</b> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;scope)</td></tr>
<tr class="separator:a9b39468d93a4f8a48c79e3dd705fa305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f89346521bcc1e8879a058322c6f2" id="r_ad31f89346521bcc1e8879a058322c6f2"><td class="memItemLeft" align="right" valign="top"><a id="ad31f89346521bcc1e8879a058322c6f2" name="ad31f89346521bcc1e8879a058322c6f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sameCanonicalScope</b> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *lhs, const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *rhs)</td></tr>
<tr class="memdesc:ad31f89346521bcc1e8879a058322c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if lhs and have the same canonical scope. <br /></td></tr>
<tr class="separator:ad31f89346521bcc1e8879a058322c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d20b0266650545d7cdc61a62d6956" id="r_a4e8d20b0266650545d7cdc61a62d6956"><td class="memItemLeft" align="right" valign="top"><a id="a4e8d20b0266650545d7cdc61a62d6956" name="a4e8d20b0266650545d7cdc61a62d6956"></a>
<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>associatedDeclaration</b> (const <a class="el" href="classSgSymbol.html">SgSymbol</a> &amp;n)</td></tr>
<tr class="memdesc:a4e8d20b0266650545d7cdc61a62d6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the associated declaration for symbol n or nullptr if there is none. <br /></td></tr>
<tr class="separator:a4e8d20b0266650545d7cdc61a62d6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585cf1441796b0c5da6a35378858bdc5" id="r_a585cf1441796b0c5da6a35378858bdc5"><td class="memItemLeft" align="right" valign="top"><a id="a585cf1441796b0c5da6a35378858bdc5" name="a585cf1441796b0c5da6a35378858bdc5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>explicitNullProcedure</b> (const <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> &amp;fndef)</td></tr>
<tr class="memdesc:a585cf1441796b0c5da6a35378858bdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff fndef is the body of an explicit null procedure <br /></td></tr>
<tr class="separator:a585cf1441796b0c5da6a35378858bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6524384260ff97c6cc5ac9f9edbbabec" id="r_a6524384260ff97c6cc5ac9f9edbbabec"><td class="memItemLeft" align="right" valign="top"><a id="a6524384260ff97c6cc5ac9f9edbbabec" name="a6524384260ff97c6cc5ac9f9edbbabec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>explicitNullRecord</b> (const <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> &amp;recdef)</td></tr>
<tr class="memdesc:a6524384260ff97c6cc5ac9f9edbbabec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff recdef is the body of an explicit null record <br /></td></tr>
<tr class="separator:a6524384260ff97c6cc5ac9f9edbbabec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c243d611beb468ad657b01b61e89a2b" id="r_a1c243d611beb468ad657b01b61e89a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a1c243d611beb468ad657b01b61e89a2b">findPubliclyVisibleFunction</a> (<a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> &amp;fnsym, const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> &amp;drvFunTy, const <a class="el" href="classSgNamedType.html">SgNamedType</a> &amp;dervTy)</td></tr>
<tr class="memdesc:a1c243d611beb468ad657b01b61e89a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the function symbol for a publicly accessible function.  <br /></td></tr>
<tr class="separator:a1c243d611beb468ad657b01b61e89a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a246be22e50a29413878c890d16e05" id="r_a97a246be22e50a29413878c890d16e05"><td class="memItemLeft" align="right" valign="top"><a id="a97a246be22e50a29413878c890d16e05" name="a97a246be22e50a29413878c890d16e05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAttribute</b> (const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> &amp;attr, const std::string &amp;attrname)</td></tr>
<tr class="memdesc:a97a246be22e50a29413878c890d16e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if attr is an attribute with name attrname. <br /></td></tr>
<tr class="separator:a97a246be22e50a29413878c890d16e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f93a79f26d12b97940e33f5e152da" id="r_a390f93a79f26d12b97940e33f5e152da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a390f93a79f26d12b97940e33f5e152da">isAnyAccessAttribute</a> (const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> &amp;attr)</td></tr>
<tr class="memdesc:a390f93a79f26d12b97940e33f5e152da"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if attr is an access attribute  <br /></td></tr>
<tr class="separator:a390f93a79f26d12b97940e33f5e152da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c796b3ca2cea689577b4e679681a9" id="r_a3c5c796b3ca2cea689577b4e679681a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3c5c796b3ca2cea689577b4e679681a9">isPragma</a> (const <a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> &amp;prgdcl, const std::string &amp;pragmaname)</td></tr>
<tr class="memdesc:a3c5c796b3ca2cea689577b4e679681a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if prgdcl is a pragma with name pragmaname.  <br /></td></tr>
<tr class="separator:a3c5c796b3ca2cea689577b4e679681a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453405acea37406743447a81deaa8c1" id="r_ad453405acea37406743447a81deaa8c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1ScopePath.html">ScopePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ad453405acea37406743447a81deaa8c1">pathToGlobal</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;n)</td></tr>
<tr class="memdesc:ad453405acea37406743447a81deaa8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a path from a scope statement to the top-level (global) scope.  <br /></td></tr>
<tr class="separator:ad453405acea37406743447a81deaa8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acb935e5eb9b7dbe781e62fa6ac090691" id="r_acb935e5eb9b7dbe781e62fa6ac090691"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#acb935e5eb9b7dbe781e62fa6ac090691">withPrivateDefinition</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *dcl)</td></tr>
<tr class="memdesc:acb935e5eb9b7dbe781e62fa6ac090691"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the declaration dcl defines a public type that is completed in a private section.  <br /></td></tr>
<tr class="separator:acb935e5eb9b7dbe781e62fa6ac090691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22de8acdeaf25645583ba63b029bf52d" id="r_a22de8acdeaf25645583ba63b029bf52d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a22de8acdeaf25645583ba63b029bf52d">withPrivateDefinition</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;dcl)</td></tr>
<tr class="memdesc:a22de8acdeaf25645583ba63b029bf52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the declaration dcl defines a public type that is completed in a private section.  <br /></td></tr>
<tr class="separator:a22de8acdeaf25645583ba63b029bf52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6954eea873cab61563a06932b41b60ef" id="r_a6954eea873cab61563a06932b41b60ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a6954eea873cab61563a06932b41b60ef">unconstrained</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> *ty)</td></tr>
<tr class="memdesc:a6954eea873cab61563a06932b41b60ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if ty is an unconstrained array  <br /></td></tr>
<tr class="separator:a6954eea873cab61563a06932b41b60ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ccba1cb54129a2b33caa4f5d26ce8d" id="r_a83ccba1cb54129a2b33caa4f5d26ce8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a83ccba1cb54129a2b33caa4f5d26ce8d">unconstrained</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;ty)</td></tr>
<tr class="memdesc:a83ccba1cb54129a2b33caa4f5d26ce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if ty is an unconstrained array  <br /></td></tr>
<tr class="separator:a83ccba1cb54129a2b33caa4f5d26ce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9424a600fefabb399d539ad37e6fe1e3" id="r_a9424a600fefabb399d539ad37e6fe1e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a9424a600fefabb399d539ad37e6fe1e3">anonymousAccess</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a9424a600fefabb399d539ad37e6fe1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if ty is an anonymous access type  <br /></td></tr>
<tr class="separator:a9424a600fefabb399d539ad37e6fe1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9454966a8be4254165d15aae57f0aceb" id="r_a9454966a8be4254165d15aae57f0aceb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a9454966a8be4254165d15aae57f0aceb">anonymousAccess</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a9454966a8be4254165d15aae57f0aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if ty is an anonymous access type  <br /></td></tr>
<tr class="separator:a9454966a8be4254165d15aae57f0aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a238a5f41854aea8040ce63f778b63a76" id="r_a238a5f41854aea8040ce63f778b63a76"><td class="memItemLeft" align="right" valign="top">StatementRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a238a5f41854aea8040ce63f778b63a76">declsInPackage</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> &amp;globalScope, const std::string &amp;mainFile)</td></tr>
<tr class="memdesc:a238a5f41854aea8040ce63f778b63a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all statements/declarations in the global scope that were defined in the source file.  <br /></td></tr>
<tr class="separator:a238a5f41854aea8040ce63f778b63a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fe120df66ef58ee7b0b83709f9a87d" id="r_a92fe120df66ef58ee7b0b83709f9a87d"><td class="memItemLeft" align="right" valign="top">StatementRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a92fe120df66ef58ee7b0b83709f9a87d">declsInPackage</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> &amp;globalScope, const <a class="el" href="classSgSourceFile.html">SgSourceFile</a> &amp;mainFile)</td></tr>
<tr class="memdesc:a92fe120df66ef58ee7b0b83709f9a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all statements/declarations in the global scope that were defined in the source file.  <br /></td></tr>
<tr class="separator:a92fe120df66ef58ee7b0b83709f9a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac805f44de5f531f30e099676787ebfa1" id="r_ac805f44de5f531f30e099676787ebfa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ac805f44de5f531f30e099676787ebfa1">firstLastDimension</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;args)</td></tr>
<tr class="memdesc:ac805f44de5f531f30e099676787ebfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an integer value for args[0] as used by type attributes first and last  <br /></td></tr>
<tr class="separator:ac805f44de5f531f30e099676787ebfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d59bba127eb06f7e6c1e252506a335b" id="r_a5d59bba127eb06f7e6c1e252506a335b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a5d59bba127eb06f7e6c1e252506a335b">firstLastDimension</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> *args)</td></tr>
<tr class="memdesc:a5d59bba127eb06f7e6c1e252506a335b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an integer value for args[0] as used by type attributes first and last  <br /></td></tr>
<tr class="separator:a5d59bba127eb06f7e6c1e252506a335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a13d519022548c649c679d3265dc6daf8" id="r_a13d519022548c649c679d3265dc6daf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1FlatArrayType.html">FlatArrayType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a13d519022548c649c679d3265dc6daf8">getArrayTypeInfo</a> (<a class="el" href="classSgType.html">SgType</a> *atype)</td></tr>
<tr class="memdesc:a13d519022548c649c679d3265dc6daf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flattened representation of <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> array types.  <br /></td></tr>
<tr class="separator:a13d519022548c649c679d3265dc6daf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13edf625d219f241287b67626f4d786" id="r_aa13edf625d219f241287b67626f4d786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1FlatArrayType.html">FlatArrayType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa13edf625d219f241287b67626f4d786">getArrayTypeInfo</a> (<a class="el" href="classSgType.html">SgType</a> &amp;atype)</td></tr>
<tr class="memdesc:aa13edf625d219f241287b67626f4d786"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flattened representation of <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> array types.  <br /></td></tr>
<tr class="separator:aa13edf625d219f241287b67626f4d786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafe16cbbbd9700b49c52241d6a947262" id="r_aafe16cbbbd9700b49c52241d6a947262"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1RecordField.html">RecordField</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aafe16cbbbd9700b49c52241d6a947262">getAllRecordFields</a> (const <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> &amp;rec)</td></tr>
<tr class="memdesc:aafe16cbbbd9700b49c52241d6a947262"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all fields (defined and inherited) of a record.  <br /></td></tr>
<tr class="separator:aafe16cbbbd9700b49c52241d6a947262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f739c1b8b369e252737fc0ad1c6e7dd" id="r_a3f739c1b8b369e252737fc0ad1c6e7dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1RecordField.html">RecordField</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3f739c1b8b369e252737fc0ad1c6e7dd">getAllRecordFields</a> (const <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> *rec)</td></tr>
<tr class="memdesc:a3f739c1b8b369e252737fc0ad1c6e7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all fields (defined and inherited) of a record.  <br /></td></tr>
<tr class="separator:a3f739c1b8b369e252737fc0ad1c6e7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9b5b0fe1ed4763a8168f940d626d4fd5" id="r_a9b5b0fe1ed4763a8168f940d626d4fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgRangeExp.html">SgRangeExp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a9b5b0fe1ed4763a8168f940d626d4fd5">range</a> (const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> *rangeAttribute)</td></tr>
<tr class="memdesc:a9b5b0fe1ed4763a8168f940d626d4fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a range for the range attribute rangeAttribute.  <br /></td></tr>
<tr class="separator:a9b5b0fe1ed4763a8168f940d626d4fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3869ed814b216d571d5db83752f2b686" id="r_a3869ed814b216d571d5db83752f2b686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgRangeExp.html">SgRangeExp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3869ed814b216d571d5db83752f2b686">range</a> (const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> &amp;rangeAttribute)</td></tr>
<tr class="memdesc:a3869ed814b216d571d5db83752f2b686"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a range for the range attribute rangeAttribute.  <br /></td></tr>
<tr class="separator:a3869ed814b216d571d5db83752f2b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e11f4e61115045d8be775df8903a58d" id="r_a1e11f4e61115045d8be775df8903a58d"><td class="memItemLeft" align="right" valign="top"><a id="a1e11f4e61115045d8be775df8903a58d" name="a1e11f4e61115045d8be775df8903a58d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>denotesRange</b> (const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;e)</td></tr>
<tr class="memdesc:a1e11f4e61115045d8be775df8903a58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the expression e denotes a range <br /></td></tr>
<tr class="separator:a1e11f4e61115045d8be775df8903a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b8a5ee60d23d50210f64489862a7b" id="r_ac26b8a5ee60d23d50210f64489862a7b"><td class="memItemLeft" align="right" valign="top"><a id="ac26b8a5ee60d23d50210f64489862a7b" name="ac26b8a5ee60d23d50210f64489862a7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>denotesRange</b> (const <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>
<tr class="memdesc:ac26b8a5ee60d23d50210f64489862a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the expression e denotes a range <br /></td></tr>
<tr class="separator:ac26b8a5ee60d23d50210f64489862a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad56ad26dcd7e332aa132f5bdb3af9711" id="r_ad56ad26dcd7e332aa132f5bdb3af9711"><td class="memItemLeft" align="right" valign="top"><a id="ad56ad26dcd7e332aa132f5bdb3af9711" name="ad56ad26dcd7e332aa132f5bdb3af9711"></a>
<a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaPackageBodyDecl.html">SgAdaPackageBodyDecl</a> &amp;bodyDecl)</td></tr>
<tr class="memdesc:ad56ad26dcd7e332aa132f5bdb3af9711"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node for the package specification <br /></td></tr>
<tr class="separator:ad56ad26dcd7e332aa132f5bdb3af9711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b84f9ff4192e3ddf8454587790cd0e" id="r_a31b84f9ff4192e3ddf8454587790cd0e"><td class="memItemLeft" align="right" valign="top"><a id="a31b84f9ff4192e3ddf8454587790cd0e" name="a31b84f9ff4192e3ddf8454587790cd0e"></a>
<a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaPackageBodyDecl.html">SgAdaPackageBodyDecl</a> *bodyDecl)</td></tr>
<tr class="memdesc:a31b84f9ff4192e3ddf8454587790cd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node for the package specification <br /></td></tr>
<tr class="separator:a31b84f9ff4192e3ddf8454587790cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af40169bd34bc9716c9fc0b5473b425aa" id="r_af40169bd34bc9716c9fc0b5473b425aa"><td class="memItemLeft" align="right" valign="top"><a id="af40169bd34bc9716c9fc0b5473b425aa" name="af40169bd34bc9716c9fc0b5473b425aa"></a>
<a class="el" href="classSgAdaPackageBodyDecl.html">SgAdaPackageBodyDecl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getPackageBodyDeclaration</b> (const <a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> &amp;specDecl)</td></tr>
<tr class="memdesc:af40169bd34bc9716c9fc0b5473b425aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node for the package body, if available <br /></td></tr>
<tr class="separator:af40169bd34bc9716c9fc0b5473b425aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87743f6d6880d8171d81396fcc1a31f4" id="r_a87743f6d6880d8171d81396fcc1a31f4"><td class="memItemLeft" align="right" valign="top"><a id="a87743f6d6880d8171d81396fcc1a31f4" name="a87743f6d6880d8171d81396fcc1a31f4"></a>
<a class="el" href="classSgAdaPackageBodyDecl.html">SgAdaPackageBodyDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPackageBodyDeclaration</b> (const <a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> *specDecl)</td></tr>
<tr class="memdesc:a87743f6d6880d8171d81396fcc1a31f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node for the package body, if available <br /></td></tr>
<tr class="separator:a87743f6d6880d8171d81396fcc1a31f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafe265921046bd447db54ebd08032763" id="r_aafe265921046bd447db54ebd08032763"><td class="memItemLeft" align="right" valign="top"><a id="aafe265921046bd447db54ebd08032763" name="aafe265921046bd447db54ebd08032763"></a>
<a class="el" href="classSgAdaPackageSpec.html">SgAdaPackageSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDefinition</b> (const <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> &amp;body)</td></tr>
<tr class="memdesc:aafe265921046bd447db54ebd08032763"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the specification definition (scope) of the package body <br /></td></tr>
<tr class="separator:aafe265921046bd447db54ebd08032763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04b2a89c58ff95c68c4e565539675de" id="r_ac04b2a89c58ff95c68c4e565539675de"><td class="memItemLeft" align="right" valign="top"><a id="ac04b2a89c58ff95c68c4e565539675de" name="ac04b2a89c58ff95c68c4e565539675de"></a>
<a class="el" href="classSgAdaPackageSpec.html">SgAdaPackageSpec</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDefinition</b> (const <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> *body)</td></tr>
<tr class="memdesc:ac04b2a89c58ff95c68c4e565539675de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the specification definition (scope) of the package body <br /></td></tr>
<tr class="separator:ac04b2a89c58ff95c68c4e565539675de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08c50a86110d734957d546b7bd2facff" id="r_a08c50a86110d734957d546b7bd2facff"><td class="memItemLeft" align="right" valign="top"><a id="a08c50a86110d734957d546b7bd2facff" name="a08c50a86110d734957d546b7bd2facff"></a>
<a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBodyDefinition</b> (const <a class="el" href="classSgAdaPackageSpec.html">SgAdaPackageSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:a08c50a86110d734957d546b7bd2facff"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the body definition (scope) of the package specification <br /></td></tr>
<tr class="separator:a08c50a86110d734957d546b7bd2facff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad258c5f520163e2ddaf8db60a9ae0a64" id="r_ad258c5f520163e2ddaf8db60a9ae0a64"><td class="memItemLeft" align="right" valign="top"><a id="ad258c5f520163e2ddaf8db60a9ae0a64" name="ad258c5f520163e2ddaf8db60a9ae0a64"></a>
<a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getBodyDefinition</b> (const <a class="el" href="classSgAdaPackageSpec.html">SgAdaPackageSpec</a> *spec)</td></tr>
<tr class="memdesc:ad258c5f520163e2ddaf8db60a9ae0a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the body definition (scope) of the package specification <br /></td></tr>
<tr class="separator:ad258c5f520163e2ddaf8db60a9ae0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b1e06ec74e5f39fd98b9b8418abe4b7" id="r_a1b1e06ec74e5f39fd98b9b8418abe4b7"><td class="memItemLeft" align="right" valign="top"><a id="a1b1e06ec74e5f39fd98b9b8418abe4b7" name="a1b1e06ec74e5f39fd98b9b8418abe4b7"></a>
<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaTaskBodyDecl.html">SgAdaTaskBodyDecl</a> &amp;bodyDecl)</td></tr>
<tr class="memdesc:a1b1e06ec74e5f39fd98b9b8418abe4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node (either <a class="el" href="classSgAdaTaskSpecDecl.html">SgAdaTaskSpecDecl</a> or <a class="el" href="classSgAdaTaskTypeDecl.html">SgAdaTaskTypeDecl</a>) for the task specification <br /></td></tr>
<tr class="separator:a1b1e06ec74e5f39fd98b9b8418abe4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588eb6c539cd29ede0f438e6b126e376" id="r_a588eb6c539cd29ede0f438e6b126e376"><td class="memItemLeft" align="right" valign="top"><a id="a588eb6c539cd29ede0f438e6b126e376" name="a588eb6c539cd29ede0f438e6b126e376"></a>
<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaTaskBodyDecl.html">SgAdaTaskBodyDecl</a> *bodyDecl)</td></tr>
<tr class="memdesc:a588eb6c539cd29ede0f438e6b126e376"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node (either <a class="el" href="classSgAdaTaskSpecDecl.html">SgAdaTaskSpecDecl</a> or <a class="el" href="classSgAdaTaskTypeDecl.html">SgAdaTaskTypeDecl</a>) for the task specification <br /></td></tr>
<tr class="separator:a588eb6c539cd29ede0f438e6b126e376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31887ec1de3890dda112ee4d214e7df4" id="r_a31887ec1de3890dda112ee4d214e7df4"><td class="memItemLeft" align="right" valign="top"><a id="a31887ec1de3890dda112ee4d214e7df4" name="a31887ec1de3890dda112ee4d214e7df4"></a>
<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaProtectedBodyDecl.html">SgAdaProtectedBodyDecl</a> &amp;bodyDecl)</td></tr>
<tr class="memdesc:a31887ec1de3890dda112ee4d214e7df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node (either <a class="el" href="classSgAdaProtectedSpecDecl.html">SgAdaProtectedSpecDecl</a> or <a class="el" href="classSgAdaProtectedTypeDecl.html">SgAdaProtectedTypeDecl</a>) for the protected object specification <br /></td></tr>
<tr class="separator:a31887ec1de3890dda112ee4d214e7df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97d9ae45c6d0d5ae33c13d8991e768" id="r_a1e97d9ae45c6d0d5ae33c13d8991e768"><td class="memItemLeft" align="right" valign="top"><a id="a1e97d9ae45c6d0d5ae33c13d8991e768" name="a1e97d9ae45c6d0d5ae33c13d8991e768"></a>
<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpecificationDeclaration</b> (const <a class="el" href="classSgAdaProtectedBodyDecl.html">SgAdaProtectedBodyDecl</a> *bodyDecl)</td></tr>
<tr class="memdesc:a1e97d9ae45c6d0d5ae33c13d8991e768"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the declaration node (either <a class="el" href="classSgAdaProtectedSpecDecl.html">SgAdaProtectedSpecDecl</a> or <a class="el" href="classSgAdaProtectedTypeDecl.html">SgAdaProtectedTypeDecl</a>) for the protected object specification <br /></td></tr>
<tr class="separator:a1e97d9ae45c6d0d5ae33c13d8991e768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaeb3b7461895a26772ec8737719e2ed6" id="r_aaeb3b7461895a26772ec8737719e2ed6"><td class="memItemLeft" align="right" valign="top"><a id="aaeb3b7461895a26772ec8737719e2ed6" name="aaeb3b7461895a26772ec8737719e2ed6"></a>
SgStatementPtrList::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (SgStatementPtrList &amp;list)</td></tr>
<tr class="memdesc:aaeb3b7461895a26772ec8737719e2ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:aaeb3b7461895a26772ec8737719e2ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3bb423de3e1ef1ea304e0a24c50434" id="r_aec3bb423de3e1ef1ea304e0a24c50434"><td class="memItemLeft" align="right" valign="top"><a id="aec3bb423de3e1ef1ea304e0a24c50434" name="aec3bb423de3e1ef1ea304e0a24c50434"></a>
SgStatementPtrList::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> &amp;block)</td></tr>
<tr class="memdesc:aec3bb423de3e1ef1ea304e0a24c50434"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:aec3bb423de3e1ef1ea304e0a24c50434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ed451dd8efa68f193757cb8b71cfd" id="r_a626ed451dd8efa68f193757cb8b71cfd"><td class="memItemLeft" align="right" valign="top"><a id="a626ed451dd8efa68f193757cb8b71cfd" name="a626ed451dd8efa68f193757cb8b71cfd"></a>
SgStatementPtrList::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *block)</td></tr>
<tr class="memdesc:a626ed451dd8efa68f193757cb8b71cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:a626ed451dd8efa68f193757cb8b71cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9517f507f8c6f4d9eb511363f75129db" id="r_a9517f507f8c6f4d9eb511363f75129db"><td class="memItemLeft" align="right" valign="top"><a id="a9517f507f8c6f4d9eb511363f75129db" name="a9517f507f8c6f4d9eb511363f75129db"></a>
SgStatementPtrList::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (const SgStatementPtrList &amp;list)</td></tr>
<tr class="memdesc:a9517f507f8c6f4d9eb511363f75129db"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:a9517f507f8c6f4d9eb511363f75129db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4e9d88a61d2f310c1ccb1ff8a43467" id="r_adc4e9d88a61d2f310c1ccb1ff8a43467"><td class="memItemLeft" align="right" valign="top"><a id="adc4e9d88a61d2f310c1ccb1ff8a43467" name="adc4e9d88a61d2f310c1ccb1ff8a43467"></a>
SgStatementPtrList::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> &amp;block)</td></tr>
<tr class="memdesc:adc4e9d88a61d2f310c1ccb1ff8a43467"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:adc4e9d88a61d2f310c1ccb1ff8a43467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316da8d42270c47e7165f7b9b0ce74e" id="r_ac316da8d42270c47e7165f7b9b0ce74e"><td class="memItemLeft" align="right" valign="top"><a id="ac316da8d42270c47e7165f7b9b0ce74e" name="ac316da8d42270c47e7165f7b9b0ce74e"></a>
SgStatementPtrList::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>declarationLimit</b> (const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *block)</td></tr>
<tr class="memdesc:ac316da8d42270c47e7165f7b9b0ce74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator to one past the last declaration (the limit) in the statement sequence. <br /></td></tr>
<tr class="separator:ac316da8d42270c47e7165f7b9b0ce74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a014f5261d964c7e5bc7a1805fcc55323" id="r_a014f5261d964c7e5bc7a1805fcc55323"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a014f5261d964c7e5bc7a1805fcc55323">tryFollowsDeclarativeBlock</a> (const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> &amp;n)</td></tr>
<tr class="memdesc:a014f5261d964c7e5bc7a1805fcc55323"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a try block following a declarative region  <br /></td></tr>
<tr class="separator:a014f5261d964c7e5bc7a1805fcc55323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2cba64b9301577a907ed30f83b64e0" id="r_a6a2cba64b9301577a907ed30f83b64e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a6a2cba64b9301577a907ed30f83b64e0">tryFollowsDeclarativeBlock</a> (const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> *n)</td></tr>
<tr class="memdesc:a6a2cba64b9301577a907ed30f83b64e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a try block following a declarative region  <br /></td></tr>
<tr class="separator:a6a2cba64b9301577a907ed30f83b64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abecbc4a0c49ea5ea504a4edb8bbdc64f" id="r_abecbc4a0c49ea5ea504a4edb8bbdc64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#abecbc4a0c49ea5ea504a4edb8bbdc64f">isPackageTryBlock</a> (const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> &amp;n)</td></tr>
<tr class="memdesc:abecbc4a0c49ea5ea504a4edb8bbdc64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> package try block  <br /></td></tr>
<tr class="separator:abecbc4a0c49ea5ea504a4edb8bbdc64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6fb0fb1c70e894da60ab1173e3dbc" id="r_a59c6fb0fb1c70e894da60ab1173e3dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a59c6fb0fb1c70e894da60ab1173e3dbc">isPackageTryBlock</a> (const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> *n)</td></tr>
<tr class="memdesc:a59c6fb0fb1c70e894da60ab1173e3dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> package try block  <br /></td></tr>
<tr class="separator:a59c6fb0fb1c70e894da60ab1173e3dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af7b8f0e79fc0e4aa5e7cd42947f94673" id="r_af7b8f0e79fc0e4aa5e7cd42947f94673"><td class="memItemLeft" align="right" valign="top"><a id="af7b8f0e79fc0e4aa5e7cd42947f94673" name="af7b8f0e79fc0e4aa5e7cd42947f94673"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasUnknownDiscriminants</b> (const <a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> &amp;n)</td></tr>
<tr class="memdesc:af7b8f0e79fc0e4aa5e7cd42947f94673"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n has an unknown discriminant part <br /></td></tr>
<tr class="separator:af7b8f0e79fc0e4aa5e7cd42947f94673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e354f2c06592811bbc9f576ec2dc23" id="r_ac7e354f2c06592811bbc9f576ec2dc23"><td class="memItemLeft" align="right" valign="top"><a id="ac7e354f2c06592811bbc9f576ec2dc23" name="ac7e354f2c06592811bbc9f576ec2dc23"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasUnknownDiscriminants</b> (const <a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> *n)</td></tr>
<tr class="memdesc:ac7e354f2c06592811bbc9f576ec2dc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n has an unknown discriminant part <br /></td></tr>
<tr class="separator:ac7e354f2c06592811bbc9f576ec2dc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9c9ac30df339c19eb6f04f68f5d50fe" id="r_ac9c9ac30df339c19eb6f04f68f5d50fe"><td class="memItemLeft" align="right" valign="top"><a id="ac9c9ac30df339c19eb6f04f68f5d50fe" name="ac9c9ac30df339c19eb6f04f68f5d50fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOutInoutArgument</b> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;call, const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;arg)</td></tr>
<tr class="memdesc:ac9c9ac30df339c19eb6f04f68f5d50fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if arg is a used as l-value in the call <br /></td></tr>
<tr class="separator:ac9c9ac30df339c19eb6f04f68f5d50fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87f242dc85076d8a0f275907a389fb3" id="r_ab87f242dc85076d8a0f275907a389fb3"><td class="memItemLeft" align="right" valign="top"><a id="ab87f242dc85076d8a0f275907a389fb3" name="ab87f242dc85076d8a0f275907a389fb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOutInoutArgument</b> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *call, const <a class="el" href="classSgExpression.html">SgExpression</a> *arg)</td></tr>
<tr class="memdesc:ab87f242dc85076d8a0f275907a389fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if arg is a used as l-value in the call <br /></td></tr>
<tr class="separator:ab87f242dc85076d8a0f275907a389fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8ef470b98bcb4d1fcdc2a7988925ea3d" id="r_a8ef470b98bcb4d1fcdc2a7988925ea3d"><td class="memItemLeft" align="right" valign="top"><a id="a8ef470b98bcb4d1fcdc2a7988925ea3d" name="a8ef470b98bcb4d1fcdc2a7988925ea3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isModularType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a8ef470b98bcb4d1fcdc2a7988925ea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a8ef470b98bcb4d1fcdc2a7988925ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c700f20b3b12459333027c76f58a81" id="r_af2c700f20b3b12459333027c76f58a81"><td class="memItemLeft" align="right" valign="top"><a id="af2c700f20b3b12459333027c76f58a81" name="af2c700f20b3b12459333027c76f58a81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isModularType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:af2c700f20b3b12459333027c76f58a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:af2c700f20b3b12459333027c76f58a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf7c21d8f9dc8a83015865a0c63b90" id="r_a7abf7c21d8f9dc8a83015865a0c63b90"><td class="memItemLeft" align="right" valign="top"><a id="a7abf7c21d8f9dc8a83015865a0c63b90" name="a7abf7c21d8f9dc8a83015865a0c63b90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isIntegerType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a7abf7c21d8f9dc8a83015865a0c63b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a7abf7c21d8f9dc8a83015865a0c63b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b6730096c645ef459b6e1c9b097b39" id="r_ad1b6730096c645ef459b6e1c9b097b39"><td class="memItemLeft" align="right" valign="top"><a id="ad1b6730096c645ef459b6e1c9b097b39" name="ad1b6730096c645ef459b6e1c9b097b39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isIntegerType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:ad1b6730096c645ef459b6e1c9b097b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:ad1b6730096c645ef459b6e1c9b097b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b33036cd2389c5b591a376d7d9b795" id="r_a37b33036cd2389c5b591a376d7d9b795"><td class="memItemLeft" align="right" valign="top"><a id="a37b33036cd2389c5b591a376d7d9b795" name="a37b33036cd2389c5b591a376d7d9b795"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFloatingPointType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a37b33036cd2389c5b591a376d7d9b795"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a37b33036cd2389c5b591a376d7d9b795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a662c4e468e8f714023c03e261570" id="r_a8b9a662c4e468e8f714023c03e261570"><td class="memItemLeft" align="right" valign="top"><a id="a8b9a662c4e468e8f714023c03e261570" name="a8b9a662c4e468e8f714023c03e261570"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFloatingPointType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a8b9a662c4e468e8f714023c03e261570"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a8b9a662c4e468e8f714023c03e261570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b843ee070e69df0def3e86dab239f" id="r_a647b843ee070e69df0def3e86dab239f"><td class="memItemLeft" align="right" valign="top"><a id="a647b843ee070e69df0def3e86dab239f" name="a647b843ee070e69df0def3e86dab239f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDiscreteType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a647b843ee070e69df0def3e86dab239f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a647b843ee070e69df0def3e86dab239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981751ff105f439c307a6bb293794fc1" id="r_a981751ff105f439c307a6bb293794fc1"><td class="memItemLeft" align="right" valign="top"><a id="a981751ff105f439c307a6bb293794fc1" name="a981751ff105f439c307a6bb293794fc1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDiscreteType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a981751ff105f439c307a6bb293794fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a981751ff105f439c307a6bb293794fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf9cc4b6a64618cc5c324ae2eee672a" id="r_a0bf9cc4b6a64618cc5c324ae2eee672a"><td class="memItemLeft" align="right" valign="top"><a id="a0bf9cc4b6a64618cc5c324ae2eee672a" name="a0bf9cc4b6a64618cc5c324ae2eee672a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBooleanType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a0bf9cc4b6a64618cc5c324ae2eee672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:a0bf9cc4b6a64618cc5c324ae2eee672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09461bc53087ab54ba1fcc482d1763b" id="r_ac09461bc53087ab54ba1fcc482d1763b"><td class="memItemLeft" align="right" valign="top"><a id="ac09461bc53087ab54ba1fcc482d1763b" name="ac09461bc53087ab54ba1fcc482d1763b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBooleanType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:ac09461bc53087ab54ba1fcc482d1763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if the type ty is the corresponding universal type representation in ROSE <br /></td></tr>
<tr class="separator:ac09461bc53087ab54ba1fcc482d1763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08b7c3044051ad8cbacddd167512e9da" id="r_a08b7c3044051ad8cbacddd167512e9da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a08b7c3044051ad8cbacddd167512e9da">isFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a08b7c3044051ad8cbacddd167512e9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty is a fixed point type  <br /></td></tr>
<tr class="separator:a08b7c3044051ad8cbacddd167512e9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16fb7d493fd5a111a42381e0fd5f749" id="r_ad16fb7d493fd5a111a42381e0fd5f749"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ad16fb7d493fd5a111a42381e0fd5f749">isFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:ad16fb7d493fd5a111a42381e0fd5f749"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty is a fixed point type  <br /></td></tr>
<tr class="separator:ad16fb7d493fd5a111a42381e0fd5f749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4bed564e1db272cc6456d042aecc856a" id="r_a4bed564e1db272cc6456d042aecc856a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a4bed564e1db272cc6456d042aecc856a">isScalarType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a4bed564e1db272cc6456d042aecc856a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if ty refers to a scalar type  <br /></td></tr>
<tr class="separator:a4bed564e1db272cc6456d042aecc856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923340144fe4f930b7ba291da1759f1" id="r_a0923340144fe4f930b7ba291da1759f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a0923340144fe4f930b7ba291da1759f1">isScalarType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a0923340144fe4f930b7ba291da1759f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if ty refers to a scalar type  <br /></td></tr>
<tr class="separator:a0923340144fe4f930b7ba291da1759f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6c36c67a19f409eaf0fffd190173eece" id="r_a6c36c67a19f409eaf0fffd190173eece"><td class="memItemLeft" align="right" valign="top"><a id="a6c36c67a19f409eaf0fffd190173eece" name="a6c36c67a19f409eaf0fffd190173eece"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDiscreteArrayType</b> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a6c36c67a19f409eaf0fffd190173eece"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if ty refers to a discrete array type <br /></td></tr>
<tr class="separator:a6c36c67a19f409eaf0fffd190173eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e6ccf0ef2c05b6df4c745e8fe5f024" id="r_a77e6ccf0ef2c05b6df4c745e8fe5f024"><td class="memItemLeft" align="right" valign="top"><a id="a77e6ccf0ef2c05b6df4c745e8fe5f024" name="a77e6ccf0ef2c05b6df4c745e8fe5f024"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDiscreteArrayType</b> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a77e6ccf0ef2c05b6df4c745e8fe5f024"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if ty refers to a discrete array type <br /></td></tr>
<tr class="separator:a77e6ccf0ef2c05b6df4c745e8fe5f024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20edc181593ab6be364b44439592816a" id="r_a20edc181593ab6be364b44439592816a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a20edc181593ab6be364b44439592816a">resolvesToFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a20edc181593ab6be364b44439592816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty resolves to a fixed point type  <br /></td></tr>
<tr class="separator:a20edc181593ab6be364b44439592816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb1a3f95266ba7bf0ccb8dac1f0fb1" id="r_aafbb1a3f95266ba7bf0ccb8dac1f0fb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aafbb1a3f95266ba7bf0ccb8dac1f0fb1">resolvesToFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:aafbb1a3f95266ba7bf0ccb8dac1f0fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty resolves to a fixed point type  <br /></td></tr>
<tr class="separator:aafbb1a3f95266ba7bf0ccb8dac1f0fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa191cf6e7d56b01783b4d1314155ff93" id="r_aa191cf6e7d56b01783b4d1314155ff93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa191cf6e7d56b01783b4d1314155ff93">isDecimalFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:aa191cf6e7d56b01783b4d1314155ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty is a decimal fixed point type  <br /></td></tr>
<tr class="separator:aa191cf6e7d56b01783b4d1314155ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475154b8808d4c8b35c3a8b47b93a199" id="r_a475154b8808d4c8b35c3a8b47b93a199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a475154b8808d4c8b35c3a8b47b93a199">isDecimalFixedType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a475154b8808d4c8b35c3a8b47b93a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if the type ty is a decimal fixed point type  <br /></td></tr>
<tr class="separator:a475154b8808d4c8b35c3a8b47b93a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7a3674cc38077b6ad5104f1c6ae54561" id="r_a7a3674cc38077b6ad5104f1c6ae54561"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a7a3674cc38077b6ad5104f1c6ae54561">booleanConstant</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>
<tr class="memdesc:a7a3674cc38077b6ad5104f1c6ae54561"><td class="mdescLeft">&#160;</td><td class="mdescRight">if e denotes an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> boolean constant, it is returned; otherwise an empty result is returned.  <br /></td></tr>
<tr class="separator:a7a3674cc38077b6ad5104f1c6ae54561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63fe7a7c49ca0be2167fdbeb907b58" id="r_adb63fe7a7c49ca0be2167fdbeb907b58"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#adb63fe7a7c49ca0be2167fdbeb907b58">booleanConstant</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;e)</td></tr>
<tr class="memdesc:adb63fe7a7c49ca0be2167fdbeb907b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">if e denotes an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> boolean constant, it is returned; otherwise an empty result is returned.  <br /></td></tr>
<tr class="separator:adb63fe7a7c49ca0be2167fdbeb907b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a87147388f4bf9cdc02362816680f4cd9" id="r_a87147388f4bf9cdc02362816680f4cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a87147388f4bf9cdc02362816680f4cd9">isGenericDecl</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;n)</td></tr>
<tr class="memdesc:a87147388f4bf9cdc02362816680f4cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node that makes a declaration (either function/procedure or package) generic.  <br /></td></tr>
<tr class="separator:a87147388f4bf9cdc02362816680f4cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b0ff581f9b831233ec97e0090d6414" id="r_af8b0ff581f9b831233ec97e0090d6414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#af8b0ff581f9b831233ec97e0090d6414">isGenericDecl</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *n)</td></tr>
<tr class="memdesc:af8b0ff581f9b831233ec97e0090d6414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node that makes a declaration (either function/procedure or package) generic.  <br /></td></tr>
<tr class="separator:af8b0ff581f9b831233ec97e0090d6414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8f9415f016e6563df4cf27d0d8703423" id="r_a8f9415f016e6563df4cf27d0d8703423"><td class="memItemLeft" align="right" valign="top"><a id="a8f9415f016e6563df4cf27d0d8703423" name="a8f9415f016e6563df4cf27d0d8703423"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unitRefDenotesGenericInstance</b> (const <a class="el" href="classSgAdaUnitRefExp.html">SgAdaUnitRefExp</a> &amp;n)</td></tr>
<tr class="memdesc:a8f9415f016e6563df4cf27d0d8703423"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n refers to a generic declaration from inside said declaration false otherwise (e.g., if n does not refer to a generic unit) <br /></td></tr>
<tr class="separator:a8f9415f016e6563df4cf27d0d8703423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba513c7f0d33970f2e3e07dff9722c3" id="r_a3ba513c7f0d33970f2e3e07dff9722c3"><td class="memItemLeft" align="right" valign="top"><a id="a3ba513c7f0d33970f2e3e07dff9722c3" name="a3ba513c7f0d33970f2e3e07dff9722c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unitRefDenotesGenericInstance</b> (const <a class="el" href="classSgAdaUnitRefExp.html">SgAdaUnitRefExp</a> *n)</td></tr>
<tr class="memdesc:a3ba513c7f0d33970f2e3e07dff9722c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n refers to a generic declaration from inside said declaration false otherwise (e.g., if n does not refer to a generic unit) <br /></td></tr>
<tr class="separator:a3ba513c7f0d33970f2e3e07dff9722c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a857a9dba27b4faa29b3cda83754862d5" id="r_a857a9dba27b4faa29b3cda83754862d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a857a9dba27b4faa29b3cda83754862d5">getGenericDecl</a> (const <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a> &amp;n)</td></tr>
<tr class="memdesc:a857a9dba27b4faa29b3cda83754862d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> for a given <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a>.  <br /></td></tr>
<tr class="separator:a857a9dba27b4faa29b3cda83754862d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf9f0736b0bcb1e47a41f03c362c38b" id="r_a0bf9f0736b0bcb1e47a41f03c362c38b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a0bf9f0736b0bcb1e47a41f03c362c38b">getGenericDecl</a> (const <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a> *n)</td></tr>
<tr class="memdesc:a0bf9f0736b0bcb1e47a41f03c362c38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> for a given <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a>.  <br /></td></tr>
<tr class="separator:a0bf9f0736b0bcb1e47a41f03c362c38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2c1adc7d58679a4e4b459999e0380652" id="r_a2c1adc7d58679a4e4b459999e0380652"><td class="memItemLeft" align="right" valign="top"><a id="a2c1adc7d58679a4e4b459999e0380652" name="a2c1adc7d58679a4e4b459999e0380652"></a>
<a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAdaDiscriminatedTypeDecl</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;n)</td></tr>
<tr class="memdesc:a2c1adc7d58679a4e4b459999e0380652"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> iff n is discriminated null otherwise <br /></td></tr>
<tr class="separator:a2c1adc7d58679a4e4b459999e0380652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8ff1723b68a18b9b5aaf360c3ca7af" id="r_a7f8ff1723b68a18b9b5aaf360c3ca7af"><td class="memItemLeft" align="right" valign="top"><a id="a7f8ff1723b68a18b9b5aaf360c3ca7af" name="a7f8ff1723b68a18b9b5aaf360c3ca7af"></a>
<a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAdaDiscriminatedTypeDecl</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *n)</td></tr>
<tr class="memdesc:a7f8ff1723b68a18b9b5aaf360c3ca7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <a class="el" href="classSgAdaDiscriminatedTypeDecl.html">SgAdaDiscriminatedTypeDecl</a> iff n is discriminated null otherwise <br /></td></tr>
<tr class="separator:a7f8ff1723b68a18b9b5aaf360c3ca7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac28f6e9b9941a312aeed328c2e5c1836" id="r_ac28f6e9b9941a312aeed328c2e5c1836"><td class="memItemLeft" align="right" valign="top"><a id="ac28f6e9b9941a312aeed328c2e5c1836" name="ac28f6e9b9941a312aeed328c2e5c1836"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasSeparatedBody</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;dcl)</td></tr>
<tr class="memdesc:ac28f6e9b9941a312aeed328c2e5c1836"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the declaration decl corresponds to a stub (aka separated unit) <br /></td></tr>
<tr class="separator:ac28f6e9b9941a312aeed328c2e5c1836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca531596a07fb26ad7d8a626c4c1345" id="r_afca531596a07fb26ad7d8a626c4c1345"><td class="memItemLeft" align="right" valign="top"><a id="afca531596a07fb26ad7d8a626c4c1345" name="afca531596a07fb26ad7d8a626c4c1345"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasSeparatedBody</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *dcl)</td></tr>
<tr class="memdesc:afca531596a07fb26ad7d8a626c4c1345"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the declaration decl corresponds to a stub (aka separated unit) <br /></td></tr>
<tr class="separator:afca531596a07fb26ad7d8a626c4c1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49769137bd6da97be4a04610a1f48065" id="r_a49769137bd6da97be4a04610a1f48065"><td class="memItemLeft" align="right" valign="top"><a id="a49769137bd6da97be4a04610a1f48065" name="a49769137bd6da97be4a04610a1f48065"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSeparatedBody</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;n)</td></tr>
<tr class="memdesc:a49769137bd6da97be4a04610a1f48065"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a unit definition that has been separated <br /></td></tr>
<tr class="separator:a49769137bd6da97be4a04610a1f48065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5518696298703c77c3e3cdbdbe9debea" id="r_a5518696298703c77c3e3cdbdbe9debea"><td class="memItemLeft" align="right" valign="top"><a id="a5518696298703c77c3e3cdbdbe9debea" name="a5518696298703c77c3e3cdbdbe9debea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSeparatedBody</b> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *n)</td></tr>
<tr class="memdesc:a5518696298703c77c3e3cdbdbe9debea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a unit definition that has been separated <br /></td></tr>
<tr class="separator:a5518696298703c77c3e3cdbdbe9debea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d074f11d03e16f95d14e41aa31147a8" id="r_a3d074f11d03e16f95d14e41aa31147a8"><td class="memItemLeft" align="right" valign="top"><a id="a3d074f11d03e16f95d14e41aa31147a8" name="a3d074f11d03e16f95d14e41aa31147a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSeparatedDefinition</b> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;n)</td></tr>
<tr class="memdesc:a3d074f11d03e16f95d14e41aa31147a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a separated function definition is separated <br /></td></tr>
<tr class="separator:a3d074f11d03e16f95d14e41aa31147a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccfd7760478fb0655d158305beddc05" id="r_abccfd7760478fb0655d158305beddc05"><td class="memItemLeft" align="right" valign="top"><a id="abccfd7760478fb0655d158305beddc05" name="abccfd7760478fb0655d158305beddc05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSeparatedDefinition</b> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *n)</td></tr>
<tr class="memdesc:abccfd7760478fb0655d158305beddc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff n is a separated function definition is separated <br /></td></tr>
<tr class="separator:abccfd7760478fb0655d158305beddc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aed9bba8e575906ccdb5def741ff9e818" id="r_aed9bba8e575906ccdb5def741ff9e818"><td class="memItemLeft" align="right" valign="top"><a id="aed9bba8e575906ccdb5def741ff9e818" name="aed9bba8e575906ccdb5def741ff9e818"></a>
<a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><b>typeRoot</b> (<a class="el" href="classSgType.html">SgType</a> &amp;)</td></tr>
<tr class="memdesc:aed9bba8e575906ccdb5def741ff9e818"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the most fundamental type after skipping subtypes, typedefs, etc. <br /></td></tr>
<tr class="separator:aed9bba8e575906ccdb5def741ff9e818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc0c9a5eaf5baac7396cbee6d84c71a" id="r_a6bc0c9a5eaf5baac7396cbee6d84c71a"><td class="memItemLeft" align="right" valign="top"><a id="a6bc0c9a5eaf5baac7396cbee6d84c71a" name="a6bc0c9a5eaf5baac7396cbee6d84c71a"></a>
<a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><b>typeRoot</b> (<a class="el" href="classSgType.html">SgType</a> *)</td></tr>
<tr class="memdesc:a6bc0c9a5eaf5baac7396cbee6d84c71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the most fundamental type after skipping subtypes, typedefs, etc. <br /></td></tr>
<tr class="separator:a6bc0c9a5eaf5baac7396cbee6d84c71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa6e7d14f3339d47a64961cc808e044cc" id="r_aa6e7d14f3339d47a64961cc808e044cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa6e7d14f3339d47a64961cc808e044cc">typeOfExpr</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;)</td></tr>
<tr class="memdesc:aa6e7d14f3339d47a64961cc808e044cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the type of an expression corrects for some peculiarities in the AST  <br /></td></tr>
<tr class="separator:aa6e7d14f3339d47a64961cc808e044cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f93b63c9d96fec819fcd451922bf5" id="r_abc1f93b63c9d96fec819fcd451922bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#abc1f93b63c9d96fec819fcd451922bf5">typeOfExpr</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> *)</td></tr>
<tr class="memdesc:abc1f93b63c9d96fec819fcd451922bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the type of an expression corrects for some peculiarities in the AST  <br /></td></tr>
<tr class="separator:abc1f93b63c9d96fec819fcd451922bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa7c1b8b1565f3a32602490fa72058d62" id="r_aa7c1b8b1565f3a32602490fa72058d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa7c1b8b1565f3a32602490fa72058d62">baseOfAccessType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:aa7c1b8b1565f3a32602490fa72058d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the base type if ty is an access type  <br /></td></tr>
<tr class="separator:aa7c1b8b1565f3a32602490fa72058d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d46a011c2fd5c4084f1573110dd025" id="r_ae4d46a011c2fd5c4084f1573110dd025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ae4d46a011c2fd5c4084f1573110dd025">baseOfAccessType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:ae4d46a011c2fd5c4084f1573110dd025"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the base type if ty is an access type  <br /></td></tr>
<tr class="separator:ae4d46a011c2fd5c4084f1573110dd025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a245c9766a85b51d0219ba4d739af57b7" id="r_a245c9766a85b51d0219ba4d739af57b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a245c9766a85b51d0219ba4d739af57b7">operatorScope</a> (const std::string &amp;opname, const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a245c9766a85b51d0219ba4d739af57b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scope where an operator associated with type ty shall be declared.  <br /></td></tr>
<tr class="separator:a245c9766a85b51d0219ba4d739af57b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05e53a8be461fe0da7805c88a485d60" id="r_aa05e53a8be461fe0da7805c88a485d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa05e53a8be461fe0da7805c88a485d60">operatorScope</a> (const std::string &amp;opname, const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:aa05e53a8be461fe0da7805c88a485d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scope where an operator associated with type ty shall be declared.  <br /></td></tr>
<tr class="separator:aa05e53a8be461fe0da7805c88a485d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeab189505b5fe4d846f50ec48ced39a7" id="r_aeab189505b5fe4d846f50ec48ced39a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aeab189505b5fe4d846f50ec48ced39a7">declarationScope</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:aeab189505b5fe4d846f50ec48ced39a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scope where type ty has been declared  <br /></td></tr>
<tr class="separator:aeab189505b5fe4d846f50ec48ced39a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45533985c2bc4071b5c4e46eaef3b980" id="r_a45533985c2bc4071b5c4e46eaef3b980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a45533985c2bc4071b5c4e46eaef3b980">declarationScope</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a45533985c2bc4071b5c4e46eaef3b980"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scope where type ty has been declared  <br /></td></tr>
<tr class="separator:a45533985c2bc4071b5c4e46eaef3b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a344225593889962ad3bc1ebb2fcf42b3" id="r_a344225593889962ad3bc1ebb2fcf42b3"><td class="memItemLeft" align="right" valign="top"><a id="a344225593889962ad3bc1ebb2fcf42b3" name="a344225593889962ad3bc1ebb2fcf42b3"></a>
<a class="el" href="structSageInterface_1_1Ada_1_1AggregateInfo.html">AggregateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>splitAggregate</b> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;exp)</td></tr>
<tr class="memdesc:a344225593889962ad3bc1ebb2fcf42b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the ancestor initializer, if exp refers to an extension aggregate null otherwise <br /></td></tr>
<tr class="separator:a344225593889962ad3bc1ebb2fcf42b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71476760b6ef09287e01efd7a9aca5ac" id="r_a71476760b6ef09287e01efd7a9aca5ac"><td class="memItemLeft" align="right" valign="top"><a id="a71476760b6ef09287e01efd7a9aca5ac" name="a71476760b6ef09287e01efd7a9aca5ac"></a>
<a class="el" href="structSageInterface_1_1Ada_1_1AggregateInfo.html">AggregateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>splitAggregate</b> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> *exp)</td></tr>
<tr class="memdesc:a71476760b6ef09287e01efd7a9aca5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the ancestor initializer, if exp refers to an extension aggregate null otherwise <br /></td></tr>
<tr class="separator:a71476760b6ef09287e01efd7a9aca5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3aefe0e1756cc21d317187011562a66b" id="r_a3aefe0e1756cc21d317187011562a66b"><td class="memItemLeft" align="right" valign="top"><a id="a3aefe0e1756cc21d317187011562a66b" name="a3aefe0e1756cc21d317187011562a66b"></a>
<a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>renamedPackage</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> &amp;n)</td></tr>
<tr class="memdesc:a3aefe0e1756cc21d317187011562a66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a package spec decl if the declaration n renames a package returns nullptr otherwise <br /></td></tr>
<tr class="separator:a3aefe0e1756cc21d317187011562a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5b44a727480db9d17e752e855498bf" id="r_a3a5b44a727480db9d17e752e855498bf"><td class="memItemLeft" align="right" valign="top"><a id="a3a5b44a727480db9d17e752e855498bf" name="a3a5b44a727480db9d17e752e855498bf"></a>
<a class="el" href="classSgAdaPackageSpecDecl.html">SgAdaPackageSpecDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>renamedPackage</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> *n)</td></tr>
<tr class="memdesc:a3a5b44a727480db9d17e752e855498bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a package spec decl if the declaration n renames a package returns nullptr otherwise <br /></td></tr>
<tr class="separator:a3a5b44a727480db9d17e752e855498bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a945d4b52e50cf10616c6d3815db784bd" id="r_a945d4b52e50cf10616c6d3815db784bd"><td class="memItemLeft" align="right" valign="top"><a id="a945d4b52e50cf10616c6d3815db784bd" name="a945d4b52e50cf10616c6d3815db784bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFunction</b> (const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> &amp;ty)</td></tr>
<tr class="memdesc:a945d4b52e50cf10616c6d3815db784bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to a function type (as opposed to procedure) <br /></td></tr>
<tr class="separator:a945d4b52e50cf10616c6d3815db784bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7b283112a3c98d53f3661d89332e2" id="r_abcc7b283112a3c98d53f3661d89332e2"><td class="memItemLeft" align="right" valign="top"><a id="abcc7b283112a3c98d53f3661d89332e2" name="abcc7b283112a3c98d53f3661d89332e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFunction</b> (const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> *ty)</td></tr>
<tr class="memdesc:abcc7b283112a3c98d53f3661d89332e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to a function type (as opposed to procedure) <br /></td></tr>
<tr class="separator:abcc7b283112a3c98d53f3661d89332e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59400d7e3ccb791c1ba7a62ac14b6ad0" id="r_a59400d7e3ccb791c1ba7a62ac14b6ad0"><td class="memItemLeft" align="right" valign="top"><a id="a59400d7e3ccb791c1ba7a62ac14b6ad0" name="a59400d7e3ccb791c1ba7a62ac14b6ad0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFunction</b> (const <a class="el" href="classSgAdaSubroutineType.html">SgAdaSubroutineType</a> &amp;ty)</td></tr>
<tr class="memdesc:a59400d7e3ccb791c1ba7a62ac14b6ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to a function type (as opposed to procedure) <br /></td></tr>
<tr class="separator:a59400d7e3ccb791c1ba7a62ac14b6ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3be294c9b35110b40137c0a1345bfec" id="r_aa3be294c9b35110b40137c0a1345bfec"><td class="memItemLeft" align="right" valign="top"><a id="aa3be294c9b35110b40137c0a1345bfec" name="aa3be294c9b35110b40137c0a1345bfec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFunction</b> (const <a class="el" href="classSgAdaSubroutineType.html">SgAdaSubroutineType</a> *ty)</td></tr>
<tr class="memdesc:aa3be294c9b35110b40137c0a1345bfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to a function type (as opposed to procedure) <br /></td></tr>
<tr class="separator:aa3be294c9b35110b40137c0a1345bfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a37dc850e3b6c0ea7a93c3d28bee50b50" id="r_a37dc850e3b6c0ea7a93c3d28bee50b50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a37dc850e3b6c0ea7a93c3d28bee50b50">functionType</a> (const <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *fnsy)</td></tr>
<tr class="memdesc:a37dc850e3b6c0ea7a93c3d28bee50b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the static type of the function symbol fnsy  <br /></td></tr>
<tr class="separator:a37dc850e3b6c0ea7a93c3d28bee50b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802da0c4cabf5391e9e3ecc10359ce7c" id="r_a802da0c4cabf5391e9e3ecc10359ce7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a802da0c4cabf5391e9e3ecc10359ce7c">functionType</a> (const <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> &amp;fnsy)</td></tr>
<tr class="memdesc:a802da0c4cabf5391e9e3ecc10359ce7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the static type of the function symbol fnsy  <br /></td></tr>
<tr class="separator:a802da0c4cabf5391e9e3ecc10359ce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2e9dcf089c9a1ec2d614f57623ce3d73" id="r_a2e9dcf089c9a1ec2d614f57623ce3d73"><td class="memItemLeft" align="right" valign="top"><a id="a2e9dcf089c9a1ec2d614f57623ce3d73" name="a2e9dcf089c9a1ec2d614f57623ce3d73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isObjectRenaming</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> *dcl)</td></tr>
<tr class="memdesc:a2e9dcf089c9a1ec2d614f57623ce3d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to an object renaming <br /></td></tr>
<tr class="separator:a2e9dcf089c9a1ec2d614f57623ce3d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a225d4f5956b9931ffde5d7372b0c" id="r_a793a225d4f5956b9931ffde5d7372b0c"><td class="memItemLeft" align="right" valign="top"><a id="a793a225d4f5956b9931ffde5d7372b0c" name="a793a225d4f5956b9931ffde5d7372b0c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isObjectRenaming</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> &amp;dcl)</td></tr>
<tr class="memdesc:a793a225d4f5956b9931ffde5d7372b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to an object renaming <br /></td></tr>
<tr class="separator:a793a225d4f5956b9931ffde5d7372b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9e747e602d87cdc3a4761d6bf8f1cde6" id="r_a9e747e602d87cdc3a4761d6bf8f1cde6"><td class="memItemLeft" align="right" valign="top"><a id="a9e747e602d87cdc3a4761d6bf8f1cde6" name="a9e747e602d87cdc3a4761d6bf8f1cde6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isExceptionRenaming</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> *dcl)</td></tr>
<tr class="memdesc:a9e747e602d87cdc3a4761d6bf8f1cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to an exception renaming <br /></td></tr>
<tr class="separator:a9e747e602d87cdc3a4761d6bf8f1cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cd2f627252f9644f8c3a458a2b2ef6" id="r_a23cd2f627252f9644f8c3a458a2b2ef6"><td class="memItemLeft" align="right" valign="top"><a id="a23cd2f627252f9644f8c3a458a2b2ef6" name="a23cd2f627252f9644f8c3a458a2b2ef6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isExceptionRenaming</b> (const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a> &amp;dcl)</td></tr>
<tr class="memdesc:a23cd2f627252f9644f8c3a458a2b2ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff ty refers to an exception renaming <br /></td></tr>
<tr class="separator:a23cd2f627252f9644f8c3a458a2b2ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6cc88fff559ad76ca897928597b4344f" id="r_a6cc88fff559ad76ca897928597b4344f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a6cc88fff559ad76ca897928597b4344f">primitiveParameterPositions</a> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;fn)</td></tr>
<tr class="memdesc:a6cc88fff559ad76ca897928597b4344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the descriptions for parameters that make an operation primitive.  <br /></td></tr>
<tr class="separator:a6cc88fff559ad76ca897928597b4344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857f0056cec96679c8c91eb01a5aebd" id="r_a4857f0056cec96679c8c91eb01a5aebd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a4857f0056cec96679c8c91eb01a5aebd">primitiveParameterPositions</a> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *fn)</td></tr>
<tr class="memdesc:a4857f0056cec96679c8c91eb01a5aebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the descriptions for parameters that make an operation primitive.  <br /></td></tr>
<tr class="separator:a4857f0056cec96679c8c91eb01a5aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1014d1cde94fb98e8cdcfdb800c431f4" id="r_a1014d1cde94fb98e8cdcfdb800c431f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveSignatureElementsDesc.html">PrimitiveSignatureElementsDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a1014d1cde94fb98e8cdcfdb800c431f4">primitiveSignatureElements</a> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;)</td></tr>
<tr class="memdesc:a1014d1cde94fb98e8cdcfdb800c431f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the descriptions for result type and parameters that make an operation primitive.  <br /></td></tr>
<tr class="separator:a1014d1cde94fb98e8cdcfdb800c431f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b26402dd9e4be4f390ceeff81f5f05" id="r_a78b26402dd9e4be4f390ceeff81f5f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveSignatureElementsDesc.html">PrimitiveSignatureElementsDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a78b26402dd9e4be4f390ceeff81f5f05">primitiveSignatureElements</a> (const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *)</td></tr>
<tr class="memdesc:a78b26402dd9e4be4f390ceeff81f5f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the descriptions for result type and parameters that make an operation primitive.  <br /></td></tr>
<tr class="separator:a78b26402dd9e4be4f390ceeff81f5f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a526c947e2a168ce00089977096293b77" id="r_a526c947e2a168ce00089977096293b77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a526c947e2a168ce00089977096293b77">exceptionTypeDecl</a> (const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;n)</td></tr>
<tr class="memdesc:a526c947e2a168ce00089977096293b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns n or a pointer to n if n declares an exception type.  <br /></td></tr>
<tr class="separator:a526c947e2a168ce00089977096293b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ba6337c6fc2e49865f081b3fac503" id="r_a722ba6337c6fc2e49865f081b3fac503"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a722ba6337c6fc2e49865f081b3fac503">exceptionTypeDecl</a> (const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *n)</td></tr>
<tr class="memdesc:a722ba6337c6fc2e49865f081b3fac503"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns n or a pointer to n if n declares an exception type.  <br /></td></tr>
<tr class="separator:a722ba6337c6fc2e49865f081b3fac503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbc03248528d9673b5d3a9dc6fefe3f" id="r_a1cbc03248528d9673b5d3a9dc6fefe3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a1cbc03248528d9673b5d3a9dc6fefe3f">exceptionTypeDecl</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;n)</td></tr>
<tr class="memdesc:a1cbc03248528d9673b5d3a9dc6fefe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns n or a pointer to n if n declares an exception type.  <br /></td></tr>
<tr class="separator:a1cbc03248528d9673b5d3a9dc6fefe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245fb765e12594336a0a696d41c233b0" id="r_a245fb765e12594336a0a696d41c233b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a245fb765e12594336a0a696d41c233b0">exceptionTypeDecl</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *n)</td></tr>
<tr class="memdesc:a245fb765e12594336a0a696d41c233b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns n or a pointer to n if n declares an exception type.  <br /></td></tr>
<tr class="separator:a245fb765e12594336a0a696d41c233b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff4fc6bd85f40960fd9b32f47eb45639" id="r_aff4fc6bd85f40960fd9b32f47eb45639"><td class="memItemLeft" align="right" valign="top">SgExpressionPtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aff4fc6bd85f40960fd9b32f47eb45639">normalizedCallArguments</a> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;n, bool withDefaultArguments=false)</td></tr>
<tr class="memdesc:aff4fc6bd85f40960fd9b32f47eb45639"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to identify the argument list automatically and uses it to invoke the preceding normalizedCallArguments2 function.  <br /></td></tr>
<tr class="separator:aff4fc6bd85f40960fd9b32f47eb45639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a731fb08e6d9eac6284d1c2dfb2010a34" id="r_a731fb08e6d9eac6284d1c2dfb2010a34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a731fb08e6d9eac6284d1c2dfb2010a34">calleeParameterList</a> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;n)</td></tr>
<tr class="memdesc:a731fb08e6d9eac6284d1c2dfb2010a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function parameter list of the associated callee (if available).  <br /></td></tr>
<tr class="separator:a731fb08e6d9eac6284d1c2dfb2010a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d2d6b2bc0ce531e3253095bbca3b50" id="r_a24d2d6b2bc0ce531e3253095bbca3b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a24d2d6b2bc0ce531e3253095bbca3b50">calleeParameterList</a> (const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *n)</td></tr>
<tr class="memdesc:a24d2d6b2bc0ce531e3253095bbca3b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the function parameter list of the associated callee (if available).  <br /></td></tr>
<tr class="separator:a24d2d6b2bc0ce531e3253095bbca3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a715a9f50049eb827d9ab468849511301" id="r_a715a9f50049eb827d9ab468849511301"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *, const <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a715a9f50049eb827d9ab468849511301">findSymbolInContext</a> (std::string id, const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;scope, const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *limit=nullptr)</td></tr>
<tr class="memdesc:a715a9f50049eb827d9ab468849511301"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the symbol with <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> in the context of scope or its logical parents in the range [scope, limit).  <br /></td></tr>
<tr class="separator:a715a9f50049eb827d9ab468849511301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0e7dd7e025c6c8d4cf88d852e2afe92e" id="r_a0e7dd7e025c6c8d4cf88d852e2afe92e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a0e7dd7e025c6c8d4cf88d852e2afe92e">overridingScope</a> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;args, const std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; &amp;primitiveArgs)</td></tr>
<tr class="memdesc:a0e7dd7e025c6c8d4cf88d852e2afe92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the overriding scope of a primitive function based on the associated arguments as defined by the argument list args and the primitive argument positions defined by primitiveArgs.  <br /></td></tr>
<tr class="separator:a0e7dd7e025c6c8d4cf88d852e2afe92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524fe66f2a71b7e62bf2143a29f48385" id="r_a524fe66f2a71b7e62bf2143a29f48385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a524fe66f2a71b7e62bf2143a29f48385">overridingScope</a> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> *args, const std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; &amp;primitiveArgs)</td></tr>
<tr class="memdesc:a524fe66f2a71b7e62bf2143a29f48385"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the overriding scope of a primitive function based on the associated arguments as defined by the argument list args and the primitive argument positions defined by primitiveArgs.  <br /></td></tr>
<tr class="separator:a524fe66f2a71b7e62bf2143a29f48385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39a4f130d1bd62d54d7a8cf9b72dc78e" id="r_a39a4f130d1bd62d54d7a8cf9b72dc78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a39a4f130d1bd62d54d7a8cf9b72dc78e">logicalParentScope</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;s)</td></tr>
<tr class="memdesc:a39a4f130d1bd62d54d7a8cf9b72dc78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the logical parent scope of a scope s.  <br /></td></tr>
<tr class="separator:a39a4f130d1bd62d54d7a8cf9b72dc78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c3e18d7f6b3a01a9a11be3ab6ec40" id="r_a3c2c3e18d7f6b3a01a9a11be3ab6ec40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3c2c3e18d7f6b3a01a9a11be3ab6ec40">logicalParentScope</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *s)</td></tr>
<tr class="memdesc:a3c2c3e18d7f6b3a01a9a11be3ab6ec40"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the logical parent scope of a scope s.  <br /></td></tr>
<tr class="separator:a3c2c3e18d7f6b3a01a9a11be3ab6ec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1bdf3748b46d6cbdfea5ac3bb78e05a3" id="r_a1bdf3748b46d6cbdfea5ac3bb78e05a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a1bdf3748b46d6cbdfea5ac3bb78e05a3">associatedDeclaration</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a1bdf3748b46d6cbdfea5ac3bb78e05a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the decl where ty was defined nullptr if no such declaration can be found.  <br /></td></tr>
<tr class="separator:a1bdf3748b46d6cbdfea5ac3bb78e05a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35d1d46714bdab9ae57f4617ae5d3a" id="r_abd35d1d46714bdab9ae57f4617ae5d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#abd35d1d46714bdab9ae57f4617ae5d3a">associatedDeclaration</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:abd35d1d46714bdab9ae57f4617ae5d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the decl where ty was defined nullptr if no such declaration can be found.  <br /></td></tr>
<tr class="separator:abd35d1d46714bdab9ae57f4617ae5d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf37476ab2d63eea746e4df8cd684b2c" id="r_abf37476ab2d63eea746e4df8cd684b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#abf37476ab2d63eea746e4df8cd684b2c">baseType</a> (const <a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:abf37476ab2d63eea746e4df8cd684b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the base type of a type ty  <br /></td></tr>
<tr class="separator:abf37476ab2d63eea746e4df8cd684b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a141f277b6e3509402c448ec993e964" id="r_a3a141f277b6e3509402c448ec993e964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3a141f277b6e3509402c448ec993e964">baseType</a> (const <a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:a3a141f277b6e3509402c448ec993e964"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the base type of a type ty  <br /></td></tr>
<tr class="separator:a3a141f277b6e3509402c448ec993e964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa9cd4bfcfbe7aa6e5e53e380b3499931" id="r_aa9cd4bfcfbe7aa6e5e53e380b3499931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgEnumDeclaration.html">SgEnumDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aa9cd4bfcfbe7aa6e5e53e380b3499931">baseEnumDeclaration</a> (<a class="el" href="classSgType.html">SgType</a> *ty)</td></tr>
<tr class="memdesc:aa9cd4bfcfbe7aa6e5e53e380b3499931"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the underlying enum declaration of a type ty  <br /></td></tr>
<tr class="separator:aa9cd4bfcfbe7aa6e5e53e380b3499931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f5d217944139c5ecd832cb807f0131" id="r_a99f5d217944139c5ecd832cb807f0131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgEnumDeclaration.html">SgEnumDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a99f5d217944139c5ecd832cb807f0131">baseEnumDeclaration</a> (<a class="el" href="classSgType.html">SgType</a> &amp;ty)</td></tr>
<tr class="memdesc:a99f5d217944139c5ecd832cb807f0131"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the underlying enum declaration of a type ty  <br /></td></tr>
<tr class="separator:a99f5d217944139c5ecd832cb807f0131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5dc2996b2bb1f33f168a61ead8fd5f1c" id="r_a5dc2996b2bb1f33f168a61ead8fd5f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgEnumType.html">SgEnumType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a5dc2996b2bb1f33f168a61ead8fd5f1c">characterBaseType</a> (<a class="el" href="classSgEnumType.html">SgEnumType</a> *ty)</td></tr>
<tr class="memdesc:a5dc2996b2bb1f33f168a61ead8fd5f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the type is based on one of the Standard character types.  <br /></td></tr>
<tr class="separator:a5dc2996b2bb1f33f168a61ead8fd5f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780d8a5cc148d09a2ce4f6fc6f92ecd5" id="r_a780d8a5cc148d09a2ce4f6fc6f92ecd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgEnumType.html">SgEnumType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a780d8a5cc148d09a2ce4f6fc6f92ecd5">characterBaseType</a> (<a class="el" href="classSgEnumType.html">SgEnumType</a> &amp;ty)</td></tr>
<tr class="memdesc:a780d8a5cc148d09a2ce4f6fc6f92ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the type is based on one of the Standard character types.  <br /></td></tr>
<tr class="separator:a780d8a5cc148d09a2ce4f6fc6f92ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7cb149300b661c52584966fc4fc6cc32" id="r_a7cb149300b661c52584966fc4fc6cc32"><td class="memItemLeft" align="right" valign="top"><a id="a7cb149300b661c52584966fc4fc6cc32" name="a7cb149300b661c52584966fc4fc6cc32"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReverseForLoop</b> (const <a class="el" href="classSgForStatement.html">SgForStatement</a> *n)</td></tr>
<tr class="memdesc:a7cb149300b661c52584966fc4fc6cc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff n is a reverse for loop; returns false otherwise <br /></td></tr>
<tr class="separator:a7cb149300b661c52584966fc4fc6cc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c7e20ec31577c2e9e1b0f65990adb" id="r_a3c8c7e20ec31577c2e9e1b0f65990adb"><td class="memItemLeft" align="right" valign="top"><a id="a3c8c7e20ec31577c2e9e1b0f65990adb" name="a3c8c7e20ec31577c2e9e1b0f65990adb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReverseForLoop</b> (const <a class="el" href="classSgForStatement.html">SgForStatement</a> &amp;n)</td></tr>
<tr class="memdesc:a3c8c7e20ec31577c2e9e1b0f65990adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff n is a reverse for loop; returns false otherwise <br /></td></tr>
<tr class="separator:a3c8c7e20ec31577c2e9e1b0f65990adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812f7e63745e7a583838713c4e3bb7cf" id="r_a812f7e63745e7a583838713c4e3bb7cf"><td class="memItemLeft" align="right" valign="top"><a id="a812f7e63745e7a583838713c4e3bb7cf" name="a812f7e63745e7a583838713c4e3bb7cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReverseForLoop</b> (const <a class="el" href="classSgForInitStatement.html">SgForInitStatement</a> *n)</td></tr>
<tr class="memdesc:a812f7e63745e7a583838713c4e3bb7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff n is a reverse for loop; returns false otherwise <br /></td></tr>
<tr class="separator:a812f7e63745e7a583838713c4e3bb7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778eb96bbbee46449bc38a0159197d2" id="r_a2778eb96bbbee46449bc38a0159197d2"><td class="memItemLeft" align="right" valign="top"><a id="a2778eb96bbbee46449bc38a0159197d2" name="a2778eb96bbbee46449bc38a0159197d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReverseForLoop</b> (const <a class="el" href="classSgForInitStatement.html">SgForInitStatement</a> &amp;n)</td></tr>
<tr class="memdesc:a2778eb96bbbee46449bc38a0159197d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true, iff n is a reverse for loop; returns false otherwise <br /></td></tr>
<tr class="separator:a2778eb96bbbee46449bc38a0159197d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39268f5ffe0edcaff5b6ce5c6f2b576b" id="r_a39268f5ffe0edcaff5b6ce5c6f2b576b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a39268f5ffe0edcaff5b6ce5c6f2b576b">positionalArgumentLimit</a> (const SgExpressionPtrList &amp;arglst)</td></tr>
<tr class="memdesc:a39268f5ffe0edcaff5b6ce5c6f2b576b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the one past the last positional argument (aka the first named argument position).  <br /></td></tr>
<tr class="separator:a39268f5ffe0edcaff5b6ce5c6f2b576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee0647d08d73a7e06e5279aaa6372b5" id="r_a3ee0647d08d73a7e06e5279aaa6372b5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3ee0647d08d73a7e06e5279aaa6372b5">positionalArgumentLimit</a> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;args)</td></tr>
<tr class="memdesc:a3ee0647d08d73a7e06e5279aaa6372b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the one past the last positional argument (aka the first named argument position).  <br /></td></tr>
<tr class="separator:a3ee0647d08d73a7e06e5279aaa6372b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bdd28384c55cce16c989527b5c9b06" id="r_a68bdd28384c55cce16c989527b5c9b06"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a68bdd28384c55cce16c989527b5c9b06">positionalArgumentLimit</a> (const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> *args)</td></tr>
<tr class="memdesc:a68bdd28384c55cce16c989527b5c9b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the one past the last positional argument (aka the first named argument position).  <br /></td></tr>
<tr class="separator:a68bdd28384c55cce16c989527b5c9b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aab3db7596c53edef97f76b61d4166ccb" id="r_aab3db7596c53edef97f76b61d4166ccb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#aab3db7596c53edef97f76b61d4166ccb">blockExistsInSource</a> (const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *blk)</td></tr>
<tr class="memdesc:aab3db7596c53edef97f76b61d4166ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the block blk is present in the <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> source code.  <br /></td></tr>
<tr class="separator:aab3db7596c53edef97f76b61d4166ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac047a7f00365c91e7f7a4d777847e967" id="r_ac047a7f00365c91e7f7a4d777847e967"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ac047a7f00365c91e7f7a4d777847e967">blockExistsInSource</a> (const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> &amp;blk)</td></tr>
<tr class="memdesc:ac047a7f00365c91e7f7a4d777847e967"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the block blk is present in the <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> source code.  <br /></td></tr>
<tr class="separator:ac047a7f00365c91e7f7a4d777847e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3901ec0b8e9bda0726793a17859d53d9" id="r_a3901ec0b8e9bda0726793a17859d53d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a3901ec0b8e9bda0726793a17859d53d9">simpleTraversal</a> (std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;fn, <a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a3901ec0b8e9bda0726793a17859d53d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses all AST nodes in an unspecified order.  <br /></td></tr>
<tr class="separator:a3901ec0b8e9bda0726793a17859d53d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc7e3e20efc948e9cf47cbce448d1dd" id="r_a4dc7e3e20efc948e9cf47cbce448d1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a4dc7e3e20efc948e9cf47cbce448d1dd">simpleTraversal</a> (std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;fn, StatementRange roots)</td></tr>
<tr class="memdesc:a4dc7e3e20efc948e9cf47cbce448d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses all AST nodes in an unspecified order.  <br /></td></tr>
<tr class="separator:a4dc7e3e20efc948e9cf47cbce448d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a03c88ea7531b2ea91346e1f61c83cf04" id="r_a03c88ea7531b2ea91346e1f61c83cf04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a03c88ea7531b2ea91346e1f61c83cf04">conversionTraversal</a> (std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;fn, <a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="separator:a03c88ea7531b2ea91346e1f61c83cf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bff655aeb960d26c8693f4d9220f2f" id="r_a13bff655aeb960d26c8693f4d9220f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a13bff655aeb960d26c8693f4d9220f2f">conversionTraversal</a> (std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;fn, StatementRange roots)</td></tr>
<tr class="separator:a13bff655aeb960d26c8693f4d9220f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4015fa31e64e3d46f71933db9076e933" id="r_a4015fa31e64e3d46f71933db9076e933"><td class="memItemLeft" align="right" valign="top"><a id="a4015fa31e64e3d46f71933db9076e933" name="a4015fa31e64e3d46f71933db9076e933"></a>
long long int&#160;</td><td class="memItemRight" valign="bottom"><b>convertIntegerLiteral</b> (const char *img)</td></tr>
<tr class="memdesc:a4015fa31e64e3d46f71933db9076e933"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts text to constant values <br /></td></tr>
<tr class="separator:a4015fa31e64e3d46f71933db9076e933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a262388cf7c97ae2e77156f205a308" id="r_a27a262388cf7c97ae2e77156f205a308"><td class="memItemLeft" align="right" valign="top"><a id="a27a262388cf7c97ae2e77156f205a308" name="a27a262388cf7c97ae2e77156f205a308"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>convertStringLiteral</b> (const char *img)</td></tr>
<tr class="memdesc:a27a262388cf7c97ae2e77156f205a308"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts text to constant values <br /></td></tr>
<tr class="separator:a27a262388cf7c97ae2e77156f205a308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d55f5e6cff7071fea89234f21ba05cb" id="r_a9d55f5e6cff7071fea89234f21ba05cb"><td class="memItemLeft" align="right" valign="top"><a id="a9d55f5e6cff7071fea89234f21ba05cb" name="a9d55f5e6cff7071fea89234f21ba05cb"></a>
long double&#160;</td><td class="memItemRight" valign="bottom"><b>convertRealLiteral</b> (const char *img)</td></tr>
<tr class="memdesc:a9d55f5e6cff7071fea89234f21ba05cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts text to constant values <br /></td></tr>
<tr class="separator:a9d55f5e6cff7071fea89234f21ba05cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0ccdda796f856a2cb79ec93d97ef90" id="r_a9b0ccdda796f856a2cb79ec93d97ef90"><td class="memItemLeft" align="right" valign="top"><a id="a9b0ccdda796f856a2cb79ec93d97ef90" name="a9b0ccdda796f856a2cb79ec93d97ef90"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>convertCharLiteral</b> (const char *img)</td></tr>
<tr class="memdesc:a9b0ccdda796f856a2cb79ec93d97ef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts text to constant values <br /></td></tr>
<tr class="separator:a9b0ccdda796f856a2cb79ec93d97ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2d2b9d6776322d18b7d1895e837f2431" id="r_a2d2b9d6776322d18b7d1895e837f2431"><td class="memItemLeft" align="right" valign="top"><a id="a2d2b9d6776322d18b7d1895e837f2431" name="a2d2b9d6776322d18b7d1895e837f2431"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyFileInfo</b> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> &amp;tgt, const <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> &amp;src)</td></tr>
<tr class="memdesc:a2d2b9d6776322d18b7d1895e837f2431"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the source code location from src to tgt. <br /></td></tr>
<tr class="separator:a2d2b9d6776322d18b7d1895e837f2431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32ad9ea120d003cf2c53329fcfc7f7d0" id="r_a32ad9ea120d003cf2c53329fcfc7f7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a32ad9ea120d003cf2c53329fcfc7f7d0">setSourcePositionInSubtreeToCompilerGenerated</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *n)</td></tr>
<tr class="memdesc:a32ad9ea120d003cf2c53329fcfc7f7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets source position in entire subtree of n to compiler generated  <br /></td></tr>
<tr class="separator:a32ad9ea120d003cf2c53329fcfc7f7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fc97a488b3ece02688e16ae11ede50" id="r_a57fc97a488b3ece02688e16ae11ede50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a57fc97a488b3ece02688e16ae11ede50">setSourcePositionInSubtreeToCompilerGenerated</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> &amp;n)</td></tr>
<tr class="memdesc:a57fc97a488b3ece02688e16ae11ede50"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets source position in entire subtree of n to compiler generated  <br /></td></tr>
<tr class="separator:a57fc97a488b3ece02688e16ae11ede50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36baef106acd662b5bc09aafb07b403" id="r_ad36baef106acd662b5bc09aafb07b403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#ad36baef106acd662b5bc09aafb07b403">convertAdaToCxxComments</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, bool cxxLineComments=true)</td></tr>
<tr class="memdesc:ad36baef106acd662b5bc09aafb07b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">/}  <br /></td></tr>
<tr class="separator:ad36baef106acd662b5bc09aafb07b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a4b8be5b62013ce84801685e3d0cba" id="r_a28a4b8be5b62013ce84801685e3d0cba"><td class="memItemLeft" align="right" valign="top"><a id="a28a4b8be5b62013ce84801685e3d0cba" name="a28a4b8be5b62013ce84801685e3d0cba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convertToCaseSensitiveSymbolTables</b> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>
<tr class="memdesc:a28a4b8be5b62013ce84801685e3d0cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts all symbol tables from case insensitive to case sensitive <br /></td></tr>
<tr class="separator:a28a4b8be5b62013ce84801685e3d0cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7162d13ae5b52ba6bf0596ec3273efdf" id="r_a7162d13ae5b52ba6bf0596ec3273efdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface_1_1Ada.html#a7162d13ae5b52ba6bf0596ec3273efdf">convertToOperatorRepresentation</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, bool convertCallSyntax=false, bool convertNamedArguments=false)</td></tr>
<tr class="memdesc:a7162d13ae5b52ba6bf0596ec3273efdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts AST from a function call representation to operator form for fundamental operator declarations.  <br /></td></tr>
<tr class="separator:a7162d13ae5b52ba6bf0596ec3273efdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aba41099d3af46567d2d857dba0959fc0" id="r_aba41099d3af46567d2d857dba0959fc0"><td class="memItemLeft" align="right" valign="top"><a id="aba41099d3af46567d2d857dba0959fc0" name="aba41099d3af46567d2d857dba0959fc0"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>roseOperatorPrefix</b></td></tr>
<tr class="separator:aba41099d3af46567d2d857dba0959fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ade04da47e64b9670d0312b769f4dd" id="r_ad7ade04da47e64b9670d0312b769f4dd"><td class="memItemLeft" align="right" valign="top"><a id="ad7ade04da47e64b9670d0312b769f4dd" name="ad7ade04da47e64b9670d0312b769f4dd"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>packageStandardName</b></td></tr>
<tr class="separator:ad7ade04da47e64b9670d0312b769f4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad871b95421e6829689dce5a8ccd706c9" id="r_ad871b95421e6829689dce5a8ccd706c9"><td class="memItemLeft" align="right" valign="top"><a id="ad871b95421e6829689dce5a8ccd706c9" name="ad871b95421e6829689dce5a8ccd706c9"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>durationTypeName</b></td></tr>
<tr class="separator:ad871b95421e6829689dce5a8ccd706c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b137ec6e1dfcaff0f32bfc7a3074cd" id="r_ae7b137ec6e1dfcaff0f32bfc7a3074cd"><td class="memItemLeft" align="right" valign="top"><a id="ae7b137ec6e1dfcaff0f32bfc7a3074cd" name="ae7b137ec6e1dfcaff0f32bfc7a3074cd"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>exceptionName</b></td></tr>
<tr class="separator:ae7b137ec6e1dfcaff0f32bfc7a3074cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a39ed43f025178691dd0a7ed797fb7a53" name="a39ed43f025178691dd0a7ed797fb7a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed43f025178691dd0a7ed797fb7a53">&#9670;&#160;</a></span>StatementRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::StatementRange = typedef std::pair&lt;SgDeclarationStatementPtrList::iterator, SgDeclarationStatementPtrList::iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00198">198</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a6548c20f85b05fb5dfc6a5fd8014ea6d" name="a6548c20f85b05fb5dfc6a5fd8014ea6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6548c20f85b05fb5dfc6a5fd8014ea6d">&#9670;&#160;</a></span>FlatArrayTypeBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSageInterface_1_1Ada.html#a6548c20f85b05fb5dfc6a5fd8014ea6d">SageInterface::Ada::FlatArrayTypeBase</a> = typedef std::tuple&lt;<a class="el" href="classSgArrayType.html">SgArrayType</a>*, std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>defines the result type for <a class="el" href="namespaceSageInterface_1_1Ada.html#a13d519022548c649c679d3265dc6daf8">getArrayTypeInfo</a> </p>

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00226">226</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="ab5f4252fcab8fb06f59ca5b0b18c3247" name="ab5f4252fcab8fb06f59ca5b0b18c3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f4252fcab8fb06f59ca5b0b18c3247">&#9670;&#160;</a></span>RecordFieldBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::RecordFieldBase = typedef std::tuple&lt;const <a class="el" href="classSgSymbol.html">SgSymbol</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00251">251</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="ab39e794e02d47f7b208fdf5a7426319f" name="ab39e794e02d47f7b208fdf5a7426319f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39e794e02d47f7b208fdf5a7426319f">&#9670;&#160;</a></span>IfExpressionInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSageInterface_1_1Ada.html#ab39e794e02d47f7b208fdf5a7426319f">SageInterface::Ada::IfExpressionInfo</a> = typedef <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfInfo</a>&lt;<a class="el" href="classSgExpression.html">SgExpression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a sequence of if (x) then value the last else does not have </p>

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00293">293</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="afcc60b817b86878e52fd7c3414f65f43" name="afcc60b817b86878e52fd7c3414f65f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc60b817b86878e52fd7c3414f65f43">&#9670;&#160;</a></span>IfStatementInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">SageInterface::Ada::IfStatementInfo</a> = typedef <a class="el" href="structSageInterface_1_1Ada_1_1IfInfo.html">IfInfo</a>&lt;<a class="el" href="classSgStatement.html">SgStatement</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00294">294</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="aae9e7583bb754823bde7a34f74aeb022" name="aae9e7583bb754823bde7a34f74aeb022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9e7583bb754823bde7a34f74aeb022">&#9670;&#160;</a></span>TypeDescriptionBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::TypeDescriptionBase = typedef std::tuple&lt;<a class="el" href="classSgType.html">SgType</a>*, bool, std::vector&lt;<a class="el" href="classSgAdaTypeConstraint.html">SgAdaTypeConstraint</a>*&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00548">548</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a79edadfdbe63f0a0b9934bdf4b813763" name="a79edadfdbe63f0a0b9934bdf4b813763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79edadfdbe63f0a0b9934bdf4b813763">&#9670;&#160;</a></span>DominantArgInfoBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::DominantArgInfoBase = typedef std::tuple&lt;const <a class="el" href="classSgType.html">SgType</a>*, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00601">601</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="af782e1f4fc3c807078f99d1c19ce98c3" name="af782e1f4fc3c807078f99d1c19ce98c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af782e1f4fc3c807078f99d1c19ce98c3">&#9670;&#160;</a></span>OperatorScopeInfoBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::OperatorScopeInfoBase = typedef std::tuple&lt;<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a>*, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00615">615</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a99a72892d9db8da2f0bca0e42b9b325d" name="a99a72892d9db8da2f0bca0e42b9b325d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a72892d9db8da2f0bca0e42b9b325d">&#9670;&#160;</a></span>ImportedUnitResultBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSageInterface_1_1Ada.html#a99a72892d9db8da2f0bca0e42b9b325d">SageInterface::Ada::ImportedUnitResultBase</a> = typedef std::tuple&lt; std::string, const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>*, const <a class="el" href="classSgAdaRenamingDecl.html">SgAdaRenamingDecl</a>*, const <a class="el" href="classSgExpression.html">SgExpression</a>* &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>describes properties of imported units </p>

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00664">664</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a216e92709b73977d9503c4ffabd49040" name="a216e92709b73977d9503c4ffabd49040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216e92709b73977d9503c4ffabd49040">&#9670;&#160;</a></span>AggregateInfoBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSageInterface_1_1Ada.html#a216e92709b73977d9503c4ffabd49040">SageInterface::Ada::AggregateInfoBase</a> = typedef std::tuple&lt; <a class="el" href="classSgAdaAncestorInitializer.html">SgAdaAncestorInitializer</a>*, SgExpressionPtrList::const_iterator, SgExpressionPtrList::const_iterator &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Details of expression aggregates. </p>

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00711">711</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a5f97940b7aa0be08a83e90ee66634d3d" name="a5f97940b7aa0be08a83e90ee66634d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f97940b7aa0be08a83e90ee66634d3d">&#9670;&#160;</a></span>PrimitiveParameterDescBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::PrimitiveParameterDescBase = typedef std::tuple&lt;size_t, const <a class="el" href="classSgInitializedName.html">SgInitializedName</a>*, const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00779">779</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<a id="a1497394bca37288a880aa4e54faffe0e" name="a1497394bca37288a880aa4e54faffe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1497394bca37288a880aa4e54faffe0e">&#9670;&#160;</a></span>PrimitiveSignatureElementsDescBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SageInterface::Ada::PrimitiveSignatureElementsDescBase = typedef std::tuple&lt; const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* , std::vector&lt;<a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sageInterfaceAda_8h_source.html#l00824">824</a> of file <a class="el" href="sageInterfaceAda_8h_source.html">sageInterfaceAda.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb935e5eb9b7dbe781e62fa6ac090691" name="acb935e5eb9b7dbe781e62fa6ac090691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb935e5eb9b7dbe781e62fa6ac090691">&#9670;&#160;</a></span>withPrivateDefinition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::withPrivateDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td>
          <td class="paramname"><em>dcl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if the declaration dcl defines a public type that is completed in a private section. </p>
<dl class="section return"><dt>Returns</dt><dd>true, iff dcl is public and completed in a private section. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>dcl is not null and points to a first-nondefining declaration. </dd></dl>

</div>
</div>
<a id="a22de8acdeaf25645583ba63b029bf52d" name="a22de8acdeaf25645583ba63b029bf52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22de8acdeaf25645583ba63b029bf52d">&#9670;&#160;</a></span>withPrivateDefinition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::withPrivateDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;&#160;</td>
          <td class="paramname"><em>dcl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if the declaration dcl defines a public type that is completed in a private section. </p>
<dl class="section return"><dt>Returns</dt><dd>true, iff dcl is public and completed in a private section. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>dcl is not null and points to a first-nondefining declaration. </dd></dl>

</div>
</div>
<a id="a6954eea873cab61563a06932b41b60ef" name="a6954eea873cab61563a06932b41b60ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6954eea873cab61563a06932b41b60ef">&#9670;&#160;</a></span>unconstrained() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::unconstrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if ty is an unconstrained array </p>
<dl class="section return"><dt>Returns</dt><dd>true iff ty is unconstrained </dd></dl>

</div>
</div>
<a id="a83ccba1cb54129a2b33caa4f5d26ce8d" name="a83ccba1cb54129a2b33caa4f5d26ce8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ccba1cb54129a2b33caa4f5d26ce8d">&#9670;&#160;</a></span>unconstrained() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::unconstrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if ty is an unconstrained array </p>
<dl class="section return"><dt>Returns</dt><dd>true iff ty is unconstrained </dd></dl>

</div>
</div>
<a id="a9424a600fefabb399d539ad37e6fe1e3" name="a9424a600fefabb399d539ad37e6fe1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9424a600fefabb399d539ad37e6fe1e3">&#9670;&#160;</a></span>anonymousAccess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::anonymousAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if ty is an anonymous access type </p>
<dl class="section return"><dt>Returns</dt><dd>true iff ty is an anonymous access type </dd></dl>

</div>
</div>
<a id="a9454966a8be4254165d15aae57f0aceb" name="a9454966a8be4254165d15aae57f0aceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9454966a8be4254165d15aae57f0aceb">&#9670;&#160;</a></span>anonymousAccess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::anonymousAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if ty is an anonymous access type </p>
<dl class="section return"><dt>Returns</dt><dd>true iff ty is an anonymous access type </dd></dl>

</div>
</div>
<a id="a238a5f41854aea8040ce63f778b63a76" name="a238a5f41854aea8040ce63f778b63a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238a5f41854aea8040ce63f778b63a76">&#9670;&#160;</a></span>declsInPackage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatementRange SageInterface::Ada::declsInPackage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> &amp;&#160;</td>
          <td class="paramname"><em>globalScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mainFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns all statements/declarations in the global scope that were defined in the source file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalScope</td><td>a reference to the global scope </td></tr>
    <tr><td class="paramname">mainfile</td><td>a reference to the main source file (name) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range [first-in-sequence, limit-of-sequence) of global-scope level statements in mainFile</dd></dl>
<p>In other words, the declarations in the with'ed packages are excluded from the returned range. </p>

</div>
</div>
<a id="a92fe120df66ef58ee7b0b83709f9a87d" name="a92fe120df66ef58ee7b0b83709f9a87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fe120df66ef58ee7b0b83709f9a87d">&#9670;&#160;</a></span>declsInPackage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StatementRange SageInterface::Ada::declsInPackage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> &amp;&#160;</td>
          <td class="paramname"><em>globalScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgSourceFile.html">SgSourceFile</a> &amp;&#160;</td>
          <td class="paramname"><em>mainFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns all statements/declarations in the global scope that were defined in the source file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalScope</td><td>a reference to the global scope </td></tr>
    <tr><td class="paramname">mainfile</td><td>a reference to the main source file (name) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range [first-in-sequence, limit-of-sequence) of global-scope level statements in mainFile</dd></dl>
<p>In other words, the declarations in the with'ed packages are excluded from the returned range. </p>

</div>
</div>
<a id="ac805f44de5f531f30e099676787ebfa1" name="ac805f44de5f531f30e099676787ebfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac805f44de5f531f30e099676787ebfa1">&#9670;&#160;</a></span>firstLastDimension() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::Ada::firstLastDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an integer value for args[0] as used by type attributes first and last </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>an exception if args[0] cannot be constant folded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>currently only constant values are supported </dd></dl>

</div>
</div>
<a id="a5d59bba127eb06f7e6c1e252506a335b" name="a5d59bba127eb06f7e6c1e252506a335b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d59bba127eb06f7e6c1e252506a335b">&#9670;&#160;</a></span>firstLastDimension() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::Ada::firstLastDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an integer value for args[0] as used by type attributes first and last </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>an exception if args[0] cannot be constant folded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>currently only constant values are supported </dd></dl>

</div>
</div>
<a id="a13d519022548c649c679d3265dc6daf8" name="a13d519022548c649c679d3265dc6daf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d519022548c649c679d3265dc6daf8">&#9670;&#160;</a></span>getArrayTypeInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1FlatArrayType.html">FlatArrayType</a> SageInterface::Ada::getArrayTypeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>atype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a flattened representation of <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> array types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atype</td><td>the type of the array to be flattened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iff atype is not an arraytype, a pair &lt;nullptr, empty vector&gt; is returned otherwise a pair of a array pointer, and a vector of index ranges. Index ranges can be specified in terms of a range (<a class="el" href="classSgRangeExp.html">SgRangeExp</a>), a type attribute (<a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a>), or full type range (<a class="el" href="classSgTypeExpression.html">SgTypeExpression</a>). (the expressions are part of the AST and MUST NOT BE DELETED). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>atype is not null. </dd></dl>

</div>
</div>
<a id="aa13edf625d219f241287b67626f4d786" name="aa13edf625d219f241287b67626f4d786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13edf625d219f241287b67626f4d786">&#9670;&#160;</a></span>getArrayTypeInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1FlatArrayType.html">FlatArrayType</a> SageInterface::Ada::getArrayTypeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>atype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a flattened representation of <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> array types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atype</td><td>the type of the array to be flattened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iff atype is not an arraytype, a pair &lt;nullptr, empty vector&gt; is returned otherwise a pair of a array pointer, and a vector of index ranges. Index ranges can be specified in terms of a range (<a class="el" href="classSgRangeExp.html">SgRangeExp</a>), a type attribute (<a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a>), or full type range (<a class="el" href="classSgTypeExpression.html">SgTypeExpression</a>). (the expressions are part of the AST and MUST NOT BE DELETED). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>atype is not null. </dd></dl>

</div>
</div>
<a id="aafe16cbbbd9700b49c52241d6a947262" name="aafe16cbbbd9700b49c52241d6a947262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe16cbbbd9700b49c52241d6a947262">&#9670;&#160;</a></span>getAllRecordFields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1RecordField.html">RecordField</a> &gt; SageInterface::Ada::getAllRecordFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns all fields (defined and inherited) of a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>the class definition for which the fields are sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>currently the entries in the returned vector are unordered. </dd></dl>

</div>
</div>
<a id="a3f739c1b8b369e252737fc0ad1c6e7dd" name="a3f739c1b8b369e252737fc0ad1c6e7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f739c1b8b369e252737fc0ad1c6e7dd">&#9670;&#160;</a></span>getAllRecordFields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1RecordField.html">RecordField</a> &gt; SageInterface::Ada::getAllRecordFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> *&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns all fields (defined and inherited) of a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>the class definition for which the fields are sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>currently the entries in the returned vector are unordered. </dd></dl>

</div>
</div>
<a id="af6f038b25d6131023783344583145c4f" name="af6f038b25d6131023783344583145c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f038b25d6131023783344583145c4f">&#9670;&#160;</a></span>staticIntegralValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int SageInterface::Ada::staticIntegralValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer constant folding </p>
<dl class="section return"><dt>Returns</dt><dd>an integral value for an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> expression if possible </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">an</td><td>exception otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b5b0fe1ed4763a8168f940d626d4fd5" name="a9b5b0fe1ed4763a8168f940d626d4fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5b0fe1ed4763a8168f940d626d4fd5">&#9670;&#160;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgRangeExp.html">SgRangeExp</a> * SageInterface::Ada::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> *&#160;</td>
          <td class="paramname"><em>rangeAttribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range for the range attribute rangeAttribute. </p>
<dl class="section return"><dt>Returns</dt><dd>a range if rangeAttribute is a range attribute and a range expression is in the AST; nullptr otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">a</td><td>std::runtime_error if the rangeAttribute uses an index specification that is not an integral constant expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>rangeAttribute is not null </dd></dl>

</div>
</div>
<a id="a3869ed814b216d571d5db83752f2b686" name="a3869ed814b216d571d5db83752f2b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3869ed814b216d571d5db83752f2b686">&#9670;&#160;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgRangeExp.html">SgRangeExp</a> * SageInterface::Ada::range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> &amp;&#160;</td>
          <td class="paramname"><em>rangeAttribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range for the range attribute rangeAttribute. </p>
<dl class="section return"><dt>Returns</dt><dd>a range if rangeAttribute is a range attribute and a range expression is in the AST; nullptr otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">a</td><td>std::runtime_error if the rangeAttribute uses an index specification that is not an integral constant expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>rangeAttribute is not null </dd></dl>

</div>
</div>
<a id="ade17c71e72b49bb8af4af5351125d9e7" name="ade17c71e72b49bb8af4af5351125d9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade17c71e72b49bb8af4af5351125d9e7">&#9670;&#160;</a></span>correspondingBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::correspondingBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the body scope (aka definition) of a task, package, or protected object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>a task, package, protected object spec or body </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding body scope (i.e., <a class="el" href="classSgAdaProtectedBody.html">SgAdaProtectedBody</a>, <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a>, <a class="el" href="classSgAdaTaskBody.html">SgAdaTaskBody</a>) returns null when a body cannot be found</dd></dl>
<p>given a spec or body, the function returns the body, null otherwise e.g., getBodyScope(SgAdaPackageSpec) -&gt; <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> getBodyScope(SgAdaPackageBody) -&gt; <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> getBodyScope(SgFunctionDefinition) -&gt; nullptr </p>

</div>
</div>
<a id="a014f5261d964c7e5bc7a1805fcc55323" name="a014f5261d964c7e5bc7a1805fcc55323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014f5261d964c7e5bc7a1805fcc55323">&#9670;&#160;</a></span>tryFollowsDeclarativeBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::tryFollowsDeclarativeBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff n is a try block following a declarative region </p>
<dl class="section note"><dt>Note</dt><dd>an ada try block is a function block, whose non-declarative range includes exactly one try stmt. In this case, the unparser can omit the separate begin and end statement. </dd></dl>

</div>
</div>
<a id="a6a2cba64b9301577a907ed30f83b64e0" name="a6a2cba64b9301577a907ed30f83b64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2cba64b9301577a907ed30f83b64e0">&#9670;&#160;</a></span>tryFollowsDeclarativeBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::tryFollowsDeclarativeBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff n is a try block following a declarative region </p>
<dl class="section note"><dt>Note</dt><dd>an ada try block is a function block, whose non-declarative range includes exactly one try stmt. In this case, the unparser can omit the separate begin and end statement. </dd></dl>

</div>
</div>
<a id="abecbc4a0c49ea5ea504a4edb8bbdc64f" name="abecbc4a0c49ea5ea504a4edb8bbdc64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecbc4a0c49ea5ea504a4edb8bbdc64f">&#9670;&#160;</a></span>isPackageTryBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isPackageTryBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff n is an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> package try block </p>
<dl class="section note"><dt>Note</dt><dd>an ada try block is a function block, whose non-declarative range includes exactly one try stmt. In this case, the unparser can omit the separate begin and end statement. </dd></dl>

</div>
</div>
<a id="a59c6fb0fb1c70e894da60ab1173e3dbc" name="a59c6fb0fb1c70e894da60ab1173e3dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c6fb0fb1c70e894da60ab1173e3dbc">&#9670;&#160;</a></span>isPackageTryBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isPackageTryBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgTryStmt.html">SgTryStmt</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true iff n is an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> package try block </p>
<dl class="section note"><dt>Note</dt><dd>an ada try block is a function block, whose non-declarative range includes exactly one try stmt. In this case, the unparser can omit the separate begin and end statement. </dd></dl>

</div>
</div>
<a id="a08b7c3044051ad8cbacddd167512e9da" name="a08b7c3044051ad8cbacddd167512e9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7c3044051ad8cbacddd167512e9da">&#9670;&#160;</a></span>isFixedType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty is a fixed point type </p>
<p>also return true for decimal fixed points </p>

</div>
</div>
<a id="ad16fb7d493fd5a111a42381e0fd5f749" name="ad16fb7d493fd5a111a42381e0fd5f749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16fb7d493fd5a111a42381e0fd5f749">&#9670;&#160;</a></span>isFixedType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty is a fixed point type </p>
<p>also return true for decimal fixed points </p>

</div>
</div>
<a id="a4bed564e1db272cc6456d042aecc856a" name="a4bed564e1db272cc6456d042aecc856a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bed564e1db272cc6456d042aecc856a">&#9670;&#160;</a></span>isScalarType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isScalarType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if ty refers to a scalar type </p>
<p>true if the ty's root type is a modular type, signed integer type, enumeration type, discrete type, fixed type, decimal fixed type, or enum type. </p>

</div>
</div>
<a id="a0923340144fe4f930b7ba291da1759f1" name="a0923340144fe4f930b7ba291da1759f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0923340144fe4f930b7ba291da1759f1">&#9670;&#160;</a></span>isScalarType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isScalarType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if ty refers to a scalar type </p>
<p>true if the ty's root type is a modular type, signed integer type, enumeration type, discrete type, fixed type, decimal fixed type, or enum type. </p>

</div>
</div>
<a id="a20edc181593ab6be364b44439592816a" name="a20edc181593ab6be364b44439592816a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20edc181593ab6be364b44439592816a">&#9670;&#160;</a></span>resolvesToFixedType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::resolvesToFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty resolves to a fixed point type </p>
<p>also return true for decimal fixed points </p>

</div>
</div>
<a id="aafbb1a3f95266ba7bf0ccb8dac1f0fb1" name="aafbb1a3f95266ba7bf0ccb8dac1f0fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbb1a3f95266ba7bf0ccb8dac1f0fb1">&#9670;&#160;</a></span>resolvesToFixedType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::resolvesToFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty resolves to a fixed point type </p>
<p>also return true for decimal fixed points </p>

</div>
</div>
<a id="aa191cf6e7d56b01783b4d1314155ff93" name="aa191cf6e7d56b01783b4d1314155ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa191cf6e7d56b01783b4d1314155ff93">&#9670;&#160;</a></span>isDecimalFixedType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isDecimalFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty is a decimal fixed point type </p>
<p>implementation is incomplete and only detects formal decimal fixed point constraints </p>

</div>
</div>
<a id="a475154b8808d4c8b35c3a8b47b93a199" name="a475154b8808d4c8b35c3a8b47b93a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475154b8808d4c8b35c3a8b47b93a199">&#9670;&#160;</a></span>isDecimalFixedType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isDecimalFixedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if the type ty is a decimal fixed point type </p>
<p>implementation is incomplete and only detects formal decimal fixed point constraints </p>

</div>
</div>
<a id="a7a3674cc38077b6ad5104f1c6ae54561" name="a7a3674cc38077b6ad5104f1c6ae54561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3674cc38077b6ad5104f1c6ae54561">&#9670;&#160;</a></span>booleanConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; SageInterface::Ada::booleanConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if e denotes an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> boolean constant, it is returned; otherwise an empty result is returned. </p>
<p>the function does not perform any constant folding </p>

</div>
</div>
<a id="adb63fe7a7c49ca0be2167fdbeb907b58" name="adb63fe7a7c49ca0be2167fdbeb907b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb63fe7a7c49ca0be2167fdbeb907b58">&#9670;&#160;</a></span>booleanConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; SageInterface::Ada::booleanConstant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if e denotes an <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> boolean constant, it is returned; otherwise an empty result is returned. </p>
<p>the function does not perform any constant folding </p>

</div>
</div>
<a id="a87147388f4bf9cdc02362816680f4cd9" name="a87147388f4bf9cdc02362816680f4cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87147388f4bf9cdc02362816680f4cd9">&#9670;&#160;</a></span>isGenericDecl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> * SageInterface::Ada::isGenericDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node that makes a declaration (either function/procedure or package) generic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a declaration that is possibly part of a generic declaration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generic declaration of n, where n is a either function/procedure or package that is declared directly under an <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a>; nullptr otherwise.</dd></dl>
<p>For a subtree SgAdaGenericDecl-&gt;SgAdaGenericDefn-&gt;n, the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node is returned. </p>

</div>
</div>
<a id="af8b0ff581f9b831233ec97e0090d6414" name="af8b0ff581f9b831233ec97e0090d6414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b0ff581f9b831233ec97e0090d6414">&#9670;&#160;</a></span>isGenericDecl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> * SageInterface::Ada::isGenericDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node that makes a declaration (either function/procedure or package) generic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a declaration that is possibly part of a generic declaration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the generic declaration of n, where n is a either function/procedure or package that is declared directly under an <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a>; nullptr otherwise.</dd></dl>
<p>For a subtree SgAdaGenericDecl-&gt;SgAdaGenericDefn-&gt;n, the <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> node is returned. </p>

</div>
</div>
<a id="a857a9dba27b4faa29b3cda83754862d5" name="a857a9dba27b4faa29b3cda83754862d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857a9dba27b4faa29b3cda83754862d5">&#9670;&#160;</a></span>getGenericDecl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> &amp; SageInterface::Ada::getGenericDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> for a given <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a>. </p>
<p>skips over intermediate renaming declarations. </p>

</div>
</div>
<a id="a0bf9f0736b0bcb1e47a41f03c362c38b" name="a0bf9f0736b0bcb1e47a41f03c362c38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf9f0736b0bcb1e47a41f03c362c38b">&#9670;&#160;</a></span>getGenericDecl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> * SageInterface::Ada::getGenericDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classSgAdaGenericDecl.html">SgAdaGenericDecl</a> for a given <a class="el" href="classSgAdaGenericInstanceDecl.html">SgAdaGenericInstanceDecl</a>. </p>
<p>skips over intermediate renaming declarations. </p>

</div>
</div>
<a id="aa6e7d14f3339d47a64961cc808e044cc" name="aa6e7d14f3339d47a64961cc808e044cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e7d14f3339d47a64961cc808e044cc">&#9670;&#160;</a></span>typeOfExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a> SageInterface::Ada::typeOfExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the type of an expression corrects for some peculiarities in the AST </p>

</div>
</div>
<a id="abc1f93b63c9d96fec819fcd451922bf5" name="abc1f93b63c9d96fec819fcd451922bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1f93b63c9d96fec819fcd451922bf5">&#9670;&#160;</a></span>typeOfExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1TypeDescription.html">TypeDescription</a> SageInterface::Ada::typeOfExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the type of an expression corrects for some peculiarities in the AST </p>

</div>
</div>
<a id="aa7c1b8b1565f3a32602490fa72058d62" name="aa7c1b8b1565f3a32602490fa72058d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c1b8b1565f3a32602490fa72058d62">&#9670;&#160;</a></span>baseOfAccessType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a> * SageInterface::Ada::baseOfAccessType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the base type if ty is an access type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>some type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base type of ty, iff ty is some access type nullptr otherwise; </dd></dl>

</div>
</div>
<a id="ae4d46a011c2fd5c4084f1573110dd025" name="ae4d46a011c2fd5c4084f1573110dd025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d46a011c2fd5c4084f1573110dd025">&#9670;&#160;</a></span>baseOfAccessType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a> * SageInterface::Ada::baseOfAccessType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the base type if ty is an access type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>some type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base type of ty, iff ty is some access type nullptr otherwise; </dd></dl>

</div>
</div>
<a id="a666b446147ccf3900b57445ab9d700ed" name="a666b446147ccf3900b57445ab9d700ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666b446147ccf3900b57445ab9d700ed">&#9670;&#160;</a></span>operatorScope() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1OperatorScopeInfo.html">OperatorScopeInfo</a> SageInterface::Ada::operatorScope </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SgTypePtrList &amp;&#160;</td>
          <td class="paramname"><em>argtypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the scope where an operator with name opname and argument types in argtypes shall be declared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opname</td><td>the operator name </td></tr>
    <tr><td class="paramname">argtypes</td><td>a list of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a scope where the described operator shall be declared, and the argument position associated with the scope. </dd></dl>

</div>
</div>
<a id="a245c9766a85b51d0219ba4d739af57b7" name="a245c9766a85b51d0219ba4d739af57b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245c9766a85b51d0219ba4d739af57b7">&#9670;&#160;</a></span>operatorScope() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp; SageInterface::Ada::operatorScope </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the scope where an operator associated with type ty shall be declared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opname</td><td>the operator name </td></tr>
    <tr><td class="paramname">ty</td><td>the type name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a scope where the described operator shall be declared. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the main difference to declarationScope is that fixed types require certain operators to exist in package standard. </dd></dl>

</div>
</div>
<a id="aa05e53a8be461fe0da7805c88a485d60" name="aa05e53a8be461fe0da7805c88a485d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05e53a8be461fe0da7805c88a485d60">&#9670;&#160;</a></span>operatorScope() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::operatorScope </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the scope where an operator associated with type ty shall be declared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opname</td><td>the operator name </td></tr>
    <tr><td class="paramname">ty</td><td>the type name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a scope where the described operator shall be declared. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the main difference to declarationScope is that fixed types require certain operators to exist in package standard. </dd></dl>

</div>
</div>
<a id="aeab189505b5fe4d846f50ec48ced39a7" name="aeab189505b5fe4d846f50ec48ced39a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab189505b5fe4d846f50ec48ced39a7">&#9670;&#160;</a></span>declarationScope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::declarationScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the scope where type ty has been declared </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>some type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scope where ty was declared </dd></dl>

</div>
</div>
<a id="a45533985c2bc4071b5c4e46eaef3b980" name="a45533985c2bc4071b5c4e46eaef3b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45533985c2bc4071b5c4e46eaef3b980">&#9670;&#160;</a></span>declarationScope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::declarationScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the scope where type ty has been declared </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>some type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scope where ty was declared </dd></dl>

</div>
</div>
<a id="afb3da93712b3ff8241449970492506b5" name="afb3da93712b3ff8241449970492506b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3da93712b3ff8241449970492506b5">&#9670;&#160;</a></span>convertRoseOperatorNameToAdaName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::Ada::convertRoseOperatorNameToAdaName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameInRose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>takes a function name as used in ROSE and converts it to a name in <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> (i.e., '"' + operator_text + '"'). </p>
<p>if nameInRose does not name an operator, then the name is returned as is. </p>

</div>
</div>
<a id="a03100a789221c2132c9f86639bcd75b0" name="a03100a789221c2132c9f86639bcd75b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03100a789221c2132c9f86639bcd75b0">&#9670;&#160;</a></span>convertRoseOperatorNameToAdaOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::Ada::convertRoseOperatorNameToAdaOperator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameInRose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>takes a function name as used in ROSE and converts it to an operator in <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> (i.e., operator_text). </p>
<p>if nameInRose does not name an operator, an empty string is returned </p>

</div>
</div>
<a id="a37dc850e3b6c0ea7a93c3d28bee50b50" name="a37dc850e3b6c0ea7a93c3d28bee50b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc850e3b6c0ea7a93c3d28bee50b50">&#9670;&#160;</a></span>functionType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> * SageInterface::Ada::functionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&#160;</td>
          <td class="paramname"><em>fnsy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the static type of the function symbol fnsy </p>
<dl class="section note"><dt>Note</dt><dd>The pointer based version returns nullptr if fnsy is nullptr. </dd></dl>

</div>
</div>
<a id="a802da0c4cabf5391e9e3ecc10359ce7c" name="a802da0c4cabf5391e9e3ecc10359ce7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802da0c4cabf5391e9e3ecc10359ce7c">&#9670;&#160;</a></span>functionType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> &amp; SageInterface::Ada::functionType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>fnsy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the static type of the function symbol fnsy </p>
<dl class="section note"><dt>Note</dt><dd>The pointer based version returns nullptr if fnsy is nullptr. </dd></dl>

</div>
</div>
<a id="a6cc88fff559ad76ca897928597b4344f" name="a6cc88fff559ad76ca897928597b4344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc88fff559ad76ca897928597b4344f">&#9670;&#160;</a></span>primitiveParameterPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; SageInterface::Ada::primitiveParameterPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the descriptions for parameters that make an operation primitive. </p>
<p>(e.g., derived types, tagged types, and anonymous access types of those.) </p><dl class="section note"><dt>Note</dt><dd>Different sources have (slightly) different definitions of primitive subprograms and primitive arguments. This implementation uses the definition by learn.adacore.com: "A primitive operation (or just a primitive) is a subprogram attached to a type.
     Ada defines primitives as subprograms defined in the same scope as the type." <a href="https://learn.adacore.com/courses/intro-to-ada/chapters/object_oriented_programming.html">https://learn.adacore.com/courses/intro-to-ada/chapters/object_oriented_programming.html</a> Thus, primitive parameters can also be of derived type.</dd></dl>
<p>Other sources tie the notion of primitive arguments to tagged types. e.g., <a href="https://en.wikibooks.org/wiki/Ada_Programming/Object_Orientation#Primitive_operations">https://en.wikibooks.org/wiki/Ada_Programming/Object_Orientation#Primitive_operations</a> . accessed on 04/01/26.</p>

</div>
</div>
<a id="a4857f0056cec96679c8c91eb01a5aebd" name="a4857f0056cec96679c8c91eb01a5aebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4857f0056cec96679c8c91eb01a5aebd">&#9670;&#160;</a></span>primitiveParameterPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; SageInterface::Ada::primitiveParameterPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the descriptions for parameters that make an operation primitive. </p>
<p>(e.g., derived types, tagged types, and anonymous access types of those.) </p><dl class="section note"><dt>Note</dt><dd>Different sources have (slightly) different definitions of primitive subprograms and primitive arguments. This implementation uses the definition by learn.adacore.com: "A primitive operation (or just a primitive) is a subprogram attached to a type.
     Ada defines primitives as subprograms defined in the same scope as the type." <a href="https://learn.adacore.com/courses/intro-to-ada/chapters/object_oriented_programming.html">https://learn.adacore.com/courses/intro-to-ada/chapters/object_oriented_programming.html</a> Thus, primitive parameters can also be of derived type.</dd></dl>
<p>Other sources tie the notion of primitive arguments to tagged types. e.g., <a href="https://en.wikibooks.org/wiki/Ada_Programming/Object_Orientation#Primitive_operations">https://en.wikibooks.org/wiki/Ada_Programming/Object_Orientation#Primitive_operations</a> . accessed on 04/01/26.</p>

</div>
</div>
<a id="a1014d1cde94fb98e8cdcfdb800c431f4" name="a1014d1cde94fb98e8cdcfdb800c431f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1014d1cde94fb98e8cdcfdb800c431f4">&#9670;&#160;</a></span>primitiveSignatureElements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveSignatureElementsDesc.html">PrimitiveSignatureElementsDesc</a> SageInterface::Ada::primitiveSignatureElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the descriptions for result type and parameters that make an operation primitive. </p>
<p>(e.g., derived types, tagged types, and anonymous access types of those.) </p>

</div>
</div>
<a id="a78b26402dd9e4be4f390ceeff81f5f05" name="a78b26402dd9e4be4f390ceeff81f5f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b26402dd9e4be4f390ceeff81f5f05">&#9670;&#160;</a></span>primitiveSignatureElements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveSignatureElementsDesc.html">PrimitiveSignatureElementsDesc</a> SageInterface::Ada::primitiveSignatureElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the descriptions for result type and parameters that make an operation primitive. </p>
<p>(e.g., derived types, tagged types, and anonymous access types of those.) </p>

</div>
</div>
<a id="a526c947e2a168ce00089977096293b77" name="a526c947e2a168ce00089977096293b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526c947e2a168ce00089977096293b77">&#9670;&#160;</a></span>exceptionTypeDecl() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> * SageInterface::Ada::exceptionTypeDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns n or a pointer to n if n declares an exception type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an exception declaration candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a exception declaration or nullptr </dd></dl>

</div>
</div>
<a id="a722ba6337c6fc2e49865f081b3fac503" name="a722ba6337c6fc2e49865f081b3fac503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722ba6337c6fc2e49865f081b3fac503">&#9670;&#160;</a></span>exceptionTypeDecl() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> * SageInterface::Ada::exceptionTypeDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns n or a pointer to n if n declares an exception type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an exception declaration candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a exception declaration or nullptr </dd></dl>

</div>
</div>
<a id="a1cbc03248528d9673b5d3a9dc6fefe3f" name="a1cbc03248528d9673b5d3a9dc6fefe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbc03248528d9673b5d3a9dc6fefe3f">&#9670;&#160;</a></span>exceptionTypeDecl() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> * SageInterface::Ada::exceptionTypeDecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns n or a pointer to n if n declares an exception type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an exception declaration candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a exception declaration or nullptr </dd></dl>

</div>
</div>
<a id="a245fb765e12594336a0a696d41c233b0" name="a245fb765e12594336a0a696d41c233b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245fb765e12594336a0a696d41c233b0">&#9670;&#160;</a></span>exceptionTypeDecl() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> * SageInterface::Ada::exceptionTypeDecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns n or a pointer to n if n declares an exception type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an exception declaration candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a exception declaration or nullptr </dd></dl>

</div>
</div>
<a id="a2569a904245da73749a35028e90f0cec" name="a2569a904245da73749a35028e90f0cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2569a904245da73749a35028e90f0cec">&#9670;&#160;</a></span>normalizedCallArguments2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgExpressionPtrList SageInterface::Ada::normalizedCallArguments2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withDefaultArguments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a list of arguments with named arguments placed at the correct position by taking into account the supplied argument list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the call expression </td></tr>
    <tr><td class="paramname">arglist</td><td>a argument list </td></tr>
    <tr><td class="paramname">withDefaultArguments</td><td>true if defaulted arguments should get filled in. if false, defaulted arguments are represented by a nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>when named arguments cannot be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>use this function during AST construction </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aff4fc6bd85f40960fd9b32f47eb45639" name="aff4fc6bd85f40960fd9b32f47eb45639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4fc6bd85f40960fd9b32f47eb45639">&#9670;&#160;</a></span>normalizedCallArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgExpressionPtrList SageInterface::Ada::normalizedCallArguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withDefaultArguments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>attempts to identify the argument list automatically and uses it to invoke the preceding normalizedCallArguments2 function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the call expression </td></tr>
    <tr><td class="paramname">withDefaultArguments</td><td>true if defaulted arguments should get filled in. if false, defaulted arguments are represented by a nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>when there is no function associated with the call. or when normalizedCallArguments2 throws. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calling this function is preferred in the general case. </dd></dl>

</div>
</div>
<a id="a731fb08e6d9eac6284d1c2dfb2010a34" name="a731fb08e6d9eac6284d1c2dfb2010a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731fb08e6d9eac6284d1c2dfb2010a34">&#9670;&#160;</a></span>calleeParameterList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> * SageInterface::Ada::calleeParameterList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the function parameter list of the associated callee (if available). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a function call expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of the parameter list of the associated function declaration or renaming declaration. nullptr, if no such function can be identified. </dd></dl>

</div>
</div>
<a id="a24d2d6b2bc0ce531e3253095bbca3b50" name="a24d2d6b2bc0ce531e3253095bbca3b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d2d6b2bc0ce531e3253095bbca3b50">&#9670;&#160;</a></span>calleeParameterList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> * SageInterface::Ada::calleeParameterList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the function parameter list of the associated callee (if available). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a function call expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of the parameter list of the associated function declaration or renaming declaration. nullptr, if no such function can be identified. </dd></dl>

</div>
</div>
<a id="ac5a7b4fc1dc863cc824e14a8607c3847" name="ac5a7b4fc1dc863cc824e14a8607c3847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a7b4fc1dc863cc824e14a8607c3847">&#9670;&#160;</a></span>normalizedArgumentPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SageInterface::Ada::normalizedArgumentPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> &amp;&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the parameter position of arg in the callee, after the parameters have been normalized. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">a</td><td>std::logic_error when a position cannot be found.</td></tr>
  </table>
  </dd>
</dl>
<p>assume declaration: procedure X(left, right : integer := 1); and call: X(right =&gt; 3) then normalizedArgumentPosition(call, "3") -&gt; 1 </p>

</div>
</div>
<a id="a715a9f50049eb827d9ab468849511301" name="a715a9f50049eb827d9ab468849511301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715a9f50049eb827d9ab468849511301">&#9670;&#160;</a></span>findSymbolInContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *, const <a class="el" href="classSgSymbol.html">SgSymbol</a> * &gt; SageInterface::Ada::findSymbolInContext </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>limit</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the symbol with <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> in the context of scope or its logical parents in the range [scope, limit). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>an identifier of the sought symbol </td></tr>
    <tr><td class="paramname">scope</td><td>current scope </td></tr>
    <tr><td class="paramname">limit</td><td>the scope in the chain that terminates the search (this scope will not be considered) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of scope and first symbol inthat scope with the name <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a>. or &lt;nullptr, nullptr&gt; if no such symbol exists in the context.</dd></dl>
<p>a scope can contain multiple symbols with the same name, so the caller may iterate over the remaining names using the scope's accessor functions (next_XXX_symbol). </p>

</div>
</div>
<a id="a0e7dd7e025c6c8d4cf88d852e2afe92e" name="a0e7dd7e025c6c8d4cf88d852e2afe92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7dd7e025c6c8d4cf88d852e2afe92e">&#9670;&#160;</a></span>overridingScope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::overridingScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>primitiveArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the overriding scope of a primitive function based on the associated arguments as defined by the argument list args and the primitive argument positions defined by primitiveArgs. </p>
<dl class="section return"><dt>Returns</dt><dd>the scope of an overriding argument (incl. the original associated type); nullptr if no such scope can be found. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>does not resolve conflicting scopes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>also <a class="el" href="namespaceSageInterface_1_1Ada.html#a6cc88fff559ad76ca897928597b4344f">primitiveParameterPositions</a> </dd></dl>

</div>
</div>
<a id="a524fe66f2a71b7e62bf2143a29f48385" name="a524fe66f2a71b7e62bf2143a29f48385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524fe66f2a71b7e62bf2143a29f48385">&#9670;&#160;</a></span>overridingScope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::overridingScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSageInterface_1_1Ada_1_1PrimitiveParameterDesc.html">PrimitiveParameterDesc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>primitiveArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the overriding scope of a primitive function based on the associated arguments as defined by the argument list args and the primitive argument positions defined by primitiveArgs. </p>
<dl class="section return"><dt>Returns</dt><dd>the scope of an overriding argument (incl. the original associated type); nullptr if no such scope can be found. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>does not resolve conflicting scopes </dd></dl>
<dl class="section see"><dt>See also</dt><dd>also <a class="el" href="namespaceSageInterface_1_1Ada.html#a6cc88fff559ad76ca897928597b4344f">primitiveParameterPositions</a> </dd></dl>

</div>
</div>
<a id="a7ec43bef5ee4d41fcc89cd4f137b62f3" name="a7ec43bef5ee4d41fcc89cd4f137b62f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec43bef5ee4d41fcc89cd4f137b62f3">&#9670;&#160;</a></span>canonicalScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::canonicalScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the canonical scope of some <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> scope scope. </p>
<p>The canonical scope of an entity is its declarative scope e.g., The canonical scope of an <a class="el" href="classSgAdaPackageBody.html">SgAdaPackageBody</a> is its spec, a <a class="el" href="classSgAdaPackageSpec.html">SgAdaPackageSpec</a> </p>

</div>
</div>
<a id="a39a4f130d1bd62d54d7a8cf9b72dc78e" name="a39a4f130d1bd62d54d7a8cf9b72dc78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a4f130d1bd62d54d7a8cf9b72dc78e">&#9670;&#160;</a></span>logicalParentScope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::logicalParentScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the logical parent scope of a scope s. </p>
<p>Compared to si::getEnclosingScope, this function returns the spec as the logical parent for <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> bodies (e.g., packages, tasks, protected objects). Otherwise, the parent scope is the same as returned by si::getEnclosingScope. </p>

</div>
</div>
<a id="a3c2c3e18d7f6b3a01a9a11be3ab6ec40" name="a3c2c3e18d7f6b3a01a9a11be3ab6ec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2c3e18d7f6b3a01a9a11be3ab6ec40">&#9670;&#160;</a></span>logicalParentScope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> * SageInterface::Ada::logicalParentScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the logical parent scope of a scope s. </p>
<p>Compared to si::getEnclosingScope, this function returns the spec as the logical parent for <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> bodies (e.g., packages, tasks, protected objects). Otherwise, the parent scope is the same as returned by si::getEnclosingScope. </p>

</div>
</div>
<a id="a1bdf3748b46d6cbdfea5ac3bb78e05a3" name="a1bdf3748b46d6cbdfea5ac3bb78e05a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdf3748b46d6cbdfea5ac3bb78e05a3">&#9670;&#160;</a></span>associatedDeclaration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * SageInterface::Ada::associatedDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the decl where ty was defined nullptr if no such declaration can be found. </p>
<p>Skips over intermediate derived types, subtypes, access (pointer) types until a <a class="el" href="classSgNamedType.html">SgNamedType</a> is found. Returns the declaration of said type. </p>

</div>
</div>
<a id="abd35d1d46714bdab9ae57f4617ae5d3a" name="abd35d1d46714bdab9ae57f4617ae5d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd35d1d46714bdab9ae57f4617ae5d3a">&#9670;&#160;</a></span>associatedDeclaration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * SageInterface::Ada::associatedDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the decl where ty was defined nullptr if no such declaration can be found. </p>
<p>Skips over intermediate derived types, subtypes, access (pointer) types until a <a class="el" href="classSgNamedType.html">SgNamedType</a> is found. Returns the declaration of said type. </p>

</div>
</div>
<a id="abf37476ab2d63eea746e4df8cd684b2c" name="abf37476ab2d63eea746e4df8cd684b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf37476ab2d63eea746e4df8cd684b2c">&#9670;&#160;</a></span>baseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a> * SageInterface::Ada::baseType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the base type of a type ty </p>
<p>In the following type hierarchy baseTypes(Y) would return { X, S1, S2 } but not Integer. </p><div class="fragment"><div class="line">type X is <span class="keyword">new</span> Integer;</div>
<div class="line">subtype S1 is X <a class="code hl_function" href="namespaceSageInterface_1_1Ada.html#a9b5b0fe1ed4763a8168f940d626d4fd5">range</a> 0..X<span class="stringliteral">&#39;Last;</span></div>
<div class="line"><span class="stringliteral">subtype S2 is S1 range 10..20;</span></div>
<div class="line"><span class="stringliteral">type Y is new S1;</span></div>
<div class="ttc" id="anamespaceSageInterface_1_1Ada_html_a9b5b0fe1ed4763a8168f940d626d4fd5"><div class="ttname"><a href="namespaceSageInterface_1_1Ada.html#a9b5b0fe1ed4763a8168f940d626d4fd5">SageInterface::Ada::range</a></div><div class="ttdeci">SgRangeExp * range(const SgAdaAttributeExp *rangeAttribute)</div><div class="ttdoc">returns a range for the range attribute rangeAttribute.</div></div>
</div><!-- fragment -->  
</div>
</div>
<a id="a3a141f277b6e3509402c448ec993e964" name="a3a141f277b6e3509402c448ec993e964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a141f277b6e3509402c448ec993e964">&#9670;&#160;</a></span>baseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a> * SageInterface::Ada::baseType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the base type of a type ty </p>
<p>In the following type hierarchy baseTypes(Y) would return { X, S1, S2 } but not Integer. </p><div class="fragment"><div class="line">type X is <span class="keyword">new</span> Integer;</div>
<div class="line">subtype S1 is X <a class="code hl_function" href="namespaceSageInterface_1_1Ada.html#a9b5b0fe1ed4763a8168f940d626d4fd5">range</a> 0..X<span class="stringliteral">&#39;Last;</span></div>
<div class="line"><span class="stringliteral">subtype S2 is S1 range 10..20;</span></div>
<div class="line"><span class="stringliteral">type Y is new S1;</span></div>
</div><!-- fragment -->  
</div>
</div>
<a id="aa9cd4bfcfbe7aa6e5e53e380b3499931" name="aa9cd4bfcfbe7aa6e5e53e380b3499931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cd4bfcfbe7aa6e5e53e380b3499931">&#9670;&#160;</a></span>baseEnumDeclaration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgEnumDeclaration.html">SgEnumDeclaration</a> * SageInterface::Ada::baseEnumDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the underlying enum declaration of a type ty </p>
<dl class="section return"><dt>Returns</dt><dd>an enum declaration associated with ty nullptr if no declaration can be found</dd></dl>
<p>baseEnumDeclaration skips over intermediate SgTypedefDeclarations that introduce a new type (  </p>

</div>
</div>
<a id="a99f5d217944139c5ecd832cb807f0131" name="a99f5d217944139c5ecd832cb807f0131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f5d217944139c5ecd832cb807f0131">&#9670;&#160;</a></span>baseEnumDeclaration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgEnumDeclaration.html">SgEnumDeclaration</a> * SageInterface::Ada::baseEnumDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the underlying enum declaration of a type ty </p>
<dl class="section return"><dt>Returns</dt><dd>an enum declaration associated with ty nullptr if no declaration can be found</dd></dl>
<p>baseEnumDeclaration skips over intermediate SgTypedefDeclarations that introduce a new type (  </p>

</div>
</div>
<a id="a5dc2996b2bb1f33f168a61ead8fd5f1c" name="a5dc2996b2bb1f33f168a61ead8fd5f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc2996b2bb1f33f168a61ead8fd5f1c">&#9670;&#160;</a></span>characterBaseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgEnumType.html">SgEnumType</a> * SageInterface::Ada::characterBaseType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgEnumType.html">SgEnumType</a> *&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the type is based on one of the Standard character types. </p>
<dl class="section return"><dt>Returns</dt><dd>the base enum type (Character, Wide_Character, or Wide_Wide_Character), if the input type is based of one of them. otherwise, returns nullptr </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In ROSE, character based enums currently do not have any member. Thus, some analysis may handle character based enums differently. </dd></dl>

</div>
</div>
<a id="a780d8a5cc148d09a2ce4f6fc6f92ecd5" name="a780d8a5cc148d09a2ce4f6fc6f92ecd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780d8a5cc148d09a2ce4f6fc6f92ecd5">&#9670;&#160;</a></span>characterBaseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgEnumType.html">SgEnumType</a> * SageInterface::Ada::characterBaseType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgEnumType.html">SgEnumType</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the type is based on one of the Standard character types. </p>
<dl class="section return"><dt>Returns</dt><dd>the base enum type (Character, Wide_Character, or Wide_Wide_Character), if the input type is based of one of them. otherwise, returns nullptr </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In ROSE, character based enums currently do not have any member. Thus, some analysis may handle character based enums differently. </dd></dl>

</div>
</div>
<a id="a39268f5ffe0edcaff5b6ce5c6f2b576b" name="a39268f5ffe0edcaff5b6ce5c6f2b576b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39268f5ffe0edcaff5b6ce5c6f2b576b">&#9670;&#160;</a></span>positionalArgumentLimit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::Ada::positionalArgumentLimit </td>
          <td>(</td>
          <td class="paramtype">const SgExpressionPtrList &amp;&#160;</td>
          <td class="paramname"><em>arglst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the one past the last positional argument (aka the first named argument position). </p>
<dl class="section return"><dt>Returns</dt><dd>one past the index of the last positional argument.</dd></dl>
<p>examples:</p><ul>
<li>argument lists without positional arguments =&gt; 0</li>
<li>argument lists without named arguments =&gt; args.size()</li>
<li>empty argument lists =&gt; 0</li>
<li>(1, 2, LEN =&gt; 3) =&gt; 2 </li>
</ul>

</div>
</div>
<a id="a3ee0647d08d73a7e06e5279aaa6372b5" name="a3ee0647d08d73a7e06e5279aaa6372b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee0647d08d73a7e06e5279aaa6372b5">&#9670;&#160;</a></span>positionalArgumentLimit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::Ada::positionalArgumentLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the one past the last positional argument (aka the first named argument position). </p>
<dl class="section return"><dt>Returns</dt><dd>one past the index of the last positional argument.</dd></dl>
<p>examples:</p><ul>
<li>argument lists without positional arguments =&gt; 0</li>
<li>argument lists without named arguments =&gt; args.size()</li>
<li>empty argument lists =&gt; 0</li>
<li>(1, 2, LEN =&gt; 3) =&gt; 2 </li>
</ul>

</div>
</div>
<a id="a68bdd28384c55cce16c989527b5c9b06" name="a68bdd28384c55cce16c989527b5c9b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bdd28384c55cce16c989527b5c9b06">&#9670;&#160;</a></span>positionalArgumentLimit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::Ada::positionalArgumentLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the one past the last positional argument (aka the first named argument position). </p>
<dl class="section return"><dt>Returns</dt><dd>one past the index of the last positional argument.</dd></dl>
<p>examples:</p><ul>
<li>argument lists without positional arguments =&gt; 0</li>
<li>argument lists without named arguments =&gt; args.size()</li>
<li>empty argument lists =&gt; 0</li>
<li>(1, 2, LEN =&gt; 3) =&gt; 2 </li>
</ul>

</div>
</div>
<a id="aab3db7596c53edef97f76b61d4166ccb" name="aab3db7596c53edef97f76b61d4166ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3db7596c53edef97f76b61d4166ccb">&#9670;&#160;</a></span>blockExistsInSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::blockExistsInSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the block blk is present in the <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> source code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blk</td><td>a reference or pointer to a ROSE basic block object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true of the block is in the source code. false if the block is ROSE artifact (or nullptr). </dd></dl>

</div>
</div>
<a id="ac047a7f00365c91e7f7a4d777847e967" name="ac047a7f00365c91e7f7a4d777847e967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac047a7f00365c91e7f7a4d777847e967">&#9670;&#160;</a></span>blockExistsInSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::blockExistsInSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the block blk is present in the <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> source code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blk</td><td>a reference or pointer to a ROSE basic block object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true of the block is in the source code. false if the block is ROSE artifact (or nullptr). </dd></dl>

</div>
</div>
<a id="a1c243d611beb468ad657b01b61e89a2b" name="a1c243d611beb468ad657b01b61e89a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c243d611beb468ad657b01b61e89a2b">&#9670;&#160;</a></span>findPubliclyVisibleFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> * SageInterface::Ada::findPubliclyVisibleFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>fnsym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgFunctionType.html">SgFunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>drvFunTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgNamedType.html">SgNamedType</a> &amp;&#160;</td>
          <td class="paramname"><em>dervTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the function symbol for a publicly accessible function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fnsym</td><td>the function symbol (maybe be private) </td></tr>
    <tr><td class="paramname">drvFunTy</td><td>the derived function type </td></tr>
    <tr><td class="paramname">dervTy</td><td>the derived type for which the symbol is sought </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function that is publicly accessible and can be used for default argument resolution. if none is found a pointer to fnsym is returned.. </dd></dl>

</div>
</div>
<a id="a390f93a79f26d12b97940e33f5e152da" name="a390f93a79f26d12b97940e33f5e152da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f93a79f26d12b97940e33f5e152da">&#9670;&#160;</a></span>isAnyAccessAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::Ada::isAnyAccessAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAdaAttributeExp.html">SgAdaAttributeExp</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if attr is an access attribute </p>
<p>either 'access, 'unchecked_access, or 'unrestricted_access. </p>

</div>
</div>
<a id="a3c5c796b3ca2cea689577b4e679681a9" name="a3c5c796b3ca2cea689577b4e679681a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5c796b3ca2cea689577b4e679681a9">&#9670;&#160;</a></span>isPragma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> * SageInterface::Ada::isPragma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> &amp;&#160;</td>
          <td class="paramname"><em>prgdcl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pragmaname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if prgdcl is a pragma with name pragmaname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prgdcl</td><td>the pragma declaration </td></tr>
    <tr><td class="paramname">pragmaname</td><td>the name to test for </td></tr>
    <tr><td class="paramname">the</td><td>pragmas argument list (possibly empty) if prgdcl is a pragmaname pragma; nullptr otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3901ec0b8e9bda0726793a17859d53d9" name="a3901ec0b8e9bda0726793a17859d53d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3901ec0b8e9bda0726793a17859d53d9">&#9670;&#160;</a></span>simpleTraversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::simpleTraversal </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses all AST nodes in an unspecified order. </p>
<p>Only traverses edges that are commonly traversed by ROSE's standard traversal mechanism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>a functor that queries and possibly transforms the AST </td></tr>
    <tr><td class="paramname">root</td><td>a singular root node (all subtrees are traversed) </td></tr>
    <tr><td class="paramname">roots</td><td>a statement range of root nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>fn is typically a functor that collects all nodes that need to be converted in a first pass. An update pass, triggered by fn's destructor carries out the actual transformations of the collected nodes. </dd></dl>

</div>
</div>
<a id="a4dc7e3e20efc948e9cf47cbce448d1dd" name="a4dc7e3e20efc948e9cf47cbce448d1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc7e3e20efc948e9cf47cbce448d1dd">&#9670;&#160;</a></span>simpleTraversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::simpleTraversal </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementRange&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverses all AST nodes in an unspecified order. </p>
<p>Only traverses edges that are commonly traversed by ROSE's standard traversal mechanism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>a functor that queries and possibly transforms the AST </td></tr>
    <tr><td class="paramname">root</td><td>a singular root node (all subtrees are traversed) </td></tr>
    <tr><td class="paramname">roots</td><td>a statement range of root nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>fn is typically a functor that collects all nodes that need to be converted in a first pass. An update pass, triggered by fn's destructor carries out the actual transformations of the collected nodes. </dd></dl>

</div>
</div>
<a id="a03c88ea7531b2ea91346e1f61c83cf04" name="a03c88ea7531b2ea91346e1f61c83cf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c88ea7531b2ea91346e1f61c83cf04">&#9670;&#160;</a></span>conversionTraversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::conversionTraversal </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13bff655aeb960d26c8693f4d9220f2f" name="a13bff655aeb960d26c8693f4d9220f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bff655aeb960d26c8693f4d9220f2f">&#9670;&#160;</a></span>conversionTraversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::conversionTraversal </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classSgNode.html">SgNode</a> *)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementRange&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad453405acea37406743447a81deaa8c1" name="ad453405acea37406743447a81deaa8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453405acea37406743447a81deaa8c1">&#9670;&#160;</a></span>pathToGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSageInterface_1_1Ada_1_1ScopePath.html">ScopePath</a> SageInterface::Ada::pathToGlobal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a path from a scope statement to the top-level (global) scope. </p>
<p>The path contains [n, global) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>innermost scope </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ad9ea120d003cf2c53329fcfc7f7d0" name="a32ad9ea120d003cf2c53329fcfc7f7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad9ea120d003cf2c53329fcfc7f7d0">&#9670;&#160;</a></span>setSourcePositionInSubtreeToCompilerGenerated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::setSourcePositionInSubtreeToCompilerGenerated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets source position in entire subtree of n to compiler generated </p>
<dl class="section note"><dt>Note</dt><dd>compare with <a class="el" href="namespaceSageInterface.html#aedd44b5f8b0be1580180a755a971cdcb" title="Set the source code positon for the subtree (including the root).">SageInterface::setSourcePositionAtRootAndAllChildren</a> the <a class="el" href="namespaceSageInterface.html" title="Functions that are useful when operating on the AST.">SageInterface</a> does not implement setting the source position to compiler generated. </dd></dl>

</div>
</div>
<a id="a57fc97a488b3ece02688e16ae11ede50" name="a57fc97a488b3ece02688e16ae11ede50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fc97a488b3ece02688e16ae11ede50">&#9670;&#160;</a></span>setSourcePositionInSubtreeToCompilerGenerated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::setSourcePositionInSubtreeToCompilerGenerated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets source position in entire subtree of n to compiler generated </p>
<dl class="section note"><dt>Note</dt><dd>compare with <a class="el" href="namespaceSageInterface.html#aedd44b5f8b0be1580180a755a971cdcb" title="Set the source code positon for the subtree (including the root).">SageInterface::setSourcePositionAtRootAndAllChildren</a> the <a class="el" href="namespaceSageInterface.html" title="Functions that are useful when operating on the AST.">SageInterface</a> does not implement setting the source position to compiler generated. </dd></dl>

</div>
</div>
<a id="ad36baef106acd662b5bc09aafb07b403" name="ad36baef106acd662b5bc09aafb07b403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36baef106acd662b5bc09aafb07b403">&#9670;&#160;</a></span>convertAdaToCxxComments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::convertAdaToCxxComments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cxxLineComments</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>/} </p>
<p>converts all <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a> style comments to C++ comments </p>

</div>
</div>
<a id="a7162d13ae5b52ba6bf0596ec3273efdf" name="a7162d13ae5b52ba6bf0596ec3273efdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7162d13ae5b52ba6bf0596ec3273efdf">&#9670;&#160;</a></span>convertToOperatorRepresentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::Ada::convertToOperatorRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convertCallSyntax</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convertNamedArguments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts AST from a function call representation to operator form for fundamental operator declarations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the subtree is traversed to find operator calls (using the traversal mechanism) </td></tr>
    <tr><td class="paramname">convertCallSyntax</td><td>false, only convert those calls where get_uses_operator_syntax() returns false true, convert all calls (may result in invalid <a class="el" href="namespaceSageInterface_1_1Ada.html" title="Contains Ada-specific functionality.">Ada</a>) </td></tr>
    <tr><td class="paramname">convertNamedArguments</td><td>not relevant, when convertCallSyntax == false true, named arguments are resolved false, named arguments are preserved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:35 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
