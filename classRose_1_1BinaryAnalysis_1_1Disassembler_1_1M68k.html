<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Disassembler::M68k Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Disassembler.html">Disassembler</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html">M68k</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Disassembler::M68k Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Disassembler.html" title="Instruction decoders.">Disassembler</a> for Motorola M68k-based instruction set architectures. </p>

<p class="definition">Definition at line <a class="el" href="Disassembler_2M68k_8h_source.html#l00022">22</a> of file <a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Disassembler_2M68k_8h_source.html">Rose/BinaryAnalysis/Disassembler/M68k.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Disassembler::M68k:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_inherit__map">
<area shape="rect" title="Disassembler for Motorola M68k&#45;based instruction set architectures." alt="" coords="5,93,156,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html" title="Virtual base class for instruction disassemblers." alt="" coords="7,5,155,45"/>
<area shape="poly" title=" " alt="" coords="83,59,83,93,78,93,78,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Disassembler::M68k:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_coll__map" id="aRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_coll__map">
<area shape="rect" title="Disassembler for Motorola M68k&#45;based instruction set architectures." alt="" coords="5,93,156,133"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html" title="Virtual base class for instruction disassemblers." alt="" coords="7,5,155,45"/>
<area shape="poly" title=" " alt="" coords="83,59,83,93,78,93,78,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html">Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for disassembling a single instruction.  <a href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e4aabf7a8b4f4c85154ce64f8b442b3" id="r_a2e4aabf7a8b4f4c85154ce64f8b442b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a2e4aabf7a8b4f4c85154ce64f8b442b3">Ptr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">M68kPtr</a></td></tr>
<tr class="memdesc:a2e4aabf7a8b4f4c85154ce64f8b442b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counted pointer.  <br /></td></tr>
<tr class="separator:a2e4aabf7a8b4f4c85154ce64f8b442b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400827a996010b947edc88bfc2f48b1f" id="r_a400827a996010b947edc88bfc2f48b1f"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a400827a996010b947edc88bfc2f48b1f">ExpressionPair</a></td></tr>
<tr class="separator:a400827a996010b947edc88bfc2f48b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Rose::BinaryAnalysis::Disassembler::Base</a></td></tr>
<tr class="memitem:ab3dcabe32d2d6ec7c08f21c7435c57da inherit pub_types_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_ab3dcabe32d2d6ec7c08f21c7435c57da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#ab3dcabe32d2d6ec7c08f21c7435c57da">Ptr</a> = <a class="el" href="classSawyer_1_1SharedPointer.html">BasePtr</a></td></tr>
<tr class="separator:ab3dcabe32d2d6ec7c08f21c7435c57da inherit pub_types_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28d8da498fcf2032d64452cfb38ed484" id="r_a28d8da498fcf2032d64452cfb38ed484"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Base::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a28d8da498fcf2032d64452cfb38ed484">clone</a> () const override</td></tr>
<tr class="memdesc:a28d8da498fcf2032d64452cfb38ed484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of a disassembler.  <br /></td></tr>
<tr class="separator:a28d8da498fcf2032d64452cfb38ed484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89351676e3ff1290115e03f1300fc3b2" id="r_a89351676e3ff1290115e03f1300fc3b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a89351676e3ff1290115e03f1300fc3b2">disassembleOne</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, rose_addr_t start_va, <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> *successors=nullptr) override</td></tr>
<tr class="memdesc:a89351676e3ff1290115e03f1300fc3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the lowest level disassembly function and is implemented in the architecture-specific subclasses.  <br /></td></tr>
<tr class="separator:a89351676e3ff1290115e03f1300fc3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85081187be5327905fc1a2e0a9e9b1" id="r_a4e85081187be5327905fc1a2e0a9e9b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a4e85081187be5327905fc1a2e0a9e9b1">makeUnknownInstruction</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Exception.html">Exception</a> &amp;) override</td></tr>
<tr class="memdesc:a4e85081187be5327905fc1a2e0a9e9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an unknown instruction from an exception.  <br /></td></tr>
<tr class="separator:a4e85081187be5327905fc1a2e0a9e9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3851724e816550a69c7c995638c969" id="r_afc3851724e816550a69c7c995638c969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html">Decoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#afc3851724e816550a69c7c995638c969">find_idis</a> (uint16_t *insn_bytes, size_t nbytes) const</td></tr>
<tr class="memdesc:afc3851724e816550a69c7c995638c969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an instruction-specific disassembler.  <br /></td></tr>
<tr class="separator:afc3851724e816550a69c7c995638c969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ba35cbf505582b3d05be08a2031499" id="r_ac7ba35cbf505582b3d05be08a2031499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#ac7ba35cbf505582b3d05be08a2031499">insert_idis</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html">Decoder</a> *)</td></tr>
<tr class="memdesc:ac7ba35cbf505582b3d05be08a2031499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an instruction-specific disassembler.  <br /></td></tr>
<tr class="separator:ac7ba35cbf505582b3d05be08a2031499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58245ee3725b798a8e9d6ebe40d1a9" id="r_adc58245ee3725b798a8e9d6ebe40d1a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#adc58245ee3725b798a8e9d6ebe40d1a9">start_instruction</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;state, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;map, rose_addr_t start_va) const</td></tr>
<tr class="memdesc:adc58245ee3725b798a8e9d6ebe40d1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a89351676e3ff1290115e03f1300fc3b2" title="This is the lowest level disassembly function and is implemented in the architecture-specific subclas...">disassembleOne()</a> to initialize the disassembler state for the next instruction.  <br /></td></tr>
<tr class="separator:adc58245ee3725b798a8e9d6ebe40d1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98628a740a32d5acb00a5f8e8659d2fe" id="r_a98628a740a32d5acb00a5f8e8659d2fe"><td class="memItemLeft" align="right" valign="top"><a id="a98628a740a32d5acb00a5f8e8659d2fe" name="a98628a740a32d5acb00a5f8e8659d2fe"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>instructionWord</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, size_t n) const</td></tr>
<tr class="memdesc:a98628a740a32d5acb00a5f8e8659d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Nth instruction word. <br /></td></tr>
<tr class="separator:a98628a740a32d5acb00a5f8e8659d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da5a260b484af65a8702e166424a81c" id="r_a9da5a260b484af65a8702e166424a81c"><td class="memItemLeft" align="right" valign="top"><a id="a9da5a260b484af65a8702e166424a81c" name="a9da5a260b484af65a8702e166424a81c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>extensionWordsUsed</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a9da5a260b484af65a8702e166424a81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of instruction words referenced so far in the current instruction. <br /></td></tr>
<tr class="separator:a9da5a260b484af65a8702e166424a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a17a752ead5e0b28da99804f818458" id="r_ab1a17a752ead5e0b28da99804f818458"><td class="memItemLeft" align="right" valign="top"><a id="ab1a17a752ead5e0b28da99804f818458" name="ab1a17a752ead5e0b28da99804f818458"></a>
<a class="el" href="classSgAsmType.html">SgAsmType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeType</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, M68kDataFormat) const</td></tr>
<tr class="memdesc:ab1a17a752ead5e0b28da99804f818458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ROSE data type for m68k data format. <br /></td></tr>
<tr class="separator:ab1a17a752ead5e0b28da99804f818458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d4254e331535fafa9865ac6cdf24c4" id="r_a86d4254e331535fafa9865ac6cdf24c4"><td class="memItemLeft" align="right" valign="top"><a id="a86d4254e331535fafa9865ac6cdf24c4" name="a86d4254e331535fafa9865ac6cdf24c4"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeDataRegister</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum, M68kDataFormat, size_t bit_offset=0) const</td></tr>
<tr class="memdesc:a86d4254e331535fafa9865ac6cdf24c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a data register reference expression. <br /></td></tr>
<tr class="separator:a86d4254e331535fafa9865ac6cdf24c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5312873d86db24f372b5990b2f97f8c" id="r_af5312873d86db24f372b5990b2f97f8c"><td class="memItemLeft" align="right" valign="top"><a id="af5312873d86db24f372b5990b2f97f8c" name="af5312873d86db24f372b5990b2f97f8c"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeAddressRegister</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum, M68kDataFormat, size_t bit_offset=0) const</td></tr>
<tr class="memdesc:af5312873d86db24f372b5990b2f97f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an address register reference expression. <br /></td></tr>
<tr class="separator:af5312873d86db24f372b5990b2f97f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5ded693784635c70c0b491dc7f5f27" id="r_aea5ded693784635c70c0b491dc7f5f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#aea5ded693784635c70c0b491dc7f5f27">makeAddressRegisterPreDecrement</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum, M68kDataFormat fmt) const</td></tr>
<tr class="memdesc:aea5ded693784635c70c0b491dc7f5f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a memory reference expression using an address register in pre-decrement mode.  <br /></td></tr>
<tr class="separator:aea5ded693784635c70c0b491dc7f5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6629b9148b7be89f117fbed6538e3619" id="r_a6629b9148b7be89f117fbed6538e3619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a6629b9148b7be89f117fbed6538e3619">makeAddressRegisterPostIncrement</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum, M68kDataFormat fmt) const</td></tr>
<tr class="memdesc:a6629b9148b7be89f117fbed6538e3619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a memory reference expression using an address register in post-increment mode.  <br /></td></tr>
<tr class="separator:a6629b9148b7be89f117fbed6538e3619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f779ce3b1127e7411e646aaf57f716" id="r_af4f779ce3b1127e7411e646aaf57f716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#af4f779ce3b1127e7411e646aaf57f716">makeDataAddressRegister</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum, M68kDataFormat fmt, size_t bit_offset=0) const</td></tr>
<tr class="memdesc:af4f779ce3b1127e7411e646aaf57f716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create either a data or address register reference expression.  <br /></td></tr>
<tr class="separator:af4f779ce3b1127e7411e646aaf57f716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a408d0947e8bf0455fed48a20da33e6" id="r_a1a408d0947e8bf0455fed48a20da33e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterNames.html">SgAsmRegisterNames</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a1a408d0947e8bf0455fed48a20da33e6">makeRegistersFromMask</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned mask, M68kDataFormat fmt, bool reverse=false) const</td></tr>
<tr class="memdesc:a1a408d0947e8bf0455fed48a20da33e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of data and/or address registers.  <br /></td></tr>
<tr class="separator:a1a408d0947e8bf0455fed48a20da33e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e2a9004f4080be79de09a793f302f9" id="r_a78e2a9004f4080be79de09a793f302f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterNames.html">SgAsmRegisterNames</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a78e2a9004f4080be79de09a793f302f9">makeFPRegistersFromMask</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned mask, M68kDataFormat fmt, bool reverse=false) const</td></tr>
<tr class="memdesc:a78e2a9004f4080be79de09a793f302f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of floating-point data registers.  <br /></td></tr>
<tr class="separator:a78e2a9004f4080be79de09a793f302f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f93b5386c176ec500e943385a287bc" id="r_ac6f93b5386c176ec500e943385a287bc"><td class="memItemLeft" align="right" valign="top"><a id="ac6f93b5386c176ec500e943385a287bc" name="ac6f93b5386c176ec500e943385a287bc"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeStatusRegister</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ac6f93b5386c176ec500e943385a287bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference to the status register. <br /></td></tr>
<tr class="separator:ac6f93b5386c176ec500e943385a287bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2571d41405004af2c8ec5ef207c532a" id="r_ae2571d41405004af2c8ec5ef207c532a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#ae2571d41405004af2c8ec5ef207c532a">makeConditionCodeRegister</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae2571d41405004af2c8ec5ef207c532a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference to the condition code register.  <br /></td></tr>
<tr class="separator:ae2571d41405004af2c8ec5ef207c532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac866094662dde160baacfb1af1b5e84d" id="r_ac866094662dde160baacfb1af1b5e84d"><td class="memItemLeft" align="right" valign="top"><a id="ac866094662dde160baacfb1af1b5e84d" name="ac866094662dde160baacfb1af1b5e84d"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeColdFireControlRegister</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum) const</td></tr>
<tr class="memdesc:ac866094662dde160baacfb1af1b5e84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create control register for ColdFire cpu. <br /></td></tr>
<tr class="separator:ac866094662dde160baacfb1af1b5e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1b9ce55c5c86880bde41300b90d5d" id="r_a00e1b9ce55c5c86880bde41300b90d5d"><td class="memItemLeft" align="right" valign="top"><a id="a00e1b9ce55c5c86880bde41300b90d5d" name="a00e1b9ce55c5c86880bde41300b90d5d"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeProgramCounter</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a00e1b9ce55c5c86880bde41300b90d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference to the program counter register. <br /></td></tr>
<tr class="separator:a00e1b9ce55c5c86880bde41300b90d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca1ea9755fa9569dd647ac2817a2710" id="r_a3ca1ea9755fa9569dd647ac2817a2710"><td class="memItemLeft" align="right" valign="top"><a id="a3ca1ea9755fa9569dd647ac2817a2710" name="a3ca1ea9755fa9569dd647ac2817a2710"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeMacRegister</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, M68kMacRegister) const</td></tr>
<tr class="memdesc:a3ca1ea9755fa9569dd647ac2817a2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MAC register reference expression. <br /></td></tr>
<tr class="separator:a3ca1ea9755fa9569dd647ac2817a2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98378b083f7d29ca9c4dfd74d2176ac5" id="r_a98378b083f7d29ca9c4dfd74d2176ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a98378b083f7d29ca9c4dfd74d2176ac5">makeMacAccumulatorRegister</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned accumIndex) const</td></tr>
<tr class="memdesc:a98378b083f7d29ca9c4dfd74d2176ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a MAC accumulator register.  <br /></td></tr>
<tr class="separator:a98378b083f7d29ca9c4dfd74d2176ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb3e7e6ebab16dbdcaf9f3c63191fa" id="r_a81eb3e7e6ebab16dbdcaf9f3c63191fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a81eb3e7e6ebab16dbdcaf9f3c63191fa">makeFPRegister</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned regnum) const</td></tr>
<tr class="memdesc:a81eb3e7e6ebab16dbdcaf9f3c63191fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a floating point register.  <br /></td></tr>
<tr class="separator:a81eb3e7e6ebab16dbdcaf9f3c63191fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f8514ec0f2910e41f7e7eab45fc19f" id="r_ad4f8514ec0f2910e41f7e7eab45fc19f"><td class="memItemLeft" align="right" valign="top"><a id="ad4f8514ec0f2910e41f7e7eab45fc19f" name="ad4f8514ec0f2910e41f7e7eab45fc19f"></a>
<a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeRegister</b> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>) const</td></tr>
<tr class="memdesc:ad4f8514ec0f2910e41f7e7eab45fc19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic ways to make a register. <br /></td></tr>
<tr class="separator:ad4f8514ec0f2910e41f7e7eab45fc19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe638f557e5bbee46641a1ba998f089" id="r_a4fe638f557e5bbee46641a1ba998f089"><td class="memItemLeft" align="right" valign="top"><a id="a4fe638f557e5bbee46641a1ba998f089" name="a4fe638f557e5bbee46641a1ba998f089"></a>
<a class="el" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeImmediateValue</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, M68kDataFormat fmt, unsigned value) const</td></tr>
<tr class="memdesc:a4fe638f557e5bbee46641a1ba998f089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an integer expression from a specified value. <br /></td></tr>
<tr class="separator:a4fe638f557e5bbee46641a1ba998f089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d996e252be3a39fe95a410b30a79ed" id="r_ab1d996e252be3a39fe95a410b30a79ed"><td class="memItemLeft" align="right" valign="top"><a id="ab1d996e252be3a39fe95a410b30a79ed" name="ab1d996e252be3a39fe95a410b30a79ed"></a>
<a class="el" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeImmediateExtension</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, M68kDataFormat fmt, size_t ext_word_idx) const</td></tr>
<tr class="memdesc:ab1d996e252be3a39fe95a410b30a79ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an integer expression from extension words. <br /></td></tr>
<tr class="separator:ab1d996e252be3a39fe95a410b30a79ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd37f6e3a5ae18f55a4396721db924e" id="r_a0bd37f6e3a5ae18f55a4396721db924e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a0bd37f6e3a5ae18f55a4396721db924e">makeAddress</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *expr) const</td></tr>
<tr class="memdesc:a0bd37f6e3a5ae18f55a4396721db924e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a memory-reference expression to an address.  <br /></td></tr>
<tr class="separator:a0bd37f6e3a5ae18f55a4396721db924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c169310f927bb9660f9aaa306bd830" id="r_a15c169310f927bb9660f9aaa306bd830"><td class="memItemLeft" align="right" valign="top">ExpressionPair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a15c169310f927bb9660f9aaa306bd830">makeOffsetWidthPair</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned extension_word) const</td></tr>
<tr class="memdesc:a15c169310f927bb9660f9aaa306bd830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an offset width pair from an extension word.  <br /></td></tr>
<tr class="separator:a15c169310f927bb9660f9aaa306bd830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56400de552d39d0c239fe6243d3a2d36" id="r_a56400de552d39d0c239fe6243d3a2d36"><td class="memItemLeft" align="right" valign="top"><a id="a56400de552d39d0c239fe6243d3a2d36" name="a56400de552d39d0c239fe6243d3a2d36"></a>
<a class="el" href="classSgAsmM68kInstruction.html">SgAsmM68kInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeInstruction</b> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, M68kInstructionKind, M68kDataFormat, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg0=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg1=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg2=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg3=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg4=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg5=NULL, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *arg6=NULL) const</td></tr>
<tr class="memdesc:a56400de552d39d0c239fe6243d3a2d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an instruction. <br /></td></tr>
<tr class="separator:a56400de552d39d0c239fe6243d3a2d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff138c0d42d0b33788b193713dc890db" id="r_aff138c0d42d0b33788b193713dc890db"><td class="memItemLeft" align="right" valign="top">M68kFamily&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#aff138c0d42d0b33788b193713dc890db">get_family</a> () const</td></tr>
<tr class="memdesc:aff138c0d42d0b33788b193713dc890db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ISA family specified in constructor.  <br /></td></tr>
<tr class="separator:aff138c0d42d0b33788b193713dc890db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a84ea58d819884f930342fa65ce90328d" id="r_a84ea58d819884f930342fa65ce90328d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a84ea58d819884f930342fa65ce90328d">makeEffectiveAddress</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned modreg, M68kDataFormat fmt, size_t ext_offset) const</td></tr>
<tr class="memdesc:a84ea58d819884f930342fa65ce90328d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an expression for m68k "&lt;ea&gt;x" or "&lt;ea&gt;y".  <br /></td></tr>
<tr class="separator:a84ea58d819884f930342fa65ce90328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdef9914d5a74f5f32030f3703441941" id="r_acdef9914d5a74f5f32030f3703441941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#acdef9914d5a74f5f32030f3703441941">makeEffectiveAddress</a> (<a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;, unsigned mode, unsigned reg, M68kDataFormat fmt, size_t ext_offset) const</td></tr>
<tr class="memdesc:acdef9914d5a74f5f32030f3703441941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an expression for m68k "&lt;ea&gt;x" or "&lt;ea&gt;y".  <br /></td></tr>
<tr class="separator:acdef9914d5a74f5f32030f3703441941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Rose::BinaryAnalysis::Disassembler::Base</a></td></tr>
<tr class="memitem:a9fb69506a12a9cb4e67d365b8e58402f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a9fb69506a12a9cb4e67d365b8e58402f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a9fb69506a12a9cb4e67d365b8e58402f">architecture</a> () const</td></tr>
<tr class="memdesc:a9fb69506a12a9cb4e67d365b8e58402f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>.  <br /></td></tr>
<tr class="separator:a9fb69506a12a9cb4e67d365b8e58402f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335b2e8e289d36fcb305294709da880c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a335b2e8e289d36fcb305294709da880c"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a335b2e8e289d36fcb305294709da880c">name</a> () const</td></tr>
<tr class="memdesc:a335b2e8e289d36fcb305294709da880c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name.  <br /></td></tr>
<tr class="separator:a335b2e8e289d36fcb305294709da880c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cbf77ee426f33dee24cfec21fa597b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a63cbf77ee426f33dee24cfec21fa597b"><td class="memItemLeft" align="right" valign="top">
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bytesPerWord</b> () const</td></tr>
<tr class="memdesc:a63cbf77ee426f33dee24cfec21fa597b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Bytes per word for the architecture. <br /></td></tr>
<tr class="separator:a63cbf77ee426f33dee24cfec21fa597b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accae6dab1ea68ce2c159a7c55a6bd8bc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_accae6dab1ea68ce2c159a7c55a6bd8bc"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><b>byteOrder</b> () const</td></tr>
<tr class="memdesc:accae6dab1ea68ce2c159a7c55a6bd8bc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order of memory. <br /></td></tr>
<tr class="separator:accae6dab1ea68ce2c159a7c55a6bd8bc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a6c70c0e0c83afaba0e7e7631b16b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a44a6c70c0e0c83afaba0e7e7631b16b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a44a6c70c0e0c83afaba0e7e7631b16b3">unparser</a> () const</td></tr>
<tr class="memdesc:a44a6c70c0e0c83afaba0e7e7631b16b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Unparser.html" title="Generates pseudo-assembly listings.">Unparser</a>.  <br /></td></tr>
<tr class="separator:a44a6c70c0e0c83afaba0e7e7631b16b3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1bd89a6012c5e451cc4293739e9506 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a1a1bd89a6012c5e451cc4293739e9506"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a1a1bd89a6012c5e451cc4293739e9506">instructionAlignment</a> () const</td></tr>
<tr class="memdesc:a1a1bd89a6012c5e451cc4293739e9506 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Instruction alignment requirement.  <br /></td></tr>
<tr class="separator:a1a1bd89a6012c5e451cc4293739e9506 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de611de86cb260558a875ebe20d6aaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a9de611de86cb260558a875ebe20d6aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a9de611de86cb260558a875ebe20d6aaa">disassembleOne</a> (const unsigned char *buf, rose_addr_t buf_va, size_t buf_size, rose_addr_t start_va, <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> *successors=NULL)</td></tr>
<tr class="memdesc:a9de611de86cb260558a875ebe20d6aaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar in functionality to the disassembleOne method that takes a <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> argument, except the content buffer is mapped 1:1 to virtual memory beginning at the specified address.  <br /></td></tr>
<tr class="separator:a9de611de86cb260558a875ebe20d6aaa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01b24d929a1963d714a790d9580950 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_aca01b24d929a1963d714a790d9580950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#aca01b24d929a1963d714a790d9580950">mark_referenced_instructions</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a7c20fb4cc5a175a93ba4556dba1334ab">InstructionMap</a> &amp;)</td></tr>
<tr class="memdesc:aca01b24d929a1963d714a790d9580950 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks parts of the file that correspond to instructions as having been referenced.  <br /></td></tr>
<tr class="separator:aca01b24d929a1963d714a790d9580950 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755c485224f50de632852539359185b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_ad755c485224f50de632852539359185b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#ad755c485224f50de632852539359185b">get_block_successors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a7c20fb4cc5a175a93ba4556dba1334ab">InstructionMap</a> &amp;, bool &amp;complete)</td></tr>
<tr class="memdesc:ad755c485224f50de632852539359185b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the successor addresses of a basic block and adds them to a successors set.  <br /></td></tr>
<tr class="separator:ad755c485224f50de632852539359185b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74653742cc639d9daea3c51fd8b01252 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a74653742cc639d9daea3c51fd8b01252"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>wordSizeBytes</b> () const</td></tr>
<tr class="separator:a74653742cc639d9daea3c51fd8b01252 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9168b491dce963b53a8eff669954ad inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_aae9168b491dce963b53a8eff669954ad"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>registerDictionary</b> () const</td></tr>
<tr class="separator:aae9168b491dce963b53a8eff669954ad inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f12afd04c2ecef6957aea8771415d4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a80f12afd04c2ecef6957aea8771415d4"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instructionPointerRegister</b> () const</td></tr>
<tr class="separator:a80f12afd04c2ecef6957aea8771415d4 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d477f6dbf2235e11666f7b2209fff83 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a7d477f6dbf2235e11666f7b2209fff83"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stackPointerRegister</b> () const</td></tr>
<tr class="separator:a7d477f6dbf2235e11666f7b2209fff83 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1d9f97a1dfd3c312845b65249fefe1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a6c1d9f97a1dfd3c312845b65249fefe1"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stackFrameRegister</b> () const</td></tr>
<tr class="separator:a6c1d9f97a1dfd3c312845b65249fefe1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ffb288f0b2db0bec10864e92d1a92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_aa89ffb288f0b2db0bec10864e92d1a92"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stackSegmentRegister</b> () const</td></tr>
<tr class="separator:aa89ffb288f0b2db0bec10864e92d1a92 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489cf824e024d24321baad130d9b97c2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a489cf824e024d24321baad130d9b97c2"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>callReturnRegister</b> () const</td></tr>
<tr class="separator:a489cf824e024d24321baad130d9b97c2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8e581ab1e0c4e37265be53090eea8fdd" id="r_a8e581ab1e0c4e37265be53090eea8fdd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a2e4aabf7a8b4f4c85154ce64f8b442b3">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a8e581ab1e0c4e37265be53090eea8fdd">instance</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, M68kFamily)</td></tr>
<tr class="memdesc:a8e581ab1e0c4e37265be53090eea8fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor for a specific family.  <br /></td></tr>
<tr class="separator:a8e581ab1e0c4e37265be53090eea8fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Rose::BinaryAnalysis::Disassembler::Base</a></td></tr>
<tr class="memitem:aa9bc4776a31bed1053e57f2fb71ffee2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_aa9bc4776a31bed1053e57f2fb71ffee2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#aa9bc4776a31bed1053e57f2fb71ffee2">find_instruction_containing</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a7c20fb4cc5a175a93ba4556dba1334ab">InstructionMap</a> &amp;insns, rose_addr_t va)</td></tr>
<tr class="memdesc:aa9bc4776a31bed1053e57f2fb71ffee2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the highest-address instruction that contains the byte at the specified virtual address.  <br /></td></tr>
<tr class="separator:aa9bc4776a31bed1053e57f2fb71ffee2 inherit pub_static_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c148190b1b02e399a1800a372feaf55" id="r_a3c148190b1b02e399a1800a372feaf55"><td class="memItemLeft" align="right" valign="top"><a id="a3c148190b1b02e399a1800a372feaf55" name="a3c148190b1b02e399a1800a372feaf55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>M68k</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:a3c148190b1b02e399a1800a372feaf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140e487854d8b5691b690e08db81039e" id="r_a140e487854d8b5691b690e08db81039e"><td class="memItemLeft" align="right" valign="top"><a id="a140e487854d8b5691b690e08db81039e" name="a140e487854d8b5691b690e08db81039e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>M68k</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, M68kFamily family)</td></tr>
<tr class="separator:a140e487854d8b5691b690e08db81039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Rose::BinaryAnalysis::Disassembler::Base</a></td></tr>
<tr class="memitem:a075b5c99a5a28e85058657469ffdbac0 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a075b5c99a5a28e85058657469ffdbac0"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:a075b5c99a5a28e85058657469ffdbac0 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html">Rose::BinaryAnalysis::Disassembler::Base</a></td></tr>
<tr class="memitem:a690f99a30b68215e0d51eb359b26437f inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a690f99a30b68215e0d51eb359b26437f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a690f99a30b68215e0d51eb359b26437f">REG_IP</a></td></tr>
<tr class="separator:a690f99a30b68215e0d51eb359b26437f inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ff4fc58ad11c2d091c1d57f76f82ed inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_ac2ff4fc58ad11c2d091c1d57f76f82ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#ac2ff4fc58ad11c2d091c1d57f76f82ed">REG_SP</a></td></tr>
<tr class="separator:ac2ff4fc58ad11c2d091c1d57f76f82ed inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed73e85282e8a65c04ef172aa445a584 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_aed73e85282e8a65c04ef172aa445a584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#aed73e85282e8a65c04ef172aa445a584">REG_SS</a></td></tr>
<tr class="separator:aed73e85282e8a65c04ef172aa445a584 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03179c674928126342c16381c9f7fad6 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a03179c674928126342c16381c9f7fad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a03179c674928126342c16381c9f7fad6">REG_SF</a></td></tr>
<tr class="separator:a03179c674928126342c16381c9f7fad6 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996f2078e678057a70d8dc424f057c1 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_ab996f2078e678057a70d8dc424f057c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#ab996f2078e678057a70d8dc424f057c1">REG_LINK</a></td></tr>
<tr class="memdesc:ab996f2078e678057a70d8dc424f057c1 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register descriptors initialized during construction.  <br /></td></tr>
<tr class="separator:ab996f2078e678057a70d8dc424f057c1 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5890adf094ba60c4bfa22f588b385642 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base" id="r_a5890adf094ba60c4bfa22f588b385642"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a5890adf094ba60c4bfa22f588b385642">instructionAlignment_</a> = 1</td></tr>
<tr class="memdesc:a5890adf094ba60c4bfa22f588b385642 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive alignment constraint for instruction addresses.  <br /></td></tr>
<tr class="separator:a5890adf094ba60c4bfa22f588b385642 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e4aabf7a8b4f4c85154ce64f8b442b3" name="a2e4aabf7a8b4f4c85154ce64f8b442b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4aabf7a8b4f4c85154ce64f8b442b3">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a2e4aabf7a8b4f4c85154ce64f8b442b3">Rose::BinaryAnalysis::Disassembler::M68k::Ptr</a> =  <a class="el" href="classSawyer_1_1SharedPointer.html">M68kPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counted pointer. </p>

<p class="definition">Definition at line <a class="el" href="Disassembler_2M68k_8h_source.html#l00025">25</a> of file <a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a>.</p>

</div>
</div>
<a id="a400827a996010b947edc88bfc2f48b1f" name="a400827a996010b947edc88bfc2f48b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400827a996010b947edc88bfc2f48b1f">&#9670;&#160;</a></span>ExpressionPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classSgAsmExpression.html">SgAsmExpression</a>*, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a>*&gt; Rose::BinaryAnalysis::Disassembler::M68k::ExpressionPair</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Disassembler_2M68k_8h_source.html#l00119">119</a> of file <a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e581ab1e0c4e37265be53090eea8fdd" name="a8e581ab1e0c4e37265be53090eea8fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e581ab1e0c4e37265be53090eea8fdd">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a2e4aabf7a8b4f4c85154ce64f8b442b3">Ptr</a> Rose::BinaryAnalysis::Disassembler::M68k::instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kFamily&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocating constructor for a specific family. </p>
<p>The <code>family</code> argument selectively activates certain features of the generic m68k disassembler. For instance, to get a disassembler specific to the FreeScale ColdFire series using "ISA_B", invoke as:</p>
<div class="fragment"><div class="line">Disassembler::Ptr disassembler = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a8e581ab1e0c4e37265be53090eea8fdd">M68k::instance</a>(m68k_freescale_isab);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_html_a8e581ab1e0c4e37265be53090eea8fdd"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a8e581ab1e0c4e37265be53090eea8fdd">Rose::BinaryAnalysis::Disassembler::M68k::instance</a></div><div class="ttdeci">static Ptr instance(const Architecture::BaseConstPtr &amp;, M68kFamily)</div><div class="ttdoc">Allocating constructor for a specific family.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a28d8da498fcf2032d64452cfb38ed484" name="a28d8da498fcf2032d64452cfb38ed484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d8da498fcf2032d64452cfb38ed484">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Base::Ptr</a> Rose::BinaryAnalysis::Disassembler::M68k::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of a disassembler. </p>
<p>The new copy has all the same settings as the original.</p>
<p>Thread safety: The thread safety of this virtual method depends on the implementation in the subclass. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a5d61b0cf46a845735377bfc7c56ae8d2">Rose::BinaryAnalysis::Disassembler::Base</a>.</p>

</div>
</div>
<a id="a89351676e3ff1290115e03f1300fc3b2" name="a89351676e3ff1290115e03f1300fc3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89351676e3ff1290115e03f1300fc3b2">&#9670;&#160;</a></span>disassembleOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Disassembler::M68k::disassembleOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> *&#160;</td>
          <td class="paramname"><em>successors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the lowest level disassembly function and is implemented in the architecture-specific subclasses. </p>
<p>It disassembles one instruction at the specified virtual address. The <code>map</code> is a mapping from virtual addresses to buffer and enables instructions to span file segments that are mapped contiguously in virtual memory by the loader but which might not be contiguous in the file. The instruction's successor virtual addresses are added to the optional successor set (note that successors of an individual instruction can also be obtained via <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aa57d491fecd502be6b814fcbf0be6d58">Architecture::Base::getSuccessors</a>). If the instruction cannot be disassembled then an exception is thrown and the successors set is not modified.</p>
<p>Thread safety: The safety of this method depends on its implementation in the subclass. In any case, no other thread can be modifying the <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html" title="An efficient mapping from an address space to stored data.">MemoryMap</a> or successors set at the same time. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#aa5135a3c3e8af238baa72236123cfd2d">Rose::BinaryAnalysis::Disassembler::Base</a>.</p>

</div>
</div>
<a id="a4e85081187be5327905fc1a2e0a9e9b1" name="a4e85081187be5327905fc1a2e0a9e9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e85081187be5327905fc1a2e0a9e9b1">&#9670;&#160;</a></span>makeUnknownInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeUnknownInstruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Exception.html">Exception</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an unknown instruction from an exception. </p>
<p>Thread safety: The safety of this method depends on its implementation in the subclass. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1Base.html#a24dba2b92492bb528265078590b6736c">Rose::BinaryAnalysis::Disassembler::Base</a>.</p>

</div>
</div>
<a id="afc3851724e816550a69c7c995638c969" name="afc3851724e816550a69c7c995638c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3851724e816550a69c7c995638c969">&#9670;&#160;</a></span>find_idis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html">Decoder</a> * Rose::BinaryAnalysis::Disassembler::M68k::find_idis </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>insn_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an instruction-specific disassembler. </p>
<p>Using the specified instruction bits, search for and return an instruction-specific disassembler. Returns null if no appropriate disassembler can be found. Instruction-specific disassemblers know how to disassemble specific instruction types (or groups of closely related instructions). </p>

</div>
</div>
<a id="ac7ba35cbf505582b3d05be08a2031499" name="ac7ba35cbf505582b3d05be08a2031499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ba35cbf505582b3d05be08a2031499">&#9670;&#160;</a></span>insert_idis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Disassembler::M68k::insert_idis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1Decoder.html">Decoder</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an instruction-specific disassembler. </p>
<p>The table must not already contain an entry that has the same <code>mask</code> and <code>match</code> values. The pointers are managed by the caller and must not be deleted while they are in the table. </p>

</div>
</div>
<a id="adc58245ee3725b798a8e9d6ebe40d1a9" name="adc58245ee3725b798a8e9d6ebe40d1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc58245ee3725b798a8e9d6ebe40d1a9">&#9670;&#160;</a></span>start_instruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Disassembler::M68k::start_instruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>start_va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k.html#a89351676e3ff1290115e03f1300fc3b2" title="This is the lowest level disassembly function and is implemented in the architecture-specific subclas...">disassembleOne()</a> to initialize the disassembler state for the next instruction. </p>

<p class="definition">Definition at line <a class="el" href="Disassembler_2M68k_8h_source.html#l00131">131</a> of file <a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a>.</p>

<p class="reference">References <a class="el" href="Disassembler_2M68k_8h_source.html#l00030">Rose::BinaryAnalysis::Disassembler::M68k::State::insn_va</a>, <a class="el" href="Disassembler_2M68k_8h_source.html#l00031">Rose::BinaryAnalysis::Disassembler::M68k::State::iwords</a>, <a class="el" href="Disassembler_2M68k_8h_source.html#l00029">Rose::BinaryAnalysis::Disassembler::M68k::State::map</a>, <a class="el" href="Disassembler_2M68k_8h_source.html#l00032">Rose::BinaryAnalysis::Disassembler::M68k::State::niwords</a>, and <a class="el" href="Disassembler_2M68k_8h_source.html#l00033">Rose::BinaryAnalysis::Disassembler::M68k::State::niwords_used</a>.</p>

</div>
</div>
<a id="aea5ded693784635c70c0b491dc7f5f27" name="aea5ded693784635c70c0b491dc7f5f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5ded693784635c70c0b491dc7f5f27">&#9670;&#160;</a></span>makeAddressRegisterPreDecrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeAddressRegisterPreDecrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>regnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a memory reference expression using an address register in pre-decrement mode. </p>
<p>The <code>fmt</code> is the format of the memory reference; all 32-bits of the address register are accessed. </p>

</div>
</div>
<a id="a6629b9148b7be89f117fbed6538e3619" name="a6629b9148b7be89f117fbed6538e3619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6629b9148b7be89f117fbed6538e3619">&#9670;&#160;</a></span>makeAddressRegisterPostIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeAddressRegisterPostIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>regnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a memory reference expression using an address register in post-increment mode. </p>
<p>The <code>fmt</code> is the format of the memory reference; all 32-bits of the address register are accessed. </p>

</div>
</div>
<a id="af4f779ce3b1127e7411e646aaf57f716" name="af4f779ce3b1127e7411e646aaf57f716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f779ce3b1127e7411e646aaf57f716">&#9670;&#160;</a></span>makeDataAddressRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeDataAddressRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>regnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create either a data or address register reference expression. </p>
<p>When <code>regnum</code> is zero through seven a data register is created; when <code>regnum</code> is eight through 15 an address register is created. </p>

</div>
</div>
<a id="a1a408d0947e8bf0455fed48a20da33e6" name="a1a408d0947e8bf0455fed48a20da33e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a408d0947e8bf0455fed48a20da33e6">&#9670;&#160;</a></span>makeRegistersFromMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterNames.html">SgAsmRegisterNames</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeRegistersFromMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of data and/or address registers. </p>
<p>The bit mask indicates the registers. Starting at the least significant bit, the register are either: D0, D1, ... D7, A0, A1, ... A7 if <code>reverse</code> is false, or A7, A6, ... A0, D7, D6, ... D0 if <code>reverse</code> is true. The returned list has the registers in order starting at the least significant bit. </p>

</div>
</div>
<a id="a78e2a9004f4080be79de09a793f302f9" name="a78e2a9004f4080be79de09a793f302f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e2a9004f4080be79de09a793f302f9">&#9670;&#160;</a></span>makeFPRegistersFromMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterNames.html">SgAsmRegisterNames</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeFPRegistersFromMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of floating-point data registers. </p>
<p>The bit mask indicates the registers. Starting at the least significant bit, the registers are either: FP0 through FP7 if <code>reverse</code> is false, or FP7 through FP0 if <code>reverse</code> is true. The returned list has the registers in order starting at the least significant bit. </p>

</div>
</div>
<a id="ae2571d41405004af2c8ec5ef207c532a" name="ae2571d41405004af2c8ec5ef207c532a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2571d41405004af2c8ec5ef207c532a">&#9670;&#160;</a></span>makeConditionCodeRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeConditionCodeRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reference to the condition code register. </p>
<p>This is the low-order 8 bits of the status register. </p>

</div>
</div>
<a id="a98378b083f7d29ca9c4dfd74d2176ac5" name="a98378b083f7d29ca9c4dfd74d2176ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98378b083f7d29ca9c4dfd74d2176ac5">&#9670;&#160;</a></span>makeMacAccumulatorRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeMacAccumulatorRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>accumIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a MAC accumulator register. </p>
<p>These are ACC0 through ACC3, 32-bit integers. </p>

</div>
</div>
<a id="a81eb3e7e6ebab16dbdcaf9f3c63191fa" name="a81eb3e7e6ebab16dbdcaf9f3c63191fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eb3e7e6ebab16dbdcaf9f3c63191fa">&#9670;&#160;</a></span>makeFPRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeFPRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>regnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a floating point register. </p>
<p>Floating point registers are different sizes on different platforms. For example, the M68040 has 80-bit registers that can store 96-bit extended-precision real values (16-bits of which are zero), but the follow on FreeScale ColdFire processors have only 64-bit registers that hold double-precision real values. </p>

</div>
</div>
<a id="a84ea58d819884f930342fa65ce90328d" name="a84ea58d819884f930342fa65ce90328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ea58d819884f930342fa65ce90328d">&#9670;&#160;</a></span>makeEffectiveAddress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeEffectiveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>modreg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ext_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an expression for m68k "&lt;ea&gt;x" or "&lt;ea&gt;y". </p>
<p>The <code>modreg</code> is a six-bit value whose high-order three bits are the addressing mode and whose low-order three bits are (usually) a register number. The return value has a type of the specified data format. The <code>ext_offset</code> indicates how many instruction extension words have already been consumed. </p>

</div>
</div>
<a id="acdef9914d5a74f5f32030f3703441941" name="acdef9914d5a74f5f32030f3703441941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdef9914d5a74f5f32030f3703441941">&#9670;&#160;</a></span>makeEffectiveAddress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeEffectiveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M68kDataFormat&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ext_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an expression for m68k "&lt;ea&gt;x" or "&lt;ea&gt;y". </p>
<p>The <code>modreg</code> is a six-bit value whose high-order three bits are the addressing mode and whose low-order three bits are (usually) a register number. The return value has a type of the specified data format. The <code>ext_offset</code> indicates how many instruction extension words have already been consumed. </p>

</div>
</div>
<a id="a0bd37f6e3a5ae18f55a4396721db924e" name="a0bd37f6e3a5ae18f55a4396721db924e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd37f6e3a5ae18f55a4396721db924e">&#9670;&#160;</a></span>makeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> * Rose::BinaryAnalysis::Disassembler::M68k::makeAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a memory-reference expression to an address. </p>
<p>This is used for things like the JSR instruction that takes an effective address that's a memory reference, and converts it to just an address. It also rewrites PC-relative addresses since the PC is constant. </p>

</div>
</div>
<a id="a15c169310f927bb9660f9aaa306bd830" name="a15c169310f927bb9660f9aaa306bd830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c169310f927bb9660f9aaa306bd830">&#9670;&#160;</a></span>makeOffsetWidthPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionPair Rose::BinaryAnalysis::Disassembler::M68k::makeOffsetWidthPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Disassembler_1_1M68k_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>extension_word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an offset width pair from an extension word. </p>
<p>The extension word contains an offset and width expression each of which is either a 5-bit unsigned integer or a data register number. This is used by various bit field instructions. </p>

</div>
</div>
<a id="aff138c0d42d0b33788b193713dc890db" name="aff138c0d42d0b33788b193713dc890db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff138c0d42d0b33788b193713dc890db">&#9670;&#160;</a></span>get_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">M68kFamily Rose::BinaryAnalysis::Disassembler::M68k::get_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns ISA family specified in constructor. </p>

<p class="definition">Definition at line <a class="el" href="Disassembler_2M68k_8h_source.html#l00239">239</a> of file <a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Disassembler_2M68k_8h_source.html">Disassembler/M68k.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
