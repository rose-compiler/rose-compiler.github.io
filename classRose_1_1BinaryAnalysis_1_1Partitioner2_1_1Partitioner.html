<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::Partitioner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::Partitioner Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Partitions instructions into basic blocks and functions. </p>
<p>A partitioner is responsible for driving a disassembler to obtain instructions, grouping those instructions into basic blocks, grouping the basic blocks into functions, and building an abstract syntax tree. The partitioner is the low-level part of the whole partitioning process (the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> is the high-level part) and is customized by registering callbacks. The partitioner knows "how" to group small components (like instructions) into larger components (like basic blocks) whereas the engine knows "where" to look for things in the specimen address space.</p>
<p>The following objects are needed as input:</p>
<ul>
<li>A memory map containing the memory for the specimen being analyzed. Parts of memory that contain instructions must be mapped with execute permission. Parts of memory that are readable and non-writable will be considered constant for the purpose of disassembly and partitioning and can contain things like dynamic linking tables that have been initialized prior to calling the partitioner. The memory map need not be the exact memory map for the specimen, and often isn't, because the specimen's mapping permissions might not be appropriate.</li>
</ul>
<ul>
<li>A disassembler which is canonical for the specimen architecture and which will return an instruction (possibly an "unknown" instruction) whenever it is asked to disassemble an address that is mapped with execute permission. The partitioner wraps the disassembler and memory map into an <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html">InstructionProvider</a> that caches disassembled instructions.</li>
</ul>
<p>The following data structures are maintained consistently by the partitioner (described in detail later):</p>
<ul>
<li>A control flow graph (CFG) indicating the basic blocks that will become part of the final abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). The CFG is highly fluid during partitioning, with basic blocks and control flow edges being added and removed. Since basic blocks are composed of instructions, the CFG indirectly represents the instructions that will become the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>.</li>
</ul>
<ul>
<li>An address usage map (AUM), which is a mapping from every address represented in the CFG to the instruction(s) and their basic blocks. A single address may have multiple overlapping instructions (although this isn't the usual case), and every instruction represented by the map belongs to exactly one basic block that belongs to the CFG.</li>
</ul>
<h1><a class="anchor" id="partitoner_basic_block"></a>
Basic Blocks</h1>
<p>A basic block (BB) is a sequence of distinct instructions that are always executed linearly from beginning to end with no branching into or out of the middle of the BB. The semantics of a BB are the composition of the semantics of each instruction in the order they would be executed. The instructions of a BB are not required to be contiguous in memory, although they usually are.</p>
<p>A basic block has a starting address (equivalent to the starting address of its first instruction when its first instruction is known), and a size measured in instructions. A basic block's size in bytes is generally not useful since there is no requirement that the instructions be contiguous in memory. Basic blocks also store the results of various analyses that are run when the block is created.</p>
<p>Basic blocks can either be represented in a partitioner's CFG/AUM, or they can exist in a detached state. Basic blocks in a detached state can be modified directly via <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html" title="Basic block information.">BasicBlock</a> methods, but blocks that are attached to the CFG/AUM are frozen. Frozen blocks can still be modified in certain ways, but usually only by going through the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> API that ensures that the CFG/AUM are kept up-to-date. The CFG/AUM will contain at most one basic block per basic block starting address.</p>
<p>If the first instruction of a basic block is unmapped or mapped without execute permission then the basic block is said to be non-existing and will have no instructions. Such blocks point to the special "nonexisting" CFG vertex when they are attached to the control flow graph. If a non-initial instruction of a basic block is unmapped or not executable then the prior instruction becomes the final instruction of the block and the block's successor will be a vertex for a non-existing basic block which in turn points to the special "nonexisting" CFG vertex. In other words, a basic block will either entirely exist or entirely not exist (there are no basic blocks containing instructions that just run off the end of memory).</p>
<p>If a basic block encounters an address which is mapped with execute permission and properly aligned but the instruction provider is unable to disassemble an instruction at that address, then the instruction provider must provide an "unknown" instruction. Since an "unknown" instruction always has indeterminate edges it becomes the final instruction of the basic block, and the CFG will contain an edge to the special "indeterminate" vertex. Blocks that have improper alignment are treated as if they started at an unmapped or non-executable address.</p>
<h1><a class="anchor" id="partitioner_data_block"></a>
Data Blocks</h1>
<p>A data block is an address and data type anywhere in memory. A data block can be attached to a CFG/AUM, or exist in a detached state. They are attached to the CFG/AUM by virtue of being owned by one or more basic blocks or functions that are attached to the CFG/AUM. Data blocks such as function alignment are typically attached to a function, while data blocks such as branch tables are typically attached to a basic block. A data block may be attached to more than one function and/or basic block, and the CFG/AUM is able to support multiple data blocks having the same address.</p>
<h1><a class="anchor" id="partitioner_functions"></a>
Functions</h1>
<p>A function is a collection of one or more basic blocks related by control flow edges. One basic block is special in that it serves as the only entry point to this function for inter-function edges (usually function calls). Any edge that leaves the function must enter a different function's entry block. These two rules can be relaxed, but result in a control flow graph that is not proper for a function&ndash;most of ROSE's analyses work only on proper control flow graphs.</p>
<p>Functions can either be represented in a partitioner's CFG/AUM, or they can exist in a detached state. Functions in a detached state can have their basic block and data block ownership adjusted, otherwise the function exists in a frozen state to prevent the CFG/AUM from becoming out of date with respect to the function. Frozen functions can only be modified through the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> API so that the CFG/AUM can be updated. When a function becomes detached from the CFG it thaws out again and can be modified. The CFG/AUM will contain at most one function per function starting address.</p>
<h1><a class="anchor" id="partitioner_cfg"></a>
Control Flow Graph</h1>
<p>At any point in time, the partitioner's control flow graph represents those basic blocks (and indirectly the instructions) that have been selected to appear in the final abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>). This is a subset of all basic blocks ever created, and a subset of the instructions known to the instruction provider. Note: a final pass during <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> construction might join certain CFG vertices into a single <a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a> under certain circumstances. The CFG is of type <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a>, a subset of <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a> whose vertices and edges both carry information: the vertices are of type <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html">CfgVertex</a> and the edges are of type <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgEdge.html">CfgEdge</a>.</p>
<p>Most CFG vertices represent basic blocks (vertex type <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a443b7ff922a8607fd07162a87e0c5b7d">V_BASIC_BLOCK</a>) and either point to a non-null <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html">BasicBlock</a> having at least one discovered instruction, or to a null basic block. A "placeholder" usually refers to a vertex with a null basic block pointer (but not necessarily), and "basic block" refers to a vertex with a non-null pointer. Therefore the set of placeholders is a superset of the set of basic blocks. A "pure placeholder" is a basic block vertex with a null pointer. Any of the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a443b7ff922a8607fd07162a87e0c5b7d">V_BASIC_BLOCK</a> vertices can also point to an optional function that owns the block.</p>
<p>Placeholders with null basic block pointers represent one of two situations: either the partitioner has not attempted to discover an instruction at the basic block starting address, or the partitioner has tried but failed due to the address being non-executable or not mapped. The two cases are distinguished from each other by whether the vertex's only outgoing edge points to the special "undiscovered" or "nonexisting" vertex. Pure placeholders always have exactly this one outgoing edge.</p>
<p>The CFG also has other special (non-basic block) vertices each represented by its own vertex type. Altogether, the special vertices, by their type, are:</p>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a52373ac58f9dd1394d939f8ba3de4cea" title="The special &quot;undiscovered&quot; vertex.">VertexType::V_UNDISCOVERED</a>:</code> a unique, special vertex whose incoming edges originate only from pure placeholders, one edge per placeholder. This vertex is returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a11e1798ead9f1bda8a0c3244a3eeabb7">undiscoveredVertex</a> and users can use its incoming edge list as a simple work-list of places where instructions need to be discovered.</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797aedb78bf04ed6f85a182dc01ca2fdee1e" title="Special vertex destination for non-existing basic blocks.">VertexType::V_NONEXISTING</a>:</code> a unique, special vertex whose incoming edges originate from pure placeholders that were discovered to have an unmapped or non-executable starting address, one edge per placeholder. In other words, this vertex's incoming edges point back to addresses where the partitioner thinks there should be a basic block but there isn't. An example is entry addresses for dynamically linked functions that have not been loaded and linked. This vertex is returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a05e4e29f3a85c8b586777f16dfe3d401">nonexistingVertex</a>.</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aec4f331fd4ff97ca588f50435cd0b797a8c41e56b594be1074f159dc7d2d29f42" title="Special vertex destination for indeterminate edges.">VertexType::V_INDETERMINATE</a>:</code> a unique, special vertex that serves as the destination for any basic block outgoing edge whose target address is not concrete. For instance, an indirect jump through a register whose value is not known will have an edge to the indeterminate vertex. An "unknown" instruction, which indicates that memory is executable but disassembly failed, also always point to the indeterminate vertex. This vertex is returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6175331304232fe65d37aa32353330a2">indeterminateVertex</a>.</li>
</ul>
<p>CFG edges are also labeled with type information:</p>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0" title="Edge is a function call.">EdgeType::E_FUNCTION_CALL</a>:</code> represents an edge known to be a function call. A function call is defined as an inter-function branch that pushes a return address onto the stack.</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5" title="Edge is a function call transfer.">EdgeType::E_FUNCTION_XFER</a>:</code> represents an inter-function edge which is not a function call. These edges represent a transfer of control from the caller to the callee (even though there is no CALL instruction) where the callee inherits the stack frame of the caller. When the callee returns it will skip over the caller because the caller does not have a distinct stack frame. An example is an edge from a thunk consisting of an indirect jump instruction that branches to another function.</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6" title="Edge is a function return.">EdgeType::E_FUNCTION_RETURN</a>:</code> represents a function return-to-caller, such as from a RET instruction. If a function can return to multiple locations, rather than store a list edges for each possible return address, the CFG stores only one edge with an abstract value, thus pointing to the indeterminate vertex. Of course if a function can only return to one address then the edge is concrete and points to a placeholder at that address, but how often does that happen?</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e" title="Edge is a function return from the call site.">EdgeType::E_CALL_RETURN</a>:</code> represents a function return with respect to a call site. These edges normally originate at CALL instructions and point to the address following the call. Lack of such an edge when the CFG is finished usually indicates that the called function cannot return.</li>
</ul>
<ul>
<li><code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740" title="Normal control flow edge, nothing special.">EdgeType::E_NORMAL</a>:</code> represents any edge not in one of the above categories.</li>
</ul>
<h1><a class="anchor" id="partitioner_aum"></a>
Address Usage Map</h1>
<p>The address usage map (AUM) is similar to the control flow graph in that they both represent the same set of instructions, basic blocks, and functions. But where the CFG organizes them according to their control flow relationships, the AUM organizes them by the memory addresses they occupy. The partitioner ensures that both data structures are always synchronized with each other from the perspective of an outside viewer (including user callbacks).</p>
<p>The AUM can answer queries about what instructions, basic blocks, data blocks, or functions are contained within, begin within, span, or overlap an address or address interval. For small intervals the results can usually be obtained in logorithmic time, but querying large intervals can be slower.</p>
<h1><a class="anchor" id="partitioner_prioritizing"></a>
Prioritizing Work</h1>
<p>The partitioner itself does not prioritize work or perform work automatically&ndash;it must be told what to do, usually through an engine. However, the partitioner does have certain features that facilitate prioritization at higher layers. Namely, it has the CFG with special vertices, and AUM and a whole set of queries, an address map that can be traversed, and user-defined callbacks that are notified for certain CFG changes.</p>
<ul>
<li>The special <em>undiscovered</em> vertex is commonly used to obtain a list of addresses where a basic block needs to be discovered. Unfortunately these addresses are in no particular order and will change continually as pure placeholders are inserted and erased from the CFG, or a pure placeholder becomes a discovered basic block.</li>
</ul>
<ul>
<li>The special <em>indeterminate</em> vertex can be queried to find basic blocks that might need more analysis. For instance, an indirect jump that results in an abstract successor might be a point where an inter-block data-flow analysis could nail down the successor to a concrete value or a set of values. A common example is case-choosing code for a C "switch" statement.</li>
</ul>
<ul>
<li>The address usage map (AUM) can be queried to find addresses where instructions haven't been discovered yet. This technique is usually combined with a memory map traversal so that only executable mapped addresses need be considered rather than the entire 4GB (or larger) specimen address space.</li>
</ul>
<ul>
<li>The user can register a callback (or callbacks) that will be notified each time a basic block or placeholder is attached or detached from the CFG, thus giving the user a chance to discover new work areas and prioritize them.</li>
</ul>
<p>The base implementation of <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> uses these features to prioritize its work and can be consulted as an example.</p>
<h1><a class="anchor" id="partitioner_provisional"></a>
Provisional Detection</h1>
<p>(This section is a placeholder for an idea that is not yet implemented.)</p>
<p>Sometimes one wants to ask the question "does a recursive disassembly starting at some particular address look reasonable?" and avoid making any changes if it doesn't. This can be accomplished by creating a second "provisional" partitioner which is either in its initial empty state or a copy of the current partitioner, running the query, and examining the result. If the result looks reasonable, then the provisional partitioner can be assigned to the current partitioner.</p>
<p>When a partitioner is copied (by the copy constructor or by assignment) it makes a new copy of the CFG and the address mapping. The new copy points to the same instructions and basic blocks as the original, but since both of these items are constant (other than basic block analysis results) they are sharing read-only information.</p>
<p>The cost of copying the CFG is linear in the number of vertices and edges. The cost of copying the address map is linear in the number of instructions (or slightly more if instructions overlap).</p>
<p>A more efficient mechanism might be developed in the future.</p>
<h1><a class="anchor" id="partitioner_function_boundaries"></a>
Function Boundary Determination</h1>
<p>(This section is a placeholder for future documentation).</p>
<h1><a class="anchor" id="partitioner_faq"></a>
Frequenctly Asked Questions</h1>
<p>Q. Why is this class final?</p>
<p>A. This class represents the low-level operations for partitioning instructions and is responsible for ensuring that certain data structures such as the CFG and AUM are always consistent. The class is final to guarantee these invariants. Its behavior can only be modified by registering callbacks. High-level behavior is implemented above this class such as in module functions (various Module*.h files) or engines derived from the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> class. Additional data can be attached to a partitioner via attributes (see <a class="el" href="namespaceSawyer_1_1Attribute.html">Sawyer::Attribute</a>). </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00263">263</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Partitioner_8h_source.html">Rose/BinaryAnalysis/Partitioner2/Partitioner.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Partitioner2::Partitioner:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_inherit__map">
<area shape="rect" title="Partitions instructions into basic blocks and functions." alt="" coords="224,55,387,95"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="14,5,167,31"/>
<area shape="poly" title=" " alt="" coords="152,32,231,53,230,58,151,37"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="5,55,176,95"/>
<area shape="poly" title=" " alt="" coords="189,73,224,73,224,78,189,78"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="19,119,162,159"/>
<area shape="poly" title=" " alt="" coords="170,113,237,93,239,98,172,118"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Partitioner2::Partitioner:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_coll__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_coll__map">
<area shape="rect" title="Partitions instructions into basic blocks and functions." alt="" coords="224,55,387,95"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="14,5,167,31"/>
<area shape="poly" title=" " alt="" coords="152,32,231,53,230,58,151,37"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="5,55,176,95"/>
<area shape="poly" title=" " alt="" coords="189,73,224,73,224,78,189,78"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="19,119,162,159"/>
<area shape="poly" title=" " alt="" coords="170,113,237,93,239,98,172,118"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_1_1Thunk.html">Thunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents information about a thunk.  <a href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_1_1Thunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a044db32618aa7b901caac5629167825e" id="r_a044db32618aa7b901caac5629167825e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Callbacks.html">Sawyer::Callbacks</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgAdjustmentCallback.html#a07047df2e79bd8c3049588feec7ba455">CfgAdjustmentCallback::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">CfgAdjustmentCallbacks</a></td></tr>
<tr class="memdesc:a044db32618aa7b901caac5629167825e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1d79564686574f7c0340b9aa9a13a7a8">cfgAdjustmentCallbacks</a>.  <br /></td></tr>
<tr class="separator:a044db32618aa7b901caac5629167825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d33eeb49d3688517f7df1f7004315a" id="r_ae0d33eeb49d3688517f7df1f7004315a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Callbacks.html">Sawyer::Callbacks</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">BasicBlockCallbackPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">BasicBlockCallbacks</a></td></tr>
<tr class="memdesc:ae0d33eeb49d3688517f7df1f7004315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adbee3513586f9d653ad1805e44df8072">basicBlockCallbacks</a>.  <br /></td></tr>
<tr class="separator:ae0d33eeb49d3688517f7df1f7004315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fa873c34d530750943a0e4171dd480" id="r_ab7fa873c34d530750943a0e4171dd480"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">FunctionPrologueMatcherPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">FunctionPrologueMatchers</a></td></tr>
<tr class="memdesc:ab7fa873c34d530750943a0e4171dd480"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0f9d0dafd282a74651166a929ef7bd66">functionPrologueMatchers</a>.  <br /></td></tr>
<tr class="separator:ab7fa873c34d530750943a0e4171dd480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4386d55af94c82efad04a6c4e9d74c37" id="r_a4386d55af94c82efad04a6c4e9d74c37"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a175cf54eba5910f765929bfd48d46eb8">FunctionPaddingMatcherPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">FunctionPaddingMatchers</a></td></tr>
<tr class="memdesc:a4386d55af94c82efad04a6c4e9d74c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af4f90960bc68617c7b20d22b198aa6e1">functionPaddingMatchers</a>.  <br /></td></tr>
<tr class="separator:a4386d55af94c82efad04a6c4e9d74c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e4b59c220a710a50c2865c337c52f4" id="r_a00e4b59c220a710a50c2865c337c52f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; rose_addr_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a00e4b59c220a710a50c2865c337c52f4">AddressNameMap</a></td></tr>
<tr class="memdesc:a00e4b59c220a710a50c2865c337c52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> address to name.  <br /></td></tr>
<tr class="separator:a00e4b59c220a710a50c2865c337c52f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4fef4ab65e1ce68aced8e1842aa0070b" id="r_a4fef4ab65e1ce68aced8e1842aa0070b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a></td></tr>
<tr class="memdesc:a4fef4ab65e1ce68aced8e1842aa0070b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a4fef4ab65e1ce68aced8e1842aa0070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c025811c07d41e351f246a16d4cc285" id="r_a5c025811c07d41e351f246a16d4cc285"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5c025811c07d41e351f246a16d4cc285">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a></td></tr>
<tr class="memdesc:a5c025811c07d41e351f246a16d4cc285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer.  <br /></td></tr>
<tr class="separator:a5c025811c07d41e351f246a16d4cc285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage" id="r_a6232bff42634b42d2dcd3b68ba39a39c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSawyer_1_1SynchronizationTraits.html">SynchronizationTraits</a>&lt; SyncTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a6232bff42634b42d2dcd3b68ba39a39c">Sync</a></td></tr>
<tr class="separator:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa36792bbbe7cfa563ef1d95515d7b5d1" id="r_aa36792bbbe7cfa563ef1d95515d7b5d1"><td class="memItemLeft" align="right" valign="top"><a id="aa36792bbbe7cfa563ef1d95515d7b5d1" name="aa36792bbbe7cfa563ef1d95515d7b5d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>saveAsRbaFile</b> (const boost::filesystem::path &amp;name, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a> fmt) const</td></tr>
<tr class="memdesc:aa36792bbbe7cfa563ef1d95515d7b5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save this partitioner as an RBA file. <br /></td></tr>
<tr class="separator:aa36792bbbe7cfa563ef1d95515d7b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891ddef591f4180c85e6f09fdfc07992" id="r_a891ddef591f4180c85e6f09fdfc07992"><td class="memItemLeft" align="right" valign="top"><a id="a891ddef591f4180c85e6f09fdfc07992" name="a891ddef591f4180c85e6f09fdfc07992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Partitioner</b> (BOOST_RV_REF(<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>))</td></tr>
<tr class="memdesc:a891ddef591f4180c85e6f09fdfc07992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a891ddef591f4180c85e6f09fdfc07992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be8e773eb502617dff6ca223119aa09" id="r_a3be8e773eb502617dff6ca223119aa09"><td class="memItemLeft" align="right" valign="top"><a id="a3be8e773eb502617dff6ca223119aa09" name="a3be8e773eb502617dff6ca223119aa09"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (BOOST_RV_REF(<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>))</td></tr>
<tr class="memdesc:a3be8e773eb502617dff6ca223119aa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a3be8e773eb502617dff6ca223119aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76677492554491ba8ed92387f14e40a" id="r_ab76677492554491ba8ed92387f14e40a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab76677492554491ba8ed92387f14e40a">isDefaultConstructed</a> () const</td></tr>
<tr class="memdesc:ab76677492554491ba8ed92387f14e40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a default constructed partitioner.  <br /></td></tr>
<tr class="separator:ab76677492554491ba8ed92387f14e40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e23726d49ed9dc8c318c30a7e5397" id="r_ab14e23726d49ed9dc8c318c30a7e5397"><td class="memItemLeft" align="right" valign="top"><a id="ab14e23726d49ed9dc8c318c30a7e5397" name="ab14e23726d49ed9dc8c318c30a7e5397"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:ab14e23726d49ed9dc8c318c30a7e5397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset CFG/AUM to initial state. <br /></td></tr>
<tr class="separator:ab14e23726d49ed9dc8c318c30a7e5397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec808a1a2846948f412dfb8af24b063" id="r_a5ec808a1a2846948f412dfb8af24b063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5ec808a1a2846948f412dfb8af24b063">architecture</a> () const</td></tr>
<tr class="memdesc:a5ec808a1a2846948f412dfb8af24b063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> information.  <br /></td></tr>
<tr class="separator:a5ec808a1a2846948f412dfb8af24b063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae759942924032c1753769bc31cde38c3" id="r_ae759942924032c1753769bc31cde38c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae759942924032c1753769bc31cde38c3">memoryMap</a> () const</td></tr>
<tr class="memdesc:ae759942924032c1753769bc31cde38c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory map.  <br /></td></tr>
<tr class="separator:ae759942924032c1753769bc31cde38c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2233a608a1889df426b85185f7a943" id="r_a1f2233a608a1889df426b85185f7a943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1f2233a608a1889df426b85185f7a943">addressIsExecutable</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:a1f2233a608a1889df426b85185f7a943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if address is executable.  <br /></td></tr>
<tr class="separator:a1f2233a608a1889df426b85185f7a943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb98bea1ac200e508d253cc2e9979d5a" id="r_acb98bea1ac200e508d253cc2e9979d5a"><td class="memItemLeft" align="right" valign="top"><a id="acb98bea1ac200e508d253cc2e9979d5a" name="acb98bea1ac200e508d253cc2e9979d5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>configureInsnUnparser</b> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;) const</td></tr>
<tr class="memdesc:acb98bea1ac200e508d253cc2e9979d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the single-instruction unparser. <br /></td></tr>
<tr class="separator:acb98bea1ac200e508d253cc2e9979d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cabb9057b20d340f28461ce1846b81" id="r_a30cabb9057b20d340f28461ce1846b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a30cabb9057b20d340f28461ce1846b81">configureInsnPlainUnparser</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a30cabb9057b20d340f28461ce1846b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure plain single-instruction unparser.  <br /></td></tr>
<tr class="separator:a30cabb9057b20d340f28461ce1846b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f7c92f966d5f498baae4ff67d63c8d" id="r_a94f7c92f966d5f498baae4ff67d63c8d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a94f7c92f966d5f498baae4ff67d63c8d">unparsePlain</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a94f7c92f966d5f498baae4ff67d63c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction in a plain way.  <br /></td></tr>
<tr class="separator:a94f7c92f966d5f498baae4ff67d63c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636381b5508ca7aa462def32a6517cee" id="r_a636381b5508ca7aa462def32a6517cee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a636381b5508ca7aa462def32a6517cee">nBytes</a> () const</td></tr>
<tr class="memdesc:a636381b5508ca7aa462def32a6517cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes represented by the CFG.  <br /></td></tr>
<tr class="separator:a636381b5508ca7aa462def32a6517cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398bf1dd74a7e6f3938eed10cf9f84e9" id="r_a398bf1dd74a7e6f3938eed10cf9f84e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a398bf1dd74a7e6f3938eed10cf9f84e9">cfg</a> () const</td></tr>
<tr class="memdesc:a398bf1dd74a7e6f3938eed10cf9f84e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control flow graph.  <br /></td></tr>
<tr class="separator:a398bf1dd74a7e6f3938eed10cf9f84e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15035967450906554776155d8bbcc26" id="r_aa15035967450906554776155d8bbcc26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa15035967450906554776155d8bbcc26">aum</a> () const</td></tr>
<tr class="memdesc:aa15035967450906554776155d8bbcc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address usage map.  <br /></td></tr>
<tr class="separator:aa15035967450906554776155d8bbcc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d94faa289fee7a0d1b2a6bd6a1dbb3" id="r_a42d94faa289fee7a0d1b2a6bd6a1dbb3"><td class="memItemLeft" align="right" valign="top"><a id="a42d94faa289fee7a0d1b2a6bd6a1dbb3" name="a42d94faa289fee7a0d1b2a6bd6a1dbb3"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>aum</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a42d94faa289fee7a0d1b2a6bd6a1dbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address usage map for a single function. <br /></td></tr>
<tr class="separator:a42d94faa289fee7a0d1b2a6bd6a1dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a244171e655c35ffb317614337e85c" id="r_af1a244171e655c35ffb317614337e85c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af1a244171e655c35ffb317614337e85c">users</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:af1a244171e655c35ffb317614337e85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entities that exist at a particular address.  <br /></td></tr>
<tr class="separator:af1a244171e655c35ffb317614337e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ea2e6c5c1a9983214e922ae0706760" id="r_a37ea2e6c5c1a9983214e922ae0706760"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a37ea2e6c5c1a9983214e922ae0706760">ghostSuccessors</a> () const</td></tr>
<tr class="memdesc:a37ea2e6c5c1a9983214e922ae0706760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine all ghost successors in the control flow graph.  <br /></td></tr>
<tr class="separator:a37ea2e6c5c1a9983214e922ae0706760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ad0090449cf7b06fdb2a39793ea2d7" id="r_aa8ad0090449cf7b06fdb2a39793ea2d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa8ad0090449cf7b06fdb2a39793ea2d7">nInstructions</a> () const</td></tr>
<tr class="memdesc:aa8ad0090449cf7b06fdb2a39793ea2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of instructions attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:aa8ad0090449cf7b06fdb2a39793ea2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1f6dcc5c29c25abda70419d822901d" id="r_a7a1f6dcc5c29c25abda70419d822901d"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7a1f6dcc5c29c25abda70419d822901d">instructionVertex</a> (rose_addr_t insnVa) const</td></tr>
<tr class="memdesc:a7a1f6dcc5c29c25abda70419d822901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CFG vertex containing specified instruction.  <br /></td></tr>
<tr class="separator:a7a1f6dcc5c29c25abda70419d822901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a72cd957b2a0414a6a125f6ead186c" id="r_aa5a72cd957b2a0414a6a125f6ead186c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa5a72cd957b2a0414a6a125f6ead186c">instructionsOverlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:aa5a72cd957b2a0414a6a125f6ead186c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns instructions that overlap with specified address interval.  <br /></td></tr>
<tr class="separator:aa5a72cd957b2a0414a6a125f6ead186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc36313234db580953212bc891ced5b" id="r_a6dc36313234db580953212bc891ced5b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6dc36313234db580953212bc891ced5b">instructionsSpanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a6dc36313234db580953212bc891ced5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns instructions that span an entire address interval.  <br /></td></tr>
<tr class="separator:a6dc36313234db580953212bc891ced5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff462caeef49426bb7c9a8a33e8629e" id="r_a1ff462caeef49426bb7c9a8a33e8629e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1ff462caeef49426bb7c9a8a33e8629e">instructionsContainedIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a1ff462caeef49426bb7c9a8a33e8629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns instructions that are fully contained in an address interval.  <br /></td></tr>
<tr class="separator:a1ff462caeef49426bb7c9a8a33e8629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65ff58a2563565be6fb29867ac358ca" id="r_ae65ff58a2563565be6fb29867ac358ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae65ff58a2563565be6fb29867ac358ca">instructionExtent</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:ae65ff58a2563565be6fb29867ac358ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address interval for an instruction.  <br /></td></tr>
<tr class="separator:ae65ff58a2563565be6fb29867ac358ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2391a325e084b2f001b2e450d6b2b181" id="r_a2391a325e084b2f001b2e450d6b2b181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2391a325e084b2f001b2e450d6b2b181">discoverInstruction</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a2391a325e084b2f001b2e450d6b2b181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover an instruction.  <br /></td></tr>
<tr class="separator:a2391a325e084b2f001b2e450d6b2b181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b9d41879a8131917ea202acf3bc680" id="r_ae8b9d41879a8131917ea202acf3bc680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a290cbfd543686205aeeba62d70b8aace">CrossReferences</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae8b9d41879a8131917ea202acf3bc680">instructionCrossReferences</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;restriction) const</td></tr>
<tr class="memdesc:ae8b9d41879a8131917ea202acf3bc680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross references.  <br /></td></tr>
<tr class="separator:ae8b9d41879a8131917ea202acf3bc680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca6e7da80bc9ed21e53cf26f01dde4" id="r_a4fca6e7da80bc9ed21e53cf26f01dde4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fca6e7da80bc9ed21e53cf26f01dde4">nPlaceholders</a> () const</td></tr>
<tr class="memdesc:a4fca6e7da80bc9ed21e53cf26f01dde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of basic basic block placeholders in the CFG.  <br /></td></tr>
<tr class="separator:a4fca6e7da80bc9ed21e53cf26f01dde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461f439dbc5dbe6b48df43995d0b4d4c" id="r_a461f439dbc5dbe6b48df43995d0b4d4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a461f439dbc5dbe6b48df43995d0b4d4c">placeholderExists</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a461f439dbc5dbe6b48df43995d0b4d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a basic block placeholder exists in the CFG.  <br /></td></tr>
<tr class="separator:a461f439dbc5dbe6b48df43995d0b4d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913fe4a4e5d9a070340a1feba2880b15" id="r_a913fe4a4e5d9a070340a1feba2880b15"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a913fe4a4e5d9a070340a1feba2880b15">insertPlaceholder</a> (rose_addr_t startVa)</td></tr>
<tr class="memdesc:a913fe4a4e5d9a070340a1feba2880b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a basic-block placeholder.  <br /></td></tr>
<tr class="separator:a913fe4a4e5d9a070340a1feba2880b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fa8cdfad165056410c6ba442d08baa" id="r_a13fa8cdfad165056410c6ba442d08baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a13fa8cdfad165056410c6ba442d08baa">basicBlockDropSemantics</a> () const</td></tr>
<tr class="memdesc:a13fa8cdfad165056410c6ba442d08baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately drop semantic information for all attached basic blocks.  <br /></td></tr>
<tr class="separator:a13fa8cdfad165056410c6ba442d08baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50f53faa1340930e8fc0fb38fa57407" id="r_ac50f53faa1340930e8fc0fb38fa57407"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac50f53faa1340930e8fc0fb38fa57407">nBasicBlocks</a> () const</td></tr>
<tr class="memdesc:ac50f53faa1340930e8fc0fb38fa57407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of basic blocks attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:ac50f53faa1340930e8fc0fb38fa57407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548d98c3c7a2ba1f9b46b8cefdcab29d" id="r_a548d98c3c7a2ba1f9b46b8cefdcab29d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a548d98c3c7a2ba1f9b46b8cefdcab29d">basicBlocks</a> () const</td></tr>
<tr class="memdesc:a548d98c3c7a2ba1f9b46b8cefdcab29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all basic blocks attached to the CFG.  <br /></td></tr>
<tr class="separator:a548d98c3c7a2ba1f9b46b8cefdcab29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb6c37daaa98a72b4c09a885fca51f0" id="r_a8fb6c37daaa98a72b4c09a885fca51f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a8fb6c37daaa98a72b4c09a885fca51f0">basicBlocksOverlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a8fb6c37daaa98a72b4c09a885fca51f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns basic blocks that overlap with specified address interval.  <br /></td></tr>
<tr class="separator:a8fb6c37daaa98a72b4c09a885fca51f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea4fd3a9e64c12144b2195f1c1dc94b" id="r_a3ea4fd3a9e64c12144b2195f1c1dc94b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3ea4fd3a9e64c12144b2195f1c1dc94b">basicBlocksSpanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a3ea4fd3a9e64c12144b2195f1c1dc94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns basic blocks that span an entire address interval.  <br /></td></tr>
<tr class="separator:a3ea4fd3a9e64c12144b2195f1c1dc94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2fd7c47884b75e50501698000ce68d" id="r_a0d2fd7c47884b75e50501698000ce68d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0d2fd7c47884b75e50501698000ce68d">basicBlocksContainedIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a0d2fd7c47884b75e50501698000ce68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns basic blocks that are fully contained in an address interval.  <br /></td></tr>
<tr class="separator:a0d2fd7c47884b75e50501698000ce68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085c79835c73723e4de338621a546e17" id="r_a085c79835c73723e4de338621a546e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a085c79835c73723e4de338621a546e17">basicBlockContainingInstruction</a> (rose_addr_t insnVa) const</td></tr>
<tr class="memdesc:a085c79835c73723e4de338621a546e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the basic block that contains a specific instruction address.  <br /></td></tr>
<tr class="separator:a085c79835c73723e4de338621a546e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020a008c3121d4f64860ee65fb0e8c69" id="r_a020a008c3121d4f64860ee65fb0e8c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a020a008c3121d4f64860ee65fb0e8c69">basicBlockInstructionExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a020a008c3121d4f64860ee65fb0e8c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by basic block instructions.  <br /></td></tr>
<tr class="separator:a020a008c3121d4f64860ee65fb0e8c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e966711e35a11ef9f0d0c159a11c1f5" id="r_a4e966711e35a11ef9f0d0c159a11c1f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4e966711e35a11ef9f0d0c159a11c1f5">basicBlockDataExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a4e966711e35a11ef9f0d0c159a11c1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by basic block data.  <br /></td></tr>
<tr class="separator:a4e966711e35a11ef9f0d0c159a11c1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fda3ccc04a2beb803ebc7af17afd3e" id="r_a34fda3ccc04a2beb803ebc7af17afd3e"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a34fda3ccc04a2beb803ebc7af17afd3e">truncateBasicBlock</a> (const ControlFlowGraph::ConstVertexIterator &amp;basicBlock, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)</td></tr>
<tr class="memdesc:a34fda3ccc04a2beb803ebc7af17afd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate an attached basic-block.  <br /></td></tr>
<tr class="separator:a34fda3ccc04a2beb803ebc7af17afd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21998ac655174b36cd99d86e3245124f" id="r_a21998ac655174b36cd99d86e3245124f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">BasicBlockSuccessors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a21998ac655174b36cd99d86e3245124f">basicBlockSuccessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9dace">Precision::Level</a> precision=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9daceaf7800da878cbb81a92cf4e9927b8a41e">Precision::HIGH</a>) const</td></tr>
<tr class="memdesc:a21998ac655174b36cd99d86e3245124f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine successors for a basic block.  <br /></td></tr>
<tr class="separator:a21998ac655174b36cd99d86e3245124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd59f9041a958f40b4c87a73353eecf" id="r_a9dd59f9041a958f40b4c87a73353eecf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9dd59f9041a958f40b4c87a73353eecf">basicBlockConcreteSuccessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, bool *isComplete=NULL) const</td></tr>
<tr class="memdesc:a9dd59f9041a958f40b4c87a73353eecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines concrete successors for a basic block.  <br /></td></tr>
<tr class="separator:a9dd59f9041a958f40b4c87a73353eecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc3ba0da480b23169e0a7163e70660" id="r_a2fdc3ba0da480b23169e0a7163e70660"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2fdc3ba0da480b23169e0a7163e70660">basicBlockGhostSuccessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2fdc3ba0da480b23169e0a7163e70660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine ghost successors for a basic block.  <br /></td></tr>
<tr class="separator:a2fdc3ba0da480b23169e0a7163e70660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6401d85f0681febea9fabcca58c9850b" id="r_a6401d85f0681febea9fabcca58c9850b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6401d85f0681febea9fabcca58c9850b">basicBlockIsFunctionCall</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9dace">Precision::Level</a> precision=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9daceaf7800da878cbb81a92cf4e9927b8a41e">Precision::HIGH</a>) const</td></tr>
<tr class="memdesc:a6401d85f0681febea9fabcca58c9850b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a basic block looks like a function call.  <br /></td></tr>
<tr class="separator:a6401d85f0681febea9fabcca58c9850b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e6f39e99322ef483b46305bc9ad73" id="r_a086e6f39e99322ef483b46305bc9ad73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a086e6f39e99322ef483b46305bc9ad73">basicBlockIsFunctionReturn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a086e6f39e99322ef483b46305bc9ad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a086e6f39e99322ef483b46305bc9ad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb1010bf2d016f2ede8259420c881d3" id="r_accb1010bf2d016f2ede8259420c881d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#accb1010bf2d016f2ede8259420c881d3">basicBlockPopsStack</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:accb1010bf2d016f2ede8259420c881d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the basic block pops at least one byte from the stack.  <br /></td></tr>
<tr class="separator:accb1010bf2d016f2ede8259420c881d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d1cfa4d3891d07145ff679dc333581" id="r_a65d1cfa4d3891d07145ff679dc333581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a65d1cfa4d3891d07145ff679dc333581">basicBlockMayReturnReset</a> () const</td></tr>
<tr class="memdesc:a65d1cfa4d3891d07145ff679dc333581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all may-return properties.  <br /></td></tr>
<tr class="separator:a65d1cfa4d3891d07145ff679dc333581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bf0ff87f9b5fa18780fb7763ea985d" id="r_a15bf0ff87f9b5fa18780fb7763ea985d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a15bf0ff87f9b5fa18780fb7763ea985d">nDataBlocks</a> () const</td></tr>
<tr class="memdesc:a15bf0ff87f9b5fa18780fb7763ea985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data blocks attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a15bf0ff87f9b5fa18780fb7763ea985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8233b76620035a5ccd034640fba7e808" id="r_a8233b76620035a5ccd034640fba7e808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a8233b76620035a5ccd034640fba7e808">dataBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a8233b76620035a5ccd034640fba7e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a data block or its equivalent is attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a8233b76620035a5ccd034640fba7e808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483de8dd2e18e32c52d9880e6b6dd619" id="r_a483de8dd2e18e32c52d9880e6b6dd619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a483de8dd2e18e32c52d9880e6b6dd619">findBestDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a483de8dd2e18e32c52d9880e6b6dd619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an existing data block.  <br /></td></tr>
<tr class="separator:a483de8dd2e18e32c52d9880e6b6dd619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5e45e130f444029bde970df5beb95d" id="r_a7b5e45e130f444029bde970df5beb95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7b5e45e130f444029bde970df5beb95d">attachDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a7b5e45e130f444029bde970df5beb95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a data block to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a7b5e45e130f444029bde970df5beb95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abb4b042b063da9f4c650c01fae42a9" id="r_a9abb4b042b063da9f4c650c01fae42a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9abb4b042b063da9f4c650c01fae42a9">detachDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a9abb4b042b063da9f4c650c01fae42a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a data block from the CFG/AUM.  <br /></td></tr>
<tr class="separator:a9abb4b042b063da9f4c650c01fae42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce9ff61ad0939cad1de41cbd239017" id="r_abbce9ff61ad0939cad1de41cbd239017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abbce9ff61ad0939cad1de41cbd239017">attachDataBlockToFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:abbce9ff61ad0939cad1de41cbd239017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a data block to an attached or detached function.  <br /></td></tr>
<tr class="separator:abbce9ff61ad0939cad1de41cbd239017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838e56822f6c76d086181e7c86b56de0" id="r_a838e56822f6c76d086181e7c86b56de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a838e56822f6c76d086181e7c86b56de0">attachDataBlockToBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a838e56822f6c76d086181e7c86b56de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a data block to a basic block.  <br /></td></tr>
<tr class="separator:a838e56822f6c76d086181e7c86b56de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e00535c562444fbb4051b2b9379d2b" id="r_a88e00535c562444fbb4051b2b9379d2b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a88e00535c562444fbb4051b2b9379d2b">dataBlocksOverlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a88e00535c562444fbb4051b2b9379d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data blocks that overlap with specified address interval.  <br /></td></tr>
<tr class="separator:a88e00535c562444fbb4051b2b9379d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cdd95c976b38cccbf7630d86c90d64" id="r_a46cdd95c976b38cccbf7630d86c90d64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a46cdd95c976b38cccbf7630d86c90d64">dataBlocksSpanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a46cdd95c976b38cccbf7630d86c90d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data blocks that span an entire address interval.  <br /></td></tr>
<tr class="separator:a46cdd95c976b38cccbf7630d86c90d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e09c6703702f4070f5c4c58d35c63c" id="r_a21e09c6703702f4070f5c4c58d35c63c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a21e09c6703702f4070f5c4c58d35c63c">dataBlocksContainedIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a21e09c6703702f4070f5c4c58d35c63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data blocks that are fully contained in an address interval.  <br /></td></tr>
<tr class="separator:a21e09c6703702f4070f5c4c58d35c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe075dcd9e6aa63476cc87d03218fa65" id="r_afe075dcd9e6aa63476cc87d03218fa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afe075dcd9e6aa63476cc87d03218fa65">dataBlockExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:afe075dcd9e6aa63476cc87d03218fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a data block.  <br /></td></tr>
<tr class="separator:afe075dcd9e6aa63476cc87d03218fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad282e79d481b35da9da7ea45a5efb435" id="r_ad282e79d481b35da9da7ea45a5efb435"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad282e79d481b35da9da7ea45a5efb435">dataBlocks</a> () const</td></tr>
<tr class="memdesc:ad282e79d481b35da9da7ea45a5efb435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all attached data blocks.  <br /></td></tr>
<tr class="separator:ad282e79d481b35da9da7ea45a5efb435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55907985af83a80be7c5801d62cc630d" id="r_a55907985af83a80be7c5801d62cc630d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a55907985af83a80be7c5801d62cc630d">nFunctions</a> () const</td></tr>
<tr class="memdesc:a55907985af83a80be7c5801d62cc630d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of functions attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a55907985af83a80be7c5801d62cc630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b81c055800f2148554197443c77902" id="r_aa2b81c055800f2148554197443c77902"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa2b81c055800f2148554197443c77902">functions</a> () const</td></tr>
<tr class="memdesc:aa2b81c055800f2148554197443c77902"><td class="mdescLeft">&#160;</td><td class="mdescRight">All functions attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:aa2b81c055800f2148554197443c77902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dab5f68f1197c80faf89e4212607bd9" id="r_a2dab5f68f1197c80faf89e4212607bd9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2dab5f68f1197c80faf89e4212607bd9">functionsOverlapping</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:a2dab5f68f1197c80faf89e4212607bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns functions that overlap with specified address interval.  <br /></td></tr>
<tr class="separator:a2dab5f68f1197c80faf89e4212607bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57d0ee49e8e7f77323ed92a015898bc" id="r_aa57d0ee49e8e7f77323ed92a015898bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa57d0ee49e8e7f77323ed92a015898bc">functionsSpanning</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:aa57d0ee49e8e7f77323ed92a015898bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns functions that span an entire address interval.  <br /></td></tr>
<tr class="separator:aa57d0ee49e8e7f77323ed92a015898bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc2a66aa2508f9e07e2e0f01187891" id="r_aebdc2a66aa2508f9e07e2e0f01187891"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aebdc2a66aa2508f9e07e2e0f01187891">functionsContainedIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;) const</td></tr>
<tr class="memdesc:aebdc2a66aa2508f9e07e2e0f01187891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns functions that are fully contained in an address interval.  <br /></td></tr>
<tr class="separator:aebdc2a66aa2508f9e07e2e0f01187891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8543619947e920edfd729d53ca6592" id="r_abb8543619947e920edfd729d53ca6592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abb8543619947e920edfd729d53ca6592">attachOrMergeFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:abb8543619947e920edfd729d53ca6592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches or merges a function into the CFG/AUM.  <br /></td></tr>
<tr class="separator:abb8543619947e920edfd729d53ca6592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962aba0191ca67b4fc246eb06339c0f4" id="r_a962aba0191ca67b4fc246eb06339c0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a962aba0191ca67b4fc246eb06339c0f4">detachFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a962aba0191ca67b4fc246eb06339c0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a function from the CFG/AUM.  <br /></td></tr>
<tr class="separator:a962aba0191ca67b4fc246eb06339c0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a414dd846ee9d789a05ad4014025047" id="r_a0a414dd846ee9d789a05ad4014025047"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Function::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0a414dd846ee9d789a05ad4014025047">entryFunctions</a> ()</td></tr>
<tr class="memdesc:a0a414dd846ee9d789a05ad4014025047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry points of the binary.  <br /></td></tr>
<tr class="separator:a0a414dd846ee9d789a05ad4014025047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cd59a5b5991a6e510ea4d7f3236596" id="r_a56cd59a5b5991a6e510ea4d7f3236596"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a56cd59a5b5991a6e510ea4d7f3236596">discoverCalledFunctions</a> () const</td></tr>
<tr class="memdesc:a56cd59a5b5991a6e510ea4d7f3236596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the CFG to find function calls.  <br /></td></tr>
<tr class="separator:a56cd59a5b5991a6e510ea4d7f3236596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf025b08b6a10ca3087da0429cc5b60" id="r_aedf025b08b6a10ca3087da0429cc5b60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aedf025b08b6a10ca3087da0429cc5b60">discoverFunctionEntryVertices</a> () const</td></tr>
<tr class="memdesc:aedf025b08b6a10ca3087da0429cc5b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the CFG to find function entry basic blocks.  <br /></td></tr>
<tr class="separator:aedf025b08b6a10ca3087da0429cc5b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647eb2c1fc6c7e941013cb1c2794fcb" id="r_a3647eb2c1fc6c7e941013cb1c2794fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_1_1Thunk.html">Thunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3647eb2c1fc6c7e941013cb1c2794fcb">functionIsThunk</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a3647eb2c1fc6c7e941013cb1c2794fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if function is a thunk.  <br /></td></tr>
<tr class="separator:a3647eb2c1fc6c7e941013cb1c2794fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e06c1c1186c02c725d79a9339dd33" id="r_a689e06c1c1186c02c725d79a9339dd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a689e06c1c1186c02c725d79a9339dd33">discoverFunctionBasicBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:a689e06c1c1186c02c725d79a9339dd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds basic blocks to a function.  <br /></td></tr>
<tr class="separator:a689e06c1c1186c02c725d79a9339dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f45d84e9d12b46da9ce9699011815" id="r_a816f45d84e9d12b46da9ce9699011815"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a816f45d84e9d12b46da9ce9699011815">functionGhostSuccessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a816f45d84e9d12b46da9ce9699011815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ghost successors for a single function.  <br /></td></tr>
<tr class="separator:a816f45d84e9d12b46da9ce9699011815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f5e1494f3244b5fee241e644a9a9c" id="r_a231f5e1494f3244b5fee241e644a9a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">FunctionCallGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a231f5e1494f3244b5fee241e644a9a9c">functionCallGraph</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html#adae60b3da31d72d5a31c6314dbbebcc3">AllowParallelEdges::Type</a> allowParallelEdges) const</td></tr>
<tr class="memdesc:a231f5e1494f3244b5fee241e644a9a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function call graph.  <br /></td></tr>
<tr class="separator:a231f5e1494f3244b5fee241e644a9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17491f0dd52a1367f0c907dbd49fcb89" id="r_a17491f0dd52a1367f0c907dbd49fcb89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a17491f0dd52a1367f0c907dbd49fcb89">functionStackDelta</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:a17491f0dd52a1367f0c907dbd49fcb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack delta analysis for one function.  <br /></td></tr>
<tr class="separator:a17491f0dd52a1367f0c907dbd49fcb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b47d70e1a381ce795dae84ed4065e92" id="r_a4b47d70e1a381ce795dae84ed4065e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4b47d70e1a381ce795dae84ed4065e92">allFunctionStackDelta</a> () const</td></tr>
<tr class="memdesc:a4b47d70e1a381ce795dae84ed4065e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute stack delta analysis for all functions.  <br /></td></tr>
<tr class="separator:a4b47d70e1a381ce795dae84ed4065e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1dbde2b06651a514eefcd25bd1b745" id="r_a1f1dbde2b06651a514eefcd25bd1b745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1f1dbde2b06651a514eefcd25bd1b745">functionOptionalMayReturn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:a1f1dbde2b06651a514eefcd25bd1b745"><td class="mdescLeft">&#160;</td><td class="mdescRight">May-return analysis for one function.  <br /></td></tr>
<tr class="separator:a1f1dbde2b06651a514eefcd25bd1b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e97742dd17eb650e1b55da7ef7f7fc" id="r_ab7e97742dd17eb650e1b55da7ef7f7fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7e97742dd17eb650e1b55da7ef7f7fc">allFunctionMayReturn</a> () const</td></tr>
<tr class="memdesc:ab7e97742dd17eb650e1b55da7ef7f7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute may-return analysis for all functions.  <br /></td></tr>
<tr class="separator:ab7e97742dd17eb650e1b55da7ef7f7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32123f065b02de2cb732a73e3ca9ab01" id="r_a32123f065b02de2cb732a73e3ca9ab01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a32123f065b02de2cb732a73e3ca9ab01">functionIsNoop</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a32123f065b02de2cb732a73e3ca9ab01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> no-op analysis.  <br /></td></tr>
<tr class="separator:a32123f065b02de2cb732a73e3ca9ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03eecbe130badb1546bb6d74fc39615" id="r_ad03eecbe130badb1546bb6d74fc39615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad03eecbe130badb1546bb6d74fc39615">allFunctionIsNoop</a> () const</td></tr>
<tr class="memdesc:ad03eecbe130badb1546bb6d74fc39615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze all functions for whether they are effectivly no-ops.  <br /></td></tr>
<tr class="separator:ad03eecbe130badb1546bb6d74fc39615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec59f22b4b45e59c2e6e7ec7817bf6" id="r_accec59f22b4b45e59c2e6e7ec7817bf6"><td class="memItemLeft" align="right" valign="top">std::set&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#accec59f22b4b45e59c2e6e7ec7817bf6">functionDataFlowConstants</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:accec59f22b4b45e59c2e6e7ec7817bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find constants in function using data-flow.  <br /></td></tr>
<tr class="separator:accec59f22b4b45e59c2e6e7ec7817bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9481327df1a175c9d33a3b8df42bac" id="r_a2f9481327df1a175c9d33a3b8df42bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2f9481327df1a175c9d33a3b8df42bac">matchFunctionPadding</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a2f9481327df1a175c9d33a3b8df42bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds function padding.  <br /></td></tr>
<tr class="separator:a2f9481327df1a175c9d33a3b8df42bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6efb6fe6923b7510b536b13cc0e6fe" id="r_a7d6efb6fe6923b7510b536b13cc0e6fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7d6efb6fe6923b7510b536b13cc0e6fe">dumpCfg</a> (std::ostream &amp;, const std::string &amp;prefix=&quot;&quot;, bool showBlocks=true, bool computeProperties=true) const</td></tr>
<tr class="memdesc:a7d6efb6fe6923b7510b536b13cc0e6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the control flow graph.  <br /></td></tr>
<tr class="separator:a7d6efb6fe6923b7510b536b13cc0e6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3edd3feb7131dbc069613a77d41c7c" id="r_a6d3edd3feb7131dbc069613a77d41c7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6d3edd3feb7131dbc069613a77d41c7c">cfgGraphViz</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;restrict=<a class="el" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b">AddressInterval::whole</a>(), bool showNeighbors=true) const</td></tr>
<tr class="memdesc:a6d3edd3feb7131dbc069613a77d41c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output CFG as <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a>.  <br /></td></tr>
<tr class="separator:a6d3edd3feb7131dbc069613a77d41c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d818d0af7af35848af8ed7d0d4e84" id="r_a764d818d0af7af35848af8ed7d0d4e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a764d818d0af7af35848af8ed7d0d4e84">expandIndeterminateCalls</a> ()</td></tr>
<tr class="memdesc:a764d818d0af7af35848af8ed7d0d4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands indeterminate function calls.  <br /></td></tr>
<tr class="separator:a764d818d0af7af35848af8ed7d0d4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae7ca9f068e4f9960e01567aba87c77" id="r_afae7ca9f068e4f9960e01567aba87c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afae7ca9f068e4f9960e01567aba87c77">updateProgress</a> (const std::string &amp;phase, double completion) const</td></tr>
<tr class="memdesc:afae7ca9f068e4f9960e01567aba87c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update partitioner with a new progress report.  <br /></td></tr>
<tr class="separator:afae7ca9f068e4f9960e01567aba87c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac43c982fd2de343c642d88f71a41fd" id="r_a9ac43c982fd2de343c642d88f71a41fd"><td class="memItemLeft" align="right" valign="top"><a id="a9ac43c982fd2de343c642d88f71a41fd" name="a9ac43c982fd2de343c642d88f71a41fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>showStatistics</b> () const</td></tr>
<tr class="memdesc:a9ac43c982fd2de343c642d88f71a41fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some partitioner performance statistics. <br /></td></tr>
<tr class="separator:a9ac43c982fd2de343c642d88f71a41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7109f0390653b09c68f076d9ad2e2c03" id="r_a7109f0390653b09c68f076d9ad2e2c03"><td class="memItemLeft" align="right" valign="top"><a id="a7109f0390653b09c68f076d9ad2e2c03" name="a7109f0390653b09c68f076d9ad2e2c03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkConsistency</b> () const</td></tr>
<tr class="separator:a7109f0390653b09c68f076d9ad2e2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46384adab5b0698bf00f5335bf8ed911" id="r_a46384adab5b0698bf00f5335bf8ed911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a46384adab5b0698bf00f5335bf8ed911">elfGot</a> (<a class="el" href="classSgAsmElfFileHeader.html">SgAsmElfFileHeader</a> *)</td></tr>
<tr class="memdesc:a46384adab5b0698bf00f5335bf8ed911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the ELF global offset table and save its address.  <br /></td></tr>
<tr class="separator:a46384adab5b0698bf00f5335bf8ed911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97095b7b65bee629e784cbab945d96f5" id="r_a97095b7b65bee629e784cbab945d96f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a97095b7b65bee629e784cbab945d96f5">elfGotVa</a> () const</td></tr>
<tr class="memdesc:a97095b7b65bee629e784cbab945d96f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously cached ELF GOT address.  <br /></td></tr>
<tr class="separator:a97095b7b65bee629e784cbab945d96f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c8051284aaa4144b0126713a7e0c0f" id="r_ab8c8051284aaa4144b0126713a7e0c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab8c8051284aaa4144b0126713a7e0c0f">smtSolver</a> () const</td></tr>
<tr class="memdesc:ab8c8051284aaa4144b0126713a7e0c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMT solver.  <br /></td></tr>
<tr class="separator:ab8c8051284aaa4144b0126713a7e0c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b603e348398a65bcfe4664742b7c802" id="r_a8b603e348398a65bcfe4664742b7c802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a8b603e348398a65bcfe4664742b7c802">newDispatcher</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a8b603e348398a65bcfe4664742b7c802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a new instruction semantics dispatcher.  <br /></td></tr>
<tr class="separator:a8b603e348398a65bcfe4664742b7c802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3f432d756dd2d1d9f1f7fca6f92475aa" id="r_a3f432d756dd2d1d9f1f7fca6f92475aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3f432d756dd2d1d9f1f7fca6f92475aa">configuration</a> ()</td></tr>
<tr class="memdesc:a3f432d756dd2d1d9f1f7fca6f92475aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information.  <br /></td></tr>
<tr class="separator:a3f432d756dd2d1d9f1f7fca6f92475aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c61ab26492260edea0f3fde603db40" id="r_a04c61ab26492260edea0f3fde603db40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a04c61ab26492260edea0f3fde603db40">configuration</a> () const</td></tr>
<tr class="memdesc:a04c61ab26492260edea0f3fde603db40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information.  <br /></td></tr>
<tr class="separator:a04c61ab26492260edea0f3fde603db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adf4a3256a387046d532d3cb46c1f874f" id="r_adf4a3256a387046d532d3cb46c1f874f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html">InstructionProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adf4a3256a387046d532d3cb46c1f874f">instructionProvider</a> ()</td></tr>
<tr class="memdesc:adf4a3256a387046d532d3cb46c1f874f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction provider.  <br /></td></tr>
<tr class="separator:adf4a3256a387046d532d3cb46c1f874f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43bf94a24b84e1db41cb1962c28a138" id="r_af43bf94a24b84e1db41cb1962c28a138"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html">InstructionProvider</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af43bf94a24b84e1db41cb1962c28a138">instructionProvider</a> () const</td></tr>
<tr class="memdesc:af43bf94a24b84e1db41cb1962c28a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction provider.  <br /></td></tr>
<tr class="separator:af43bf94a24b84e1db41cb1962c28a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a91104e910985b258a2fc57542401de1e" id="r_a91104e910985b258a2fc57542401de1e"><td class="memItemLeft" align="right" valign="top"><a id="a91104e910985b258a2fc57542401de1e" name="a91104e910985b258a2fc57542401de1e"></a>
<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>interpretation</b> () const</td></tr>
<tr class="memdesc:a91104e910985b258a2fc57542401de1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Interpretation corresponding to the memory map. <br /></td></tr>
<tr class="separator:a91104e910985b258a2fc57542401de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17738fe3d4803ef334331ce2bc8a5d10" id="r_a17738fe3d4803ef334331ce2bc8a5d10"><td class="memItemLeft" align="right" valign="top"><a id="a17738fe3d4803ef334331ce2bc8a5d10" name="a17738fe3d4803ef334331ce2bc8a5d10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>interpretation</b> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *)</td></tr>
<tr class="memdesc:a17738fe3d4803ef334331ce2bc8a5d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Interpretation corresponding to the memory map. <br /></td></tr>
<tr class="separator:a17738fe3d4803ef334331ce2bc8a5d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a19eb21d247558791a63fb7617ab633cf" id="r_a19eb21d247558791a63fb7617ab633cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> () const</td></tr>
<tr class="memdesc:a19eb21d247558791a63fb7617ab633cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unparser.  <br /></td></tr>
<tr class="separator:a19eb21d247558791a63fb7617ab633cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa938d509ecf2c0f32bd187768d9c3774" id="r_aa938d509ecf2c0f32bd187768d9c3774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa938d509ecf2c0f32bd187768d9c3774">unparser</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;)</td></tr>
<tr class="memdesc:aa938d509ecf2c0f32bd187768d9c3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unparser.  <br /></td></tr>
<tr class="separator:aa938d509ecf2c0f32bd187768d9c3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab89a7c3deacacf3b30349cd4949077d2" id="r_ab89a7c3deacacf3b30349cd4949077d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a> () const</td></tr>
<tr class="memdesc:ab89a7c3deacacf3b30349cd4949077d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unparser.  <br /></td></tr>
<tr class="separator:ab89a7c3deacacf3b30349cd4949077d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1b10a79a982dca6ff3da9e7e7586e4" id="r_a9a1b10a79a982dca6ff3da9e7e7586e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9a1b10a79a982dca6ff3da9e7e7586e4">insnUnparser</a> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;)</td></tr>
<tr class="memdesc:a9a1b10a79a982dca6ff3da9e7e7586e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unparser.  <br /></td></tr>
<tr class="separator:a9a1b10a79a982dca6ff3da9e7e7586e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afad5706bae39185f92727e64d1bfe7b2" id="r_afad5706bae39185f92727e64d1bfe7b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afad5706bae39185f92727e64d1bfe7b2">unparse</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:afad5706bae39185f92727e64d1bfe7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:afad5706bae39185f92727e64d1bfe7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed5a6b672c9f77ad811b1f8808845a4" id="r_a5ed5a6b672c9f77ad811b1f8808845a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5ed5a6b672c9f77ad811b1f8808845a4">unparse</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a5ed5a6b672c9f77ad811b1f8808845a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:a5ed5a6b672c9f77ad811b1f8808845a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dda04b77417e2f63f28c9c571e70d8e" id="r_a4dda04b77417e2f63f28c9c571e70d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4dda04b77417e2f63f28c9c571e70d8e">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a4dda04b77417e2f63f28c9c571e70d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:a4dda04b77417e2f63f28c9c571e70d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d05b429b8839fa522d25f6f2efb52f3" id="r_a2d05b429b8839fa522d25f6f2efb52f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2d05b429b8839fa522d25f6f2efb52f3">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2d05b429b8839fa522d25f6f2efb52f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:a2d05b429b8839fa522d25f6f2efb52f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6151596a1e14f8d4af4216ea6ac602dd" id="r_a6151596a1e14f8d4af4216ea6ac602dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6151596a1e14f8d4af4216ea6ac602dd">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a6151596a1e14f8d4af4216ea6ac602dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:a6151596a1e14f8d4af4216ea6ac602dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa4b903df664099e041c8e1b5c75d98" id="r_a7aa4b903df664099e041c8e1b5c75d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7aa4b903df664099e041c8e1b5c75d98">unparse</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a7aa4b903df664099e041c8e1b5c75d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse some entity.  <br /></td></tr>
<tr class="separator:a7aa4b903df664099e041c8e1b5c75d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a11e1798ead9f1bda8a0c3244a3eeabb7" id="r_a11e1798ead9f1bda8a0c3244a3eeabb7"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a11e1798ead9f1bda8a0c3244a3eeabb7">undiscoveredVertex</a> ()</td></tr>
<tr class="memdesc:a11e1798ead9f1bda8a0c3244a3eeabb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "undiscovered" vertex.  <br /></td></tr>
<tr class="separator:a11e1798ead9f1bda8a0c3244a3eeabb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97038517c1f41d1385db8655c85336e" id="r_af97038517c1f41d1385db8655c85336e"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af97038517c1f41d1385db8655c85336e">undiscoveredVertex</a> () const</td></tr>
<tr class="memdesc:af97038517c1f41d1385db8655c85336e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "undiscovered" vertex.  <br /></td></tr>
<tr class="separator:af97038517c1f41d1385db8655c85336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6175331304232fe65d37aa32353330a2" id="r_a6175331304232fe65d37aa32353330a2"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6175331304232fe65d37aa32353330a2">indeterminateVertex</a> ()</td></tr>
<tr class="memdesc:a6175331304232fe65d37aa32353330a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "indeterminate" vertex.  <br /></td></tr>
<tr class="separator:a6175331304232fe65d37aa32353330a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162169db17eb5c41b19a92e4e771cd05" id="r_a162169db17eb5c41b19a92e4e771cd05"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a162169db17eb5c41b19a92e4e771cd05">indeterminateVertex</a> () const</td></tr>
<tr class="memdesc:a162169db17eb5c41b19a92e4e771cd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "indeterminate" vertex.  <br /></td></tr>
<tr class="separator:a162169db17eb5c41b19a92e4e771cd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a05e4e29f3a85c8b586777f16dfe3d401" id="r_a05e4e29f3a85c8b586777f16dfe3d401"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a05e4e29f3a85c8b586777f16dfe3d401">nonexistingVertex</a> ()</td></tr>
<tr class="memdesc:a05e4e29f3a85c8b586777f16dfe3d401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "non-existing" vertex.  <br /></td></tr>
<tr class="separator:a05e4e29f3a85c8b586777f16dfe3d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079d7ce5fde92dd03dcf45bbd42044ff" id="r_a079d7ce5fde92dd03dcf45bbd42044ff"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a079d7ce5fde92dd03dcf45bbd42044ff">nonexistingVertex</a> () const</td></tr>
<tr class="memdesc:a079d7ce5fde92dd03dcf45bbd42044ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the special "non-existing" vertex.  <br /></td></tr>
<tr class="separator:a079d7ce5fde92dd03dcf45bbd42044ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abae01ec1ba802eb0a224dbf7d60a3b41" id="r_abae01ec1ba802eb0a224dbf7d60a3b41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41">isEdgeIntraProcedural</a> (ControlFlowGraph::ConstEdgeIterator edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:abae01ec1ba802eb0a224dbf7d60a3b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is intra-procedural.  <br /></td></tr>
<tr class="separator:abae01ec1ba802eb0a224dbf7d60a3b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e8c0dd72cd2d5d43ba68571a8b90d3" id="r_a61e8c0dd72cd2d5d43ba68571a8b90d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a61e8c0dd72cd2d5d43ba68571a8b90d3">isEdgeIntraProcedural</a> (const ControlFlowGraph::Edge &amp;edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a61e8c0dd72cd2d5d43ba68571a8b90d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is intra-procedural.  <br /></td></tr>
<tr class="separator:a61e8c0dd72cd2d5d43ba68571a8b90d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1300386a5c0d0aebb68ab38f382bef" id="r_a5a1300386a5c0d0aebb68ab38f382bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5a1300386a5c0d0aebb68ab38f382bef">isEdgeIntraProcedural</a> (ControlFlowGraph::ConstEdgeIterator edge) const</td></tr>
<tr class="memdesc:a5a1300386a5c0d0aebb68ab38f382bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is intra-procedural.  <br /></td></tr>
<tr class="separator:a5a1300386a5c0d0aebb68ab38f382bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b572cbde5e0b2787dfc90247ba717b4" id="r_a7b572cbde5e0b2787dfc90247ba717b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7b572cbde5e0b2787dfc90247ba717b4">isEdgeIntraProcedural</a> (const ControlFlowGraph::Edge &amp;edge) const</td></tr>
<tr class="memdesc:a7b572cbde5e0b2787dfc90247ba717b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is intra-procedural.  <br /></td></tr>
<tr class="separator:a7b572cbde5e0b2787dfc90247ba717b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3d25a8610e23546320ba56f81f982b17" id="r_a3d25a8610e23546320ba56f81f982b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3d25a8610e23546320ba56f81f982b17">isEdgeInterProcedural</a> (ControlFlowGraph::ConstEdgeIterator edge) const</td></tr>
<tr class="memdesc:a3d25a8610e23546320ba56f81f982b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:a3d25a8610e23546320ba56f81f982b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac13d26ec7956c9b3cb229395deee2f" id="r_aeac13d26ec7956c9b3cb229395deee2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aeac13d26ec7956c9b3cb229395deee2f">isEdgeInterProcedural</a> (ControlFlowGraph::ConstEdgeIterator edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;sourceFunction) const</td></tr>
<tr class="memdesc:aeac13d26ec7956c9b3cb229395deee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:aeac13d26ec7956c9b3cb229395deee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47e4aeb1153be044e8bf50426d6d67d" id="r_ad47e4aeb1153be044e8bf50426d6d67d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad47e4aeb1153be044e8bf50426d6d67d">isEdgeInterProcedural</a> (ControlFlowGraph::ConstEdgeIterator edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;sourceFunction, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;targetFunction) const</td></tr>
<tr class="memdesc:ad47e4aeb1153be044e8bf50426d6d67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:ad47e4aeb1153be044e8bf50426d6d67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d3f24fdeae174928cc56db6e2f0ef" id="r_af07d3f24fdeae174928cc56db6e2f0ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af07d3f24fdeae174928cc56db6e2f0ef">isEdgeInterProcedural</a> (const ControlFlowGraph::Edge &amp;edge) const</td></tr>
<tr class="memdesc:af07d3f24fdeae174928cc56db6e2f0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:af07d3f24fdeae174928cc56db6e2f0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8446029e0f5416c69973ffeb9d729" id="r_a54c8446029e0f5416c69973ffeb9d729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a54c8446029e0f5416c69973ffeb9d729">isEdgeInterProcedural</a> (const ControlFlowGraph::Edge &amp;edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;sourceFunction) const</td></tr>
<tr class="memdesc:a54c8446029e0f5416c69973ffeb9d729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:a54c8446029e0f5416c69973ffeb9d729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60391d6f452eba60623068b09c32e8d9" id="r_a60391d6f452eba60623068b09c32e8d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a60391d6f452eba60623068b09c32e8d9">isEdgeInterProcedural</a> (const ControlFlowGraph::Edge &amp;edge, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;sourceFunction, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;targetFunction) const</td></tr>
<tr class="memdesc:a60391d6f452eba60623068b09c32e8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is inter-procedural.  <br /></td></tr>
<tr class="separator:a60391d6f452eba60623068b09c32e8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac8221a7204eaf78c449216505ad6da6f" id="r_ac8221a7204eaf78c449216505ad6da6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac8221a7204eaf78c449216505ad6da6f">instructionExists</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:ac8221a7204eaf78c449216505ad6da6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an instruction is attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:ac8221a7204eaf78c449216505ad6da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc57d10132f8aa9384130bee455760a" id="r_affc57d10132f8aa9384130bee455760a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#affc57d10132f8aa9384130bee455760a">instructionExists</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn) const</td></tr>
<tr class="memdesc:affc57d10132f8aa9384130bee455760a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether an instruction is attached to the CFG/AUM.  <br /></td></tr>
<tr class="separator:affc57d10132f8aa9384130bee455760a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a45c38dbee180601ba20d8bea0743bbd2" id="r_a45c38dbee180601ba20d8bea0743bbd2"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a45c38dbee180601ba20d8bea0743bbd2">findPlaceholder</a> (rose_addr_t startVa)</td></tr>
<tr class="memdesc:a45c38dbee180601ba20d8bea0743bbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the CFG vertex for a basic block placeholder.  <br /></td></tr>
<tr class="separator:a45c38dbee180601ba20d8bea0743bbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62394ba2bf95f6d5cc1e3daa218fc548" id="r_a62394ba2bf95f6d5cc1e3daa218fc548"><td class="memItemLeft" align="right" valign="top">ControlFlowGraph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a62394ba2bf95f6d5cc1e3daa218fc548">findPlaceholder</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a62394ba2bf95f6d5cc1e3daa218fc548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the CFG vertex for a basic block placeholder.  <br /></td></tr>
<tr class="separator:a62394ba2bf95f6d5cc1e3daa218fc548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3859d1f9d482925807e5184f2edc927" id="r_aa3859d1f9d482925807e5184f2edc927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa3859d1f9d482925807e5184f2edc927">erasePlaceholder</a> (const ControlFlowGraph::ConstVertexIterator &amp;placeholder)</td></tr>
<tr class="memdesc:aa3859d1f9d482925807e5184f2edc927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block placeholder from the CFG/AUM.  <br /></td></tr>
<tr class="separator:aa3859d1f9d482925807e5184f2edc927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c089a88177962e1cbf61ae6cbaae8" id="r_ad20c089a88177962e1cbf61ae6cbaae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad20c089a88177962e1cbf61ae6cbaae8">erasePlaceholder</a> (rose_addr_t startVa)</td></tr>
<tr class="memdesc:ad20c089a88177962e1cbf61ae6cbaae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block placeholder from the CFG/AUM.  <br /></td></tr>
<tr class="separator:ad20c089a88177962e1cbf61ae6cbaae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a83d233223c0b28d62f954a6e05f7d1c6" id="r_a83d233223c0b28d62f954a6e05f7d1c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a83d233223c0b28d62f954a6e05f7d1c6">basicBlockSemanticsAutoDrop</a> () const</td></tr>
<tr class="memdesc:a83d233223c0b28d62f954a6e05f7d1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Automatically drop semantics for attached basic blocks.  <br /></td></tr>
<tr class="separator:a83d233223c0b28d62f954a6e05f7d1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d19f795095e94ac99684eaa9fced25" id="r_ae6d19f795095e94ac99684eaa9fced25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae6d19f795095e94ac99684eaa9fced25">basicBlockSemanticsAutoDrop</a> (bool)</td></tr>
<tr class="memdesc:ae6d19f795095e94ac99684eaa9fced25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Automatically drop semantics for attached basic blocks.  <br /></td></tr>
<tr class="separator:ae6d19f795095e94ac99684eaa9fced25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a66a97e2e317e4c4c9886f7603c0297a0" id="r_a66a97e2e317e4c4c9886f7603c0297a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a66a97e2e317e4c4c9886f7603c0297a0">basicBlockExists</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a66a97e2e317e4c4c9886f7603c0297a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a discovered basic block exists in the CFG/AUM.  <br /></td></tr>
<tr class="separator:a66a97e2e317e4c4c9886f7603c0297a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b21967cc3614b7ebb6fae45eb89910a" id="r_a5b21967cc3614b7ebb6fae45eb89910a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5b21967cc3614b7ebb6fae45eb89910a">basicBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a5b21967cc3614b7ebb6fae45eb89910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a discovered basic block exists in the CFG/AUM.  <br /></td></tr>
<tr class="separator:a5b21967cc3614b7ebb6fae45eb89910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb63857e3fe0a8f26d5455153180ad24" id="r_abb63857e3fe0a8f26d5455153180ad24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abb63857e3fe0a8f26d5455153180ad24">detachBasicBlock</a> (rose_addr_t startVa)</td></tr>
<tr class="memdesc:abb63857e3fe0a8f26d5455153180ad24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a basic block from the CFG/AUM.  <br /></td></tr>
<tr class="separator:abb63857e3fe0a8f26d5455153180ad24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892fc63e9b892c3d34ffa20e93af847c" id="r_a892fc63e9b892c3d34ffa20e93af847c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a892fc63e9b892c3d34ffa20e93af847c">detachBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;basicBlock)</td></tr>
<tr class="memdesc:a892fc63e9b892c3d34ffa20e93af847c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a basic block from the CFG/AUM.  <br /></td></tr>
<tr class="separator:a892fc63e9b892c3d34ffa20e93af847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12c8fd94109e339dd618dd82204d98a" id="r_ac12c8fd94109e339dd618dd82204d98a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac12c8fd94109e339dd618dd82204d98a">detachBasicBlock</a> (const ControlFlowGraph::ConstVertexIterator &amp;placeholder)</td></tr>
<tr class="memdesc:ac12c8fd94109e339dd618dd82204d98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a basic block from the CFG/AUM.  <br /></td></tr>
<tr class="separator:ac12c8fd94109e339dd618dd82204d98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9083c0451c518e1f5d3fffab124fd31b" id="r_a9083c0451c518e1f5d3fffab124fd31b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9083c0451c518e1f5d3fffab124fd31b">attachBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a9083c0451c518e1f5d3fffab124fd31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a basic block to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a9083c0451c518e1f5d3fffab124fd31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f32461b9b251756b60703ceeb8ba7d" id="r_a64f32461b9b251756b60703ceeb8ba7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a64f32461b9b251756b60703ceeb8ba7d">attachBasicBlock</a> (const ControlFlowGraph::ConstVertexIterator &amp;placeholder, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a64f32461b9b251756b60703ceeb8ba7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a basic block to the CFG/AUM.  <br /></td></tr>
<tr class="separator:a64f32461b9b251756b60703ceeb8ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a41100afc7155355c5dea909016f156c5" id="r_a41100afc7155355c5dea909016f156c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a41100afc7155355c5dea909016f156c5">discoverBasicBlock</a> (rose_addr_t startVa) const</td></tr>
<tr class="memdesc:a41100afc7155355c5dea909016f156c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover instructions for a detached basic block.  <br /></td></tr>
<tr class="separator:a41100afc7155355c5dea909016f156c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23ec10529a0bfd96613355677833833" id="r_ab23ec10529a0bfd96613355677833833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab23ec10529a0bfd96613355677833833">discoverBasicBlock</a> (const ControlFlowGraph::ConstVertexIterator &amp;placeholder) const</td></tr>
<tr class="memdesc:ab23ec10529a0bfd96613355677833833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover instructions for a detached basic block.  <br /></td></tr>
<tr class="separator:ab23ec10529a0bfd96613355677833833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afef2b31b31a4a0b0d96d5b04ea6c17e9" id="r_afef2b31b31a4a0b0d96d5b04ea6c17e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afef2b31b31a4a0b0d96d5b04ea6c17e9">basicBlockStackDeltaIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:afef2b31b31a4a0b0d96d5b04ea6c17e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stack delta expression.  <br /></td></tr>
<tr class="separator:afef2b31b31a4a0b0d96d5b04ea6c17e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab081575b668b12bfd718f375b249e925" id="r_ab081575b668b12bfd718f375b249e925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab081575b668b12bfd718f375b249e925">basicBlockStackDeltaOut</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:ab081575b668b12bfd718f375b249e925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stack delta expression.  <br /></td></tr>
<tr class="separator:ab081575b668b12bfd718f375b249e925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49a009b3d03288f93843a1ddd12d05a4" id="r_a49a009b3d03288f93843a1ddd12d05a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a49a009b3d03288f93843a1ddd12d05a4">forgetStackDeltas</a> () const</td></tr>
<tr class="memdesc:a49a009b3d03288f93843a1ddd12d05a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all cached stack deltas.  <br /></td></tr>
<tr class="separator:a49a009b3d03288f93843a1ddd12d05a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44b0eef20dd3869c2af43743a029f8" id="r_a2c44b0eef20dd3869c2af43743a029f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2c44b0eef20dd3869c2af43743a029f8">forgetStackDeltas</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2c44b0eef20dd3869c2af43743a029f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all cached stack deltas.  <br /></td></tr>
<tr class="separator:a2c44b0eef20dd3869c2af43743a029f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a245e7d63cb2ae9ae090c6dcbdaea1d67" id="r_a245e7d63cb2ae9ae090c6dcbdaea1d67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a245e7d63cb2ae9ae090c6dcbdaea1d67">stackDeltaInterproceduralLimit</a> () const</td></tr>
<tr class="memdesc:a245e7d63cb2ae9ae090c6dcbdaea1d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: max depth for inter-procedural stack delta analysis.  <br /></td></tr>
<tr class="separator:a245e7d63cb2ae9ae090c6dcbdaea1d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf7df85e46a95cd47867358136c74d" id="r_a24bf7df85e46a95cd47867358136c74d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a24bf7df85e46a95cd47867358136c74d">stackDeltaInterproceduralLimit</a> (size_t)</td></tr>
<tr class="memdesc:a24bf7df85e46a95cd47867358136c74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: max depth for inter-procedural stack delta analysis.  <br /></td></tr>
<tr class="separator:a24bf7df85e46a95cd47867358136c74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2171b0c875ca1e43a5c8b88565657f40" id="r_a2171b0c875ca1e43a5c8b88565657f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2171b0c875ca1e43a5c8b88565657f40">basicBlockOptionalMayReturn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2171b0c875ca1e43a5c8b88565657f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if part of the CFG can pop the top stack frame.  <br /></td></tr>
<tr class="separator:a2171b0c875ca1e43a5c8b88565657f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f0217d80e014f136ee7b2587db875d" id="r_af6f0217d80e014f136ee7b2587db875d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af6f0217d80e014f136ee7b2587db875d">basicBlockOptionalMayReturn</a> (const ControlFlowGraph::ConstVertexIterator &amp;) const</td></tr>
<tr class="memdesc:af6f0217d80e014f136ee7b2587db875d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if part of the CFG can pop the top stack frame.  <br /></td></tr>
<tr class="separator:af6f0217d80e014f136ee7b2587db875d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a8935bf5419d72e34517aa16fac80d0" id="r_a5a8935bf5419d72e34517aa16fac80d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5a8935bf5419d72e34517aa16fac80d0">functionExists</a> (rose_addr_t entryVa) const</td></tr>
<tr class="memdesc:a5a8935bf5419d72e34517aa16fac80d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a function exists in the CFG/AUM.  <br /></td></tr>
<tr class="separator:a5a8935bf5419d72e34517aa16fac80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd073e9715745ce2f8c89c5451b1f8e" id="r_addd073e9715745ce2f8c89c5451b1f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#addd073e9715745ce2f8c89c5451b1f8e">functionExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;entryBlock) const</td></tr>
<tr class="memdesc:addd073e9715745ce2f8c89c5451b1f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a function exists in the CFG/AUM.  <br /></td></tr>
<tr class="separator:addd073e9715745ce2f8c89c5451b1f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289f2ffdcb17f03b77ed0d869491d85e" id="r_a289f2ffdcb17f03b77ed0d869491d85e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a289f2ffdcb17f03b77ed0d869491d85e">functionExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:a289f2ffdcb17f03b77ed0d869491d85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a function exists in the CFG/AUM.  <br /></td></tr>
<tr class="separator:a289f2ffdcb17f03b77ed0d869491d85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a526858251058ad50fa4d0edf4a1bf58c" id="r_a526858251058ad50fa4d0edf4a1bf58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a526858251058ad50fa4d0edf4a1bf58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:a526858251058ad50fa4d0edf4a1bf58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae517a4a06da32ac0824761eb55b2a246" id="r_ae517a4a06da32ac0824761eb55b2a246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae517a4a06da32ac0824761eb55b2a246">functionExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;retval) const</td></tr>
<tr class="memdesc:ae517a4a06da32ac0824761eb55b2a246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:ae517a4a06da32ac0824761eb55b2a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a5ca131bfb0893bcb3d1852c239606" id="r_af2a5ca131bfb0893bcb3d1852c239606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:af2a5ca131bfb0893bcb3d1852c239606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:af2a5ca131bfb0893bcb3d1852c239606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cdfa5cf661f8ce005df36036e55040" id="r_ac3cdfa5cf661f8ce005df36036e55040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac3cdfa5cf661f8ce005df36036e55040">functionBasicBlockExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;retval) const</td></tr>
<tr class="memdesc:ac3cdfa5cf661f8ce005df36036e55040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:ac3cdfa5cf661f8ce005df36036e55040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee59ca03c6f7d7fb7864cdc19d16046" id="r_adee59ca03c6f7d7fb7864cdc19d16046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:adee59ca03c6f7d7fb7864cdc19d16046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:adee59ca03c6f7d7fb7864cdc19d16046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bc1e8259580c53e17ecc4158c75204" id="r_ad2bc1e8259580c53e17ecc4158c75204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad2bc1e8259580c53e17ecc4158c75204">functionDataBlockExtent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function, <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;retval) const</td></tr>
<tr class="memdesc:ad2bc1e8259580c53e17ecc4158c75204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the addresses used by a function.  <br /></td></tr>
<tr class="separator:ad2bc1e8259580c53e17ecc4158c75204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1ac2f6619db585e2e05730cc5e6d713" id="r_ae1ac2f6619db585e2e05730cc5e6d713"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae1ac2f6619db585e2e05730cc5e6d713">attachFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:ae1ac2f6619db585e2e05730cc5e6d713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a function to the CFG/AUM.  <br /></td></tr>
<tr class="separator:ae1ac2f6619db585e2e05730cc5e6d713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0c86f0d5b375536d148ad5106bece4" id="r_abc0c86f0d5b375536d148ad5106bece4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abc0c86f0d5b375536d148ad5106bece4">attachFunctions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Functions</a> &amp;)</td></tr>
<tr class="memdesc:abc0c86f0d5b375536d148ad5106bece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a function to the CFG/AUM.  <br /></td></tr>
<tr class="separator:abc0c86f0d5b375536d148ad5106bece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a397727a62ba5ace82d367e41a0e0a8a4" id="r_a397727a62ba5ace82d367e41a0e0a8a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a397727a62ba5ace82d367e41a0e0a8a4">attachFunctionBasicBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Functions</a> &amp;)</td></tr>
<tr class="memdesc:a397727a62ba5ace82d367e41a0e0a8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create placeholders for function basic blocks.  <br /></td></tr>
<tr class="separator:a397727a62ba5ace82d367e41a0e0a8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2737237359168319a290373271d431" id="r_a7c2737237359168319a290373271d431"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7c2737237359168319a290373271d431">attachFunctionBasicBlocks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a7c2737237359168319a290373271d431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create placeholders for function basic blocks.  <br /></td></tr>
<tr class="separator:a7c2737237359168319a290373271d431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abab3fdf3bc1836894594a5a114af185d" id="r_abab3fdf3bc1836894594a5a114af185d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abab3fdf3bc1836894594a5a114af185d">functionsOwningBasicBlock</a> (const ControlFlowGraph::Vertex &amp;, bool doSort=true) const</td></tr>
<tr class="memdesc:abab3fdf3bc1836894594a5a114af185d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions that own the specified basic block.  <br /></td></tr>
<tr class="separator:abab3fdf3bc1836894594a5a114af185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5a5379da039798b532857f23ca89f1" id="r_acd5a5379da039798b532857f23ca89f1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#acd5a5379da039798b532857f23ca89f1">functionsOwningBasicBlock</a> (const ControlFlowGraph::ConstVertexIterator &amp;, bool doSort=true) const</td></tr>
<tr class="memdesc:acd5a5379da039798b532857f23ca89f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions that own the specified basic block.  <br /></td></tr>
<tr class="separator:acd5a5379da039798b532857f23ca89f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0637c5b72913f3f6d37dfd7fa63c162" id="r_ad0637c5b72913f3f6d37dfd7fa63c162"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad0637c5b72913f3f6d37dfd7fa63c162">functionsOwningBasicBlock</a> (rose_addr_t bblockVa, bool doSort=true) const</td></tr>
<tr class="memdesc:ad0637c5b72913f3f6d37dfd7fa63c162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions that own the specified basic block.  <br /></td></tr>
<tr class="separator:ad0637c5b72913f3f6d37dfd7fa63c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fca2190fd794f70a449dbbb79fe8c2" id="r_a73fca2190fd794f70a449dbbb79fe8c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a73fca2190fd794f70a449dbbb79fe8c2">functionsOwningBasicBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;, bool doSort=true) const</td></tr>
<tr class="memdesc:a73fca2190fd794f70a449dbbb79fe8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions that own the specified basic block.  <br /></td></tr>
<tr class="separator:a73fca2190fd794f70a449dbbb79fe8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0230e7382f9932c0d10122d6ff0e4d" id="r_a6b0230e7382f9932c0d10122d6ff0e4d"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6b0230e7382f9932c0d10122d6ff0e4d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6b0230e7382f9932c0d10122d6ff0e4d">functionsOwningBasicBlocks</a> (const Container &amp;bblocks) const</td></tr>
<tr class="memdesc:a6b0230e7382f9932c0d10122d6ff0e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds functions that own the specified basic block.  <br /></td></tr>
<tr class="separator:a6b0230e7382f9932c0d10122d6ff0e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6a579eadf50ba9156291b237c7d914c7" id="r_a6a579eadf50ba9156291b237c7d914c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a6a579eadf50ba9156291b237c7d914c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling convention analysis for one function.  <br /></td></tr>
<tr class="separator:a6a579eadf50ba9156291b237c7d914c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ef68fd80bb647a3c981160aecacc9" id="r_a398ef68fd80bb647a3c981160aecacc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a398ef68fd80bb647a3c981160aecacc9">functionCallingConvention</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a398ef68fd80bb647a3c981160aecacc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling convention analysis for one function.  <br /></td></tr>
<tr class="separator:a398ef68fd80bb647a3c981160aecacc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a169ead089da01d3c1a366158da88f887" id="r_a169ead089da01d3c1a366158da88f887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a> () const</td></tr>
<tr class="memdesc:a169ead089da01d3c1a366158da88f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute calling conventions for all functions.  <br /></td></tr>
<tr class="separator:a169ead089da01d3c1a366158da88f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c0049139df1883b9fc3778a5eac948" id="r_a22c0049139df1883b9fc3778a5eac948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a22c0049139df1883b9fc3778a5eac948">allFunctionCallingConvention</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a22c0049139df1883b9fc3778a5eac948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute calling conventions for all functions.  <br /></td></tr>
<tr class="separator:a22c0049139df1883b9fc3778a5eac948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acc04ac3895d1d4bf71a59917b8f4f58f" id="r_acc04ac3895d1d4bf71a59917b8f4f58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#acc04ac3895d1d4bf71a59917b8f4f58f">functionCallingConventionDefinitions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:acc04ac3895d1d4bf71a59917b8f4f58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of matching calling conventions.  <br /></td></tr>
<tr class="separator:acc04ac3895d1d4bf71a59917b8f4f58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf6636a1aed2b3515506d5a0c5acbc" id="r_afbbf6636a1aed2b3515506d5a0c5acbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afbbf6636a1aed2b3515506d5a0c5acbc">functionCallingConventionDefinitions</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;) const</td></tr>
<tr class="memdesc:afbbf6636a1aed2b3515506d5a0c5acbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of matching calling conventions.  <br /></td></tr>
<tr class="separator:afbbf6636a1aed2b3515506d5a0c5acbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afccbdf2e84d7911b57adcd8e841f7895" id="r_afccbdf2e84d7911b57adcd8e841f7895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afccbdf2e84d7911b57adcd8e841f7895">allFunctionCallingConventionDefinition</a> () const</td></tr>
<tr class="memdesc:afccbdf2e84d7911b57adcd8e841f7895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes calling conventions and saves results.  <br /></td></tr>
<tr class="separator:afccbdf2e84d7911b57adcd8e841f7895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5f1e12c6f6e20b7358eace2dc67810" id="r_aef5f1e12c6f6e20b7358eace2dc67810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aef5f1e12c6f6e20b7358eace2dc67810">allFunctionCallingConventionDefinition</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;) const</td></tr>
<tr class="memdesc:aef5f1e12c6f6e20b7358eace2dc67810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes calling conventions and saves results.  <br /></td></tr>
<tr class="separator:aef5f1e12c6f6e20b7358eace2dc67810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acefeba1c276c383f3bf5db78e58348f8" id="r_acefeba1c276c383f3bf5db78e58348f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#acefeba1c276c383f3bf5db78e58348f8">fixInterFunctionEdges</a> ()</td></tr>
<tr class="memdesc:acefeba1c276c383f3bf5db78e58348f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust inter-function edge types.  <br /></td></tr>
<tr class="separator:acefeba1c276c383f3bf5db78e58348f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d58d3405caf3cfa8452717983f0e92" id="r_a32d58d3405caf3cfa8452717983f0e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a32d58d3405caf3cfa8452717983f0e92">fixInterFunctionEdge</a> (const ControlFlowGraph::ConstEdgeIterator &amp;)</td></tr>
<tr class="memdesc:a32d58d3405caf3cfa8452717983f0e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust inter-function edge types.  <br /></td></tr>
<tr class="separator:a32d58d3405caf3cfa8452717983f0e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1c1455386ac51f740d0203757ade7eda" id="r_a1c1455386ac51f740d0203757ade7eda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1c1455386ac51f740d0203757ade7eda">forgetFunctionIsNoop</a> () const</td></tr>
<tr class="memdesc:a1c1455386ac51f740d0203757ade7eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached function no-op analysis results.  <br /></td></tr>
<tr class="separator:a1c1455386ac51f740d0203757ade7eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6e0fe616601bbdff658e633973303" id="r_ae1f6e0fe616601bbdff658e633973303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae1f6e0fe616601bbdff658e633973303">forgetFunctionIsNoop</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ae1f6e0fe616601bbdff658e633973303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached function no-op analysis results.  <br /></td></tr>
<tr class="separator:ae1f6e0fe616601bbdff658e633973303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d79564686574f7c0340b9aa9a13a7a8" id="r_a1d79564686574f7c0340b9aa9a13a7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">CfgAdjustmentCallbacks</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1d79564686574f7c0340b9aa9a13a7a8">cfgAdjustmentCallbacks</a> ()</td></tr>
<tr class="memdesc:a1d79564686574f7c0340b9aa9a13a7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all callbacks invoked when the CFG is adjusted.  <br /></td></tr>
<tr class="separator:a1d79564686574f7c0340b9aa9a13a7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a961f55e6648faa27f6a9208129eaa" id="r_ae3a961f55e6648faa27f6a9208129eaa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">CfgAdjustmentCallbacks</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae3a961f55e6648faa27f6a9208129eaa">cfgAdjustmentCallbacks</a> () const</td></tr>
<tr class="memdesc:ae3a961f55e6648faa27f6a9208129eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all callbacks invoked when the CFG is adjusted.  <br /></td></tr>
<tr class="separator:ae3a961f55e6648faa27f6a9208129eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adbee3513586f9d653ad1805e44df8072" id="r_adbee3513586f9d653ad1805e44df8072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">BasicBlockCallbacks</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adbee3513586f9d653ad1805e44df8072">basicBlockCallbacks</a> ()</td></tr>
<tr class="memdesc:adbee3513586f9d653ad1805e44df8072"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRose_1_1Callbacks.html" title="User callbacks.">Callbacks</a> for adjusting basic block during discovery.  <br /></td></tr>
<tr class="separator:adbee3513586f9d653ad1805e44df8072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8523df6eabbb1832ba2599f12e1139" id="r_a6d8523df6eabbb1832ba2599f12e1139"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">BasicBlockCallbacks</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6d8523df6eabbb1832ba2599f12e1139">basicBlockCallbacks</a> () const</td></tr>
<tr class="memdesc:a6d8523df6eabbb1832ba2599f12e1139"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRose_1_1Callbacks.html" title="User callbacks.">Callbacks</a> for adjusting basic block during discovery.  <br /></td></tr>
<tr class="separator:a6d8523df6eabbb1832ba2599f12e1139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0f9d0dafd282a74651166a929ef7bd66" id="r_a0f9d0dafd282a74651166a929ef7bd66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">FunctionPrologueMatchers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0f9d0dafd282a74651166a929ef7bd66">functionPrologueMatchers</a> ()</td></tr>
<tr class="memdesc:a0f9d0dafd282a74651166a929ef7bd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list of function prologue matchers.  <br /></td></tr>
<tr class="separator:a0f9d0dafd282a74651166a929ef7bd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686ce25c11ded514e782689b70ab831" id="r_aa686ce25c11ded514e782689b70ab831"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">FunctionPrologueMatchers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa686ce25c11ded514e782689b70ab831">functionPrologueMatchers</a> () const</td></tr>
<tr class="memdesc:aa686ce25c11ded514e782689b70ab831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list of function prologue matchers.  <br /></td></tr>
<tr class="separator:aa686ce25c11ded514e782689b70ab831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a057bdf19279739ae62f719679b9e435e" id="r_a057bdf19279739ae62f719679b9e435e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a057bdf19279739ae62f719679b9e435e">nextFunctionPrologue</a> (rose_addr_t startVa)</td></tr>
<tr class="memdesc:a057bdf19279739ae62f719679b9e435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next function by searching for a function prologue.  <br /></td></tr>
<tr class="separator:a057bdf19279739ae62f719679b9e435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab241b8cc20fee9e119bc87108181c04c" id="r_ab241b8cc20fee9e119bc87108181c04c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab241b8cc20fee9e119bc87108181c04c">nextFunctionPrologue</a> (rose_addr_t startVa, rose_addr_t &amp;lastSearchedVa)</td></tr>
<tr class="memdesc:ab241b8cc20fee9e119bc87108181c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next function by searching for a function prologue.  <br /></td></tr>
<tr class="separator:ab241b8cc20fee9e119bc87108181c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af4f90960bc68617c7b20d22b198aa6e1" id="r_af4f90960bc68617c7b20d22b198aa6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">FunctionPaddingMatchers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af4f90960bc68617c7b20d22b198aa6e1">functionPaddingMatchers</a> ()</td></tr>
<tr class="memdesc:af4f90960bc68617c7b20d22b198aa6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list of function padding matchers.  <br /></td></tr>
<tr class="separator:af4f90960bc68617c7b20d22b198aa6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c4909464402bdeb6f011be79f3bce3" id="r_ad6c4909464402bdeb6f011be79f3bce3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">FunctionPaddingMatchers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad6c4909464402bdeb6f011be79f3bce3">functionPaddingMatchers</a> () const</td></tr>
<tr class="memdesc:ad6c4909464402bdeb6f011be79f3bce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list of function padding matchers.  <br /></td></tr>
<tr class="separator:ad6c4909464402bdeb6f011be79f3bce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9538bdedba72f445d634e12318638927" id="r_a9538bdedba72f445d634e12318638927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9538bdedba72f445d634e12318638927">progress</a> () const</td></tr>
<tr class="memdesc:a9538bdedba72f445d634e12318638927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to report progress.  <br /></td></tr>
<tr class="separator:a9538bdedba72f445d634e12318638927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e459b2365ffad02c1cc039a7d78e69" id="r_aa4e459b2365ffad02c1cc039a7d78e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa4e459b2365ffad02c1cc039a7d78e69">progress</a> (const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:aa4e459b2365ffad02c1cc039a7d78e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to report progress.  <br /></td></tr>
<tr class="separator:aa4e459b2365ffad02c1cc039a7d78e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af80253a4cbd1c1b6ab6002b7fc9b68d0" id="r_af80253a4cbd1c1b6ab6002b7fc9b68d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html">BasePartitionerSettings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af80253a4cbd1c1b6ab6002b7fc9b68d0">settings</a> () const</td></tr>
<tr class="memdesc:af80253a4cbd1c1b6ab6002b7fc9b68d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> settings.  <br /></td></tr>
<tr class="separator:af80253a4cbd1c1b6ab6002b7fc9b68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c70195a626f5bfc1815ee34c0089d9e" id="r_a5c70195a626f5bfc1815ee34c0089d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5c70195a626f5bfc1815ee34c0089d9e">settings</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html">BasePartitionerSettings</a> &amp;)</td></tr>
<tr class="memdesc:a5c70195a626f5bfc1815ee34c0089d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> settings.  <br /></td></tr>
<tr class="separator:a5c70195a626f5bfc1815ee34c0089d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa61c4e5ba2cdcbafdcfc0d516aad58dd" id="r_aa61c4e5ba2cdcbafdcfc0d516aad58dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa61c4e5ba2cdcbafdcfc0d516aad58dd">enableSymbolicSemantics</a> (bool=true)</td></tr>
<tr class="memdesc:aa61c4e5ba2cdcbafdcfc0d516aad58dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use or not use symbolic semantics.  <br /></td></tr>
<tr class="separator:aa61c4e5ba2cdcbafdcfc0d516aad58dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d24e95b439b9db0d4de8ab072389c05" id="r_a9d24e95b439b9db0d4de8ab072389c05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9d24e95b439b9db0d4de8ab072389c05">disableSymbolicSemantics</a> ()</td></tr>
<tr class="memdesc:a9d24e95b439b9db0d4de8ab072389c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use or not use symbolic semantics.  <br /></td></tr>
<tr class="separator:a9d24e95b439b9db0d4de8ab072389c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afd39509811f980642d576d75b80bc5" id="r_a6afd39509811f980642d576d75b80bc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6afd39509811f980642d576d75b80bc5">usingSymbolicSemantics</a> () const</td></tr>
<tr class="memdesc:a6afd39509811f980642d576d75b80bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use or not use symbolic semantics.  <br /></td></tr>
<tr class="separator:a6afd39509811f980642d576d75b80bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aacc6e0b5abbd00fa7532bbefdf282b45" id="r_aacc6e0b5abbd00fa7532bbefdf282b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aacc6e0b5abbd00fa7532bbefdf282b45">autoAddCallReturnEdges</a> (bool)</td></tr>
<tr class="memdesc:aacc6e0b5abbd00fa7532bbefdf282b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Insert (or not) function call return edges.  <br /></td></tr>
<tr class="separator:aacc6e0b5abbd00fa7532bbefdf282b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3ce89bee3aaf40be572adc12721774" id="r_a5d3ce89bee3aaf40be572adc12721774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5d3ce89bee3aaf40be572adc12721774">autoAddCallReturnEdges</a> () const</td></tr>
<tr class="memdesc:a5d3ce89bee3aaf40be572adc12721774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Insert (or not) function call return edges.  <br /></td></tr>
<tr class="separator:a5d3ce89bee3aaf40be572adc12721774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a814aa15cf8a9e2a64c4eed1f296ee12f" id="r_a814aa15cf8a9e2a64c4eed1f296ee12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a814aa15cf8a9e2a64c4eed1f296ee12f">assumeFunctionsReturn</a> (bool)</td></tr>
<tr class="memdesc:a814aa15cf8a9e2a64c4eed1f296ee12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Assume (or not) that function calls return.  <br /></td></tr>
<tr class="separator:a814aa15cf8a9e2a64c4eed1f296ee12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bff28f30fb934d587a87db10cc7b376" id="r_a4bff28f30fb934d587a87db10cc7b376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4bff28f30fb934d587a87db10cc7b376">assumeFunctionsReturn</a> () const</td></tr>
<tr class="memdesc:a4bff28f30fb934d587a87db10cc7b376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Assume (or not) that function calls return.  <br /></td></tr>
<tr class="separator:a4bff28f30fb934d587a87db10cc7b376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a617226ae2c4d7a265c062feb62514263" id="r_a617226ae2c4d7a265c062feb62514263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a617226ae2c4d7a265c062feb62514263">addressName</a> (rose_addr_t, const std::string &amp;)</td></tr>
<tr class="memdesc:a617226ae2c4d7a265c062feb62514263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name for address.  <br /></td></tr>
<tr class="separator:a617226ae2c4d7a265c062feb62514263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513eacb6e9cfed7aa0318dfa27ce5053" id="r_a513eacb6e9cfed7aa0318dfa27ce5053"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a513eacb6e9cfed7aa0318dfa27ce5053">addressName</a> (rose_addr_t) const</td></tr>
<tr class="memdesc:a513eacb6e9cfed7aa0318dfa27ce5053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name for address.  <br /></td></tr>
<tr class="separator:a513eacb6e9cfed7aa0318dfa27ce5053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53f179dcd5c69d16abf99c4a013df50" id="r_ac53f179dcd5c69d16abf99c4a013df50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a00e4b59c220a710a50c2865c337c52f4">AddressNameMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac53f179dcd5c69d16abf99c4a013df50">addressNames</a> () const</td></tr>
<tr class="memdesc:ac53f179dcd5c69d16abf99c4a013df50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name for address.  <br /></td></tr>
<tr class="separator:ac53f179dcd5c69d16abf99c4a013df50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a74d34a46abec1d6d76bcfc850acc12" id="r_a3a74d34a46abec1d6d76bcfc850acc12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3a74d34a46abec1d6d76bcfc850acc12">sourceLocations</a> () const</td></tr>
<tr class="memdesc:a3a74d34a46abec1d6d76bcfc850acc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Source locations.  <br /></td></tr>
<tr class="separator:a3a74d34a46abec1d6d76bcfc850acc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04011a92e1f74fed11979763482e52c" id="r_af04011a92e1f74fed11979763482e52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af04011a92e1f74fed11979763482e52c">sourceLocations</a> ()</td></tr>
<tr class="memdesc:af04011a92e1f74fed11979763482e52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Source locations.  <br /></td></tr>
<tr class="separator:af04011a92e1f74fed11979763482e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171748caa4fd6464b3d3ae8f3c6c78a" id="r_ae171748caa4fd6464b3d3ae8f3c6c78a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae171748caa4fd6464b3d3ae8f3c6c78a">sourceLocations</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp;)</td></tr>
<tr class="memdesc:ae171748caa4fd6464b3d3ae8f3c6c78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Source locations.  <br /></td></tr>
<tr class="separator:ae171748caa4fd6464b3d3ae8f3c6c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b8429dbe1667ba105dd8fc07c717b1b" id="r_a6b8429dbe1667ba105dd8fc07c717b1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6b8429dbe1667ba105dd8fc07c717b1b">checkingCallBranch</a> () const</td></tr>
<tr class="memdesc:a6b8429dbe1667ba105dd8fc07c717b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to look for function calls used as branches.  <br /></td></tr>
<tr class="separator:a6b8429dbe1667ba105dd8fc07c717b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacab680b5e42d3d5c778523ae5e85c" id="r_a3dacab680b5e42d3d5c778523ae5e85c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3dacab680b5e42d3d5c778523ae5e85c">checkingCallBranch</a> (bool)</td></tr>
<tr class="memdesc:a3dacab680b5e42d3d5c778523ae5e85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to look for function calls used as branches.  <br /></td></tr>
<tr class="separator:a3dacab680b5e42d3d5c778523ae5e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2255efa947eb938f95d9fda0c228abe7" id="r_a2255efa947eb938f95d9fda0c228abe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2255efa947eb938f95d9fda0c228abe7">semanticMemoryParadigm</a> () const</td></tr>
<tr class="memdesc:a2255efa947eb938f95d9fda0c228abe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to use map- or list-based memory states.  <br /></td></tr>
<tr class="separator:a2255efa947eb938f95d9fda0c228abe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3a0642ddfe12bbb3880eb0f6cc103b" id="r_ada3a0642ddfe12bbb3880eb0f6cc103b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ada3a0642ddfe12bbb3880eb0f6cc103b">semanticMemoryParadigm</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a>)</td></tr>
<tr class="memdesc:ada3a0642ddfe12bbb3880eb0f6cc103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to use map- or list-based memory states.  <br /></td></tr>
<tr class="separator:ada3a0642ddfe12bbb3880eb0f6cc103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7d74a04b3bb40159766088ba7fb60171" id="r_a7d74a04b3bb40159766088ba7fb60171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7d74a04b3bb40159766088ba7fb60171">newOperators</a> () const</td></tr>
<tr class="memdesc:a7d74a04b3bb40159766088ba7fb60171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain new RiscOperators.  <br /></td></tr>
<tr class="separator:a7d74a04b3bb40159766088ba7fb60171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65534c6d358b36a9165ce7534c28fba4" id="r_a65534c6d358b36a9165ce7534c28fba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a65534c6d358b36a9165ce7534c28fba4">newOperators</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a>) const</td></tr>
<tr class="memdesc:a65534c6d358b36a9165ce7534c28fba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain new RiscOperators.  <br /></td></tr>
<tr class="separator:a65534c6d358b36a9165ce7534c28fba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedFromThis"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedFromThis')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedFromThis.html">Sawyer::SharedFromThis&lt; Partitioner &gt;</a></td></tr>
<tr class="memitem:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a5225cf4c7055339254ace1c62005ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; Partitioner &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a5225cf4c7055339254ace1c62005ac55">sharedFromThis</a> ()</td></tr>
<tr class="memdesc:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a8b829a965e98f9ccb1b22da4a68a6f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; const Partitioner &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a8b829a965e98f9ccb1b22da4a68a6f76">sharedFromThis</a> () const</td></tr>
<tr class="memdesc:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae15492e36a2af8002023cab5afeaf671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae15492e36a2af8002023cab5afeaf671">Storage</a> ()</td></tr>
<tr class="memdesc:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9f66f01b292f92cdc70a18de1a7085ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9f66f01b292f92cdc70a18de1a7085ef">Storage</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae0dda357eaeee6b1974c3feae00c40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae0dda357eaeee6b1974c3feae00c40dd">operator=</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_abf3618e6d7c3a3f4bcc38ad23da3b8e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#abf3618e6d7c3a3f4bcc38ad23da3b8e9">attributeExists</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check attribute existence.  <br /></td></tr>
<tr class="separator:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a5a79e661eb48d0b9548bd0dacc63daba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a5a79e661eb48d0b9548bd0dacc63daba">eraseAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>)</td></tr>
<tr class="memdesc:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute.  <br /></td></tr>
<tr class="separator:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ab9276a22e706c4e76d65d45e715051e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ab9276a22e706c4e76d65d45e715051e0">clearAttributes</a> ()</td></tr>
<tr class="memdesc:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all attributes.  <br /></td></tr>
<tr class="separator:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9900916e61e6c0ce53e87803221962c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9900916e61e6c0ce53e87803221962c0">setAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute.  <br /></td></tr>
<tr class="separator:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a2143837f634be78ae5143e962d272fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a2143837f634be78ae5143e962d272fb8">setAttributeMaybe</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute if not already present.  <br /></td></tr>
<tr class="separator:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae39391002b59fc46db71a536cbe3e075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae39391002b59fc46db71a536cbe3e075">getAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute that is known to exist.  <br /></td></tr>
<tr class="separator:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a921b9ff8dc5cd78f751517bc22127496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a921b9ff8dc5cd78f751517bc22127496">attributeOrElse</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;dflt) const</td></tr>
<tr class="memdesc:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a specified value.  <br /></td></tr>
<tr class="separator:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a80072b861bfe95e1146934a3a53506ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a80072b861bfe95e1146934a3a53506ed">attributeOrDefault</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a default-constructed value.  <br /></td></tr>
<tr class="separator:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4277013fbe140a78e10182ca9053935c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4277013fbe140a78e10182ca9053935c">optionalAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute as an optional value.  <br /></td></tr>
<tr class="separator:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4b9e838c10d8c99838518457b35783ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4b9e838c10d8c99838518457b35783ac">nAttributes</a> () const</td></tr>
<tr class="memdesc:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <br /></td></tr>
<tr class="separator:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a1739a58e26f1dd40590fd9ee78936781"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a1739a58e26f1dd40590fd9ee78936781">attributeIds</a> () const</td></tr>
<tr class="memdesc:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ID numbers for all IDs stored in this container.  <br /></td></tr>
<tr class="separator:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9ae890949346ab904e5328e618f79d9b" id="r_a9ae890949346ab904e5328e618f79d9b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9ae890949346ab904e5328e618f79d9b">instance</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a9ae890949346ab904e5328e618f79d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default allocating constructor.  <br /></td></tr>
<tr class="separator:a9ae890949346ab904e5328e618f79d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94e58c565c5ae1afc52fd01bbfbf956" id="r_aa94e58c565c5ae1afc52fd01bbfbf956"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa94e58c565c5ae1afc52fd01bbfbf956">instance</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:aa94e58c565c5ae1afc52fd01bbfbf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a partitioner.  <br /></td></tr>
<tr class="separator:aa94e58c565c5ae1afc52fd01bbfbf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec85d9e187036f771a8bbc90053b0f6" id="r_afec85d9e187036f771a8bbc90053b0f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afec85d9e187036f771a8bbc90053b0f6">instanceFromRbaFile</a> (const boost::filesystem::path &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>=<a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a>)</td></tr>
<tr class="memdesc:afec85d9e187036f771a8bbc90053b0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a partitioner by loading it and an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from a file.  <br /></td></tr>
<tr class="separator:afec85d9e187036f771a8bbc90053b0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e4a7482687adc99bd3c208d5cb33f9" id="r_a99e4a7482687adc99bd3c208d5cb33f9"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a99e4a7482687adc99bd3c208d5cb33f9">vertexNameEnd</a> (const ControlFlowGraph::Vertex &amp;)</td></tr>
<tr class="memdesc:a99e4a7482687adc99bd3c208d5cb33f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of last instruction in vertex.  <br /></td></tr>
<tr class="separator:a99e4a7482687adc99bd3c208d5cb33f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d17b542ecbd0ca653f881ca07838b94" id="r_a4d17b542ecbd0ca653f881ca07838b94"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4d17b542ecbd0ca653f881ca07838b94">basicBlockName</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a4d17b542ecbd0ca653f881ca07838b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of a basic block.  <br /></td></tr>
<tr class="separator:a4d17b542ecbd0ca653f881ca07838b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08407d13d3749121e97a34ea418ec555" id="r_a08407d13d3749121e97a34ea418ec555"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a08407d13d3749121e97a34ea418ec555">dataBlockName</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a08407d13d3749121e97a34ea418ec555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of a data block.  <br /></td></tr>
<tr class="separator:a08407d13d3749121e97a34ea418ec555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733d5db9d2fef789b23734864eecfc08" id="r_a733d5db9d2fef789b23734864eecfc08"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a733d5db9d2fef789b23734864eecfc08">functionName</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a733d5db9d2fef789b23734864eecfc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of a function.  <br /></td></tr>
<tr class="separator:a733d5db9d2fef789b23734864eecfc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac2b676583ea0551bcdfaf8c04d959f" id="r_a9ac2b676583ea0551bcdfaf8c04d959f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9ac2b676583ea0551bcdfaf8c04d959f">vertexName</a> (const ControlFlowGraph::ConstVertexIterator &amp;) const</td></tr>
<tr class="memdesc:a9ac2b676583ea0551bcdfaf8c04d959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of a vertex.  <br /></td></tr>
<tr class="separator:a9ac2b676583ea0551bcdfaf8c04d959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad939aa0645969e081565ad2414ef9449" id="r_ad939aa0645969e081565ad2414ef9449"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad939aa0645969e081565ad2414ef9449">vertexName</a> (const ControlFlowGraph::Vertex &amp;)</td></tr>
<tr class="memdesc:ad939aa0645969e081565ad2414ef9449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of a vertex.  <br /></td></tr>
<tr class="separator:ad939aa0645969e081565ad2414ef9449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93376dd7d5af2a9c398d1452726f75c" id="r_ad93376dd7d5af2a9c398d1452726f75c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad93376dd7d5af2a9c398d1452726f75c">edgeNameSrc</a> (const ControlFlowGraph::ConstEdgeIterator &amp;) const</td></tr>
<tr class="memdesc:ad93376dd7d5af2a9c398d1452726f75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an incoming edge.  <br /></td></tr>
<tr class="separator:ad93376dd7d5af2a9c398d1452726f75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86f4571f621eefce01fea827112ac0c" id="r_af86f4571f621eefce01fea827112ac0c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af86f4571f621eefce01fea827112ac0c">edgeNameSrc</a> (const ControlFlowGraph::Edge &amp;)</td></tr>
<tr class="memdesc:af86f4571f621eefce01fea827112ac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an incoming edge.  <br /></td></tr>
<tr class="separator:af86f4571f621eefce01fea827112ac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cd15ffcb26b22813a373b18be9adf7" id="r_ac8cd15ffcb26b22813a373b18be9adf7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac8cd15ffcb26b22813a373b18be9adf7">edgeNameDst</a> (const ControlFlowGraph::ConstEdgeIterator &amp;) const</td></tr>
<tr class="memdesc:ac8cd15ffcb26b22813a373b18be9adf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an outgoing edge.  <br /></td></tr>
<tr class="separator:ac8cd15ffcb26b22813a373b18be9adf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2edb5c627b6e84c97486d04203c0ed8" id="r_ae2edb5c627b6e84c97486d04203c0ed8"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae2edb5c627b6e84c97486d04203c0ed8">edgeNameDst</a> (const ControlFlowGraph::Edge &amp;)</td></tr>
<tr class="memdesc:ae2edb5c627b6e84c97486d04203c0ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an outgoing edge.  <br /></td></tr>
<tr class="separator:ae2edb5c627b6e84c97486d04203c0ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea5e94b2c40b9e90fb8b6c49658e76" id="r_a60ea5e94b2c40b9e90fb8b6c49658e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a60ea5e94b2c40b9e90fb8b6c49658e76">edgeName</a> (const ControlFlowGraph::ConstEdgeIterator &amp;) const</td></tr>
<tr class="memdesc:a60ea5e94b2c40b9e90fb8b6c49658e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an edge.  <br /></td></tr>
<tr class="separator:a60ea5e94b2c40b9e90fb8b6c49658e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e389a5294afe922d9e1b267c3196a1" id="r_ae2e389a5294afe922d9e1b267c3196a1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae2e389a5294afe922d9e1b267c3196a1">edgeName</a> (const ControlFlowGraph::Edge &amp;)</td></tr>
<tr class="memdesc:ae2e389a5294afe922d9e1b267c3196a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of an edge.  <br /></td></tr>
<tr class="separator:ae2e389a5294afe922d9e1b267c3196a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4fef4ab65e1ce68aced8e1842aa0070b" name="a4fef4ab65e1ce68aced8e1842aa0070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fef4ab65e1ce68aced8e1842aa0070b">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Rose::BinaryAnalysis::Partitioner2::Partitioner::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00278">278</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="a5c025811c07d41e351f246a16d4cc285" name="a5c025811c07d41e351f246a16d4cc285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c025811c07d41e351f246a16d4cc285">&#9670;&#160;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a5c025811c07d41e351f246a16d4cc285">Rose::BinaryAnalysis::Partitioner2::Partitioner::ConstPtr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">PartitionerConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00279">279</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="a044db32618aa7b901caac5629167825e" name="a044db32618aa7b901caac5629167825e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044db32618aa7b901caac5629167825e">&#9670;&#160;</a></span>CfgAdjustmentCallbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Callbacks.html">Sawyer::Callbacks</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgAdjustmentCallback.html#a07047df2e79bd8c3049588feec7ba455">CfgAdjustmentCallback::Ptr</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">Rose::BinaryAnalysis::Partitioner2::Partitioner::CfgAdjustmentCallbacks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a1d79564686574f7c0340b9aa9a13a7a8">cfgAdjustmentCallbacks</a>. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00283">283</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="ae0d33eeb49d3688517f7df1f7004315a" name="ae0d33eeb49d3688517f7df1f7004315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d33eeb49d3688517f7df1f7004315a">&#9670;&#160;</a></span>BasicBlockCallbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Callbacks.html">Sawyer::Callbacks</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">BasicBlockCallbackPtr</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">Rose::BinaryAnalysis::Partitioner2::Partitioner::BasicBlockCallbacks</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adbee3513586f9d653ad1805e44df8072">basicBlockCallbacks</a>. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00284">284</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="ab7fa873c34d530750943a0e4171dd480" name="ab7fa873c34d530750943a0e4171dd480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fa873c34d530750943a0e4171dd480">&#9670;&#160;</a></span>FunctionPrologueMatchers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">FunctionPrologueMatcherPtr</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">Rose::BinaryAnalysis::Partitioner2::Partitioner::FunctionPrologueMatchers</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0f9d0dafd282a74651166a929ef7bd66">functionPrologueMatchers</a>. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00285">285</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="a4386d55af94c82efad04a6c4e9d74c37" name="a4386d55af94c82efad04a6c4e9d74c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4386d55af94c82efad04a6c4e9d74c37">&#9670;&#160;</a></span>FunctionPaddingMatchers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a175cf54eba5910f765929bfd48d46eb8">FunctionPaddingMatcherPtr</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">Rose::BinaryAnalysis::Partitioner2::Partitioner::FunctionPaddingMatchers</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af4f90960bc68617c7b20d22b198aa6e1">functionPaddingMatchers</a>. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00286">286</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="a00e4b59c220a710a50c2865c337c52f4" name="a00e4b59c220a710a50c2865c337c52f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e4b59c220a710a50c2865c337c52f4">&#9670;&#160;</a></span>AddressNameMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;rose_addr_t, std::string&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a00e4b59c220a710a50c2865c337c52f4">Rose::BinaryAnalysis::Partitioner2::Partitioner::AddressNameMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> address to name. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l00297">297</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ae890949346ab904e5328e618f79d9b" name="a9ae890949346ab904e5328e618f79d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae890949346ab904e5328e618f79d9b">&#9670;&#160;</a></span>instance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Ptr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default allocating constructor. </p>
<p>The default constructor does not produce a usable partitioner, but is convenient when one needs to pass a default partitioner by value or reference. </p>

</div>
</div>
<a id="aa94e58c565c5ae1afc52fd01bbfbf956" name="aa94e58c565c5ae1afc52fd01bbfbf956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94e58c565c5ae1afc52fd01bbfbf956">&#9670;&#160;</a></span>instance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fef4ab65e1ce68aced8e1842aa0070b">Ptr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a partitioner. </p>
<p>The partitioner must be provided with a disassembler, which also determines the specimen's target architecture, and a memory map that represents a (partially) loaded instance of the specimen (i.e., a process). </p>

</div>
</div>
<a id="afec85d9e187036f771a8bbc90053b0f6" name="afec85d9e187036f771a8bbc90053b0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec85d9e187036f771a8bbc90053b0f6">&#9670;&#160;</a></span>instanceFromRbaFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a30252e56f3ed8c058c29b65be2f92b83">PartitionerPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instanceFromRbaFile </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8">SerialIo::Format</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1SerialIo.html#a342cb143c541ac8553230113560945f8a51a55d05550a5796c20099ab8c442c64">SerialIo::BINARY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a partitioner by loading it and an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> from a file. </p>
<p>The specified RBA file is opened and read to create a new <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> object and associated <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">Engine::partition</a> function also understands how to open RBA files. </p>

</div>
</div>
<a id="ab76677492554491ba8ed92387f14e40a" name="ab76677492554491ba8ed92387f14e40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76677492554491ba8ed92387f14e40a">&#9670;&#160;</a></span>isDefaultConstructed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isDefaultConstructed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a default constructed partitioner. </p>
<p>Most methods won't work when applied to a default-constructed partitioner since it has no way to obtain instructions and it has an empty memory map.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a3f432d756dd2d1d9f1f7fca6f92475aa" name="a3f432d756dd2d1d9f1f7fca6f92475aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f432d756dd2d1d9f1f7fca6f92475aa">&#9670;&#160;</a></span>configuration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information. </p>
<p>The configuration holds information about functions and basic blocks which is used to provide default values and such.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a04c61ab26492260edea0f3fde603db40" name="a04c61ab26492260edea0f3fde603db40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c61ab26492260edea0f3fde603db40">&#9670;&#160;</a></span>configuration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html">Configuration</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Configuration.html" title="Holds configuration information.">Configuration</a> information. </p>
<p>The configuration holds information about functions and basic blocks which is used to provide default values and such.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a5ec808a1a2846948f412dfb8af24b063" name="a5ec808a1a2846948f412dfb8af24b063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec808a1a2846948f412dfb8af24b063">&#9670;&#160;</a></span>architecture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::architecture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> information. </p>
<p>Returns a non-null pointer to the architecture information. </p>

</div>
</div>
<a id="adf4a3256a387046d532d3cb46c1f874f" name="adf4a3256a387046d532d3cb46c1f874f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4a3256a387046d532d3cb46c1f874f">&#9670;&#160;</a></span>instructionProvider() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html">InstructionProvider</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionProvider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instruction provider. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af43bf94a24b84e1db41cb1962c28a138" name="af43bf94a24b84e1db41cb1962c28a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43bf94a24b84e1db41cb1962c28a138">&#9670;&#160;</a></span>instructionProvider() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html">InstructionProvider</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionProvider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instruction provider. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae759942924032c1753769bc31cde38c3" name="ae759942924032c1753769bc31cde38c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae759942924032c1753769bc31cde38c3">&#9670;&#160;</a></span>memoryMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">MemoryMap::Ptr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::memoryMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memory map. </p>
<p>It is generally unwise to make extensive changes to a memory map after the partitioner has started using it, because that means that any instructions or data obtained earlier from the map might not be an accurate representation of memory anymore.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a1f2233a608a1889df426b85185f7a943" name="a1f2233a608a1889df426b85185f7a943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2233a608a1889df426b85185f7a943">&#9670;&#160;</a></span>addressIsExecutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::addressIsExecutable </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if address is executable. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a19eb21d247558791a63fb7617ab633cf" name="a19eb21d247558791a63fb7617ab633cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19eb21d247558791a63fb7617ab633cf">&#9670;&#160;</a></span>unparser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::unparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an unparser. </p>
<p>This unparser is initiallly a copy of the one provided by the disassembler, but it can be reset to something else if desired. This is the unparser used by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afad5706bae39185f92727e64d1bfe7b2">unparse</a> method for the partitioner as a whole, functions, basic blocks, and data blocks. Instructions use the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a> instead.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa938d509ecf2c0f32bd187768d9c3774" name="aa938d509ecf2c0f32bd187768d9c3774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa938d509ecf2c0f32bd187768d9c3774">&#9670;&#160;</a></span>unparser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an unparser. </p>
<p>This unparser is initiallly a copy of the one provided by the disassembler, but it can be reset to something else if desired. This is the unparser used by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afad5706bae39185f92727e64d1bfe7b2">unparse</a> method for the partitioner as a whole, functions, basic blocks, and data blocks. Instructions use the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a> instead.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ab89a7c3deacacf3b30349cd4949077d2" name="ab89a7c3deacacf3b30349cd4949077d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89a7c3deacacf3b30349cd4949077d2">&#9670;&#160;</a></span>insnUnparser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::insnUnparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an unparser. </p>
<p>This unparser is initially a copy of the one provided by the disassembler, and adjusted to be most useful for printing single instructions. By default, it prints the instruction address, mnemonic, and operands but not raw bytes, stack deltas, comments, or anything else.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9a1b10a79a982dca6ff3da9e7e7586e4" name="a9a1b10a79a982dca6ff3da9e7e7586e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1b10a79a982dca6ff3da9e7e7586e4">&#9670;&#160;</a></span>insnUnparser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::insnUnparser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an unparser. </p>
<p>This unparser is initially a copy of the one provided by the disassembler, and adjusted to be most useful for printing single instructions. By default, it prints the instruction address, mnemonic, and operands but not raw bytes, stack deltas, comments, or anything else.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a30cabb9057b20d340f28461ce1846b81" name="a30cabb9057b20d340f28461ce1846b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cabb9057b20d340f28461ce1846b81">&#9670;&#160;</a></span>configureInsnPlainUnparser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::configureInsnPlainUnparser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure plain single-instruction unparser. </p>
<p>This configures an unparser for showing just the instruction mnemonic and operands. </p>

</div>
</div>
<a id="afad5706bae39185f92727e64d1bfe7b2" name="afad5706bae39185f92727e64d1bfe7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad5706bae39185f92727e64d1bfe7b2">&#9670;&#160;</a></span>unparse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a5ed5a6b672c9f77ad811b1f8808845a4" name="a5ed5a6b672c9f77ad811b1f8808845a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed5a6b672c9f77ad811b1f8808845a4">&#9670;&#160;</a></span>unparse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a4dda04b77417e2f63f28c9c571e70d8e" name="a4dda04b77417e2f63f28c9c571e70d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dda04b77417e2f63f28c9c571e70d8e">&#9670;&#160;</a></span>unparse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2d05b429b8839fa522d25f6f2efb52f3" name="a2d05b429b8839fa522d25f6f2efb52f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d05b429b8839fa522d25f6f2efb52f3">&#9670;&#160;</a></span>unparse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6151596a1e14f8d4af4216ea6ac602dd" name="a6151596a1e14f8d4af4216ea6ac602dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6151596a1e14f8d4af4216ea6ac602dd">&#9670;&#160;</a></span>unparse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7aa4b903df664099e041c8e1b5c75d98" name="a7aa4b903df664099e041c8e1b5c75d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa4b903df664099e041c8e1b5c75d98">&#9670;&#160;</a></span>unparse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse some entity. </p>
<p>Unparses an instruction, basic block, data block, function, or all functions using the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a19eb21d247558791a63fb7617ab633cf">unparser</a> (except for instructions, which use the unparser returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab89a7c3deacacf3b30349cd4949077d2">insnUnparser</a>).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a94f7c92f966d5f498baae4ff67d63c8d" name="a94f7c92f966d5f498baae4ff67d63c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f7c92f966d5f498baae4ff67d63c8d">&#9670;&#160;</a></span>unparsePlain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::unparsePlain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse an instruction in a plain way. </p>
<p>This generates a string for the instruction that shows only the mnemonic and arguments. </p>

</div>
</div>
<a id="a636381b5508ca7aa462def32a6517cee" name="a636381b5508ca7aa462def32a6517cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636381b5508ca7aa462def32a6517cee">&#9670;&#160;</a></span>nBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes represented by the CFG. </p>
<p>This is a constant time operation.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a11e1798ead9f1bda8a0c3244a3eeabb7" name="a11e1798ead9f1bda8a0c3244a3eeabb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e1798ead9f1bda8a0c3244a3eeabb7">&#9670;&#160;</a></span>undiscoveredVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::undiscoveredVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "undiscovered" vertex. </p>
<p>The incoming edges for this vertex originate from the basic block placeholder vertices.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af97038517c1f41d1385db8655c85336e" name="af97038517c1f41d1385db8655c85336e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97038517c1f41d1385db8655c85336e">&#9670;&#160;</a></span>undiscoveredVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::undiscoveredVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "undiscovered" vertex. </p>
<p>The incoming edges for this vertex originate from the basic block placeholder vertices.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6175331304232fe65d37aa32353330a2" name="a6175331304232fe65d37aa32353330a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6175331304232fe65d37aa32353330a2">&#9670;&#160;</a></span>indeterminateVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::indeterminateVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "indeterminate" vertex. </p>
<p>The incoming edges for this vertex originate from basic blocks whose successors are not all concrete values. Each such basic block has only one edge from that block to this vertex.</p>
<p>Indeterminate successors result from, among other things, indirect jump instructions, like x86 "JMP [EAX]".</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a162169db17eb5c41b19a92e4e771cd05" name="a162169db17eb5c41b19a92e4e771cd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162169db17eb5c41b19a92e4e771cd05">&#9670;&#160;</a></span>indeterminateVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::indeterminateVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "indeterminate" vertex. </p>
<p>The incoming edges for this vertex originate from basic blocks whose successors are not all concrete values. Each such basic block has only one edge from that block to this vertex.</p>
<p>Indeterminate successors result from, among other things, indirect jump instructions, like x86 "JMP [EAX]".</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a05e4e29f3a85c8b586777f16dfe3d401" name="a05e4e29f3a85c8b586777f16dfe3d401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e4e29f3a85c8b586777f16dfe3d401">&#9670;&#160;</a></span>nonexistingVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::nonexistingVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "non-existing" vertex. </p>
<p>The incoming edges for this vertex originate from basic blocks that have no instructions but which aren't merely placeholders. Such basic blocks exist when an attempt is made to discover a basic block but its starting address is memory which is not mapped or memory which is mapped without execute permission.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a079d7ce5fde92dd03dcf45bbd42044ff" name="a079d7ce5fde92dd03dcf45bbd42044ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079d7ce5fde92dd03dcf45bbd42044ff">&#9670;&#160;</a></span>nonexistingVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::nonexistingVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the special "non-existing" vertex. </p>
<p>The incoming edges for this vertex originate from basic blocks that have no instructions but which aren't merely placeholders. Such basic blocks exist when an attempt is made to discover a basic block but its starting address is memory which is not mapped or memory which is mapped without execute permission.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a398bf1dd74a7e6f3938eed10cf9f84e9" name="a398bf1dd74a7e6f3938eed10cf9f84e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398bf1dd74a7e6f3938eed10cf9f84e9">&#9670;&#160;</a></span>cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">ControlFlowGraph</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::cfg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the control flow graph. </p>
<p>Returns the global control flow graph. The CFG should not be modified by the caller except through the partitioner's own API.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa15035967450906554776155d8bbcc26" name="aa15035967450906554776155d8bbcc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15035967450906554776155d8bbcc26">&#9670;&#160;</a></span>aum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUsageMap.html">AddressUsageMap</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::aum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address usage map. </p>
<p>Returns the global address usage map. The AUM should not be modified by the caller except through the paritioner's own API.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af1a244171e655c35ffb317614337e85c" name="af1a244171e655c35ffb317614337e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a244171e655c35ffb317614337e85c">&#9670;&#160;</a></span>users()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::users </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entities that exist at a particular address. </p>
<p>Returns a vector of <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> objects that describe instructions, basic blocks, data blocks, and functions that exist at the specified address. </p>

</div>
</div>
<a id="a37ea2e6c5c1a9983214e922ae0706760" name="a37ea2e6c5c1a9983214e922ae0706760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ea2e6c5c1a9983214e922ae0706760">&#9670;&#160;</a></span>ghostSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::ghostSuccessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine all ghost successors in the control flow graph. </p>
<p>The return value is a list of basic block ghost successors for which no basic block or basic block placeholder exists.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2fdc3ba0da480b23169e0a7163e70660" title="Determine ghost successors for a basic block.">basicBlockGhostSuccessors</a> </dd></dl>

</div>
</div>
<a id="abae01ec1ba802eb0a224dbf7d60a3b41" name="abae01ec1ba802eb0a224dbf7d60a3b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae01ec1ba802eb0a224dbf7d60a3b41">&#9670;&#160;</a></span>isEdgeIntraProcedural() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeIntraProcedural </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is intra-procedural. </p>
<p>An intra-procedural edge is an edge whose source and target are owned by the same function and which is not part of a function call, function transfer, or function return. This function returns true if the edge is intra-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is not intra-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If a function is specified and that function is listed as an owner of both the source and target blocks, then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and neither the source nor the target block have any function owners then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and there exists some function that is an owner of both the source and target blocks then the edge is intra-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not intra-procedural.</li>
</ul>
<p>When no function is specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3d25a8610e23546320ba56f81f982b17" title="Determine if an edge is inter-procedural.">isEdgeInterProcedural</a>. </dd></dl>

</div>
</div>
<a id="a61e8c0dd72cd2d5d43ba68571a8b90d3" name="a61e8c0dd72cd2d5d43ba68571a8b90d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e8c0dd72cd2d5d43ba68571a8b90d3">&#9670;&#160;</a></span>isEdgeIntraProcedural() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeIntraProcedural </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is intra-procedural. </p>
<p>An intra-procedural edge is an edge whose source and target are owned by the same function and which is not part of a function call, function transfer, or function return. This function returns true if the edge is intra-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is not intra-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If a function is specified and that function is listed as an owner of both the source and target blocks, then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and neither the source nor the target block have any function owners then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and there exists some function that is an owner of both the source and target blocks then the edge is intra-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not intra-procedural.</li>
</ul>
<p>When no function is specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3d25a8610e23546320ba56f81f982b17" title="Determine if an edge is inter-procedural.">isEdgeInterProcedural</a>. </dd></dl>

</div>
</div>
<a id="a5a1300386a5c0d0aebb68ab38f382bef" name="a5a1300386a5c0d0aebb68ab38f382bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1300386a5c0d0aebb68ab38f382bef">&#9670;&#160;</a></span>isEdgeIntraProcedural() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeIntraProcedural </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is intra-procedural. </p>
<p>An intra-procedural edge is an edge whose source and target are owned by the same function and which is not part of a function call, function transfer, or function return. This function returns true if the edge is intra-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is not intra-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If a function is specified and that function is listed as an owner of both the source and target blocks, then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and neither the source nor the target block have any function owners then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and there exists some function that is an owner of both the source and target blocks then the edge is intra-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not intra-procedural.</li>
</ul>
<p>When no function is specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3d25a8610e23546320ba56f81f982b17" title="Determine if an edge is inter-procedural.">isEdgeInterProcedural</a>. </dd></dl>

</div>
</div>
<a id="a7b572cbde5e0b2787dfc90247ba717b4" name="a7b572cbde5e0b2787dfc90247ba717b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b572cbde5e0b2787dfc90247ba717b4">&#9670;&#160;</a></span>isEdgeIntraProcedural() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeIntraProcedural </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is intra-procedural. </p>
<p>An intra-procedural edge is an edge whose source and target are owned by the same function and which is not part of a function call, function transfer, or function return. This function returns true if the edge is intra-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is not intra-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If a function is specified and that function is listed as an owner of both the source and target blocks, then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and neither the source nor the target block have any function owners then the edge is intra-procedural.</li>
</ul>
<ul>
<li>If no function is specified and there exists some function that is an owner of both the source and target blocks then the edge is intra-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not intra-procedural.</li>
</ul>
<p>When no function is specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3d25a8610e23546320ba56f81f982b17" title="Determine if an edge is inter-procedural.">isEdgeInterProcedural</a>. </dd></dl>

</div>
</div>
<a id="a3d25a8610e23546320ba56f81f982b17" name="a3d25a8610e23546320ba56f81f982b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d25a8610e23546320ba56f81f982b17">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="aeac13d26ec7956c9b3cb229395deee2f" name="aeac13d26ec7956c9b3cb229395deee2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac13d26ec7956c9b3cb229395deee2f">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="ad47e4aeb1153be044e8bf50426d6d67d" name="ad47e4aeb1153be044e8bf50426d6d67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47e4aeb1153be044e8bf50426d6d67d">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>targetFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="af07d3f24fdeae174928cc56db6e2f0ef" name="af07d3f24fdeae174928cc56db6e2f0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d3f24fdeae174928cc56db6e2f0ef">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="a54c8446029e0f5416c69973ffeb9d729" name="a54c8446029e0f5416c69973ffeb9d729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8446029e0f5416c69973ffeb9d729">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="a60391d6f452eba60623068b09c32e8d9" name="a60391d6f452eba60623068b09c32e8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60391d6f452eba60623068b09c32e8d9">&#9670;&#160;</a></span>isEdgeInterProcedural() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::isEdgeInterProcedural </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>targetFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is inter-procedural. </p>
<p>An inter-procedural edge is an edge which is part of a function call, a function transfer, or a function return or an edge whose source and target blocks are owned by different functions. This function returns true if the edge is inter-procedural and false if not. The return value is calculated as follows:</p>
<ul>
<li>An edge of type <code>E_FUNCTION_CALL</code>, <code>E_FUNCTION_XFER</code>, or <code>E_FUNCTION_RETURN</code> is inter-procedural regardless of which functions own the source and target blocks.</li>
</ul>
<ul>
<li>If two functions are specified and the source block is owned by the first function, the target block is owned by the second function, and the functions are different then the block is inter-procedural.</li>
</ul>
<ul>
<li>If only the source function is specified and the source block is owned by the source function and the target block is not owned by the source function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If only the target function is specified and the target block is owned by the target function and the source block is not owned by the target function then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and neither the source nor the target block have any function owners then the edge is inter-procedural.</li>
</ul>
<ul>
<li>If no functions are specified and the list of functions owning the source block is not equal to the list of functions owning the destination block then the block is inter-procedural.</li>
</ul>
<ul>
<li>Otherwise the edge is not inter-procedural.</li>
</ul>
<p>When no functions are specified it can be ambiguous as to whether a branch is intra- or inter-procedural; a branch could be both intra- and inter-procedural.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abae01ec1ba802eb0a224dbf7d60a3b41" title="Determine if an edge is intra-procedural.">isEdgeIntraProcedural</a>. </dd></dl>

</div>
</div>
<a id="aa8ad0090449cf7b06fdb2a39793ea2d7" name="aa8ad0090449cf7b06fdb2a39793ea2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ad0090449cf7b06fdb2a39793ea2d7">&#9670;&#160;</a></span>nInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nInstructions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of instructions attached to the CFG/AUM. </p>
<p>This statistic is computed in time linearly proportional to the number of basic blocks in the control flow graph.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ac8221a7204eaf78c449216505ad6da6f" name="ac8221a7204eaf78c449216505ad6da6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8221a7204eaf78c449216505ad6da6f">&#9670;&#160;</a></span>instructionExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an instruction is attached to the CFG/AUM. </p>
<p>If the CFG/AUM represents an instruction that starts at the specified address, then this method returns the instruction/block pair, otherwise it returns an empty pair. The initial instruction for a basic block does not exist if the basic block is only represented by a placeholder in the CFG; such a basic block is said to be "undiscovered".</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="affc57d10132f8aa9384130bee455760a" name="affc57d10132f8aa9384130bee455760a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc57d10132f8aa9384130bee455760a">&#9670;&#160;</a></span>instructionExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AddressUser.html">AddressUser</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"><em>insn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether an instruction is attached to the CFG/AUM. </p>
<p>If the CFG/AUM represents an instruction that starts at the specified address, then this method returns the instruction/block pair, otherwise it returns an empty pair. The initial instruction for a basic block does not exist if the basic block is only represented by a placeholder in the CFG; such a basic block is said to be "undiscovered".</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7a1f6dcc5c29c25abda70419d822901d" name="a7a1f6dcc5c29c25abda70419d822901d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1f6dcc5c29c25abda70419d822901d">&#9670;&#160;</a></span>instructionVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionVertex </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>insnVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CFG vertex containing specified instruction. </p>
<p>Returns the control flow graph vertex that contains the specified instruction. If the instruction does not exist in the CFG then the end vertex is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa5a72cd957b2a0414a6a125f6ead186c" name="aa5a72cd957b2a0414a6a125f6ead186c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a72cd957b2a0414a6a125f6ead186c">&#9670;&#160;</a></span>instructionsOverlapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionsOverlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns instructions that overlap with specified address interval. </p>
<p>Returns a sorted list of distinct instructions that are attached to the CFG/AUM and which overlap at least one byte in the specified address interval. An instruction overlaps the interval if any of its bytes are within the interval.</p>
<p>The returned list of instructions are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6dc36313234db580953212bc891ced5b" name="a6dc36313234db580953212bc891ced5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc36313234db580953212bc891ced5b">&#9670;&#160;</a></span>instructionsSpanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionsSpanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns instructions that span an entire address interval. </p>
<p>Returns a sorted list of distinct instructions that are attached to the CFG/AUM and which span the entire specified interval. An instruction spans the interval if the set of addresses for all its bytes are a superset of the interval.</p>
<p>The returned list of instructions are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a1ff462caeef49426bb7c9a8a33e8629e" name="a1ff462caeef49426bb7c9a8a33e8629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff462caeef49426bb7c9a8a33e8629e">&#9670;&#160;</a></span>instructionsContainedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionsContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns instructions that are fully contained in an address interval. </p>
<p>Returns a sorted list of distinct instructions that are attached to the CFG/AUM and which are fully contained within the specified interval. In order to be fully contained in the interval, the set of addresses of the bytes in the instruction must be a subset of the specified interval.</p>
<p>The returned list of instructions are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae65ff58a2563565be6fb29867ac358ca" name="ae65ff58a2563565be6fb29867ac358ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65ff58a2563565be6fb29867ac358ca">&#9670;&#160;</a></span>instructionExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address interval for an instruction. </p>
<p>Returns the minimal interval describing from where the instruction was disassembled. An instruction always exists in a contiguous region of memory, therefore the return value is a single interval rather than a set of intervals. If a null pointer is specified then an empty interval is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2391a325e084b2f001b2e450d6b2b181" name="a2391a325e084b2f001b2e450d6b2b181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2391a325e084b2f001b2e450d6b2b181">&#9670;&#160;</a></span>discoverInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverInstruction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover an instruction. </p>
<p>Returns (and caches) the instruction at the specified address by invoking an <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionProvider.html" title="Provides and caches instructions.">InstructionProvider</a>. Unlike <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ac8221a7204eaf78c449216505ad6da6f">instructionExists</a>, the address does not need to be known by the CFG/AUM.</p>
<p>If the <code>startVa</code> is not mapped with execute permission or is improperly aligned for the architecture then a null pointer is returned. If an instruction cannot be disassembled at the address (e.g., bad byte code or not implemented) then a special 1-byte "unknown" instruction is returned; such instructions have indeterminate control flow successors and no semantics. If an instruction was previously returned for this address (including the "unknown" instruction) then that same instruction will be returned this time.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae8b9d41879a8131917ea202acf3bc680" name="ae8b9d41879a8131917ea202acf3bc680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b9d41879a8131917ea202acf3bc680">&#9670;&#160;</a></span>instructionCrossReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a290cbfd543686205aeeba62d70b8aace">CrossReferences</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::instructionCrossReferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>restriction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cross references. </p>
<p>Scans all attached instructions looking for constants mentioned in the instructions and builds a mapping from those constants back to the instructions. Only constants present in the <code>restriction</code> set are considered. </p>

</div>
</div>
<a id="a4fca6e7da80bc9ed21e53cf26f01dde4" name="a4fca6e7da80bc9ed21e53cf26f01dde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca6e7da80bc9ed21e53cf26f01dde4">&#9670;&#160;</a></span>nPlaceholders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nPlaceholders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of basic basic block placeholders in the CFG. </p>
<p>A placeholder optionally points to a basic block, and this method returns the number of placeholders in the CFG regardless of whether they point to a discovered basic block. Note that vertices that are mere placeholders and don't point to a discovered basic block are not represented in the AUM since a placeholder has no instructions.</p>
<p>This is a constant-time operation.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a461f439dbc5dbe6b48df43995d0b4d4c" name="a461f439dbc5dbe6b48df43995d0b4d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461f439dbc5dbe6b48df43995d0b4d4c">&#9670;&#160;</a></span>placeholderExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::placeholderExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a basic block placeholder exists in the CFG. </p>
<p>Returns true if the CFG contains a placeholder at the specified address, and false if no such placeholder exists. The placeholder may or may not point to a discovered basic block.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a45c38dbee180601ba20d8bea0743bbd2" title="Find the CFG vertex for a basic block placeholder.">findPlaceholder</a> </dd></dl>

</div>
</div>
<a id="a45c38dbee180601ba20d8bea0743bbd2" name="a45c38dbee180601ba20d8bea0743bbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c38dbee180601ba20d8bea0743bbd2">&#9670;&#160;</a></span>findPlaceholder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::findPlaceholder </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the CFG vertex for a basic block placeholder. </p>
<p>If the CFG contains a basic block placeholder at the specified address then that CFG vertex is returned, otherwise the end vertex (<code>partitioner.cfg().vertices().end()</code>) is returned.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a461f439dbc5dbe6b48df43995d0b4d4c" title="Determines whether a basic block placeholder exists in the CFG.">placeholderExists</a> </dd></dl>

</div>
</div>
<a id="a62394ba2bf95f6d5cc1e3daa218fc548" name="a62394ba2bf95f6d5cc1e3daa218fc548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62394ba2bf95f6d5cc1e3daa218fc548">&#9670;&#160;</a></span>findPlaceholder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::findPlaceholder </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the CFG vertex for a basic block placeholder. </p>
<p>If the CFG contains a basic block placeholder at the specified address then that CFG vertex is returned, otherwise the end vertex (<code>partitioner.cfg().vertices().end()</code>) is returned.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a461f439dbc5dbe6b48df43995d0b4d4c" title="Determines whether a basic block placeholder exists in the CFG.">placeholderExists</a> </dd></dl>

</div>
</div>
<a id="a913fe4a4e5d9a070340a1feba2880b15" name="a913fe4a4e5d9a070340a1feba2880b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913fe4a4e5d9a070340a1feba2880b15">&#9670;&#160;</a></span>insertPlaceholder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::insertPlaceholder </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a basic-block placeholder. </p>
<p>Inserts a basic block placeholder into the CFG if it does not already exist.</p>
<p>If a new placeholder is inserted, then it represents the starting address of a not-yet-discovered basic block (as far as the CFG/AUM is concerned), and will contain a single incident edge which goes to the special "undiscovered" vertex. The new placeholder does not point to a basic block yet.</p>
<p>If the specified address is the starting address of an instruction that's already attached to the CFG/AUM (but not the start of a basic block) then the existing basic block that owns that instruction is truncated (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a34fda3ccc04a2beb803ebc7af17afd3e">truncateBasicBlock</a>), thereby inserting a new placeholder.</p>
<p>This method returns a pointer to either the existing placeholder (which may already point to an attached basic block) or the new placeholder.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa3859d1f9d482925807e5184f2edc927" name="aa3859d1f9d482925807e5184f2edc927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3859d1f9d482925807e5184f2edc927">&#9670;&#160;</a></span>erasePlaceholder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::erasePlaceholder </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>placeholder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block placeholder from the CFG/AUM. </p>
<p>The specified placeholder (basic block starting address) is removed from the CFG along with its outgoing edges. If the placeholder pointed to a basic block then the basic block is detached from the CFG as if <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abb63857e3fe0a8f26d5455153180ad24">detachBasicBlock</a> had been called. It is an error to attempt to remove a placeholder that has incoming edges that are not self edges (doing so will detach the basic block from the CFG/AUM before throwing an exception).</p>
<p>If the placeholder pointed to a discovered basic block then that basic block is returned, otherwise the null pointer is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad20c089a88177962e1cbf61ae6cbaae8" name="ad20c089a88177962e1cbf61ae6cbaae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20c089a88177962e1cbf61ae6cbaae8">&#9670;&#160;</a></span>erasePlaceholder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::erasePlaceholder </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block placeholder from the CFG/AUM. </p>
<p>The specified placeholder (basic block starting address) is removed from the CFG along with its outgoing edges. If the placeholder pointed to a basic block then the basic block is detached from the CFG as if <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#abb63857e3fe0a8f26d5455153180ad24">detachBasicBlock</a> had been called. It is an error to attempt to remove a placeholder that has incoming edges that are not self edges (doing so will detach the basic block from the CFG/AUM before throwing an exception).</p>
<p>If the placeholder pointed to a discovered basic block then that basic block is returned, otherwise the null pointer is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a83d233223c0b28d62f954a6e05f7d1c6" name="a83d233223c0b28d62f954a6e05f7d1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d233223c0b28d62f954a6e05f7d1c6">&#9670;&#160;</a></span>basicBlockSemanticsAutoDrop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockSemanticsAutoDrop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Automatically drop semantics for attached basic blocks. </p>
<p>Basic blocks normally cache their semantic state as they're being discovered so that the state does not need to be recomputed from the beginning of the block each time a new instruction is appended. However, caching this information can consume a large number of symbolic expression nodes which are seldom needed once the basic block is fully discovered. Therefore, setting this property to true will cause a basic block's semantic information to be forgotten as soon as the basic block is attached to the CFG.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a13fa8cdfad165056410c6ba442d08baa" title="Immediately drop semantic information for all attached basic blocks.">basicBlockDropSemantics</a> </dd></dl>

</div>
</div>
<a id="ae6d19f795095e94ac99684eaa9fced25" name="ae6d19f795095e94ac99684eaa9fced25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d19f795095e94ac99684eaa9fced25">&#9670;&#160;</a></span>basicBlockSemanticsAutoDrop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockSemanticsAutoDrop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Automatically drop semantics for attached basic blocks. </p>
<p>Basic blocks normally cache their semantic state as they're being discovered so that the state does not need to be recomputed from the beginning of the block each time a new instruction is appended. However, caching this information can consume a large number of symbolic expression nodes which are seldom needed once the basic block is fully discovered. Therefore, setting this property to true will cause a basic block's semantic information to be forgotten as soon as the basic block is attached to the CFG.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a13fa8cdfad165056410c6ba442d08baa" title="Immediately drop semantic information for all attached basic blocks.">basicBlockDropSemantics</a> </dd></dl>

</div>
</div>
<a id="a13fa8cdfad165056410c6ba442d08baa" name="a13fa8cdfad165056410c6ba442d08baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fa8cdfad165056410c6ba442d08baa">&#9670;&#160;</a></span>basicBlockDropSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockDropSemantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately drop semantic information for all attached basic blocks. </p>
<p>Semantic information for all attached basic blocks is immediately forgotten by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#a8b365a03211eaee8481bfa81c95d10a2">BasicBlock::dropSemantics</a>. It can be recomputed later if necessary.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a83d233223c0b28d62f954a6e05f7d1c6" title="Property: Automatically drop semantics for attached basic blocks.">basicBlockSemanticsAutoDrop</a> </dd></dl>

</div>
</div>
<a id="ac50f53faa1340930e8fc0fb38fa57407" name="ac50f53faa1340930e8fc0fb38fa57407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50f53faa1340930e8fc0fb38fa57407">&#9670;&#160;</a></span>nBasicBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nBasicBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of basic blocks attached to the CFG/AUM. </p>
<p>This method returns the number of CFG vertices that are more than mere placeholders in that they point to an actual, discovered basic block.</p>
<p>This operation is linear in the number of vertices in the CFG. Consider using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4fca6e7da80bc9ed21e53cf26f01dde4">nPlaceholders</a> instead.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a548d98c3c7a2ba1f9b46b8cefdcab29d" name="a548d98c3c7a2ba1f9b46b8cefdcab29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548d98c3c7a2ba1f9b46b8cefdcab29d">&#9670;&#160;</a></span>basicBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all basic blocks attached to the CFG. </p>
<p>The returned list contains distinct basic blocks sorted by their starting address.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a8fb6c37daaa98a72b4c09a885fca51f0" title="Returns basic blocks that overlap with specified address interval.">basicBlocksOverlapping</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3ea4fd3a9e64c12144b2195f1c1dc94b">basicBlocksSpanning</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0d2fd7c47884b75e50501698000ce68d">basicBlocksContainedIn</a> </dd></dl>

</div>
</div>
<a id="a66a97e2e317e4c4c9886f7603c0297a0" name="a66a97e2e317e4c4c9886f7603c0297a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a97e2e317e4c4c9886f7603c0297a0">&#9670;&#160;</a></span>basicBlockExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a discovered basic block exists in the CFG/AUM. </p>
<p>If the CFG/AUM contains a basic block that starts at the specified address then a pointer to that basic block is returned, otherwise a null pointer is returned. A null pointer is returned if the CFG contains only a placeholder vertex for a basic block at the specified address.</p>
<p>If a basic block pointer is specified instead of an address, the return value will be the same pointer if the specified basic block is attached to the CFG/AUM, otherwise the null pointer is returned. It is not sufficient for the CFG/AUM to contain a basic block at the same starting address &ndash; it must be the same actual basic block object. If you're only looking for a similar (i.e., starting at the same address) basic block then use the version that takes an address:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BasicBlock::Ptr</a> original = ...;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BasicBlock::Ptr</a> similar = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a66a97e2e317e4c4c9886f7603c0297a0">basicBlockExists</a>(original-&gt;address());</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_html_a66a97e2e317e4c4c9886f7603c0297a0"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a66a97e2e317e4c4c9886f7603c0297a0">Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockExists</a></div><div class="ttdeci">BasicBlockPtr basicBlockExists(rose_addr_t startVa) const</div><div class="ttdoc">Determines whether a discovered basic block exists in the CFG/AUM.</div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; BasicBlock &gt;</a></div></div>
</div><!-- fragment --><p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a461f439dbc5dbe6b48df43995d0b4d4c" title="Determines whether a basic block placeholder exists in the CFG.">placeholderExists</a> </dd></dl>

</div>
</div>
<a id="a5b21967cc3614b7ebb6fae45eb89910a" name="a5b21967cc3614b7ebb6fae45eb89910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b21967cc3614b7ebb6fae45eb89910a">&#9670;&#160;</a></span>basicBlockExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a discovered basic block exists in the CFG/AUM. </p>
<p>If the CFG/AUM contains a basic block that starts at the specified address then a pointer to that basic block is returned, otherwise a null pointer is returned. A null pointer is returned if the CFG contains only a placeholder vertex for a basic block at the specified address.</p>
<p>If a basic block pointer is specified instead of an address, the return value will be the same pointer if the specified basic block is attached to the CFG/AUM, otherwise the null pointer is returned. It is not sufficient for the CFG/AUM to contain a basic block at the same starting address &ndash; it must be the same actual basic block object. If you're only looking for a similar (i.e., starting at the same address) basic block then use the version that takes an address:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BasicBlock::Ptr</a> original = ...;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BasicBlock::Ptr</a> similar = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a66a97e2e317e4c4c9886f7603c0297a0">basicBlockExists</a>(original-&gt;address());</div>
</div><!-- fragment --><p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a461f439dbc5dbe6b48df43995d0b4d4c" title="Determines whether a basic block placeholder exists in the CFG.">placeholderExists</a> </dd></dl>

</div>
</div>
<a id="a8fb6c37daaa98a72b4c09a885fca51f0" name="a8fb6c37daaa98a72b4c09a885fca51f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb6c37daaa98a72b4c09a885fca51f0">&#9670;&#160;</a></span>basicBlocksOverlapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlocksOverlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns basic blocks that overlap with specified address interval. </p>
<p>Returns a sorted list of distinct basic blocks that are attached to the CFG/AUM and which overlap at least one byte in the specified address interval. By "overlap" we mean that the basic block has at least one instruction that overlaps with the specified interval. An instruction overlaps the interval if any of its bytes are within the interval.</p>
<p>The returned list of basic blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a3ea4fd3a9e64c12144b2195f1c1dc94b" name="a3ea4fd3a9e64c12144b2195f1c1dc94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea4fd3a9e64c12144b2195f1c1dc94b">&#9670;&#160;</a></span>basicBlocksSpanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlocksSpanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns basic blocks that span an entire address interval. </p>
<p>Returns a sorted list of distinct basic blocks that are attached to the CFG/AUM and which span the entire specified interval. In order for a basic block to span an interval its set of instructions must span the interval. In other words, the union of the addresses of the bytes contained in all the basic block's instructions is a superset of the specified interval.</p>
<p>The returned list of basic blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a0d2fd7c47884b75e50501698000ce68d" name="a0d2fd7c47884b75e50501698000ce68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2fd7c47884b75e50501698000ce68d">&#9670;&#160;</a></span>basicBlocksContainedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlocksContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns basic blocks that are fully contained in an address interval. </p>
<p>Returns a sorted list of distinct basic blocks that are attached to the CFG/AUM and which are fully contained within the specified interval. In order to be fully contained in the interval, the union of the addresses of the bytes in the basic block's instructions must be a subset of the specified interval.</p>
<p>The returned list of basic blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a085c79835c73723e4de338621a546e17" name="a085c79835c73723e4de338621a546e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085c79835c73723e4de338621a546e17">&#9670;&#160;</a></span>basicBlockContainingInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockContainingInstruction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>insnVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the basic block that contains a specific instruction address. </p>
<p>Returns the basic block that contains an instruction that starts at the specified address, or null if no such instruction or basic block exists in the CFG/AUM.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a020a008c3121d4f64860ee65fb0e8c69" name="a020a008c3121d4f64860ee65fb0e8c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020a008c3121d4f64860ee65fb0e8c69">&#9670;&#160;</a></span>basicBlockInstructionExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockInstructionExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by basic block instructions. </p>
<p>Returns an interval set which is the union of the addresses of the bytes in the basic block's instructions. Most basic blocks are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE. ROSE only requires that the global control flow graph has edges that enter at only the initial instruction of the basic block and exit only from its final instruction. The instructions need not be contiguous or non-overlapping.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a4e966711e35a11ef9f0d0c159a11c1f5" name="a4e966711e35a11ef9f0d0c159a11c1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e966711e35a11ef9f0d0c159a11c1f5">&#9670;&#160;</a></span>basicBlockDataExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockDataExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by basic block data. </p>
<p>Returns an interval set which is the union of the extents for each data block referenced by this basic block.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="abb63857e3fe0a8f26d5455153180ad24" name="abb63857e3fe0a8f26d5455153180ad24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb63857e3fe0a8f26d5455153180ad24">&#9670;&#160;</a></span>detachBasicBlock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::detachBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a basic block from the CFG/AUM. </p>
<p>The specified basic block is detached from the CFG/AUM, leaving only a placeholder in its place. The original outgoing edges in the CFG are replaced by a single edge from the placeholder to the special "undiscovered" vertex. The instructions that had been attached to the CFG/AUM on behalf of the basic block are also detached from the CFG/AUM.</p>
<p>Any data blocks owned by this attached basic block will have their ownership counts decremented, and those data blocks whose attached owner counts reach zero are detached from the CFG/AUM.</p>
<p>This function does not modify the basic block itself; it only detaches it from the CFG/AUM. A basic block that is attached to the CFG/AUM is in a frozen state and cannot be modified directly, so one use of this function is to allow the user to modify a basic block and then re-attach it to the CFG/AUM. Detaching an already-detached basic block is a no-op.</p>
<p>This method returns a pointer to the basic block so it can be manipulated by the user after it is detached. If the user specified a basic block pointer to start with, then the return value is this same pointer; this function does nothing if the basic block was already detached. If the basic block was specified by its starting address and the CFG/AUM has no record of such a block then a null pointer is returned.</p>
<p>In order to completely remove a basic block, including its placeholder, use <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa3859d1f9d482925807e5184f2edc927">erasePlaceholder</a>.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a892fc63e9b892c3d34ffa20e93af847c" name="a892fc63e9b892c3d34ffa20e93af847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892fc63e9b892c3d34ffa20e93af847c">&#9670;&#160;</a></span>detachBasicBlock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::detachBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>basicBlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a basic block from the CFG/AUM. </p>
<p>The specified basic block is detached from the CFG/AUM, leaving only a placeholder in its place. The original outgoing edges in the CFG are replaced by a single edge from the placeholder to the special "undiscovered" vertex. The instructions that had been attached to the CFG/AUM on behalf of the basic block are also detached from the CFG/AUM.</p>
<p>Any data blocks owned by this attached basic block will have their ownership counts decremented, and those data blocks whose attached owner counts reach zero are detached from the CFG/AUM.</p>
<p>This function does not modify the basic block itself; it only detaches it from the CFG/AUM. A basic block that is attached to the CFG/AUM is in a frozen state and cannot be modified directly, so one use of this function is to allow the user to modify a basic block and then re-attach it to the CFG/AUM. Detaching an already-detached basic block is a no-op.</p>
<p>This method returns a pointer to the basic block so it can be manipulated by the user after it is detached. If the user specified a basic block pointer to start with, then the return value is this same pointer; this function does nothing if the basic block was already detached. If the basic block was specified by its starting address and the CFG/AUM has no record of such a block then a null pointer is returned.</p>
<p>In order to completely remove a basic block, including its placeholder, use <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa3859d1f9d482925807e5184f2edc927">erasePlaceholder</a>.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ac12c8fd94109e339dd618dd82204d98a" name="ac12c8fd94109e339dd618dd82204d98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12c8fd94109e339dd618dd82204d98a">&#9670;&#160;</a></span>detachBasicBlock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::detachBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>placeholder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a basic block from the CFG/AUM. </p>
<p>The specified basic block is detached from the CFG/AUM, leaving only a placeholder in its place. The original outgoing edges in the CFG are replaced by a single edge from the placeholder to the special "undiscovered" vertex. The instructions that had been attached to the CFG/AUM on behalf of the basic block are also detached from the CFG/AUM.</p>
<p>Any data blocks owned by this attached basic block will have their ownership counts decremented, and those data blocks whose attached owner counts reach zero are detached from the CFG/AUM.</p>
<p>This function does not modify the basic block itself; it only detaches it from the CFG/AUM. A basic block that is attached to the CFG/AUM is in a frozen state and cannot be modified directly, so one use of this function is to allow the user to modify a basic block and then re-attach it to the CFG/AUM. Detaching an already-detached basic block is a no-op.</p>
<p>This method returns a pointer to the basic block so it can be manipulated by the user after it is detached. If the user specified a basic block pointer to start with, then the return value is this same pointer; this function does nothing if the basic block was already detached. If the basic block was specified by its starting address and the CFG/AUM has no record of such a block then a null pointer is returned.</p>
<p>In order to completely remove a basic block, including its placeholder, use <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aa3859d1f9d482925807e5184f2edc927">erasePlaceholder</a>.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a34fda3ccc04a2beb803ebc7af17afd3e" name="a34fda3ccc04a2beb803ebc7af17afd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fda3ccc04a2beb803ebc7af17afd3e">&#9670;&#160;</a></span>truncateBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph::VertexIterator Rose::BinaryAnalysis::Partitioner2::Partitioner::truncateBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>basicBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"><em>insn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate an attached basic-block. </p>
<p>The specified block is modified so that its final instruction is the instruction immediately prior to the specified instruction, a new placeholder vertex is created with the address of the specified instruction, and an edge is created from the truncated block to the new placeholder. All other outgoing edges of the truncated block are erased.</p>
<p>The specified block must exist and the instruction must not be the first instruction of the basic block. If the basic block contains the specified instruction then the block is split and a pointer to the new block returned. Otherwise a CFG vertex end iterator is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9083c0451c518e1f5d3fffab124fd31b" name="a9083c0451c518e1f5d3fffab124fd31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9083c0451c518e1f5d3fffab124fd31b">&#9670;&#160;</a></span>attachBasicBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::attachBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a basic block to the CFG/AUM. </p>
<p>The specified basic block is inserted into the CFG/AUM. If the CFG already has a placeholder for the block then the specified block is stored at that placeholder, otherwise a new placeholder is created first. A basic block cannot be attached if the CFG/AUM already knows about a different basic block at the same address. Attempting to attach a block which is already attached is allowed, and is a no-op. It is an error to specify a null pointer for the basic block.</p>
<p>If the basic block owns any data blocks, those data blocks are also attached to the partitioner.</p>
<p>The basic block's cached successors are consulted when creating the new edges in the CFG. The block's successor types are used as-is except for the following modifications:</p>
<ul>
<li>If the basic block is a function call and none of the successors are labeled as function calls (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) then all normal successors (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>) create function call edges in the CFG.</li>
</ul>
<ul>
<li>If the basic block is a function call and it has no call-return successor (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) and this partitioner's autoAddCallReturnEdges property is true then a may-return analysis is performed on each callee and a call-return edge is added if any callee could return. If the analysis is indeterminate then an edge is added if this partitioner's assumeCallsReturn property is true.</li>
</ul>
<ul>
<li>If the basic block is a function return and has no function return successor (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6">E_FUNCTION_RETURN</a>, which normally is a symbolic address) then all normal successors (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>) create function return edges in the CFG.</li>
</ul>
<p>New placeholder vertices will be created automatically for new CFG edges that don't target an existing vertex.</p>
<p>A placeholder can be specified for better efficiency, in which case the placeholder must have the same address as the basic block.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a64f32461b9b251756b60703ceeb8ba7d" name="a64f32461b9b251756b60703ceeb8ba7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f32461b9b251756b60703ceeb8ba7d">&#9670;&#160;</a></span>attachBasicBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::attachBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>placeholder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a basic block to the CFG/AUM. </p>
<p>The specified basic block is inserted into the CFG/AUM. If the CFG already has a placeholder for the block then the specified block is stored at that placeholder, otherwise a new placeholder is created first. A basic block cannot be attached if the CFG/AUM already knows about a different basic block at the same address. Attempting to attach a block which is already attached is allowed, and is a no-op. It is an error to specify a null pointer for the basic block.</p>
<p>If the basic block owns any data blocks, those data blocks are also attached to the partitioner.</p>
<p>The basic block's cached successors are consulted when creating the new edges in the CFG. The block's successor types are used as-is except for the following modifications:</p>
<ul>
<li>If the basic block is a function call and none of the successors are labeled as function calls (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) then all normal successors (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>) create function call edges in the CFG.</li>
</ul>
<ul>
<li>If the basic block is a function call and it has no call-return successor (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) and this partitioner's autoAddCallReturnEdges property is true then a may-return analysis is performed on each callee and a call-return edge is added if any callee could return. If the analysis is indeterminate then an edge is added if this partitioner's assumeCallsReturn property is true.</li>
</ul>
<ul>
<li>If the basic block is a function return and has no function return successor (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9aa8198f2b222aec4a6c4665d37432bde6">E_FUNCTION_RETURN</a>, which normally is a symbolic address) then all normal successors (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>) create function return edges in the CFG.</li>
</ul>
<p>New placeholder vertices will be created automatically for new CFG edges that don't target an existing vertex.</p>
<p>A placeholder can be specified for better efficiency, in which case the placeholder must have the same address as the basic block.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a41100afc7155355c5dea909016f156c5" name="a41100afc7155355c5dea909016f156c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41100afc7155355c5dea909016f156c5">&#9670;&#160;</a></span>discoverBasicBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover instructions for a detached basic block. </p>
<p>Obtains a basic block and its instructions without modifying the control flow graph. If the basic block already exists in the CFG/AUM then that block is returned, otherwise a new block is created but not added to the CFG/AUM. A basic block is created by adding one instruction at a time until one of the following conditions is met (tested in this order):</p>
<ul>
<li>An instruction could not be obtained from the instruction provider via <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2391a325e084b2f001b2e450d6b2b181">discoverInstruction</a>. The instruction provider should return null only if the address is not mapped with execute permission or is improperly aligned for the architecture. The basic block's final instruction is the previous instruction, if any. If the block is empty then it is said to be non-existing, and will have a special successor when added to the CFG.</li>
</ul>
<ul>
<li>The instruction is an "unknown" instruction. The instruction provider returns an unknown instruction if it isn't able to disassemble an instruction at the specified address but the address is mapped with execute permission and the address was properly aligned. The partitioner treats this "unknown" instruction as a valid instruction with indeterminate successors (see below) and no semantics.</li>
</ul>
<ul>
<li>Note: at this point the user-defined basic block successors callbacks are invoked. They can query characteristics of the basic block, adjust the basic block successor cache (see below) and other characteristics of the block, and write values into a results structure that is used by some of the subsequent block termination conditions.</li>
</ul>
<ul>
<li>The instruction has a concrete successor address that is an address of a non-initial instruction in this block. Basic blocks cannot have a non-initial instruction with more than one incoming edge, therefore we've already added too many instructions to this block. We could proceed two ways: (A) We could throw away this instruction with the back-edge successor and make the block terminate at the previous instruction. This causes the basic block to be as big as possible for as long as possible, which is a good thing if it is determined later that the instruction with the back-edge is not reachable anyway. (B) We could truncate the basic block at the back-edge target so that the instruction prior to that is the final instruction. This is good because it converges to a steady state faster, but could result in basic blocks that are smaller than optimal. (The current algorithm uses method A.)</li>
</ul>
<ul>
<li>The user-defined basic block callbacks indicated that the block should be terminated. If the callback set the <code>terminate</code> member of the <code>results</code> output argument to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html#af6be690af50f27273f52f9ad130552a6afff21b93876d3bbfb357354cf3d9a4cc">BasicBlockCallback::TERMINATE_NOW</a> or <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html#af6be690af50f27273f52f9ad130552a6ae980aa959f6a81e24631d4dd5417eb13">BasicBlockCallback::TERMINATE_PRIOR</a>, then the current instruction either becomes the final instruction of the basic block, or the prior instruction becomes the final instruction.</li>
</ul>
<ul>
<li>The instruction is the final instruction of the basic block according to configuration information for that block. The basic block is terminated at this instruction.</li>
</ul>
<ul>
<li>The instruction causes this basic block to look like a function call. This instruction becomes the final instruction of the basic block and when the block is inserted into the CFG/AUM the edge will be marked as a function call edge. <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call instructions typically have one successor (the target function, usually concrete, but sometimes indeterminate), but the partitioner may eventually insert a "return" edge into the CFG when this basic block is attached.</li>
</ul>
<ul>
<li>The instruction doesn't have exactly one successor. Basic blocks cannot have a non-final instruction that branches, so this instruction becomes the final instruction.</li>
</ul>
<ul>
<li>The instruction successor is not a constant. If the successor cannot be resolved to a constant then this instruction becomes the final instruction. If this basic block is eventually attached to the CFG/AUM then an edge to the special "indeterminate" vertex will be created.</li>
</ul>
<ul>
<li>The instruction successor is the starting address for the block on which we're working. A basic block's instructions are distinct by definition, so this instruction becomes the final instruction for the block.</li>
</ul>
<ul>
<li>The instruction successor is the starting address of a basic block already in the CFG. This is a common case and probably means that what we discovered earlier is correct.</li>
</ul>
<ul>
<li>The instruction successor is an instruction already in the CFG other than in the conflict block. A "conflict
    block" is the basic block, if any, that contains as a non-first instruction the first instruction of this block. If the first instruction of the block being discovered is an instruction in the middle of some other basic block in the CFG, then we allow this block to use some of the same instructions as in the conflict block and we do not terminate construction of this block at this time. Usually what happens is the block being discovered uses all the final instructions from the conflict block; an exception is when an opaque predicate in the conflicting block is no longer opaque in the new block. Eventually if the new block is attached to the CFG/AUM then the conflict block will be truncated. When there is no conflict block then this instruction becomes the final instruction of the basic block.</li>
</ul>
<h1><a class="anchor" id="successors"></a>
Calculation of control flow successors</h1>
<p>The basic block has a list of successor addresses and control flow edge types, but these are not added to the partitioner's CFG until the basic block is attached. A basic block's successor list can come from three places:</p>
<ul>
<li>A block's successor list is initialized according to the final instruction. This list can be based on instruction pattern or semantic information for the entire block up to that point.</li>
</ul>
<ul>
<li>Basic block callbacks are allowed to adjust or replace the block's successor list.</li>
</ul>
<ul>
<li>If the configuration file has a successor list then that list is used. The list only applies if the configuration for the basic block also specifies a final instruction address and that address matches the current final instruction of the basic block.</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ab23ec10529a0bfd96613355677833833" name="ab23ec10529a0bfd96613355677833833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23ec10529a0bfd96613355677833833">&#9670;&#160;</a></span>discoverBasicBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>placeholder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover instructions for a detached basic block. </p>
<p>Obtains a basic block and its instructions without modifying the control flow graph. If the basic block already exists in the CFG/AUM then that block is returned, otherwise a new block is created but not added to the CFG/AUM. A basic block is created by adding one instruction at a time until one of the following conditions is met (tested in this order):</p>
<ul>
<li>An instruction could not be obtained from the instruction provider via <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2391a325e084b2f001b2e450d6b2b181">discoverInstruction</a>. The instruction provider should return null only if the address is not mapped with execute permission or is improperly aligned for the architecture. The basic block's final instruction is the previous instruction, if any. If the block is empty then it is said to be non-existing, and will have a special successor when added to the CFG.</li>
</ul>
<ul>
<li>The instruction is an "unknown" instruction. The instruction provider returns an unknown instruction if it isn't able to disassemble an instruction at the specified address but the address is mapped with execute permission and the address was properly aligned. The partitioner treats this "unknown" instruction as a valid instruction with indeterminate successors (see below) and no semantics.</li>
</ul>
<ul>
<li>Note: at this point the user-defined basic block successors callbacks are invoked. They can query characteristics of the basic block, adjust the basic block successor cache (see below) and other characteristics of the block, and write values into a results structure that is used by some of the subsequent block termination conditions.</li>
</ul>
<ul>
<li>The instruction has a concrete successor address that is an address of a non-initial instruction in this block. Basic blocks cannot have a non-initial instruction with more than one incoming edge, therefore we've already added too many instructions to this block. We could proceed two ways: (A) We could throw away this instruction with the back-edge successor and make the block terminate at the previous instruction. This causes the basic block to be as big as possible for as long as possible, which is a good thing if it is determined later that the instruction with the back-edge is not reachable anyway. (B) We could truncate the basic block at the back-edge target so that the instruction prior to that is the final instruction. This is good because it converges to a steady state faster, but could result in basic blocks that are smaller than optimal. (The current algorithm uses method A.)</li>
</ul>
<ul>
<li>The user-defined basic block callbacks indicated that the block should be terminated. If the callback set the <code>terminate</code> member of the <code>results</code> output argument to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html#af6be690af50f27273f52f9ad130552a6afff21b93876d3bbfb357354cf3d9a4cc">BasicBlockCallback::TERMINATE_NOW</a> or <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html#af6be690af50f27273f52f9ad130552a6ae980aa959f6a81e24631d4dd5417eb13">BasicBlockCallback::TERMINATE_PRIOR</a>, then the current instruction either becomes the final instruction of the basic block, or the prior instruction becomes the final instruction.</li>
</ul>
<ul>
<li>The instruction is the final instruction of the basic block according to configuration information for that block. The basic block is terminated at this instruction.</li>
</ul>
<ul>
<li>The instruction causes this basic block to look like a function call. This instruction becomes the final instruction of the basic block and when the block is inserted into the CFG/AUM the edge will be marked as a function call edge. <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call instructions typically have one successor (the target function, usually concrete, but sometimes indeterminate), but the partitioner may eventually insert a "return" edge into the CFG when this basic block is attached.</li>
</ul>
<ul>
<li>The instruction doesn't have exactly one successor. Basic blocks cannot have a non-final instruction that branches, so this instruction becomes the final instruction.</li>
</ul>
<ul>
<li>The instruction successor is not a constant. If the successor cannot be resolved to a constant then this instruction becomes the final instruction. If this basic block is eventually attached to the CFG/AUM then an edge to the special "indeterminate" vertex will be created.</li>
</ul>
<ul>
<li>The instruction successor is the starting address for the block on which we're working. A basic block's instructions are distinct by definition, so this instruction becomes the final instruction for the block.</li>
</ul>
<ul>
<li>The instruction successor is the starting address of a basic block already in the CFG. This is a common case and probably means that what we discovered earlier is correct.</li>
</ul>
<ul>
<li>The instruction successor is an instruction already in the CFG other than in the conflict block. A "conflict
    block" is the basic block, if any, that contains as a non-first instruction the first instruction of this block. If the first instruction of the block being discovered is an instruction in the middle of some other basic block in the CFG, then we allow this block to use some of the same instructions as in the conflict block and we do not terminate construction of this block at this time. Usually what happens is the block being discovered uses all the final instructions from the conflict block; an exception is when an opaque predicate in the conflicting block is no longer opaque in the new block. Eventually if the new block is attached to the CFG/AUM then the conflict block will be truncated. When there is no conflict block then this instruction becomes the final instruction of the basic block.</li>
</ul>
<h1><a class="anchor" id="successors"></a>
Calculation of control flow successors</h1>
<p>The basic block has a list of successor addresses and control flow edge types, but these are not added to the partitioner's CFG until the basic block is attached. A basic block's successor list can come from three places:</p>
<ul>
<li>A block's successor list is initialized according to the final instruction. This list can be based on instruction pattern or semantic information for the entire block up to that point.</li>
</ul>
<ul>
<li>Basic block callbacks are allowed to adjust or replace the block's successor list.</li>
</ul>
<ul>
<li>If the configuration file has a successor list then that list is used. The list only applies if the configuration for the basic block also specifies a final instruction address and that address matches the current final instruction of the basic block.</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a21998ac655174b36cd99d86e3245124f" name="a21998ac655174b36cd99d86e3245124f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21998ac655174b36cd99d86e3245124f">&#9670;&#160;</a></span>basicBlockSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a7595093daccb663b9934aa6264656473">BasicBlockSuccessors</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockSuccessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9dace">Precision::Level</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9daceaf7800da878cbb81a92cf4e9927b8a41e">Precision::HIGH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine successors for a basic block. </p>
<p>Basic block successors are returned as a vector in no particular order. This method returns the most basic successors; for instance, function call instructions will have an edge for the called function but no edge for the return. The basic block holds a successor cache which is consulted/updated by this method.</p>
<p>If <code>precision</code> is <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9daceaf7800da878cbb81a92cf4e9927b8a41e">Precision::HIGH</a>, then use instruction semantics if they're available. Otherwise, use a more naive method that usually works fine for most architectures with code generated by mainstream compilers. Low precision is substantially faster than high precision.</p>
<p>The basic block need not be complete or attached to the CFG/AUM. A basic block that has no instructions has no successors.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9dd59f9041a958f40b4c87a73353eecf" name="a9dd59f9041a958f40b4c87a73353eecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd59f9041a958f40b4c87a73353eecf">&#9670;&#160;</a></span>basicBlockConcreteSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockConcreteSuccessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isComplete</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines concrete successors for a basic block. </p>
<p>Returns a vector of distinct, concrete successor addresses. <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Semantics.html" title="Instruction semantics for the partitioner.">Semantics</a> is identical to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a21998ac655174b36cd99d86e3245124f">basicBlockSuccessors</a> except non-concrete values are removed from the list. The optional <code>isComplete</code> argument is set to true or false depending on whether the set of returned concrete successors represents the complete set of successors (true) or some member in the complete set is not concrete (false).</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2fdc3ba0da480b23169e0a7163e70660" name="a2fdc3ba0da480b23169e0a7163e70660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc3ba0da480b23169e0a7163e70660">&#9670;&#160;</a></span>basicBlockGhostSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockGhostSuccessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine ghost successors for a basic block. </p>
<p>The ghost successors of a basic block are those addresses where control could have naively flowed had we looked only at individual instructions rather than entire basic blocks. When a whole basic block is examined, the predicate of a conditional branch instruction might be determined to be constant, in which case the branch becomes unconditional, and the non-taken side of the branch becomes a ghost successor. Ghost successors are addresses rather than basic blocks (although they can be easily turned into basic blocks if desired), and can originate from any instruction within a basic block.</p>
<p>The basic block need not be complete and need not be attached to a CFG/AUM, although the specified pointer must not be null. A basic block that has no instructions has no ghost successors. The true successors are not included in the list of ghost successors. The basic block holds a ghost successor cache which is consulted/updated by this method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6401d85f0681febea9fabcca58c9850b" name="a6401d85f0681febea9fabcca58c9850b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6401d85f0681febea9fabcca58c9850b">&#9670;&#160;</a></span>basicBlockIsFunctionCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockIsFunctionCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9dace">Precision::Level</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Precision.html#a7d42b6f74dc747058ffae453dcd9daceaf7800da878cbb81a92cf4e9927b8a41e">Precision::HIGH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a basic block looks like a function call. </p>
<p>If the basic block appears to be a function call by some analysis then this function returns true. The analysis may use instruction semantics to look at the stack, it may look at the kind of instructions in the block, it may look for patterns at the callee address if known, etc. The basic block caches the result of this analysis.</p>
<p>If the analysis cannot prove that the block is a function call, then returns false.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a086e6f39e99322ef483b46305bc9ad73" name="a086e6f39e99322ef483b46305bc9ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e6f39e99322ef483b46305bc9ad73">&#9670;&#160;</a></span>basicBlockIsFunctionReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockIsFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a basic block looks like a function return. </p>
<p>If the basic block appears by some analysis to be a return from a function call, then this function returns true. The anlaysis may use instruction semantics to look at the stack, it may look at the kind of instructions in the lbock, it may look for patterns, etc. The basic block caches the result of this analysis.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="accb1010bf2d016f2ede8259420c881d3" name="accb1010bf2d016f2ede8259420c881d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb1010bf2d016f2ede8259420c881d3">&#9670;&#160;</a></span>basicBlockPopsStack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockPopsStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the basic block pops at least one byte from the stack. </p>
<p>Returns true if the basic block has a net effect of popping at least one byte from the stack compared to the original stack pointer. Returns false if the block does not pop or its behavior cannot be determined. </p>

</div>
</div>
<a id="afef2b31b31a4a0b0d96d5b04ea6c17e9" name="afef2b31b31a4a0b0d96d5b04ea6c17e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef2b31b31a4a0b0d96d5b04ea6c17e9">&#9670;&#160;</a></span>basicBlockStackDeltaIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockStackDeltaIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stack delta expression. </p>
<p>The stack delta is the value of the stack pointer register at the entrance to the specified block minus the stack delta at the entry point of the function. The function entry point stack delta is zero; the return address pushed onto the stack by the caller is attributed to the caller, and popping the return address during the callee's return is attributed to the callee. Thus, most functions that use a caller-cleans-up-args ABI will have a stack delta equal to the size of the return address, and that delta will be positive for stacks that grow down, and negative for stacks that grow up.</p>
<p>The resulting stack delta can be four different kinds of values:</p>
<ul>
<li>Never-computed is indicated by the basic block not caching any value for the stack delta. This method will always attempt to compute a stack delta if none is cached in the basic block.</li>
</ul>
<ul>
<li>Error is indicated by a cached null expression. Errors are usually due to a reachable basic block that contains an instruction for which semantics are not known.</li>
</ul>
<ul>
<li>Constant offset, for which the <code>toInteger</code> predicate applied to the return value is true. I.e., the delta is a concrete value fits in a 64-bit signed integer.</li>
</ul>
<ul>
<li>Top, indicated by a non-null return value for which <code>toInteger</code> is false. This results when two or more paths through the control flow graph result in different constant offsets. It can also occur when the algebraic simplifications that are built into ROSE fail to simplify a constant expression.</li>
</ul>
<p>Two stack deltas are computed for each basic block: the stack delta at the start of the block and the start delta at the end of the block, returned by the "in" and "out" variants of this method, respectively. Since basic blocks can be shared among multiple functions and have a different delta in each, a function context must be provided as an argument.</p>
<p>Since stack deltas use the control flow graph during the analysis, the specified basic block and function must be attached to the CFG/AUM before calling this method. Also, since predefined stack deltas are based on function names, function calls must be to basic blocks that are attached to a function. Note that currently (Dec 2014) PE thunks transfering to a non-linked dynamic function are given names by <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe.html#a0812112b3c883a423796272ab1e28fd2">ModulesPe::nameImportThunks</a>, which runs after all basic blocks and functions have been discovered and attached to the CFG/AUM.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a17491f0dd52a1367f0c907dbd49fcb89" title="Stack delta analysis for one function.">functionStackDelta</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4b47d70e1a381ce795dae84ed4065e92">allFunctionStackDelta</a> </dd></dl>

</div>
</div>
<a id="ab081575b668b12bfd718f375b249e925" name="ab081575b668b12bfd718f375b249e925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab081575b668b12bfd718f375b249e925">&#9670;&#160;</a></span>basicBlockStackDeltaOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockStackDeltaOut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stack delta expression. </p>
<p>The stack delta is the value of the stack pointer register at the entrance to the specified block minus the stack delta at the entry point of the function. The function entry point stack delta is zero; the return address pushed onto the stack by the caller is attributed to the caller, and popping the return address during the callee's return is attributed to the callee. Thus, most functions that use a caller-cleans-up-args ABI will have a stack delta equal to the size of the return address, and that delta will be positive for stacks that grow down, and negative for stacks that grow up.</p>
<p>The resulting stack delta can be four different kinds of values:</p>
<ul>
<li>Never-computed is indicated by the basic block not caching any value for the stack delta. This method will always attempt to compute a stack delta if none is cached in the basic block.</li>
</ul>
<ul>
<li>Error is indicated by a cached null expression. Errors are usually due to a reachable basic block that contains an instruction for which semantics are not known.</li>
</ul>
<ul>
<li>Constant offset, for which the <code>toInteger</code> predicate applied to the return value is true. I.e., the delta is a concrete value fits in a 64-bit signed integer.</li>
</ul>
<ul>
<li>Top, indicated by a non-null return value for which <code>toInteger</code> is false. This results when two or more paths through the control flow graph result in different constant offsets. It can also occur when the algebraic simplifications that are built into ROSE fail to simplify a constant expression.</li>
</ul>
<p>Two stack deltas are computed for each basic block: the stack delta at the start of the block and the start delta at the end of the block, returned by the "in" and "out" variants of this method, respectively. Since basic blocks can be shared among multiple functions and have a different delta in each, a function context must be provided as an argument.</p>
<p>Since stack deltas use the control flow graph during the analysis, the specified basic block and function must be attached to the CFG/AUM before calling this method. Also, since predefined stack deltas are based on function names, function calls must be to basic blocks that are attached to a function. Note that currently (Dec 2014) PE thunks transfering to a non-linked dynamic function are given names by <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1ModulesPe.html#a0812112b3c883a423796272ab1e28fd2">ModulesPe::nameImportThunks</a>, which runs after all basic blocks and functions have been discovered and attached to the CFG/AUM.</p>
<p>Thread safety: Not thread safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a17491f0dd52a1367f0c907dbd49fcb89" title="Stack delta analysis for one function.">functionStackDelta</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4b47d70e1a381ce795dae84ed4065e92">allFunctionStackDelta</a> </dd></dl>

</div>
</div>
<a id="a49a009b3d03288f93843a1ddd12d05a4" name="a49a009b3d03288f93843a1ddd12d05a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a009b3d03288f93843a1ddd12d05a4">&#9670;&#160;</a></span>forgetStackDeltas() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::forgetStackDeltas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all cached stack deltas. </p>
<p>Causes all stack deltas for basic blocks and functions that are attached to the CFG/AUM to be forgotten. This is useful if one needs to recompute deltas in light of new information.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2c44b0eef20dd3869c2af43743a029f8" name="a2c44b0eef20dd3869c2af43743a029f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c44b0eef20dd3869c2af43743a029f8">&#9670;&#160;</a></span>forgetStackDeltas() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::forgetStackDeltas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all cached stack deltas. </p>
<p>Causes all stack deltas for basic blocks and functions that are attached to the CFG/AUM to be forgotten. This is useful if one needs to recompute deltas in light of new information.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a245e7d63cb2ae9ae090c6dcbdaea1d67" name="a245e7d63cb2ae9ae090c6dcbdaea1d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245e7d63cb2ae9ae090c6dcbdaea1d67">&#9670;&#160;</a></span>stackDeltaInterproceduralLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::stackDeltaInterproceduralLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: max depth for inter-procedural stack delta analysis. </p>
<p>Stack delta analysis will be interprocedural when this property has a value greater than one. Interprocedural analysis is only used when a called function's stack delta is unknown. Large values for this property will likely be clipped by the actual dataflow implementation.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a24bf7df85e46a95cd47867358136c74d" name="a24bf7df85e46a95cd47867358136c74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bf7df85e46a95cd47867358136c74d">&#9670;&#160;</a></span>stackDeltaInterproceduralLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::stackDeltaInterproceduralLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: max depth for inter-procedural stack delta analysis. </p>
<p>Stack delta analysis will be interprocedural when this property has a value greater than one. Interprocedural analysis is only used when a called function's stack delta is unknown. Large values for this property will likely be clipped by the actual dataflow implementation.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2171b0c875ca1e43a5c8b88565657f40" name="a2171b0c875ca1e43a5c8b88565657f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2171b0c875ca1e43a5c8b88565657f40">&#9670;&#160;</a></span>basicBlockOptionalMayReturn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockOptionalMayReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if part of the CFG can pop the top stack frame. </p>
<p>This analysis enters the CFG at the specified basic block and follows certain edges looking for a basic block where <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a086e6f39e99322ef483b46305bc9ad73">basicBlockIsFunctionReturn</a> returns true. The analysis caches results in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#af52ccc46880a0675733716e9f7c9b3d9">mayReturn</a> property of the reachable basic blocks.</p>
<p>Since the analysis results might change if edges are inserted or erased even on distant basic blocks, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a65d1cfa4d3891d07145ff679dc333581">basicBlockMayReturnReset</a> method can be used to "forget" the property for all basic blocks in the CFG/AUM.</p>
<p>A basic block's may-return property is computed as follows (the first applicable rule wins):</p>
<ul>
<li>If the block is owned by a function and the function's name is present on a whitelist or blacklist then the block's may-return is positive if whitelisted or negative if blacklisted.</li>
</ul>
<ul>
<li>If the block is a non-existing placeholder (i.e. its address is not mapped with execute permission) then its may-return is positive or negative depending on the value of this partitioner's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a814aa15cf8a9e2a64c4eed1f296ee12f">assumeFunctionsReturn</a> property.</li>
</ul>
<ul>
<li>If the block is a function return then the block's may-return is positive.</li>
</ul>
<ul>
<li>If any significant successor (defined below) of the block has a positive may-return value then the block's may-return is also positive.</li>
</ul>
<ul>
<li>If any significant succesor has an indeterminate may-return value, then the block's may-return is also indeterminate.</li>
</ul>
<ul>
<li>The block's may-return is negative.</li>
</ul>
<p>A successor vertex is significant if there exists a significant edge to that vertex using these rules (first rule that applies wins):</p>
<ul>
<li>A self-edge is never signiciant. A self edge does not affect the outcome of the analysis, so they're excluded.</li>
</ul>
<ul>
<li>A function-call edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) is never significant. Even if the called function may return, it doesn't affect whether the block in question may return.</li>
</ul>
<ul>
<li>A call-return edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) is significant if at least one of its sibling function call edges (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) points to a vertex with a positive may-return, or if any sibling function call edge points to a vertex with an indeterminate may-return.</li>
</ul>
<ul>
<li>The edge is significant. This includes edges to the indeterminate and undiscovered vertices, whose may-return is always indeterminate.</li>
</ul>
<p>The algorithm uses a combination of depth-first traversal and recursive calls. If any vertex's may-return is requested recursively while it is being computed, the recursive call returns an indeterminate may-return. Indeterminate results are indicated by returning nothing.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af6f0217d80e014f136ee7b2587db875d" name="af6f0217d80e014f136ee7b2587db875d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f0217d80e014f136ee7b2587db875d">&#9670;&#160;</a></span>basicBlockOptionalMayReturn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockOptionalMayReturn </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if part of the CFG can pop the top stack frame. </p>
<p>This analysis enters the CFG at the specified basic block and follows certain edges looking for a basic block where <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a086e6f39e99322ef483b46305bc9ad73">basicBlockIsFunctionReturn</a> returns true. The analysis caches results in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlock.html#af52ccc46880a0675733716e9f7c9b3d9">mayReturn</a> property of the reachable basic blocks.</p>
<p>Since the analysis results might change if edges are inserted or erased even on distant basic blocks, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a65d1cfa4d3891d07145ff679dc333581">basicBlockMayReturnReset</a> method can be used to "forget" the property for all basic blocks in the CFG/AUM.</p>
<p>A basic block's may-return property is computed as follows (the first applicable rule wins):</p>
<ul>
<li>If the block is owned by a function and the function's name is present on a whitelist or blacklist then the block's may-return is positive if whitelisted or negative if blacklisted.</li>
</ul>
<ul>
<li>If the block is a non-existing placeholder (i.e. its address is not mapped with execute permission) then its may-return is positive or negative depending on the value of this partitioner's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a814aa15cf8a9e2a64c4eed1f296ee12f">assumeFunctionsReturn</a> property.</li>
</ul>
<ul>
<li>If the block is a function return then the block's may-return is positive.</li>
</ul>
<ul>
<li>If any significant successor (defined below) of the block has a positive may-return value then the block's may-return is also positive.</li>
</ul>
<ul>
<li>If any significant succesor has an indeterminate may-return value, then the block's may-return is also indeterminate.</li>
</ul>
<ul>
<li>The block's may-return is negative.</li>
</ul>
<p>A successor vertex is significant if there exists a significant edge to that vertex using these rules (first rule that applies wins):</p>
<ul>
<li>A self-edge is never signiciant. A self edge does not affect the outcome of the analysis, so they're excluded.</li>
</ul>
<ul>
<li>A function-call edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) is never significant. Even if the called function may return, it doesn't affect whether the block in question may return.</li>
</ul>
<ul>
<li>A call-return edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) is significant if at least one of its sibling function call edges (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>) points to a vertex with a positive may-return, or if any sibling function call edge points to a vertex with an indeterminate may-return.</li>
</ul>
<ul>
<li>The edge is significant. This includes edges to the indeterminate and undiscovered vertices, whose may-return is always indeterminate.</li>
</ul>
<p>The algorithm uses a combination of depth-first traversal and recursive calls. If any vertex's may-return is requested recursively while it is being computed, the recursive call returns an indeterminate may-return. Indeterminate results are indicated by returning nothing.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a65d1cfa4d3891d07145ff679dc333581" name="a65d1cfa4d3891d07145ff679dc333581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d1cfa4d3891d07145ff679dc333581">&#9670;&#160;</a></span>basicBlockMayReturnReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockMayReturnReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all may-return properties. </p>
<p>This function is const because it doesn't modify the CFG/AUM; it only removes the may-return property from all the CFG/AUM basic blocks.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a15bf0ff87f9b5fa18780fb7763ea985d" name="a15bf0ff87f9b5fa18780fb7763ea985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bf0ff87f9b5fa18780fb7763ea985d">&#9670;&#160;</a></span>nDataBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nDataBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data blocks attached to the CFG/AUM. </p>
<p>This is a relatively expensive operation compared to querying the number of basic blocks or functions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a8233b76620035a5ccd034640fba7e808" name="a8233b76620035a5ccd034640fba7e808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8233b76620035a5ccd034640fba7e808">&#9670;&#160;</a></span>dataBlockExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a data block or its equivalent is attached to the CFG/AUM. </p>
<p>If the AUM contains the specified data block or an equivalent data block, then return the non-null pointer for the data block that's already present in the AUM. Otherwise return a null pointer.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a483de8dd2e18e32c52d9880e6b6dd619" name="a483de8dd2e18e32c52d9880e6b6dd619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483de8dd2e18e32c52d9880e6b6dd619">&#9670;&#160;</a></span>findBestDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::findBestDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an existing data block. </p>
<p>Finds a data block that spans the specified address interval or which can be extended to span the address interval. The first choice is to return the smallest data block that spans the entire interval; second choice is the largest block that contains the first byte of the interval. If there is a tie in sizes then the block with the highest starting address wins. If no suitable data block can be found then the null pointer is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7b5e45e130f444029bde970df5beb95d" name="a7b5e45e130f444029bde970df5beb95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5e45e130f444029bde970df5beb95d">&#9670;&#160;</a></span>attachDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::attachDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a data block to the CFG/AUM. </p>
<p>Attaches the data block to the CFG/AUM if it is not already attached and there is no equivalent data block already attached. If no equivalent data block exists in the CFG/AUM then the specified block is attached and will have an ownership count of zero since none of its owners are attached (otherwise the data block or an equivalent block would also have been already attached). It is an error to supply a null pointer.</p>
<p>Returns the canonical data block, either one that already existed in the CFG/AUM or the specified data block which is now attached.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9abb4b042b063da9f4c650c01fae42a9" name="a9abb4b042b063da9f4c650c01fae42a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb4b042b063da9f4c650c01fae42a9">&#9670;&#160;</a></span>detachDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::detachDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches a data block from the CFG/AUM. </p>
<p>The specified data block is detached from the CFG/AUM and thawed, and returned so it can be modified. It is an error to attempt to detach a data block which is owned by attached basic blocks or attached functions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="abbce9ff61ad0939cad1de41cbd239017" name="abbce9ff61ad0939cad1de41cbd239017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce9ff61ad0939cad1de41cbd239017">&#9670;&#160;</a></span>attachDataBlockToFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::attachDataBlockToFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a data block to an attached or detached function. </p>
<p>Causes the data block to be owned by the specified function. If the function is attached to this partitioner (i.e., appears in the control flow graph and address usage map) then the specified data block is also attached to this partitioner (if it wasn't already) and will appear in the address usage map.</p>
<p>Returns either the specified data block or an equivalent data block that's already owned by the function.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a838e56822f6c76d086181e7c86b56de0" name="a838e56822f6c76d086181e7c86b56de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838e56822f6c76d086181e7c86b56de0">&#9670;&#160;</a></span>attachDataBlockToBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::attachDataBlockToBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a data block to a basic block. </p>
<p>Causes the data block to be owned by the specified basic block. If the basic block is attached to this partitioner (i.e., appears in the control flow graph and address usage map) then the specified data block is also attached to this partitioner (if it wasn't already) and will appear in the address usage map.</p>
<p>If the basic block already owns a data block with the same starting address and size, then the specified data block is not attached to the basic block.</p>
<p>Returns either the specified data block or an equivalent data block that's already owned by the basic block.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a88e00535c562444fbb4051b2b9379d2b" name="a88e00535c562444fbb4051b2b9379d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e00535c562444fbb4051b2b9379d2b">&#9670;&#160;</a></span>dataBlocksOverlapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlocksOverlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns data blocks that overlap with specified address interval. </p>
<p>Returns a sorted list of distinct data blocks that are attached to the CFG/AUM and which overlap at least one byte in the specified address interval. All bytes represented by the data block are returned, even if they are unused or marked as padding in the data block type.</p>
<p>The returned list of data blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a46cdd95c976b38cccbf7630d86c90d64" name="a46cdd95c976b38cccbf7630d86c90d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cdd95c976b38cccbf7630d86c90d64">&#9670;&#160;</a></span>dataBlocksSpanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlocksSpanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns data blocks that span an entire address interval. </p>
<p>Returns a sorted list of distinct data blocks that are attached to the CFG/AUM and which span the entire specified interval. All bytes represented by the data block are returned, even if they are unused or marked as padding in the data block type.</p>
<p>The returned list of data blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a21e09c6703702f4070f5c4c58d35c63c" name="a21e09c6703702f4070f5c4c58d35c63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e09c6703702f4070f5c4c58d35c63c">&#9670;&#160;</a></span>dataBlocksContainedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlocksContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns data blocks that are fully contained in an address interval. </p>
<p>Returns a sorted list of distinct data blocks that are attached to the CFG/AUM and which are fully contained within the specified interval. All bytes represented by the data block are returned, even if they are unused or marked as padding in the data block type.</p>
<p>The returned list of data blocks are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="afe075dcd9e6aa63476cc87d03218fa65" name="afe075dcd9e6aa63476cc87d03218fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe075dcd9e6aa63476cc87d03218fa65">&#9670;&#160;</a></span>dataBlockExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlockExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a data block. </p>
<p>Returns an address interval describing all addresses of the data block, even if they are unused or marked as padding in the data block type. Since all addresses are returned, the extent of a data block is always contiguous.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad282e79d481b35da9da7ea45a5efb435" name="ad282e79d481b35da9da7ea45a5efb435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad282e79d481b35da9da7ea45a5efb435">&#9670;&#160;</a></span>dataBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of all attached data blocks. </p>
<p>Returns a sorted list of distinct data blocks that are attached to the CFG/AUM.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a55907985af83a80be7c5801d62cc630d" name="a55907985af83a80be7c5801d62cc630d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55907985af83a80be7c5801d62cc630d">&#9670;&#160;</a></span>nFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::nFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of functions attached to the CFG/AUM. </p>
<p>This is a constant-time operation.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a5a8935bf5419d72e34517aa16fac80d0" name="a5a8935bf5419d72e34517aa16fac80d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8935bf5419d72e34517aa16fac80d0">&#9670;&#160;</a></span>functionExists() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionExists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>entryVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a function exists in the CFG/AUM. </p>
<p>If the CFG/AUM knows about the specified function then this method returns a pointer to that function, otherwise it returns the null pointer.</p>
<p>The argument identifies the function for which to search:</p>
<ul>
<li>The function's entry address. </li>
<li>The basic block that serves as the function's entry block. </li>
<li>A function pointer.</li>
</ul>
<p>If the argument is a function pointer then this method checks that the specified function exists in the CFG/AUM and returns the argument if it exists, or else null if it doesn't exist. This test uses the function pointer directly, not the entry address &ndash; it returns non-null only if the argument is the actual function object stored in the CFG/AUM.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="addd073e9715745ce2f8c89c5451b1f8e" name="addd073e9715745ce2f8c89c5451b1f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd073e9715745ce2f8c89c5451b1f8e">&#9670;&#160;</a></span>functionExists() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>entryBlock</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a function exists in the CFG/AUM. </p>
<p>If the CFG/AUM knows about the specified function then this method returns a pointer to that function, otherwise it returns the null pointer.</p>
<p>The argument identifies the function for which to search:</p>
<ul>
<li>The function's entry address. </li>
<li>The basic block that serves as the function's entry block. </li>
<li>A function pointer.</li>
</ul>
<p>If the argument is a function pointer then this method checks that the specified function exists in the CFG/AUM and returns the argument if it exists, or else null if it doesn't exist. This test uses the function pointer directly, not the entry address &ndash; it returns non-null only if the argument is the actual function object stored in the CFG/AUM.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a289f2ffdcb17f03b77ed0d869491d85e" name="a289f2ffdcb17f03b77ed0d869491d85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289f2ffdcb17f03b77ed0d869491d85e">&#9670;&#160;</a></span>functionExists() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a function exists in the CFG/AUM. </p>
<p>If the CFG/AUM knows about the specified function then this method returns a pointer to that function, otherwise it returns the null pointer.</p>
<p>The argument identifies the function for which to search:</p>
<ul>
<li>The function's entry address. </li>
<li>The basic block that serves as the function's entry block. </li>
<li>A function pointer.</li>
</ul>
<p>If the argument is a function pointer then this method checks that the specified function exists in the CFG/AUM and returns the argument if it exists, or else null if it doesn't exist. This test uses the function pointer directly, not the entry address &ndash; it returns non-null only if the argument is the actual function object stored in the CFG/AUM.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa2b81c055800f2148554197443c77902" name="aa2b81c055800f2148554197443c77902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b81c055800f2148554197443c77902">&#9670;&#160;</a></span>functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All functions attached to the CFG/AUM. </p>
<p>Returns a vector of distinct functions sorted by their entry address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2dab5f68f1197c80faf89e4212607bd9" name="a2dab5f68f1197c80faf89e4212607bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dab5f68f1197c80faf89e4212607bd9">&#9670;&#160;</a></span>functionsOverlapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOverlapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns functions that overlap with specified address interval. </p>
<p>Returns a sorted list of distinct functions that are attached to the CFG/AUM and which overlap at least one byte in the specified address interval. By "overlap" we mean that the function owns at least one basic block or data block that overlaps with the interval.</p>
<p>The returned list of funtions are sorted by their entry address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa57d0ee49e8e7f77323ed92a015898bc" name="aa57d0ee49e8e7f77323ed92a015898bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57d0ee49e8e7f77323ed92a015898bc">&#9670;&#160;</a></span>functionsSpanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsSpanning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns functions that span an entire address interval. </p>
<p>Returns a sorted list of distinct functions that are attached to the CFG/AUM and which span the entire specified interval. In order for a function to span the interval its extent must be a superset of the interval. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a>. In other words, the union of all the addresseses represented by the function's basic blocks and data blocks is a superset of the specified interval.</p>
<p>The returned list of functions are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aebdc2a66aa2508f9e07e2e0f01187891" name="aebdc2a66aa2508f9e07e2e0f01187891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc2a66aa2508f9e07e2e0f01187891">&#9670;&#160;</a></span>functionsContainedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns functions that are fully contained in an address interval. </p>
<p>Returns a sorted list of distinct functions that are attached to the CFG/AUM and which are fully contained within the specified interval. In order to be fully contained in the interval, the addresses represented by the function's basic blocks and data blocks must be a subset of the specified interval.</p>
<p>The returned list of functions are sorted by their starting address.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a526858251058ad50fa4d0edf4a1bf58c" name="a526858251058ad50fa4d0edf4a1bf58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526858251058ad50fa4d0edf4a1bf58c">&#9670;&#160;</a></span>functionExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae517a4a06da32ac0824761eb55b2a246" name="ae517a4a06da32ac0824761eb55b2a246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae517a4a06da32ac0824761eb55b2a246">&#9670;&#160;</a></span>functionExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::functionExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af2a5ca131bfb0893bcb3d1852c239606" name="af2a5ca131bfb0893bcb3d1852c239606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a5ca131bfb0893bcb3d1852c239606">&#9670;&#160;</a></span>functionBasicBlockExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionBasicBlockExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ac3cdfa5cf661f8ce005df36036e55040" name="ac3cdfa5cf661f8ce005df36036e55040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cdfa5cf661f8ce005df36036e55040">&#9670;&#160;</a></span>functionBasicBlockExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::functionBasicBlockExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="adee59ca03c6f7d7fb7864cdc19d16046" name="adee59ca03c6f7d7fb7864cdc19d16046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee59ca03c6f7d7fb7864cdc19d16046">&#9670;&#160;</a></span>functionDataBlockExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionDataBlockExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad2bc1e8259580c53e17ecc4158c75204" name="ad2bc1e8259580c53e17ecc4158c75204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bc1e8259580c53e17ecc4158c75204">&#9670;&#160;</a></span>functionDataBlockExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::functionDataBlockExtent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the addresses used by a function. </p>
<p>Returns an interval set which is the union of the addresses of the function's basic blocks and/or data blocks. Most functions are contiguous in memory and can be represented by a single address interval, but this is not a requirement in ROSE.</p>
<p>The versions of these functions that take an AddressIntervalSet argument simply insert additional address intervals into that set without clearing it first.</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a526858251058ad50fa4d0edf4a1bf58c">functionExtent</a> &ndash; addresses of all instructions and static data </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af2a5ca131bfb0893bcb3d1852c239606">functionBasicBlockExtent</a> &ndash; addresses of instructions </li>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#adee59ca03c6f7d7fb7864cdc19d16046">functionDataBlockExtent</a> &ndash; addresses of static data</li>
</ul>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae1ac2f6619db585e2e05730cc5e6d713" name="ae1ac2f6619db585e2e05730cc5e6d713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ac2f6619db585e2e05730cc5e6d713">&#9670;&#160;</a></span>attachFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::attachFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a function to the CFG/AUM. </p>
<p>The indicated function(s) is inserted into the control flow graph. Basic blocks (or at least placeholders) are inserted into the CFG for the function entry address and any basic block addresses the function might already contain. This method returns the number of new basic block placeholders that were created. If any data blocks are associated with the function then they are inserted into the AUM.</p>
<p>It is permissible to insert the same function multiple times at the same address (subsequent insertions are no-ops), but it is an error to insert a different function at the same address as an existing function. The CFG/AUM is capable of representing at most one function per function entry address.</p>
<p>All functions that are attached to the CFG/AUM are marked as frozen and the user is prevented from directly manipulating the function's basic block and data block ownership lists. The connectivity of frozen functions can only be changed by using the partitioner's API, not the function's API. This allows the partitioner to keep the CFG in a consistent state.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="abc0c86f0d5b375536d148ad5106bece4" name="abc0c86f0d5b375536d148ad5106bece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0c86f0d5b375536d148ad5106bece4">&#9670;&#160;</a></span>attachFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::attachFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Functions</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a function to the CFG/AUM. </p>
<p>The indicated function(s) is inserted into the control flow graph. Basic blocks (or at least placeholders) are inserted into the CFG for the function entry address and any basic block addresses the function might already contain. This method returns the number of new basic block placeholders that were created. If any data blocks are associated with the function then they are inserted into the AUM.</p>
<p>It is permissible to insert the same function multiple times at the same address (subsequent insertions are no-ops), but it is an error to insert a different function at the same address as an existing function. The CFG/AUM is capable of representing at most one function per function entry address.</p>
<p>All functions that are attached to the CFG/AUM are marked as frozen and the user is prevented from directly manipulating the function's basic block and data block ownership lists. The connectivity of frozen functions can only be changed by using the partitioner's API, not the function's API. This allows the partitioner to keep the CFG in a consistent state.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="abb8543619947e920edfd729d53ca6592" name="abb8543619947e920edfd729d53ca6592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8543619947e920edfd729d53ca6592">&#9670;&#160;</a></span>attachOrMergeFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::attachOrMergeFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches or merges a function into the CFG/AUM. </p>
<p>If no other function exists at the specified function's entry address, then this method behaves identically to <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae1ac2f6619db585e2e05730cc5e6d713">attachFunction</a>. Otherwise, this method attempts to merge the specified function into an existing function. In any case, it returns a pointer to the function in the CFG/AUM (the existing one, or the new one). If the merge is not possible, then an exception is thrown.</p>
<p>One of the things that are merged are the basic blocks. If the function being attached is A and the partitioner already knows about B having the same entry address as A, then all basic blocks owned by A are now (also) owned by B. Some of those blocks happened to be owned by other functions also attached to the partitioner they continue to be owned also by those other functions. Data blocks are handled in a similar fashion.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a397727a62ba5ace82d367e41a0e0a8a4" name="a397727a62ba5ace82d367e41a0e0a8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397727a62ba5ace82d367e41a0e0a8a4">&#9670;&#160;</a></span>attachFunctionBasicBlocks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::attachFunctionBasicBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a252c6a30b832738a71f9884b0bc6aabc">Functions</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create placeholders for function basic blocks. </p>
<p>Ensures that a basic block placeholder (or basic block) exists for each function entry address and each function basic block address. If a placeholder is absent then one is created by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a913fe4a4e5d9a070340a1feba2880b15">insertPlaceholder</a>. The return value is the number of new placeholders created. A function that is attached to the CFG/AUM cannot have its basic block and data block membership lists manipulated directly by the user, but only through the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> API.</p>
<p>If the function is attached to the CFG/AUM then additional actions occur: any placeholders (or basic blocks) owned by this function are verified to not be owned by some other function, and they are marked as owned by this function.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7c2737237359168319a290373271d431" name="a7c2737237359168319a290373271d431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2737237359168319a290373271d431">&#9670;&#160;</a></span>attachFunctionBasicBlocks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::Partitioner::attachFunctionBasicBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create placeholders for function basic blocks. </p>
<p>Ensures that a basic block placeholder (or basic block) exists for each function entry address and each function basic block address. If a placeholder is absent then one is created by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a913fe4a4e5d9a070340a1feba2880b15">insertPlaceholder</a>. The return value is the number of new placeholders created. A function that is attached to the CFG/AUM cannot have its basic block and data block membership lists manipulated directly by the user, but only through the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> API.</p>
<p>If the function is attached to the CFG/AUM then additional actions occur: any placeholders (or basic blocks) owned by this function are verified to not be owned by some other function, and they are marked as owned by this function.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a962aba0191ca67b4fc246eb06339c0f4" name="a962aba0191ca67b4fc246eb06339c0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962aba0191ca67b4fc246eb06339c0f4">&#9670;&#160;</a></span>detachFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::detachFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches a function from the CFG/AUM. </p>
<p>The indicated function is detached from the control flow graph. Although this function's basic blocks remain attached to the CFG/AUM, they are no longer considered to be owned by this function even though this function will continue to list the addresses of those blocks as its members. Any data blocks that were owned by only this function become detached from the CFG/AUM, but this function continues to point to them; other multiply-owned data blocks will remain attached to the CFG/AUM and will continue to be pointed to by this function, but the CFG/AUM will no longer list this function as one of their owners.</p>
<p>Detaching a function from the CFG/AUM does not change the function other than thawing it so it can be modified by the user directly through its API. Attempting to detach a function that is already detached has no effect.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a0a414dd846ee9d789a05ad4014025047" name="a0a414dd846ee9d789a05ad4014025047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a414dd846ee9d789a05ad4014025047">&#9670;&#160;</a></span>entryFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Function::Ptr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::entryFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry points of the binary. </p>
<p>Returns a vector of functions which correspond to binary entry points.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="abab3fdf3bc1836894594a5a114af185d" name="abab3fdf3bc1836894594a5a114af185d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab3fdf3bc1836894594a5a114af185d">&#9670;&#160;</a></span>functionsOwningBasicBlock() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOwningBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Vertex &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions that own the specified basic block. </p>
<p>Return the functions that own the specified basic block(s). The returned vector has distinct function pointers sorted by their entry addresses. Usually a basic block is owned by zero or one function. If a basic block cannot be found or if it has no owning functions then an empty vector is returned. The returned functions are all attached to the partitioner (that's how the partitioner knows about them); detached functions are not found.</p>
<p>Basic blocks can be specified in a number of ways:</p>
<ul>
<li>As a CFG vertex. This is the fastest method since ownership information is stored directly in the CFG vertex. This is identical to calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#a01cbd1660b94259ec53ef2003a682def">CfgVertex::owningFunctions</a> except the return value is a vector and the functions are sorted differently. The only expense is sorting the return value, which is usually a single function and therefore constant time (the following bullets also assume this is constant time).</li>
</ul>
<ul>
<li>As a starting address. If a basic block with the specified starting address exists in the CFG then its function owners are retrieved from the vertex. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a block pointer. The address of the block is used to find the CFG vertex from which ownership information is obtained. Basic block ownership is stored in the CFG, therefore if the provided basic block is not attached to the partitioner, the partitioner substitutes one that is attached. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a vector of any of the above. The returned vector is the union of the owning functions. Run time is O(N M) where N is the length of the vector and M is the time from above.</li>
</ul>
<p>If <code>doSort</code> is clear then the result vector is not sorted, although it will still consist of unique function pointers. The return value from the variants that take more than one basic block is always sorted.</p>
<p>The returned function will be a function that is attached to the CFG/AUM; detached functions are never returned since the partitioner does not necessarily know about them.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="acd5a5379da039798b532857f23ca89f1" name="acd5a5379da039798b532857f23ca89f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5a5379da039798b532857f23ca89f1">&#9670;&#160;</a></span>functionsOwningBasicBlock() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOwningBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions that own the specified basic block. </p>
<p>Return the functions that own the specified basic block(s). The returned vector has distinct function pointers sorted by their entry addresses. Usually a basic block is owned by zero or one function. If a basic block cannot be found or if it has no owning functions then an empty vector is returned. The returned functions are all attached to the partitioner (that's how the partitioner knows about them); detached functions are not found.</p>
<p>Basic blocks can be specified in a number of ways:</p>
<ul>
<li>As a CFG vertex. This is the fastest method since ownership information is stored directly in the CFG vertex. This is identical to calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#a01cbd1660b94259ec53ef2003a682def">CfgVertex::owningFunctions</a> except the return value is a vector and the functions are sorted differently. The only expense is sorting the return value, which is usually a single function and therefore constant time (the following bullets also assume this is constant time).</li>
</ul>
<ul>
<li>As a starting address. If a basic block with the specified starting address exists in the CFG then its function owners are retrieved from the vertex. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a block pointer. The address of the block is used to find the CFG vertex from which ownership information is obtained. Basic block ownership is stored in the CFG, therefore if the provided basic block is not attached to the partitioner, the partitioner substitutes one that is attached. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a vector of any of the above. The returned vector is the union of the owning functions. Run time is O(N M) where N is the length of the vector and M is the time from above.</li>
</ul>
<p>If <code>doSort</code> is clear then the result vector is not sorted, although it will still consist of unique function pointers. The return value from the variants that take more than one basic block is always sorted.</p>
<p>The returned function will be a function that is attached to the CFG/AUM; detached functions are never returned since the partitioner does not necessarily know about them.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad0637c5b72913f3f6d37dfd7fa63c162" name="ad0637c5b72913f3f6d37dfd7fa63c162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0637c5b72913f3f6d37dfd7fa63c162">&#9670;&#160;</a></span>functionsOwningBasicBlock() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOwningBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>bblockVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions that own the specified basic block. </p>
<p>Return the functions that own the specified basic block(s). The returned vector has distinct function pointers sorted by their entry addresses. Usually a basic block is owned by zero or one function. If a basic block cannot be found or if it has no owning functions then an empty vector is returned. The returned functions are all attached to the partitioner (that's how the partitioner knows about them); detached functions are not found.</p>
<p>Basic blocks can be specified in a number of ways:</p>
<ul>
<li>As a CFG vertex. This is the fastest method since ownership information is stored directly in the CFG vertex. This is identical to calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#a01cbd1660b94259ec53ef2003a682def">CfgVertex::owningFunctions</a> except the return value is a vector and the functions are sorted differently. The only expense is sorting the return value, which is usually a single function and therefore constant time (the following bullets also assume this is constant time).</li>
</ul>
<ul>
<li>As a starting address. If a basic block with the specified starting address exists in the CFG then its function owners are retrieved from the vertex. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a block pointer. The address of the block is used to find the CFG vertex from which ownership information is obtained. Basic block ownership is stored in the CFG, therefore if the provided basic block is not attached to the partitioner, the partitioner substitutes one that is attached. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a vector of any of the above. The returned vector is the union of the owning functions. Run time is O(N M) where N is the length of the vector and M is the time from above.</li>
</ul>
<p>If <code>doSort</code> is clear then the result vector is not sorted, although it will still consist of unique function pointers. The return value from the variants that take more than one basic block is always sorted.</p>
<p>The returned function will be a function that is attached to the CFG/AUM; detached functions are never returned since the partitioner does not necessarily know about them.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a73fca2190fd794f70a449dbbb79fe8c2" name="a73fca2190fd794f70a449dbbb79fe8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fca2190fd794f70a449dbbb79fe8c2">&#9670;&#160;</a></span>functionsOwningBasicBlock() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOwningBasicBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds functions that own the specified basic block. </p>
<p>Return the functions that own the specified basic block(s). The returned vector has distinct function pointers sorted by their entry addresses. Usually a basic block is owned by zero or one function. If a basic block cannot be found or if it has no owning functions then an empty vector is returned. The returned functions are all attached to the partitioner (that's how the partitioner knows about them); detached functions are not found.</p>
<p>Basic blocks can be specified in a number of ways:</p>
<ul>
<li>As a CFG vertex. This is the fastest method since ownership information is stored directly in the CFG vertex. This is identical to calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#a01cbd1660b94259ec53ef2003a682def">CfgVertex::owningFunctions</a> except the return value is a vector and the functions are sorted differently. The only expense is sorting the return value, which is usually a single function and therefore constant time (the following bullets also assume this is constant time).</li>
</ul>
<ul>
<li>As a starting address. If a basic block with the specified starting address exists in the CFG then its function owners are retrieved from the vertex. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a block pointer. The address of the block is used to find the CFG vertex from which ownership information is obtained. Basic block ownership is stored in the CFG, therefore if the provided basic block is not attached to the partitioner, the partitioner substitutes one that is attached. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a vector of any of the above. The returned vector is the union of the owning functions. Run time is O(N M) where N is the length of the vector and M is the time from above.</li>
</ul>
<p>If <code>doSort</code> is clear then the result vector is not sorted, although it will still consist of unique function pointers. The return value from the variants that take more than one basic block is always sorted.</p>
<p>The returned function will be a function that is attached to the CFG/AUM; detached functions are never returned since the partitioner does not necessarily know about them.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6b0230e7382f9932c0d10122d6ff0e4d" name="a6b0230e7382f9932c0d10122d6ff0e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0230e7382f9932c0d10122d6ff0e4d">&#9670;&#160;</a></span>functionsOwningBasicBlocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionsOwningBasicBlocks </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>bblocks</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds functions that own the specified basic block. </p>
<p>Return the functions that own the specified basic block(s). The returned vector has distinct function pointers sorted by their entry addresses. Usually a basic block is owned by zero or one function. If a basic block cannot be found or if it has no owning functions then an empty vector is returned. The returned functions are all attached to the partitioner (that's how the partitioner knows about them); detached functions are not found.</p>
<p>Basic blocks can be specified in a number of ways:</p>
<ul>
<li>As a CFG vertex. This is the fastest method since ownership information is stored directly in the CFG vertex. This is identical to calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1CfgVertex.html#a01cbd1660b94259ec53ef2003a682def">CfgVertex::owningFunctions</a> except the return value is a vector and the functions are sorted differently. The only expense is sorting the return value, which is usually a single function and therefore constant time (the following bullets also assume this is constant time).</li>
</ul>
<ul>
<li>As a starting address. If a basic block with the specified starting address exists in the CFG then its function owners are retrieved from the vertex. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a block pointer. The address of the block is used to find the CFG vertex from which ownership information is obtained. Basic block ownership is stored in the CFG, therefore if the provided basic block is not attached to the partitioner, the partitioner substitutes one that is attached. Runtime is O(log |V|) where |V| is the number of vertices in the CFG.</li>
</ul>
<ul>
<li>As a vector of any of the above. The returned vector is the union of the owning functions. Run time is O(N M) where N is the length of the vector and M is the time from above.</li>
</ul>
<p>If <code>doSort</code> is clear then the result vector is not sorted, although it will still consist of unique function pointers. The return value from the variants that take more than one basic block is always sorted.</p>
<p>The returned function will be a function that is attached to the CFG/AUM; detached functions are never returned since the partitioner does not necessarily know about them.</p>
<p>Thread safety: Not thread safe. </p>

<p class="definition">Definition at line <a class="el" href="Partitioner_8h_source.html#l01782">1782</a> of file <a class="el" href="Partitioner_8h_source.html">Partitioner.h</a>.</p>

</div>
</div>
<a id="a56cd59a5b5991a6e510ea4d7f3236596" name="a56cd59a5b5991a6e510ea4d7f3236596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cd59a5b5991a6e510ea4d7f3236596">&#9670;&#160;</a></span>discoverCalledFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverCalledFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the CFG to find function calls. </p>
<p>Scans the CFG without modifying it and looks for edges that are marked as being function calls. A function is created at each call if one doesn't already exist in the CFG/AUM, and the list of created functions is returned. None of the created functions are added to the CFG/AUM.</p>
<p>See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#aedf025b08b6a10ca3087da0429cc5b60">discoverFunctionEntryVertices</a> which returns a superset of the functions returned by this method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aedf025b08b6a10ca3087da0429cc5b60" name="aedf025b08b6a10ca3087da0429cc5b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf025b08b6a10ca3087da0429cc5b60">&#9670;&#160;</a></span>discoverFunctionEntryVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverFunctionEntryVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the CFG to find function entry basic blocks. </p>
<p>Scans the CFG without modifying it in order to find vertices (basic blocks and basic block placeholders) that are the entry points of functions. A vertex is a function entry point if it has an incoming edge that is a function call or if it is the entry block of a function that already exists.</p>
<p>The returned function pointers are sorted by function entry address.</p>
<p>See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a56cd59a5b5991a6e510ea4d7f3236596">discoverCalledFunctions</a> which returns a subset of the functions returned by this method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a3647eb2c1fc6c7e941013cb1c2794fcb" name="a3647eb2c1fc6c7e941013cb1c2794fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3647eb2c1fc6c7e941013cb1c2794fcb">&#9670;&#160;</a></span>functionIsThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner_1_1Thunk.html">Thunk</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionIsThunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if function is a thunk. </p>
<p>If the function is non-null and a thunk then some information about the thunk is returned, otherwise nothing is returned. A function is a thunk if it has the <a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852ca331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a> bit set in its reason mask, and it has exactly one basic block, and the basic block has exactly one successor, and the successor is concrete.</p>
<p>As a side effect, the basic block's outgoing edge type is changed to E_FUNCTION_XFER.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a689e06c1c1186c02c725d79a9339dd33" name="a689e06c1c1186c02c725d79a9339dd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689e06c1c1186c02c725d79a9339dd33">&#9670;&#160;</a></span>discoverFunctionBasicBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::discoverFunctionBasicBlocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds basic blocks to a function. </p>
<p>Attempts to discover the basic blocks that should belong to the specified function. It does so by finding all CFG vertices that are reachable from the already-owned vertices without following edges that are marked as function calls, function transfers, or function returns and without following edges that lead to the entry point of another function.</p>
<p>The CFG is not modified by this method. The function is modified and must not exist in the CFG; the function must be in a thawed state.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a816f45d84e9d12b46da9ce9699011815" name="a816f45d84e9d12b46da9ce9699011815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f45d84e9d12b46da9ce9699011815">&#9670;&#160;</a></span>functionGhostSuccessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionGhostSuccessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns ghost successors for a single function. </p>
<p>Returns the set of basic block starting addresses that are naive successors for the basic blocks of a function but which are not actual control flow successors due to the presence of opaque predicates.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a231f5e1494f3244b5fee241e644a9a9c" name="a231f5e1494f3244b5fee241e644a9a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f5e1494f3244b5fee241e644a9a9c">&#9670;&#160;</a></span>functionCallGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">FunctionCallGraph</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionCallGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html#adae60b3da31d72d5a31c6314dbbebcc3">AllowParallelEdges::Type</a>&#160;</td>
          <td class="paramname"><em>allowParallelEdges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a function call graph. </p>
<p>If <code>allowParallelEdges</code> is true then the returned call graph will have one edge for each function call and each edge will have a count of one. Otherwise multiple calls between the same pair of functions are coalesced into single edges with non-unit counts in the call graph.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a17491f0dd52a1367f0c907dbd49fcb89" name="a17491f0dd52a1367f0c907dbd49fcb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17491f0dd52a1367f0c907dbd49fcb89">&#9670;&#160;</a></span>functionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionStackDelta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack delta analysis for one function. </p>
<p>Computes stack deltas if possible at each basic block within the specified function. The algorithm starts at the function's entry block with an incoming stack delta of zero, and performs a dataflow anysis following a control flow graph that contains those vertices reachable from the entry block by following only intra-function edges. Each such vertex is given an incoming and outgoing stack delta.</p>
<p>If the function appears to make reasonable use of the stack then an overall stack delta is returned. This is the delta resulting from the final function return blocks. Otherwise a null expression is returned. The result is cached in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#adb56c48f312c73d7fac7db541d66a2a2" title="Property: Stack delta.">Function::stackDelta</a> property.</p>
<p>Since this analysis is based on data flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all its basic blocks must also exist in the CFG/AUM. Also, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#afef2b31b31a4a0b0d96d5b04ea6c17e9">basicBlockStackDeltaIn</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab081575b668b12bfd718f375b249e925">basicBlockStackDeltaOut</a> methods must be non-null for each reachable block in the function.</p>
<p>If the configuration information specifies a stack delta for this function then that delta is used instead of performing any analysis.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a4b47d70e1a381ce795dae84ed4065e92" name="a4b47d70e1a381ce795dae84ed4065e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b47d70e1a381ce795dae84ed4065e92">&#9670;&#160;</a></span>allFunctionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionStackDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute stack delta analysis for all functions. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a1f1dbde2b06651a514eefcd25bd1b745" name="a1f1dbde2b06651a514eefcd25bd1b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1dbde2b06651a514eefcd25bd1b745">&#9670;&#160;</a></span>functionOptionalMayReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; bool &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionOptionalMayReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>May-return analysis for one function. </p>
<p>Determines if a function can possibly return to its caller. This is a simple wrapper around <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2171b0c875ca1e43a5c8b88565657f40">basicBlockOptionalMayReturn</a> invoked on the function's entry block. See that method for details.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ab7e97742dd17eb650e1b55da7ef7f7fc" name="ab7e97742dd17eb650e1b55da7ef7f7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e97742dd17eb650e1b55da7ef7f7fc">&#9670;&#160;</a></span>allFunctionMayReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionMayReturn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute may-return analysis for all functions. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6a579eadf50ba9156291b237c7d914c7" name="a6a579eadf50ba9156291b237c7d914c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a579eadf50ba9156291b237c7d914c7">&#9670;&#160;</a></span>functionCallingConvention() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionCallingConvention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling convention analysis for one function. </p>
<p>Analyses a function to determine characteristics of its calling convention, such as which registers are callee-saved, which registers and stack locations are input parameters, and which are output parameters. The calling convention analysis itself does not define the entire calling convention&ndash;instead, the analysis results must be matched against a dictionary of calling convention definitions. Each function has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">callingConventionDefinition</a> property that points to the best definition; if this method reanalyzes the calling convention then the definition is reset to the null pointer.</p>
<p>Since this analysis is based on data-flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all its basic blocks must also exist in the CFG/AUM.</p>
<p>Warning: If the specified function calls other functions for which a calling convention analysis has not been run the analysis of this function may be incorrect. This is because the analysis of this function must know which registers are clobbered by the call in order to produce accurate results. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>. If a default calling convention is supplied then it determines which registers are clobbered by a call to a function that hasn't been analyzed yet.</p>
<p>Calling convention analysis results are stored in the function object. If calling convention analysis has already been run for this function then the old results are returned. The old results can be cleared on a per-function basis with <code>function-&gt;callingConventionAnalysis().<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab14e23726d49ed9dc8c318c30a7e5397" title="Reset CFG/AUM to initial state.">clear()</a></code>.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>, which computes calling convention characteristics for all functions at once, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#acc04ac3895d1d4bf71a59917b8f4f58f">functionCallingConventionDefinitions</a>, which returns matching definitions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a398ef68fd80bb647a3c981160aecacc9" name="a398ef68fd80bb647a3c981160aecacc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398ef68fd80bb647a3c981160aecacc9">&#9670;&#160;</a></span>functionCallingConvention() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionCallingConvention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling convention analysis for one function. </p>
<p>Analyses a function to determine characteristics of its calling convention, such as which registers are callee-saved, which registers and stack locations are input parameters, and which are output parameters. The calling convention analysis itself does not define the entire calling convention&ndash;instead, the analysis results must be matched against a dictionary of calling convention definitions. Each function has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">callingConventionDefinition</a> property that points to the best definition; if this method reanalyzes the calling convention then the definition is reset to the null pointer.</p>
<p>Since this analysis is based on data-flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all its basic blocks must also exist in the CFG/AUM.</p>
<p>Warning: If the specified function calls other functions for which a calling convention analysis has not been run the analysis of this function may be incorrect. This is because the analysis of this function must know which registers are clobbered by the call in order to produce accurate results. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>. If a default calling convention is supplied then it determines which registers are clobbered by a call to a function that hasn't been analyzed yet.</p>
<p>Calling convention analysis results are stored in the function object. If calling convention analysis has already been run for this function then the old results are returned. The old results can be cleared on a per-function basis with <code>function-&gt;callingConventionAnalysis().<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab14e23726d49ed9dc8c318c30a7e5397" title="Reset CFG/AUM to initial state.">clear()</a></code>.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>, which computes calling convention characteristics for all functions at once, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#acc04ac3895d1d4bf71a59917b8f4f58f">functionCallingConventionDefinitions</a>, which returns matching definitions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a169ead089da01d3c1a366158da88f887" name="a169ead089da01d3c1a366158da88f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169ead089da01d3c1a366158da88f887">&#9670;&#160;</a></span>allFunctionCallingConvention() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionCallingConvention </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute calling conventions for all functions. </p>
<p>Analyzes calling conventions for all functions and caches results in the function objects. The analysis uses a depth first traversal of the call graph, invoking the analysis as the traversal unwinds. This increases the chance that the calling conventions of callees are known before their callers are analyzed. However, this analysis must break cycles in mutually recursive calls, and does so by using an optional default calling convention where the cycle is broken. This default is not inserted as a result&ndash;it only influences the data-flow portion of the analysis.</p>
<p>After this method runs, results can be queried per function with either <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#af7c57d1e3d138db3e6555c39993a0f3f">Function::callingConventionAnalysis</a> or <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a>.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a22c0049139df1883b9fc3778a5eac948" name="a22c0049139df1883b9fc3778a5eac948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c0049139df1883b9fc3778a5eac948">&#9670;&#160;</a></span>allFunctionCallingConvention() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionCallingConvention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute calling conventions for all functions. </p>
<p>Analyzes calling conventions for all functions and caches results in the function objects. The analysis uses a depth first traversal of the call graph, invoking the analysis as the traversal unwinds. This increases the chance that the calling conventions of callees are known before their callers are analyzed. However, this analysis must break cycles in mutually recursive calls, and does so by using an optional default calling convention where the cycle is broken. This default is not inserted as a result&ndash;it only influences the data-flow portion of the analysis.</p>
<p>After this method runs, results can be queried per function with either <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#af7c57d1e3d138db3e6555c39993a0f3f">Function::callingConventionAnalysis</a> or <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a>.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="acc04ac3895d1d4bf71a59917b8f4f58f" name="acc04ac3895d1d4bf71a59917b8f4f58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc04ac3895d1d4bf71a59917b8f4f58f">&#9670;&#160;</a></span>functionCallingConventionDefinitions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionCallingConventionDefinitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of matching calling conventions. </p>
<p>Given a function, run a calling convention analysis (if necessary) and return the list of common architecture calling convention definitions that match the characteristics of the function. This method differs from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a> in that the former returns an analysis object that holds the function characteristics, while this method then takes a list of common calling convention definitions (based on the architecture) and returns those definitions that are consistent with the function characteristics.</p>
<p>Since this analysis is based on data-flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all ts basic blocks must also exist in the CFG/AUM.</p>
<p>If the specified function calls other functions for which a calling convention analysis has not been run the analysis of this function may be incorrect. This is because the analysis of this function must know which registers are clobbered by the call in order to produce accurate results. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>. If a default calling convention is supplied then it determines which registers are clobbered by a call to a function that hasn't been analyzed yet.</p>
<p>If the calling convention analysis fails or no common architecture calling convention definition matches the characteristics of the function, then an empty list is returned. This method does not access the function's calling convention property &ndash; it recomputes the list of matching definitions from scratch.</p>
<p>Thread safety: Not thread safe.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a>, which returns the calling convention characteristics of a function (rather than definitions), and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>, which runs that analysis over all functions. </p>

</div>
</div>
<a id="afbbf6636a1aed2b3515506d5a0c5acbc" name="afbbf6636a1aed2b3515506d5a0c5acbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf6636a1aed2b3515506d5a0c5acbc">&#9670;&#160;</a></span>functionCallingConventionDefinitions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::functionCallingConventionDefinitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of matching calling conventions. </p>
<p>Given a function, run a calling convention analysis (if necessary) and return the list of common architecture calling convention definitions that match the characteristics of the function. This method differs from <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a> in that the former returns an analysis object that holds the function characteristics, while this method then takes a list of common calling convention definitions (based on the architecture) and returns those definitions that are consistent with the function characteristics.</p>
<p>Since this analysis is based on data-flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all ts basic blocks must also exist in the CFG/AUM.</p>
<p>If the specified function calls other functions for which a calling convention analysis has not been run the analysis of this function may be incorrect. This is because the analysis of this function must know which registers are clobbered by the call in order to produce accurate results. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>. If a default calling convention is supplied then it determines which registers are clobbered by a call to a function that hasn't been analyzed yet.</p>
<p>If the calling convention analysis fails or no common architecture calling convention definition matches the characteristics of the function, then an empty list is returned. This method does not access the function's calling convention property &ndash; it recomputes the list of matching definitions from scratch.</p>
<p>Thread safety: Not thread safe.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a6a579eadf50ba9156291b237c7d914c7">functionCallingConvention</a>, which returns the calling convention characteristics of a function (rather than definitions), and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a>, which runs that analysis over all functions. </p>

</div>
</div>
<a id="afccbdf2e84d7911b57adcd8e841f7895" name="afccbdf2e84d7911b57adcd8e841f7895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccbdf2e84d7911b57adcd8e841f7895">&#9670;&#160;</a></span>allFunctionCallingConventionDefinition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionCallingConventionDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes calling conventions and saves results. </p>
<p>This method invokes <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a> to analyze the behavior of every function, then finds the list of matching definitions for each function. A histogram of definitions is calculated and each function is re-examined. If any function matched more than one definition, then the most frequent of those definitions is chosen as that function's "best" calling convention definition and saved in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">Function::callingConventionDefinition</a> property.</p>
<p>If a default calling convention definition is provided, it gets passed to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a> analysis. The default is also assigned as the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">Function::callingConventionDefinition</a> property of any function for which calling convention analysis fails.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aef5f1e12c6f6e20b7358eace2dc67810" name="aef5f1e12c6f6e20b7358eace2dc67810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5f1e12c6f6e20b7358eace2dc67810">&#9670;&#160;</a></span>allFunctionCallingConventionDefinition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionCallingConventionDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">CallingConvention::Definition::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyzes calling conventions and saves results. </p>
<p>This method invokes <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a> to analyze the behavior of every function, then finds the list of matching definitions for each function. A histogram of definitions is calculated and each function is re-examined. If any function matched more than one definition, then the most frequent of those definitions is chosen as that function's "best" calling convention definition and saved in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">Function::callingConventionDefinition</a> property.</p>
<p>If a default calling convention definition is provided, it gets passed to the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a169ead089da01d3c1a366158da88f887">allFunctionCallingConvention</a> analysis. The default is also assigned as the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">Function::callingConventionDefinition</a> property of any function for which calling convention analysis fails.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="acefeba1c276c383f3bf5db78e58348f8" name="acefeba1c276c383f3bf5db78e58348f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefeba1c276c383f3bf5db78e58348f8">&#9670;&#160;</a></span>fixInterFunctionEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::fixInterFunctionEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust inter-function edge types. </p>
<p>For any CFG edge whose source and destination are two different functions but whose type is <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>, replace the edge with either a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5">E_FUNCTION_XFER</a> edge as appropriate.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a32d58d3405caf3cfa8452717983f0e92" name="a32d58d3405caf3cfa8452717983f0e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d58d3405caf3cfa8452717983f0e92">&#9670;&#160;</a></span>fixInterFunctionEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::fixInterFunctionEdge </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust inter-function edge types. </p>
<p>For any CFG edge whose source and destination are two different functions but whose type is <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9af7b849dcb4c98cebc5319e2fae83a740">E_NORMAL</a>, replace the edge with either a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5">E_FUNCTION_XFER</a> edge as appropriate.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a32123f065b02de2cb732a73e3ca9ab01" name="a32123f065b02de2cb732a73e3ca9ab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32123f065b02de2cb732a73e3ca9ab01">&#9670;&#160;</a></span>functionIsNoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::functionIsNoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> no-op analysis. </p>
<p>Analyzes a function to determine whether the function is effectively no operation. Returns true if the function can be proven to be a no-op, false if the analysis can prove the function has an effect, and also false if the analysis cannot make a determination.</p>
<p>Since this analysis is based on data-flow, which is based on a control flow graph, the function must be attached to the CFG/AUM and all its basic blocks must also exist in the CFG/AUM.</p>
<p>The no-op analysis results are stored in the function object. If no-op analysis has already been run for this function then the old results are returned. The old results can be cleared on a per-function basis with <code>function-&gt;isNoop().<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab14e23726d49ed9dc8c318c30a7e5397" title="Reset CFG/AUM to initial state.">clear()</a></code>.</p>
<p>Thread safety: Not thread safe.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad03eecbe130badb1546bb6d74fc39615">allFunctionIsNoop</a>, which analyzes all functions at once and which therefore may be faster than invoking the analysis one function at a time. </p>

</div>
</div>
<a id="ad03eecbe130badb1546bb6d74fc39615" name="ad03eecbe130badb1546bb6d74fc39615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03eecbe130badb1546bb6d74fc39615">&#9670;&#160;</a></span>allFunctionIsNoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::allFunctionIsNoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze all functions for whether they are effectivly no-ops. </p>
<p>Invokes the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a32123f065b02de2cb732a73e3ca9ab01">functionIsNoop</a> analysis on each function, perhaps concurrently.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a1c1455386ac51f740d0203757ade7eda" name="a1c1455386ac51f740d0203757ade7eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1455386ac51f740d0203757ade7eda">&#9670;&#160;</a></span>forgetFunctionIsNoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::forgetFunctionIsNoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears cached function no-op analysis results. </p>
<p>Clears the function no-op analysis results for the specified function or all functions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae1f6e0fe616601bbdff658e633973303" name="ae1f6e0fe616601bbdff658e633973303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6e0fe616601bbdff658e633973303">&#9670;&#160;</a></span>forgetFunctionIsNoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::forgetFunctionIsNoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears cached function no-op analysis results. </p>
<p>Clears the function no-op analysis results for the specified function or all functions.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="accec59f22b4b45e59c2e6e7ec7817bf6" name="accec59f22b4b45e59c2e6e7ec7817bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accec59f22b4b45e59c2e6e7ec7817bf6">&#9670;&#160;</a></span>functionDataFlowConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionDataFlowConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find constants in function using data-flow. </p>
<p>This function runs a simple data-flow operation on the specified function and examines all states to obtain a set of constants. </p>

</div>
</div>
<a id="a1d79564686574f7c0340b9aa9a13a7a8" name="a1d79564686574f7c0340b9aa9a13a7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d79564686574f7c0340b9aa9a13a7a8">&#9670;&#160;</a></span>cfgAdjustmentCallbacks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">CfgAdjustmentCallbacks</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::cfgAdjustmentCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all callbacks invoked when the CFG is adjusted. </p>
<p>Inserting a new callback goes something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyCallback: Partitioner::CfgAdjustmentCallback {</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a> instance() { <span class="keywordflow">return</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a>(<span class="keyword">new</span> MyCallback); }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> chain, <span class="keyword">const</span> AttachedBasicBlock &amp;args) { ... }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> chain, <span class="keyword">const</span> DetachedBasicBlock &amp;args) { ... }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">partitioner.cfgAdjustmentCallbacks().append(MyCallback::instance());</div>
</div><!-- fragment --><p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae3a961f55e6648faa27f6a9208129eaa" name="ae3a961f55e6648faa27f6a9208129eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a961f55e6648faa27f6a9208129eaa">&#9670;&#160;</a></span>cfgAdjustmentCallbacks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a044db32618aa7b901caac5629167825e">CfgAdjustmentCallbacks</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::cfgAdjustmentCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all callbacks invoked when the CFG is adjusted. </p>
<p>Inserting a new callback goes something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyCallback: Partitioner::CfgAdjustmentCallback {</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a> instance() { <span class="keywordflow">return</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a>(<span class="keyword">new</span> MyCallback); }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> chain, <span class="keyword">const</span> AttachedBasicBlock &amp;args) { ... }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> chain, <span class="keyword">const</span> DetachedBasicBlock &amp;args) { ... }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">partitioner.cfgAdjustmentCallbacks().append(MyCallback::instance());</div>
</div><!-- fragment --><p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="adbee3513586f9d653ad1805e44df8072" name="adbee3513586f9d653ad1805e44df8072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbee3513586f9d653ad1805e44df8072">&#9670;&#160;</a></span>basicBlockCallbacks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">BasicBlockCallbacks</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceRose_1_1Callbacks.html" title="User callbacks.">Callbacks</a> for adjusting basic block during discovery. </p>
<p>Each time an instruction is appended to a basic block these callbacks are invoked to make adjustments to the block. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html">BasicBlockCallback</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a41100afc7155355c5dea909016f156c5">discoverBasicBlock</a> for details.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6d8523df6eabbb1832ba2599f12e1139" name="a6d8523df6eabbb1832ba2599f12e1139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8523df6eabbb1832ba2599f12e1139">&#9670;&#160;</a></span>basicBlockCallbacks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae0d33eeb49d3688517f7df1f7004315a">BasicBlockCallbacks</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceRose_1_1Callbacks.html" title="User callbacks.">Callbacks</a> for adjusting basic block during discovery. </p>
<p>Each time an instruction is appended to a basic block these callbacks are invoked to make adjustments to the block. See <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasicBlockCallback.html">BasicBlockCallback</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a41100afc7155355c5dea909016f156c5">discoverBasicBlock</a> for details.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a0f9d0dafd282a74651166a929ef7bd66" name="a0f9d0dafd282a74651166a929ef7bd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9d0dafd282a74651166a929ef7bd66">&#9670;&#160;</a></span>functionPrologueMatchers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">FunctionPrologueMatchers</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionPrologueMatchers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered list of function prologue matchers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a057bdf19279739ae62f719679b9e435e" title="Finds the next function by searching for a function prologue.">nextFunctionPrologue</a></dd></dl>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa686ce25c11ded514e782689b70ab831" name="aa686ce25c11ded514e782689b70ab831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686ce25c11ded514e782689b70ab831">&#9670;&#160;</a></span>functionPrologueMatchers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ab7fa873c34d530750943a0e4171dd480">FunctionPrologueMatchers</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionPrologueMatchers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered list of function prologue matchers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a057bdf19279739ae62f719679b9e435e" title="Finds the next function by searching for a function prologue.">nextFunctionPrologue</a></dd></dl>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a057bdf19279739ae62f719679b9e435e" name="a057bdf19279739ae62f719679b9e435e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057bdf19279739ae62f719679b9e435e">&#9670;&#160;</a></span>nextFunctionPrologue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::nextFunctionPrologue </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next function by searching for a function prologue. </p>
<p>Scans executable memory starting at <code>startVa</code> and tries to match a function prologue pattern. The patterns are represented by matchers that have been inserted into the vector reference returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0f9d0dafd282a74651166a929ef7bd66">functionPrologueMatchers</a>. The first matcher that finds an instruction anchored at a supplied starting address wins. The starting address is incremented at each step so that it is always an address that is mapped with execute permission and is not an address that is the start of an instruction that's in the CFG.</p>
<p>If a matcher matches a function prologue then a detached function is created and returned. The starting address need not be the same as the anchor address for the match. For instance, a matcher might match one or more no-op instructions followed by the function prologue, in which case the address after the no-ops is the one used as the entry point of the returned function.</p>
<p>Some function prologue matchers can return multiple functions. For instance, a matcher for a thunk might return the thunk and the function to which it points. In any case, the first function is the primary one.</p>
<p>If no match is found then an empty vector is returned.</p>
<p>If The <code>lastSearchedVa</code> argument is provided, then it is set to the highest address at which a function prologue was searched.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ab241b8cc20fee9e119bc87108181c04c" name="ab241b8cc20fee9e119bc87108181c04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab241b8cc20fee9e119bc87108181c04c">&#9670;&#160;</a></span>nextFunctionPrologue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::nextFunctionPrologue </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>startVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t &amp;&#160;</td>
          <td class="paramname"><em>lastSearchedVa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next function by searching for a function prologue. </p>
<p>Scans executable memory starting at <code>startVa</code> and tries to match a function prologue pattern. The patterns are represented by matchers that have been inserted into the vector reference returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a0f9d0dafd282a74651166a929ef7bd66">functionPrologueMatchers</a>. The first matcher that finds an instruction anchored at a supplied starting address wins. The starting address is incremented at each step so that it is always an address that is mapped with execute permission and is not an address that is the start of an instruction that's in the CFG.</p>
<p>If a matcher matches a function prologue then a detached function is created and returned. The starting address need not be the same as the anchor address for the match. For instance, a matcher might match one or more no-op instructions followed by the function prologue, in which case the address after the no-ops is the one used as the entry point of the returned function.</p>
<p>Some function prologue matchers can return multiple functions. For instance, a matcher for a thunk might return the thunk and the function to which it points. In any case, the first function is the primary one.</p>
<p>If no match is found then an empty vector is returned.</p>
<p>If The <code>lastSearchedVa</code> argument is provided, then it is set to the highest address at which a function prologue was searched.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af4f90960bc68617c7b20d22b198aa6e1" name="af4f90960bc68617c7b20d22b198aa6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f90960bc68617c7b20d22b198aa6e1">&#9670;&#160;</a></span>functionPaddingMatchers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">FunctionPaddingMatchers</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionPaddingMatchers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered list of function padding matchers. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad6c4909464402bdeb6f011be79f3bce3" name="ad6c4909464402bdeb6f011be79f3bce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c4909464402bdeb6f011be79f3bce3">&#9670;&#160;</a></span>functionPaddingMatchers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a4386d55af94c82efad04a6c4e9d74c37">FunctionPaddingMatchers</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::functionPaddingMatchers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered list of function padding matchers. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2f9481327df1a175c9d33a3b8df42bac" name="a2f9481327df1a175c9d33a3b8df42bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9481327df1a175c9d33a3b8df42bac">&#9670;&#160;</a></span>matchFunctionPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::matchFunctionPadding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds function padding. </p>
<p>Scans backward from the specified function's entry address by invoking each function padding matcher in the order returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#af4f90960bc68617c7b20d22b198aa6e1">functionPaddingMatchers</a> until one of them finds some padding. Once found, a data block is created and returned. If no padding is found then the null pointer is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7d6efb6fe6923b7510b536b13cc0e6fe" name="a7d6efb6fe6923b7510b536b13cc0e6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6efb6fe6923b7510b536b13cc0e6fe">&#9670;&#160;</a></span>dumpCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::dumpCfg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showBlocks</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeProperties</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the control flow graph. </p>
<p>Emits the control flow graph, basic blocks, and their instructions to the specified stream. The addresses are starting addresses, and the suffix "[P]" means the address is a basic block placeholder, and the suffix "[X]" means the basic block was discovered to be non-existing (i.e., no executable memory for the first instruction).</p>
<p>A <code>prefix</code> can be specified to be added to the beginning of each line of output. If <code>showBlocks</code> is set then the instructions are shown for each basic block. If <code>computeProperties</code> is set then various properties are computed and cached rather than only consulting the cache.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6d3edd3feb7131dbc069613a77d41c7c" name="a6d3edd3feb7131dbc069613a77d41c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3edd3feb7131dbc069613a77d41c7c">&#9670;&#160;</a></span>cfgGraphViz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::cfgGraphViz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#aa3ce7a7c9a79d236c3de26532f25bbf5">AddressInterval</a> &amp;&#160;</td>
          <td class="paramname"><em>restrict</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html#afef17d3137598cbd8a997969657d746b">AddressInterval::whole</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showNeighbors</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output CFG as <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a>. </p>
<p>This is a wrapper around the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a> class. It emits a graph with function subgraphs for the vertices that are selected by the <code>restrict</code> parameter.</p>
<p>If <code>showNeighbors</code> is false then only edges whose source and target are both selected vertices are shown, otherwise edges that go from a selected vertex to an unselected vertex are also emitted, with the target vertex having abbreviated information in the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz.html" title="Support for generating and reading GraphViz output.">GraphViz</a> output.</p>
<p>This is only a simple wrapper around <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CfgEmitter.html">GraphViz::CfgEmitter</a>. That API has many more options than are presented by this method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad939aa0645969e081565ad2414ef9449" name="ad939aa0645969e081565ad2414ef9449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad939aa0645969e081565ad2414ef9449">&#9670;&#160;</a></span>vertexName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::vertexName </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Vertex &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of a vertex. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9ac2b676583ea0551bcdfaf8c04d959f" name="a9ac2b676583ea0551bcdfaf8c04d959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac2b676583ea0551bcdfaf8c04d959f">&#9670;&#160;</a></span>vertexName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::vertexName </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of a vertex. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a99e4a7482687adc99bd3c208d5cb33f9" name="a99e4a7482687adc99bd3c208d5cb33f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e4a7482687adc99bd3c208d5cb33f9">&#9670;&#160;</a></span>vertexNameEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::vertexNameEnd </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Vertex &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of last instruction in vertex. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="af86f4571f621eefce01fea827112ac0c" name="af86f4571f621eefce01fea827112ac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86f4571f621eefce01fea827112ac0c">&#9670;&#160;</a></span>edgeNameSrc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeNameSrc </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of an incoming edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ad93376dd7d5af2a9c398d1452726f75c" name="ad93376dd7d5af2a9c398d1452726f75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93376dd7d5af2a9c398d1452726f75c">&#9670;&#160;</a></span>edgeNameSrc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeNameSrc </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of an incoming edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae2edb5c627b6e84c97486d04203c0ed8" name="ae2edb5c627b6e84c97486d04203c0ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2edb5c627b6e84c97486d04203c0ed8">&#9670;&#160;</a></span>edgeNameDst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeNameDst </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of an outgoing edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ac8cd15ffcb26b22813a373b18be9adf7" name="ac8cd15ffcb26b22813a373b18be9adf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cd15ffcb26b22813a373b18be9adf7">&#9670;&#160;</a></span>edgeNameDst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeNameDst </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of an outgoing edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ae2e389a5294afe922d9e1b267c3196a1" name="ae2e389a5294afe922d9e1b267c3196a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e389a5294afe922d9e1b267c3196a1">&#9670;&#160;</a></span>edgeName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeName </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::Edge &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of an edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a60ea5e94b2c40b9e90fb8b6c49658e76" name="a60ea5e94b2c40b9e90fb8b6c49658e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ea5e94b2c40b9e90fb8b6c49658e76">&#9670;&#160;</a></span>edgeName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::edgeName </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph::ConstEdgeIterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of an edge. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a4d17b542ecbd0ca653f881ca07838b94" name="a4d17b542ecbd0ca653f881ca07838b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d17b542ecbd0ca653f881ca07838b94">&#9670;&#160;</a></span>basicBlockName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::basicBlockName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of a basic block. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a08407d13d3749121e97a34ea418ec555" name="a08407d13d3749121e97a34ea418ec555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08407d13d3749121e97a34ea418ec555">&#9670;&#160;</a></span>dataBlockName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::dataBlockName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of a data block. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a733d5db9d2fef789b23734864eecfc08" name="a733d5db9d2fef789b23734864eecfc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733d5db9d2fef789b23734864eecfc08">&#9670;&#160;</a></span>functionName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Partitioner2::Partitioner::functionName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of a function. </p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a764d818d0af7af35848af8ed7d0d4e84" name="a764d818d0af7af35848af8ed7d0d4e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764d818d0af7af35848af8ed7d0d4e84">&#9670;&#160;</a></span>expandIndeterminateCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::expandIndeterminateCalls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands indeterminate function calls. </p>
<p>Modifies the control flow graph so that any function call to the indeterminate vertex is replaced by function calls to every possible function. </p>

</div>
</div>
<a id="a9538bdedba72f445d634e12318638927" name="a9538bdedba72f445d634e12318638927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9538bdedba72f445d634e12318638927">&#9670;&#160;</a></span>progress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: How to report progress. </p>
<p>Partitioning progress is reported in two ways:</p>
<ul>
<li>Various diagnostic facilities use the <code>MARCH</code> stream to emit a progress report to the terminal. These streams can be enabled and disabled from the command-line or with function calls using the <a class="el" href="namespaceSawyer_1_1Message.html">Sawyer::Message</a> API.</li>
</ul>
<ul>
<li>The partitioner also has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9538bdedba72f445d634e12318638927">progress</a> property that can be queried in thread-safe manners that allows one thread to run partitioner algorithms and other threads to query the progress.</li>
</ul>
<p>If a non-null progress object is specified, then the partitioner will make progress reports to that object as well as emitting a progress bar to the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html" title="Binary function detection.">Partitioner2</a> diagnostic stream. The progress bar can be disabled independently of reporting to a progress object, but no progress is reported if the progress object is null.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="aa4e459b2365ffad02c1cc039a7d78e69" name="aa4e459b2365ffad02c1cc039a7d78e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e459b2365ffad02c1cc039a7d78e69">&#9670;&#160;</a></span>progress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::progress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: How to report progress. </p>
<p>Partitioning progress is reported in two ways:</p>
<ul>
<li>Various diagnostic facilities use the <code>MARCH</code> stream to emit a progress report to the terminal. These streams can be enabled and disabled from the command-line or with function calls using the <a class="el" href="namespaceSawyer_1_1Message.html">Sawyer::Message</a> API.</li>
</ul>
<ul>
<li>The partitioner also has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a9538bdedba72f445d634e12318638927">progress</a> property that can be queried in thread-safe manners that allows one thread to run partitioner algorithms and other threads to query the progress.</li>
</ul>
<p>If a non-null progress object is specified, then the partitioner will make progress reports to that object as well as emitting a progress bar to the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html" title="Binary function detection.">Partitioner2</a> diagnostic stream. The progress bar can be disabled independently of reporting to a progress object, but no progress is reported if the progress object is null.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="afae7ca9f068e4f9960e01567aba87c77" name="afae7ca9f068e4f9960e01567aba87c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae7ca9f068e4f9960e01567aba87c77">&#9670;&#160;</a></span>updateProgress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::updateProgress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>completion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update partitioner with a new progress report. </p>
<p>This method is const because it doesn't change the partitioner, it only forwards the phase and completion to whatever <a class="el" href="classRose_1_1Progress.html">Progress</a> object is associated with the partition, if any. </p>

</div>
</div>
<a id="a46384adab5b0698bf00f5335bf8ed911" name="a46384adab5b0698bf00f5335bf8ed911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46384adab5b0698bf00f5335bf8ed911">&#9670;&#160;</a></span>elfGot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * Rose::BinaryAnalysis::Partitioner2::Partitioner::elfGot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmElfFileHeader.html">SgAsmElfFileHeader</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the ELF global offset table and save its address. </p>
<p>Returns the GOT section and caches the section's actual mapped address.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a97095b7b65bee629e784cbab945d96f5">elfGotVa</a>. </p>

</div>
</div>
<a id="a97095b7b65bee629e784cbab945d96f5" name="a97095b7b65bee629e784cbab945d96f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97095b7b65bee629e784cbab945d96f5">&#9670;&#160;</a></span>elfGotVa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Partitioner2::Partitioner::elfGotVa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously cached ELF GOT address. </p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a46384adab5b0698bf00f5335bf8ed911">elfGot</a>. </p>

</div>
</div>
<a id="af80253a4cbd1c1b6ab6002b7fc9b68d0" name="af80253a4cbd1c1b6ab6002b7fc9b68d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80253a4cbd1c1b6ab6002b7fc9b68d0">&#9670;&#160;</a></span>settings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html">BasePartitionerSettings</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> settings. </p>
<p>These are settings that are typically controlled from the command-line.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a5c70195a626f5bfc1815ee34c0089d9e" name="a5c70195a626f5bfc1815ee34c0089d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c70195a626f5bfc1815ee34c0089d9e">&#9670;&#160;</a></span>settings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::settings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Partitioner2_1_1BasePartitionerSettings.html">BasePartitionerSettings</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> settings. </p>
<p>These are settings that are typically controlled from the command-line.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aa61c4e5ba2cdcbafdcfc0d516aad58dd" name="aa61c4e5ba2cdcbafdcfc0d516aad58dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c4e5ba2cdcbafdcfc0d516aad58dd">&#9670;&#160;</a></span>enableSymbolicSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::enableSymbolicSemantics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use or not use symbolic semantics. </p>
<p>When true, a symbolic semantics domain will be used to reason about certain code properties such as successors for a basic block. When false, more naive but faster methods are used.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a9d24e95b439b9db0d4de8ab072389c05" name="a9d24e95b439b9db0d4de8ab072389c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d24e95b439b9db0d4de8ab072389c05">&#9670;&#160;</a></span>disableSymbolicSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::disableSymbolicSemantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use or not use symbolic semantics. </p>
<p>When true, a symbolic semantics domain will be used to reason about certain code properties such as successors for a basic block. When false, more naive but faster methods are used.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a6afd39509811f980642d576d75b80bc5" name="a6afd39509811f980642d576d75b80bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afd39509811f980642d576d75b80bc5">&#9670;&#160;</a></span>usingSymbolicSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::usingSymbolicSemantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use or not use symbolic semantics. </p>
<p>When true, a symbolic semantics domain will be used to reason about certain code properties such as successors for a basic block. When false, more naive but faster methods are used.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="aacc6e0b5abbd00fa7532bbefdf282b45" name="aacc6e0b5abbd00fa7532bbefdf282b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc6e0b5abbd00fa7532bbefdf282b45">&#9670;&#160;</a></span>autoAddCallReturnEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::autoAddCallReturnEdges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Insert (or not) function call return edges. </p>
<p>When true, attaching a function call basic block to the CFG will create a call-return edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) in the CFG even if the basic block has no explicit call-return edge and an analysis indicates that the callee (or at least one callee if there are more than one) may return. Call-return edges are typically the edge from a <code>CALL</code> instruction to the instruction immediately following in the address space.</p>
<p>If true, then the decision to add a call-return edge is made at the time the function call site is attached to the basic block, but the may-return analysis for the callees might be indeterminate at that time (such as if the callee instructions have not been discovered). The assumeCallsReturn partitioner property can be used to guess whether indeterminate may-return analysis should be assumed as a positive or negative result.</p>
<p>Deciding whether to add a call-return edge at the time of the call-site insertion can result in two kinds of errors: an extra CFG edge where there shouldn't be one, or a missing CFG edge where there should be one. An alternative is to turn off the autoAddCallReturnEdges property and delay the decision to a time when more information is available. This is the approach taken by the default <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &ndash; it maintains a list of basic blocks that need to be investigated at a later time to determine if a call-return edge should be inserted, and it delays the decision as long as possible.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a5d3ce89bee3aaf40be572adc12721774" name="a5d3ce89bee3aaf40be572adc12721774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3ce89bee3aaf40be572adc12721774">&#9670;&#160;</a></span>autoAddCallReturnEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::autoAddCallReturnEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Insert (or not) function call return edges. </p>
<p>When true, attaching a function call basic block to the CFG will create a call-return edge (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a76ea6d7de9572eb01afabb86058c5a6e">E_CALL_RETURN</a>) in the CFG even if the basic block has no explicit call-return edge and an analysis indicates that the callee (or at least one callee if there are more than one) may return. Call-return edges are typically the edge from a <code>CALL</code> instruction to the instruction immediately following in the address space.</p>
<p>If true, then the decision to add a call-return edge is made at the time the function call site is attached to the basic block, but the may-return analysis for the callees might be indeterminate at that time (such as if the callee instructions have not been discovered). The assumeCallsReturn partitioner property can be used to guess whether indeterminate may-return analysis should be assumed as a positive or negative result.</p>
<p>Deciding whether to add a call-return edge at the time of the call-site insertion can result in two kinds of errors: an extra CFG edge where there shouldn't be one, or a missing CFG edge where there should be one. An alternative is to turn off the autoAddCallReturnEdges property and delay the decision to a time when more information is available. This is the approach taken by the default <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> &ndash; it maintains a list of basic blocks that need to be investigated at a later time to determine if a call-return edge should be inserted, and it delays the decision as long as possible.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a814aa15cf8a9e2a64c4eed1f296ee12f" name="a814aa15cf8a9e2a64c4eed1f296ee12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814aa15cf8a9e2a64c4eed1f296ee12f">&#9670;&#160;</a></span>assumeFunctionsReturn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::assumeFunctionsReturn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Assume (or not) that function calls return. </p>
<p>If the may-return analysis is indeterminate and the partitioner needs to make an immediate decision about whether a function might return to its caller then this property is used. This property also determines whether the may-return analysis uses a whitelist or blacklist.</p>
<p>If this property is true, then functions are assumed to return unless it can be proven that they cannot. A blacklist is one way to prove that a function does not return. On the other hand, if this property is false then functions are assumed to not return unless it can be proven that they can. A whitelist is one way to prove that a function can return.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a4bff28f30fb934d587a87db10cc7b376" name="a4bff28f30fb934d587a87db10cc7b376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bff28f30fb934d587a87db10cc7b376">&#9670;&#160;</a></span>assumeFunctionsReturn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::assumeFunctionsReturn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Assume (or not) that function calls return. </p>
<p>If the may-return analysis is indeterminate and the partitioner needs to make an immediate decision about whether a function might return to its caller then this property is used. This property also determines whether the may-return analysis uses a whitelist or blacklist.</p>
<p>If this property is true, then functions are assumed to return unless it can be proven that they cannot. A blacklist is one way to prove that a function does not return. On the other hand, if this property is false then functions are assumed to not return unless it can be proven that they can. A whitelist is one way to prove that a function can return.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a617226ae2c4d7a265c062feb62514263" name="a617226ae2c4d7a265c062feb62514263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617226ae2c4d7a265c062feb62514263">&#9670;&#160;</a></span>addressName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::addressName </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name for address. </p>
<p>The partitioner stores a mapping from addresses to user specified names and uses those names when no other names are specified. For instance, if a function that has no name is attached to the CFG/AUM and a name has been specified for its entry address, then the function is given that name.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a513eacb6e9cfed7aa0318dfa27ce5053" name="a513eacb6e9cfed7aa0318dfa27ce5053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513eacb6e9cfed7aa0318dfa27ce5053">&#9670;&#160;</a></span>addressName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::addressName </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name for address. </p>
<p>The partitioner stores a mapping from addresses to user specified names and uses those names when no other names are specified. For instance, if a function that has no name is attached to the CFG/AUM and a name has been specified for its entry address, then the function is given that name.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ac53f179dcd5c69d16abf99c4a013df50" name="ac53f179dcd5c69d16abf99c4a013df50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53f179dcd5c69d16abf99c4a013df50">&#9670;&#160;</a></span>addressNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a00e4b59c220a710a50c2865c337c52f4">AddressNameMap</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::addressNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Name for address. </p>
<p>The partitioner stores a mapping from addresses to user specified names and uses those names when no other names are specified. For instance, if a function that has no name is attached to the CFG/AUM and a name has been specified for its entry address, then the function is given that name.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a3a74d34a46abec1d6d76bcfc850acc12" name="a3a74d34a46abec1d6d76bcfc850acc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a74d34a46abec1d6d76bcfc850acc12">&#9670;&#160;</a></span>sourceLocations() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::sourceLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Source locations. </p>
<p>The partitioner stores a mapping from source locations to virtual addresses and vice versa. </p>

</div>
</div>
<a id="af04011a92e1f74fed11979763482e52c" name="af04011a92e1f74fed11979763482e52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04011a92e1f74fed11979763482e52c">&#9670;&#160;</a></span>sourceLocations() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp; Rose::BinaryAnalysis::Partitioner2::Partitioner::sourceLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Source locations. </p>
<p>The partitioner stores a mapping from source locations to virtual addresses and vice versa. </p>

</div>
</div>
<a id="ae171748caa4fd6464b3d3ae8f3c6c78a" name="ae171748caa4fd6464b3d3ae8f3c6c78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae171748caa4fd6464b3d3ae8f3c6c78a">&#9670;&#160;</a></span>sourceLocations() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::sourceLocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SourceLocations.html">SourceLocations</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Source locations. </p>
<p>The partitioner stores a mapping from source locations to virtual addresses and vice versa. </p>

</div>
</div>
<a id="a6b8429dbe1667ba105dd8fc07c717b1b" name="a6b8429dbe1667ba105dd8fc07c717b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8429dbe1667ba105dd8fc07c717b1b">&#9670;&#160;</a></span>checkingCallBranch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Partitioner::checkingCallBranch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Whether to look for function calls used as branches. </p>
<p>If this property is set, then function call instructions are not automatically assumed to be actual function calls.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a3dacab680b5e42d3d5c778523ae5e85c" name="a3dacab680b5e42d3d5c778523ae5e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dacab680b5e42d3d5c778523ae5e85c">&#9670;&#160;</a></span>checkingCallBranch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::checkingCallBranch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Whether to look for function calls used as branches. </p>
<p>If this property is set, then function call instructions are not automatically assumed to be actual function calls.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a2255efa947eb938f95d9fda0c228abe7" name="a2255efa947eb938f95d9fda0c228abe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255efa947eb938f95d9fda0c228abe7">&#9670;&#160;</a></span>semanticMemoryParadigm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::semanticMemoryParadigm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Whether to use map- or list-based memory states. </p>
<p>The partitioner can use either list-based memory states or map-based memory states. The list-based states are more precise, but the map-based states are faster. This property determines which kind of state is created by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7d74a04b3bb40159766088ba7fb60171">newOperators</a> method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ada3a0642ddfe12bbb3880eb0f6cc103b" name="ada3a0642ddfe12bbb3880eb0f6cc103b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3a0642ddfe12bbb3880eb0f6cc103b">&#9670;&#160;</a></span>semanticMemoryParadigm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Partitioner::semanticMemoryParadigm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Whether to use map- or list-based memory states. </p>
<p>The partitioner can use either list-based memory states or map-based memory states. The list-based states are more precise, but the map-based states are faster. This property determines which kind of state is created by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a7d74a04b3bb40159766088ba7fb60171">newOperators</a> method.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="ab8c8051284aaa4144b0126713a7e0c0f" name="ab8c8051284aaa4144b0126713a7e0c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c8051284aaa4144b0126713a7e0c0f">&#9670;&#160;</a></span>smtSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::smtSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SMT solver. </p>
<p>Returns the SMT solver being used for instruction semantics. The partitioner owns the solver, so the caller should not delete it. Some configurations will not use a solver, in which case the null pointer is returned.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a7d74a04b3bb40159766088ba7fb60171" name="a7d74a04b3bb40159766088ba7fb60171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d74a04b3bb40159766088ba7fb60171">&#9670;&#160;</a></span>newOperators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::newOperators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain new RiscOperators. </p>
<p>Creates a new instruction semantics infrastructure with a fresh machine state. The partitioner supports two kinds of memory state representations: list-based and map-based (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2255efa947eb938f95d9fda0c228abe7">semanticMemoryParadigm</a>). If the memory paradigm is not specified then the partitioner's default paradigm is used. Returns a null pointer if the architecture does not support semantics.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a65534c6d358b36a9165ce7534c28fba4" name="a65534c6d358b36a9165ce7534c28fba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65534c6d358b36a9165ce7534c28fba4">&#9670;&#160;</a></span>newOperators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::newOperators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aadadf7e7180c2ad4b04995fa7f4df7c5">SemanticMemoryParadigm</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain new RiscOperators. </p>
<p>Creates a new instruction semantics infrastructure with a fresh machine state. The partitioner supports two kinds of memory state representations: list-based and map-based (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a2255efa947eb938f95d9fda0c228abe7">semanticMemoryParadigm</a>). If the memory paradigm is not specified then the partitioner's default paradigm is used. Returns a null pointer if the architecture does not support semantics.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<a id="a8b603e348398a65bcfe4664742b7c802" name="a8b603e348398a65bcfe4664742b7c802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b603e348398a65bcfe4664742b7c802">&#9670;&#160;</a></span>newDispatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> Rose::BinaryAnalysis::Partitioner2::Partitioner::newDispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a new instruction semantics dispatcher. </p>
<p>Creates and returns a new dispatcher for the instruction semantics framework. The dispatcher will contain a copy of the RiscOperators argument initialized with a new memory/register state. Returns a null pointer if instruction semantics are not supported for the specimen's architecture.</p>
<p>Thread safety: Not thread safe. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Partitioner_8h_source.html">Partitioner.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
