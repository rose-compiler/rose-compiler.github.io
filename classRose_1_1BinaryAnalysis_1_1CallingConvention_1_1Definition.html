<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::CallingConvention::Definition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html">CallingConvention</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html">Definition</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::CallingConvention::Definition Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Information about calling conventions. </p>
<p>A definition typically comes from external documentation rather than direct analysis. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00030">30</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Definition_8h_source.html">Rose/BinaryAnalysis/CallingConvention/Definition.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::CallingConvention::Definition:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_inherit__map" id="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_inherit__map">
<area shape="rect" title="Information about calling conventions." alt="" coords="8,79,156,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,31"/>
<area shape="poly" title=" " alt="" coords="85,45,85,78,79,78,79,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::CallingConvention::Definition:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_coll__map" id="aRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition_coll__map">
<area shape="rect" title="Information about calling conventions." alt="" coords="8,79,156,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,31"/>
<area shape="poly" title=" " alt="" coords="85,45,85,78,79,78,79,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a147b7c9dd7d27c5894748ec98a227125" id="r_a147b7c9dd7d27c5894748ec98a227125"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">DefinitionPtr</a></td></tr>
<tr class="memdesc:a147b7c9dd7d27c5894748ec98a227125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer to calling convention definition.  <br /></td></tr>
<tr class="separator:a147b7c9dd7d27c5894748ec98a227125"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63b2922124346d84befe1b3b42106e77" id="r_a63b2922124346d84befe1b3b42106e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a63b2922124346d84befe1b3b42106e77">clearParameters</a> ()</td></tr>
<tr class="memdesc:a63b2922124346d84befe1b3b42106e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all parameters.  <br /></td></tr>
<tr class="separator:a63b2922124346d84befe1b3b42106e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7128c9c9a6202cada8a54ae2ad6cc42e" id="r_a7128c9c9a6202cada8a54ae2ad6cc42e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a7128c9c9a6202cada8a54ae2ad6cc42e">inputParameters</a> () const</td></tr>
<tr class="memdesc:a7128c9c9a6202cada8a54ae2ad6cc42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Enumerated input parameters.  <br /></td></tr>
<tr class="separator:a7128c9c9a6202cada8a54ae2ad6cc42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5407a5c269b01556a1640345e32a9e6" id="r_af5407a5c269b01556a1640345e32a9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#af5407a5c269b01556a1640345e32a9e6">inputRegisterParts</a> () const</td></tr>
<tr class="memdesc:af5407a5c269b01556a1640345e32a9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the set of input registers.  <br /></td></tr>
<tr class="separator:af5407a5c269b01556a1640345e32a9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2ec8f3eee6bb279c2c7eef49ebed38" id="r_a2e2ec8f3eee6bb279c2c7eef49ebed38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2e2ec8f3eee6bb279c2c7eef49ebed38">clearInputParameters</a> ()</td></tr>
<tr class="memdesc:a2e2ec8f3eee6bb279c2c7eef49ebed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase enumerated input parameters.  <br /></td></tr>
<tr class="separator:a2e2ec8f3eee6bb279c2c7eef49ebed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bf9e0333fa370be641f13cab39ee7b" id="r_a20bf9e0333fa370be641f13cab39ee7b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a20bf9e0333fa370be641f13cab39ee7b">outputParameters</a> () const</td></tr>
<tr class="memdesc:a20bf9e0333fa370be641f13cab39ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: List of output parameters.  <br /></td></tr>
<tr class="separator:a20bf9e0333fa370be641f13cab39ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2153a01a2f00329f4ae41a985f9d93dd" id="r_a2153a01a2f00329f4ae41a985f9d93dd"><td class="memItemLeft" align="right" valign="top"><a id="a2153a01a2f00329f4ae41a985f9d93dd" name="a2153a01a2f00329f4ae41a985f9d93dd"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>outputRegisterParts</b> () const</td></tr>
<tr class="memdesc:a2153a01a2f00329f4ae41a985f9d93dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of output registers. <br /></td></tr>
<tr class="separator:a2153a01a2f00329f4ae41a985f9d93dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f97351d957b65c7c49e72dcc3377889" id="r_a6f97351d957b65c7c49e72dcc3377889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6f97351d957b65c7c49e72dcc3377889">clearOutputParameters</a> ()</td></tr>
<tr class="memdesc:a6f97351d957b65c7c49e72dcc3377889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase output parameters.  <br /></td></tr>
<tr class="separator:a6f97351d957b65c7c49e72dcc3377889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b65950021e908228a5d559c15780dd" id="r_a32b65950021e908228a5d559c15780dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a32b65950021e908228a5d559c15780dd">byteOrder</a> () const</td></tr>
<tr class="memdesc:a32b65950021e908228a5d559c15780dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Order of bytes for multi-byte values in memory.  <br /></td></tr>
<tr class="separator:a32b65950021e908228a5d559c15780dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d69f3c4f0249857a5b9cae0cb2d89f" id="r_a10d69f3c4f0249857a5b9cae0cb2d89f"><td class="memItemLeft" align="right" valign="top"><a id="a10d69f3c4f0249857a5b9cae0cb2d89f" name="a10d69f3c4f0249857a5b9cae0cb2d89f"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calleeSavedRegisterParts</b> () const</td></tr>
<tr class="memdesc:a10d69f3c4f0249857a5b9cae0cb2d89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the set of callee-saved registers. <br /></td></tr>
<tr class="separator:a10d69f3c4f0249857a5b9cae0cb2d89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e62c11d247a502eaa6b4957fe88add" id="r_a12e62c11d247a502eaa6b4957fe88add"><td class="memItemLeft" align="right" valign="top"><a id="a12e62c11d247a502eaa6b4957fe88add" name="a12e62c11d247a502eaa6b4957fe88add"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scratchRegisterParts</b> () const</td></tr>
<tr class="memdesc:a12e62c11d247a502eaa6b4957fe88add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the set of scratch registers. <br /></td></tr>
<tr class="separator:a12e62c11d247a502eaa6b4957fe88add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20570f076da7e4572676115173aafbd" id="r_ac20570f076da7e4572676115173aafbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ac20570f076da7e4572676115173aafbd">getUsedRegisterParts</a> () const</td></tr>
<tr class="memdesc:ac20570f076da7e4572676115173aafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all registers mentioned in this definition.  <br /></td></tr>
<tr class="separator:ac20570f076da7e4572676115173aafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a711044f66f4736662c89bbead1289376" id="r_a711044f66f4736662c89bbead1289376"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a711044f66f4736662c89bbead1289376">comment</a> () const</td></tr>
<tr class="memdesc:a711044f66f4736662c89bbead1289376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Full name of calling convention.  <br /></td></tr>
<tr class="separator:a711044f66f4736662c89bbead1289376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2042f28ae7178c4ea3d72b892f8bad" id="r_abf2042f28ae7178c4ea3d72b892f8bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#abf2042f28ae7178c4ea3d72b892f8bad">comment</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:abf2042f28ae7178c4ea3d72b892f8bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Full name of calling convention.  <br /></td></tr>
<tr class="separator:abf2042f28ae7178c4ea3d72b892f8bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1858bd6690066c3260f5bad602c7c599" id="r_a1858bd6690066c3260f5bad602c7c599"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a1858bd6690066c3260f5bad602c7c599">bitsPerWord</a> () const</td></tr>
<tr class="memdesc:a1858bd6690066c3260f5bad602c7c599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size in bits.  <br /></td></tr>
<tr class="separator:a1858bd6690066c3260f5bad602c7c599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbcf244d3f96dadc592c15a45e1fd89" id="r_afdbcf244d3f96dadc592c15a45e1fd89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#afdbcf244d3f96dadc592c15a45e1fd89">bitsPerWord</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;)</td></tr>
<tr class="memdesc:afdbcf244d3f96dadc592c15a45e1fd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size in bits.  <br /></td></tr>
<tr class="separator:afdbcf244d3f96dadc592c15a45e1fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeee8a8c3b854ad474de1a7b248ed7405" id="r_aeee8a8c3b854ad474de1a7b248ed7405"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#aeee8a8c3b854ad474de1a7b248ed7405">nonParameterInputs</a> () const</td></tr>
<tr class="memdesc:aeee8a8c3b854ad474de1a7b248ed7405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-parameter inputs.  <br /></td></tr>
<tr class="separator:aeee8a8c3b854ad474de1a7b248ed7405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2351945ef173416f91128d5bece0b2e6" id="r_a2351945ef173416f91128d5bece0b2e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2351945ef173416f91128d5bece0b2e6">nonParameterInputs</a> ()</td></tr>
<tr class="memdesc:a2351945ef173416f91128d5bece0b2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-parameter inputs.  <br /></td></tr>
<tr class="separator:a2351945ef173416f91128d5bece0b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ade3e21ee4aa09471031ba3db89aab8a9" id="r_ade3e21ee4aa09471031ba3db89aab8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ade3e21ee4aa09471031ba3db89aab8a9">appendInputParameter</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;)</td></tr>
<tr class="memdesc:ade3e21ee4aa09471031ba3db89aab8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append input parameter.  <br /></td></tr>
<tr class="separator:ade3e21ee4aa09471031ba3db89aab8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891f4db792ae89f0ea31ea1da9ffb99" id="r_ac891f4db792ae89f0ea31ea1da9ffb99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ac891f4db792ae89f0ea31ea1da9ffb99">appendInputParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg)</td></tr>
<tr class="memdesc:ac891f4db792ae89f0ea31ea1da9ffb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append input parameter.  <br /></td></tr>
<tr class="separator:ac891f4db792ae89f0ea31ea1da9ffb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e28fb9d677d68af87a3af4a54b925" id="r_a6b7e28fb9d677d68af87a3af4a54b925"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6b7e28fb9d677d68af87a3af4a54b925">appendInputParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, int64_t offset)</td></tr>
<tr class="memdesc:a6b7e28fb9d677d68af87a3af4a54b925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append input parameter.  <br /></td></tr>
<tr class="separator:a6b7e28fb9d677d68af87a3af4a54b925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899c363a8e691c5330fa8a47f2e8b09" id="r_ad899c363a8e691c5330fa8a47f2e8b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ad899c363a8e691c5330fa8a47f2e8b09">appendInputParameter</a> (rose_addr_t va)</td></tr>
<tr class="memdesc:ad899c363a8e691c5330fa8a47f2e8b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append input parameter.  <br /></td></tr>
<tr class="separator:ad899c363a8e691c5330fa8a47f2e8b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae2d521e08b220dfef241415ffdfaa3b5" id="r_ae2d521e08b220dfef241415ffdfaa3b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae2d521e08b220dfef241415ffdfaa3b5">appendOutputParameter</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;)</td></tr>
<tr class="memdesc:ae2d521e08b220dfef241415ffdfaa3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append output parameter.  <br /></td></tr>
<tr class="separator:ae2d521e08b220dfef241415ffdfaa3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67222a6940a8033d0031429c9617259" id="r_ae67222a6940a8033d0031429c9617259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae67222a6940a8033d0031429c9617259">appendOutputParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg)</td></tr>
<tr class="memdesc:ae67222a6940a8033d0031429c9617259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append output parameter.  <br /></td></tr>
<tr class="separator:ae67222a6940a8033d0031429c9617259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d676e036c51a276cbd1fbbc444ec95" id="r_a64d676e036c51a276cbd1fbbc444ec95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a64d676e036c51a276cbd1fbbc444ec95">appendOutputParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, int64_t offset)</td></tr>
<tr class="memdesc:a64d676e036c51a276cbd1fbbc444ec95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append output parameter.  <br /></td></tr>
<tr class="separator:a64d676e036c51a276cbd1fbbc444ec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c1b9f8eebb579db8a313a6f6b2718" id="r_ad43c1b9f8eebb579db8a313a6f6b2718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ad43c1b9f8eebb579db8a313a6f6b2718">appendOutputParameter</a> (rose_addr_t va)</td></tr>
<tr class="memdesc:ad43c1b9f8eebb579db8a313a6f6b2718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append output parameter.  <br /></td></tr>
<tr class="separator:ad43c1b9f8eebb579db8a313a6f6b2718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20bad253596039d6a0d2150cd574f479" id="r_a20bad253596039d6a0d2150cd574f479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#aad5ead8d3159ae269bf3a14c3afd29a0">StackParameterOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a20bad253596039d6a0d2150cd574f479">stackParameterOrder</a> () const</td></tr>
<tr class="memdesc:a20bad253596039d6a0d2150cd574f479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack parameter order.  <br /></td></tr>
<tr class="separator:a20bad253596039d6a0d2150cd574f479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254cbd0e054495dcaf54e8d81e6e2a02" id="r_a254cbd0e054495dcaf54e8d81e6e2a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a254cbd0e054495dcaf54e8d81e6e2a02">stackParameterOrder</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#aad5ead8d3159ae269bf3a14c3afd29a0">StackParameterOrder</a> x)</td></tr>
<tr class="memdesc:a254cbd0e054495dcaf54e8d81e6e2a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack parameter order.  <br /></td></tr>
<tr class="separator:a254cbd0e054495dcaf54e8d81e6e2a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9c358a160b66ffdfb0f0213c3e0c685b" id="r_a9c358a160b66ffdfb0f0213c3e0c685b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a9c358a160b66ffdfb0f0213c3e0c685b">stackPointerRegister</a> () const</td></tr>
<tr class="memdesc:a9c358a160b66ffdfb0f0213c3e0c685b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register for implied stack parameters.  <br /></td></tr>
<tr class="separator:a9c358a160b66ffdfb0f0213c3e0c685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3728e3f2ebeb5bc1066cfd5013a65b" id="r_a8e3728e3f2ebeb5bc1066cfd5013a65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a8e3728e3f2ebeb5bc1066cfd5013a65b">stackPointerRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>)</td></tr>
<tr class="memdesc:a8e3728e3f2ebeb5bc1066cfd5013a65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register for implied stack parameters.  <br /></td></tr>
<tr class="separator:a8e3728e3f2ebeb5bc1066cfd5013a65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7dedbc78553593a71f601574a9a915b6" id="r_a7dedbc78553593a71f601574a9a915b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a7dedbc78553593a71f601574a9a915b6">nonParameterStackSize</a> () const</td></tr>
<tr class="memdesc:a7dedbc78553593a71f601574a9a915b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Size of non-parameter stack area.  <br /></td></tr>
<tr class="separator:a7dedbc78553593a71f601574a9a915b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a914f5c905cd1b6614ea1472f7ba78" id="r_ad3a914f5c905cd1b6614ea1472f7ba78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ad3a914f5c905cd1b6614ea1472f7ba78">nonParameterStackSize</a> (size_t nBytes)</td></tr>
<tr class="memdesc:ad3a914f5c905cd1b6614ea1472f7ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Size of non-parameter stack area.  <br /></td></tr>
<tr class="separator:ad3a914f5c905cd1b6614ea1472f7ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acb7f994ffd7041c8e089eabb0465e25c" id="r_acb7f994ffd7041c8e089eabb0465e25c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#acb7f994ffd7041c8e089eabb0465e25c">stackDirection</a> () const</td></tr>
<tr class="memdesc:acb7f994ffd7041c8e089eabb0465e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Direction that stack grows for a push operation.  <br /></td></tr>
<tr class="separator:acb7f994ffd7041c8e089eabb0465e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8442f6972da46b9f394b8f3cb7601973" id="r_a8442f6972da46b9f394b8f3cb7601973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a8442f6972da46b9f394b8f3cb7601973">stackDirection</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a> x)</td></tr>
<tr class="memdesc:a8442f6972da46b9f394b8f3cb7601973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Direction that stack grows for a push operation.  <br /></td></tr>
<tr class="separator:a8442f6972da46b9f394b8f3cb7601973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf10c296ebf530cc268db8a4e734a60b" id="r_acf10c296ebf530cc268db8a4e734a60b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ab6c85c1c76bcd6a3d106ee914ac0b163">StackCleanup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#acf10c296ebf530cc268db8a4e734a60b">stackCleanup</a> () const</td></tr>
<tr class="memdesc:acf10c296ebf530cc268db8a4e734a60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Who pops stack parameters.  <br /></td></tr>
<tr class="separator:acf10c296ebf530cc268db8a4e734a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a5263312db73d95a6163af520c7fe5" id="r_a02a5263312db73d95a6163af520c7fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a02a5263312db73d95a6163af520c7fe5">stackCleanup</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ab6c85c1c76bcd6a3d106ee914ac0b163">StackCleanup</a> x)</td></tr>
<tr class="memdesc:a02a5263312db73d95a6163af520c7fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Who pops stack parameters.  <br /></td></tr>
<tr class="separator:a02a5263312db73d95a6163af520c7fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6e341bc20e9137eaccafc1f794521fad" id="r_a6e341bc20e9137eaccafc1f794521fad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6e341bc20e9137eaccafc1f794521fad">stackAlignment</a> () const</td></tr>
<tr class="memdesc:a6e341bc20e9137eaccafc1f794521fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack alignment.  <br /></td></tr>
<tr class="separator:a6e341bc20e9137eaccafc1f794521fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb627142d723a786ba2cc5ec583c3d0" id="r_a1eb627142d723a786ba2cc5ec583c3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a1eb627142d723a786ba2cc5ec583c3d0">stackAlignment</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;)</td></tr>
<tr class="memdesc:a1eb627142d723a786ba2cc5ec583c3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack alignment.  <br /></td></tr>
<tr class="separator:a1eb627142d723a786ba2cc5ec583c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a72d5e2e92f65274172704f87dd21436d" id="r_a72d5e2e92f65274172704f87dd21436d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a72d5e2e92f65274172704f87dd21436d">thisParameter</a> () const</td></tr>
<tr class="memdesc:a72d5e2e92f65274172704f87dd21436d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Object pointer parameter.  <br /></td></tr>
<tr class="separator:a72d5e2e92f65274172704f87dd21436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1fd286ad0f46a150f1678afced6794" id="r_afa1fd286ad0f46a150f1678afced6794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#afa1fd286ad0f46a150f1678afced6794">thisParameter</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;x)</td></tr>
<tr class="memdesc:afa1fd286ad0f46a150f1678afced6794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Object pointer parameter.  <br /></td></tr>
<tr class="separator:afa1fd286ad0f46a150f1678afced6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa6fcbb9a43ae2c797b044c781fb87" id="r_a1dfa6fcbb9a43ae2c797b044c781fb87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a1dfa6fcbb9a43ae2c797b044c781fb87">thisParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg)</td></tr>
<tr class="memdesc:a1dfa6fcbb9a43ae2c797b044c781fb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Object pointer parameter.  <br /></td></tr>
<tr class="separator:a1dfa6fcbb9a43ae2c797b044c781fb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6646673c790641b05d76a4dc27c2e6" id="r_a1f6646673c790641b05d76a4dc27c2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a1f6646673c790641b05d76a4dc27c2e6">thisParameter</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> reg, int64_t offset)</td></tr>
<tr class="memdesc:a1f6646673c790641b05d76a4dc27c2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Object pointer parameter.  <br /></td></tr>
<tr class="separator:a1f6646673c790641b05d76a4dc27c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324a8293605cebb459b07ea0d38521e" id="r_af324a8293605cebb459b07ea0d38521e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#af324a8293605cebb459b07ea0d38521e">thisParameter</a> (rose_addr_t va)</td></tr>
<tr class="memdesc:af324a8293605cebb459b07ea0d38521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Object pointer parameter.  <br /></td></tr>
<tr class="separator:af324a8293605cebb459b07ea0d38521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a953f5f29b6b5520c2f47b58928a8ed6a" id="r_a953f5f29b6b5520c2f47b58928a8ed6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a953f5f29b6b5520c2f47b58928a8ed6a">returnAddressLocation</a> () const</td></tr>
<tr class="memdesc:a953f5f29b6b5520c2f47b58928a8ed6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of return address.  <br /></td></tr>
<tr class="separator:a953f5f29b6b5520c2f47b58928a8ed6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a50277d72d3271e9513d6ca05916b" id="r_aaf5a50277d72d3271e9513d6ca05916b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#aaf5a50277d72d3271e9513d6ca05916b">returnAddressLocation</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;x)</td></tr>
<tr class="memdesc:aaf5a50277d72d3271e9513d6ca05916b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of return address.  <br /></td></tr>
<tr class="separator:aaf5a50277d72d3271e9513d6ca05916b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67aae882510d3499ab5aa3d8f5518961" id="r_a67aae882510d3499ab5aa3d8f5518961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a67aae882510d3499ab5aa3d8f5518961">instructionPointerRegister</a> () const</td></tr>
<tr class="memdesc:a67aae882510d3499ab5aa3d8f5518961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register that points to next instruction to execute.  <br /></td></tr>
<tr class="separator:a67aae882510d3499ab5aa3d8f5518961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ea9c50df469debee96f3b6c92f1d58" id="r_a37ea9c50df469debee96f3b6c92f1d58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a37ea9c50df469debee96f3b6c92f1d58">instructionPointerRegister</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> x)</td></tr>
<tr class="memdesc:a37ea9c50df469debee96f3b6c92f1d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register that points to next instruction to execute.  <br /></td></tr>
<tr class="separator:a37ea9c50df469debee96f3b6c92f1d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2d23a435cb5f7dfa7d2488e39e688307" id="r_a2d23a435cb5f7dfa7d2488e39e688307"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2d23a435cb5f7dfa7d2488e39e688307">calleeSavedRegisters</a> () const</td></tr>
<tr class="memdesc:a2d23a435cb5f7dfa7d2488e39e688307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Callee-saved registers.  <br /></td></tr>
<tr class="separator:a2d23a435cb5f7dfa7d2488e39e688307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99465c3602edf940d89e24b4506a22d7" id="r_a99465c3602edf940d89e24b4506a22d7"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a99465c3602edf940d89e24b4506a22d7">calleeSavedRegisters</a> ()</td></tr>
<tr class="memdesc:a99465c3602edf940d89e24b4506a22d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Callee-saved registers.  <br /></td></tr>
<tr class="separator:a99465c3602edf940d89e24b4506a22d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2bcd9a2db21a73f830953471fa45f962" id="r_a2bcd9a2db21a73f830953471fa45f962"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2bcd9a2db21a73f830953471fa45f962">scratchRegisters</a> () const</td></tr>
<tr class="memdesc:a2bcd9a2db21a73f830953471fa45f962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Scratch registers.  <br /></td></tr>
<tr class="separator:a2bcd9a2db21a73f830953471fa45f962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650d9740cf23e3e3f418ab3551016267" id="r_a650d9740cf23e3e3f418ab3551016267"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a650d9740cf23e3e3f418ab3551016267">scratchRegisters</a> ()</td></tr>
<tr class="memdesc:a650d9740cf23e3e3f418ab3551016267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Scratch registers.  <br /></td></tr>
<tr class="separator:a650d9740cf23e3e3f418ab3551016267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa9c6fbbeb0fa181a4abebbcc5329565e" id="r_aa9c6fbbeb0fa181a4abebbcc5329565e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#aa9c6fbbeb0fa181a4abebbcc5329565e">returnValueAllocator</a> () const</td></tr>
<tr class="memdesc:aa9c6fbbeb0fa181a4abebbcc5329565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for return values.  <br /></td></tr>
<tr class="separator:aa9c6fbbeb0fa181a4abebbcc5329565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b1c1462ea1daf2c3bd6b5c319bdf18" id="r_af6b1c1462ea1daf2c3bd6b5c319bdf18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#af6b1c1462ea1daf2c3bd6b5c319bdf18">returnValueAllocator</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> &amp;)</td></tr>
<tr class="memdesc:af6b1c1462ea1daf2c3bd6b5c319bdf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for return values.  <br /></td></tr>
<tr class="separator:af6b1c1462ea1daf2c3bd6b5c319bdf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a975e14584e97d969ea955450636c2268" id="r_a975e14584e97d969ea955450636c2268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a975e14584e97d969ea955450636c2268">argumentValueAllocator</a> () const</td></tr>
<tr class="memdesc:a975e14584e97d969ea955450636c2268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for argument values.  <br /></td></tr>
<tr class="separator:a975e14584e97d969ea955450636c2268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fab5db4252faadf2f16ee276034e52" id="r_a90fab5db4252faadf2f16ee276034e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a90fab5db4252faadf2f16ee276034e52">argumentValueAllocator</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> &amp;)</td></tr>
<tr class="memdesc:a90fab5db4252faadf2f16ee276034e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for argument values.  <br /></td></tr>
<tr class="separator:a90fab5db4252faadf2f16ee276034e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a888636d4de3d8b848e7e4682cae06416" id="r_a888636d4de3d8b848e7e4682cae06416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a888636d4de3d8b848e7e4682cae06416">print</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a888636d4de3d8b848e7e4682cae06416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print detailed information about this calling convention.  <br /></td></tr>
<tr class="separator:a888636d4de3d8b848e7e4682cae06416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5f67d5c962dfe62816e1b23426aee3" id="r_a6e5f67d5c962dfe62816e1b23426aee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6e5f67d5c962dfe62816e1b23426aee3">print</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;regDict) const</td></tr>
<tr class="memdesc:a6e5f67d5c962dfe62816e1b23426aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print detailed information about this calling convention.  <br /></td></tr>
<tr class="separator:a6e5f67d5c962dfe62816e1b23426aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf9475d0c7c1ef6c71118ccba4624f9b" id="r_adf9475d0c7c1ef6c71118ccba4624f9b"><td class="memTemplParams" colspan="2"><a id="adf9475d0c7c1ef6c71118ccba4624f9b" name="adf9475d0c7c1ef6c71118ccba4624f9b"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:adf9475d0c7c1ef6c71118ccba4624f9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (S &amp;, unsigned)</td></tr>
<tr class="separator:adf9475d0c7c1ef6c71118ccba4624f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334043034cd7b29d1fb58b84fe41bf1e" id="r_a334043034cd7b29d1fb58b84fe41bf1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a334043034cd7b29d1fb58b84fe41bf1e">Definition</a> ()</td></tr>
<tr class="memdesc:a334043034cd7b29d1fb58b84fe41bf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a334043034cd7b29d1fb58b84fe41bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">) and is a single word. The comment</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Construct a new calling convention.</p>
<p>The name of the calling convention usually comes from the documentation (see is a more complete name for the convention perhaps including the operating system and architecture but not containing line termination. </p>
</td></tr>
<tr class="memitem:a3b6cfc260ed47d194b4e2dfedd7630aa" id="r_a3b6cfc260ed47d194b4e2dfedd7630aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a3b6cfc260ed47d194b4e2dfedd7630aa">Definition</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a3c1b7b877e182f6e4e49c0da752efbdc">name</a>, const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a711044f66f4736662c89bbead1289376">comment</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:a3b6cfc260ed47d194b4e2dfedd7630aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated.  <br /></td></tr>
<tr class="separator:a3b6cfc260ed47d194b4e2dfedd7630aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2452e72621515eb4e4b4d6267a0e972c" id="r_a2452e72621515eb4e4b4d6267a0e972c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2452e72621515eb4e4b4d6267a0e972c">~Definition</a> ()</td></tr>
<tr class="memdesc:a2452e72621515eb4e4b4d6267a0e972c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated.  <br /></td></tr>
<tr class="separator:a2452e72621515eb4e4b4d6267a0e972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9521097024a7088397978b2ce6b45fcc" id="r_a9521097024a7088397978b2ce6b45fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a9521097024a7088397978b2ce6b45fcc">architecture</a> () const</td></tr>
<tr class="memdesc:a9521097024a7088397978b2ce6b45fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated.  <br /></td></tr>
<tr class="separator:a9521097024a7088397978b2ce6b45fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6accbc16fb31e2cec735b4500f7384a5" id="r_a6accbc16fb31e2cec735b4500f7384a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6accbc16fb31e2cec735b4500f7384a5">registerDictionary</a> () const</td></tr>
<tr class="memdesc:a6accbc16fb31e2cec735b4500f7384a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register dictionary for the architecture.  <br /></td></tr>
<tr class="separator:a6accbc16fb31e2cec735b4500f7384a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1b7b877e182f6e4e49c0da752efbdc" id="r_a3c1b7b877e182f6e4e49c0da752efbdc"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a3c1b7b877e182f6e4e49c0da752efbdc">name</a> () const</td></tr>
<tr class="memdesc:a3c1b7b877e182f6e4e49c0da752efbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Short name of calling convention.  <br /></td></tr>
<tr class="separator:a3c1b7b877e182f6e4e49c0da752efbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faac2b11cb88534de7f763c8bfb88e8" id="r_a5faac2b11cb88534de7f763c8bfb88e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a5faac2b11cb88534de7f763c8bfb88e8">name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a5faac2b11cb88534de7f763c8bfb88e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated.  <br /></td></tr>
<tr class="separator:a5faac2b11cb88534de7f763c8bfb88e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45265b16e6d191a5aa63da1d1777fcc" id="r_ac45265b16e6d191a5aa63da1d1777fcc"><td class="memItemLeft" align="right" valign="top"><a id="ac45265b16e6d191a5aa63da1d1777fcc" name="ac45265b16e6d191a5aa63da1d1777fcc"></a>
static <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a3c1b7b877e182f6e4e49c0da752efbdc">name</a>, const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a711044f66f4736662c89bbead1289376">comment</a>, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="memdesc:ac45265b16e6d191a5aa63da1d1777fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocating constructor. <br /></td></tr>
<tr class="separator:ac45265b16e6d191a5aa63da1d1777fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a147b7c9dd7d27c5894748ec98a227125" name="a147b7c9dd7d27c5894748ec98a227125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147b7c9dd7d27c5894748ec98a227125">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a147b7c9dd7d27c5894748ec98a227125">Rose::BinaryAnalysis::CallingConvention::Definition::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">DefinitionPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer to calling convention definition. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00033">33</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a334043034cd7b29d1fb58b84fe41bf1e" name="a334043034cd7b29d1fb58b84fe41bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334043034cd7b29d1fb58b84fe41bf1e">&#9670;&#160;</a></span>Definition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::CallingConvention::Definition::Definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs a new calling convention with no name or parameters. </p>

</div>
</div>
<a id="a3b6cfc260ed47d194b4e2dfedd7630aa" name="a3b6cfc260ed47d194b4e2dfedd7630aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6cfc260ed47d194b4e2dfedd7630aa">&#9670;&#160;</a></span>Definition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::CallingConvention::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated. </p>
<p>Returns a non-null architecture from a weak pointer, aborting if the architecture has been deleted. Since <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> objects contain a dictionary of all their calling conventions, the architecture's lifetime normally exceeds the lifetime of a calling convention definition and the weak pointer will be valid. </p>

</div>
</div>
<a id="a2452e72621515eb4e4b4d6267a0e972c" name="a2452e72621515eb4e4b4d6267a0e972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2452e72621515eb4e4b4d6267a0e972c">&#9670;&#160;</a></span>~Definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::CallingConvention::Definition::~Definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated. </p>
<p>Returns a non-null architecture from a weak pointer, aborting if the architecture has been deleted. Since <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> objects contain a dictionary of all their calling conventions, the architecture's lifetime normally exceeds the lifetime of a calling convention definition and the weak pointer will be valid. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9521097024a7088397978b2ce6b45fcc" name="a9521097024a7088397978b2ce6b45fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9521097024a7088397978b2ce6b45fcc">&#9670;&#160;</a></span>architecture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::CallingConvention::Definition::architecture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated. </p>
<p>Returns a non-null architecture from a weak pointer, aborting if the architecture has been deleted. Since <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> objects contain a dictionary of all their calling conventions, the architecture's lifetime normally exceeds the lifetime of a calling convention definition and the weak pointer will be valid. </p>

</div>
</div>
<a id="a6accbc16fb31e2cec735b4500f7384a5" name="a6accbc16fb31e2cec735b4500f7384a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6accbc16fb31e2cec735b4500f7384a5">&#9670;&#160;</a></span>registerDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> Rose::BinaryAnalysis::CallingConvention::Definition::registerDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Register dictionary for the architecture. </p>
<p>This property is read-only, set by the constructor. The register dictionary is not null. </p>

</div>
</div>
<a id="a3c1b7b877e182f6e4e49c0da752efbdc" name="a3c1b7b877e182f6e4e49c0da752efbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1b7b877e182f6e4e49c0da752efbdc">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::CallingConvention::Definition::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Short name of calling convention. </p>
<p>Standard calling conventions have documented names, like "stdcall" and that's what should appear here. They're usually a single word. It is not necessary to include information like compiler, OS, wordsize, etc. Instead, the calling convention dictionary will have more than one convention named "stdcall" for the various architectures, one for x86 32-bit, another for x86-64, etc. Also, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a711044f66f4736662c89bbead1289376">comment</a> property can contain a more complete name. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00114">114</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a5faac2b11cb88534de7f763c8bfb88e8" name="a5faac2b11cb88534de7f763c8bfb88e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faac2b11cb88534de7f763c8bfb88e8">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> with which this definition is associated. </p>
<p>Returns a non-null architecture from a weak pointer, aborting if the architecture has been deleted. Since <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> objects contain a dictionary of all their calling conventions, the architecture's lifetime normally exceeds the lifetime of a calling convention definition and the weak pointer will be valid. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00115">115</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a711044f66f4736662c89bbead1289376" name="a711044f66f4736662c89bbead1289376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711044f66f4736662c89bbead1289376">&#9670;&#160;</a></span>comment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::CallingConvention::Definition::comment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Full name of calling convention. </p>
<p>Whereas the <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> property contains a single-word name, this property contains the full name of the calling convention. The full name may include an operating system, compiler, architecture, word-size etc. It should not contain any line termination. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00125">125</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="abf2042f28ae7178c4ea3d72b892f8bad" name="abf2042f28ae7178c4ea3d72b892f8bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2042f28ae7178c4ea3d72b892f8bad">&#9670;&#160;</a></span>comment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Full name of calling convention. </p>
<p>Whereas the <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> property contains a single-word name, this property contains the full name of the calling convention. The full name may include an operating system, compiler, architecture, word-size etc. It should not contain any line termination. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00126">126</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a1858bd6690066c3260f5bad602c7c599" name="a1858bd6690066c3260f5bad602c7c599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1858bd6690066c3260f5bad602c7c599">&#9670;&#160;</a></span>bitsPerWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CallingConvention::Definition::bitsPerWord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Word size in bits. </p>
<p>This is the natural width of a word measured in bits. The value is positive and usually a multiple of eight.</p>
<p>If this property has no value, then it defaults to the word size of the architecture. </p>

</div>
</div>
<a id="afdbcf244d3f96dadc592c15a45e1fd89" name="afdbcf244d3f96dadc592c15a45e1fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbcf244d3f96dadc592c15a45e1fd89">&#9670;&#160;</a></span>bitsPerWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::bitsPerWord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Word size in bits. </p>
<p>This is the natural width of a word measured in bits. The value is positive and usually a multiple of eight.</p>
<p>If this property has no value, then it defaults to the word size of the architecture. </p>

</div>
</div>
<a id="aeee8a8c3b854ad474de1a7b248ed7405" name="aeee8a8c3b854ad474de1a7b248ed7405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee8a8c3b854ad474de1a7b248ed7405">&#9670;&#160;</a></span>nonParameterInputs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::nonParameterInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-parameter inputs. </p>
<p>This is the list of all allowed inputs that are not function parameters. For instance, things like the instruction pointer which the caller initializes to be the entry point of the function, or the x86 direction flag "df" which is normally set by the caller but not considered a function argument. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00147">147</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a2351945ef173416f91128d5bece0b2e6" name="a2351945ef173416f91128d5bece0b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2351945ef173416f91128d5bece0b2e6">&#9670;&#160;</a></span>nonParameterInputs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::nonParameterInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-parameter inputs. </p>
<p>This is the list of all allowed inputs that are not function parameters. For instance, things like the instruction pointer which the caller initializes to be the entry point of the function, or the x86 direction flag "df" which is normally set by the caller but not considered a function argument. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00148">148</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a63b2922124346d84befe1b3b42106e77" name="a63b2922124346d84befe1b3b42106e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b2922124346d84befe1b3b42106e77">&#9670;&#160;</a></span>clearParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::clearParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all parameters. </p>
<p>Removes all input parameters, output parameters, and object pointer parameter. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00154">154</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="Definition_8h_source.html#l00177">clearInputParameters()</a>, and <a class="el" href="Definition_8h_source.html#l00210">clearOutputParameters()</a>.</p>

</div>
</div>
<a id="a7128c9c9a6202cada8a54ae2ad6cc42e" name="a7128c9c9a6202cada8a54ae2ad6cc42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7128c9c9a6202cada8a54ae2ad6cc42e">&#9670;&#160;</a></span>inputParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::inputParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Enumerated input parameters. </p>
<p>Returns the vector of input (and in-out) parameters that have been enumerated; does not include implied stack parameters. This property is read-only; see also <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ade3e21ee4aa09471031ba3db89aab8a9">appendInputParameter</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a2e2ec8f3eee6bb279c2c7eef49ebed38">clearInputParameters</a>. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00165">165</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="af5407a5c269b01556a1640345e32a9e6" name="af5407a5c269b01556a1640345e32a9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5407a5c269b01556a1640345e32a9e6">&#9670;&#160;</a></span>inputRegisterParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a> Rose::BinaryAnalysis::CallingConvention::Definition::inputRegisterParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the set of input registers. </p>
<p>The returned list is all registers that might serve as function inputs, both function input parameters and non-parameter inputs. </p>

</div>
</div>
<a id="a2e2ec8f3eee6bb279c2c7eef49ebed38" name="a2e2ec8f3eee6bb279c2c7eef49ebed38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2ec8f3eee6bb279c2c7eef49ebed38">&#9670;&#160;</a></span>clearInputParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::clearInputParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase enumerated input parameters. </p>
<p>Removes all enumerated input parameters. In-out parameters, those input parameters that are also listed as outputs, are only removed from the input parameter list, effectively converting them to output-only parameters. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00177">177</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Definition_8h_source.html#l00154">clearParameters()</a>.</p>

</div>
</div>
<a id="ade3e21ee4aa09471031ba3db89aab8a9" name="ade3e21ee4aa09471031ba3db89aab8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3e21ee4aa09471031ba3db89aab8a9">&#9670;&#160;</a></span>appendInputParameter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendInputParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append input parameter. </p>
<p>This method appends a new parameter to the list of enumerated input or in-out parameters. Generally only non-stack parameters need to be enumerated since any parameter with a higher index is assumed to be located on the stack. </p>

<p class="reference">Referenced by <a class="el" href="Definition_8h_source.html#l00186">appendInputParameter()</a>, <a class="el" href="Definition_8h_source.html#l00189">appendInputParameter()</a>, and <a class="el" href="Definition_8h_source.html#l00192">appendInputParameter()</a>.</p>

</div>
</div>
<a id="ac891f4db792ae89f0ea31ea1da9ffb99" name="ac891f4db792ae89f0ea31ea1da9ffb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac891f4db792ae89f0ea31ea1da9ffb99">&#9670;&#160;</a></span>appendInputParameter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendInputParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append input parameter. </p>
<p>This method appends a new parameter to the list of enumerated input or in-out parameters. Generally only non-stack parameters need to be enumerated since any parameter with a higher index is assumed to be located on the stack. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00186">186</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ade3e21ee4aa09471031ba3db89aab8a9">appendInputParameter()</a>.</p>

</div>
</div>
<a id="a6b7e28fb9d677d68af87a3af4a54b925" name="a6b7e28fb9d677d68af87a3af4a54b925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7e28fb9d677d68af87a3af4a54b925">&#9670;&#160;</a></span>appendInputParameter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendInputParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append input parameter. </p>
<p>This method appends a new parameter to the list of enumerated input or in-out parameters. Generally only non-stack parameters need to be enumerated since any parameter with a higher index is assumed to be located on the stack. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00189">189</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ade3e21ee4aa09471031ba3db89aab8a9">appendInputParameter()</a>.</p>

</div>
</div>
<a id="ad899c363a8e691c5330fa8a47f2e8b09" name="ad899c363a8e691c5330fa8a47f2e8b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad899c363a8e691c5330fa8a47f2e8b09">&#9670;&#160;</a></span>appendInputParameter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendInputParameter </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append input parameter. </p>
<p>This method appends a new parameter to the list of enumerated input or in-out parameters. Generally only non-stack parameters need to be enumerated since any parameter with a higher index is assumed to be located on the stack. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00192">192</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ade3e21ee4aa09471031ba3db89aab8a9">appendInputParameter()</a>.</p>

</div>
</div>
<a id="a20bf9e0333fa370be641f13cab39ee7b" name="a20bf9e0333fa370be641f13cab39ee7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bf9e0333fa370be641f13cab39ee7b">&#9670;&#160;</a></span>outputParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::outputParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: List of output parameters. </p>
<p>Returns the vector of output (and in-out) parameters. This property is read-only; see also <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae2d521e08b220dfef241415ffdfaa3b5">appendOutputParameter</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#a6f97351d957b65c7c49e72dcc3377889">clearOutputParameters</a>. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00201">201</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a6f97351d957b65c7c49e72dcc3377889" name="a6f97351d957b65c7c49e72dcc3377889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f97351d957b65c7c49e72dcc3377889">&#9670;&#160;</a></span>clearOutputParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::clearOutputParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase output parameters. </p>
<p>Removes all output parameters. In-out parameters, those output parameters that are also listed as inputs, are only removed from the output parameter list, effectively converting them to input-only parameters. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00210">210</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Definition_8h_source.html#l00154">clearParameters()</a>.</p>

</div>
</div>
<a id="ae2d521e08b220dfef241415ffdfaa3b5" name="ae2d521e08b220dfef241415ffdfaa3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d521e08b220dfef241415ffdfaa3b5">&#9670;&#160;</a></span>appendOutputParameter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendOutputParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append output parameter. </p>
<p>This method appends a new output parameter. Output parameters may be the same as input parameters. For instance, if an input parameter is the EAX register then EAX can also be an output parameter, such as during a Linux system call where the input is the system call number and the output is the system call return value. Outputs written to the stack need not be enumerated in the calling convention dictionary. </p>

<p class="reference">Referenced by <a class="el" href="Definition_8h_source.html#l00221">appendOutputParameter()</a>, <a class="el" href="Definition_8h_source.html#l00224">appendOutputParameter()</a>, and <a class="el" href="Definition_8h_source.html#l00227">appendOutputParameter()</a>.</p>

</div>
</div>
<a id="ae67222a6940a8033d0031429c9617259" name="ae67222a6940a8033d0031429c9617259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67222a6940a8033d0031429c9617259">&#9670;&#160;</a></span>appendOutputParameter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendOutputParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append output parameter. </p>
<p>This method appends a new output parameter. Output parameters may be the same as input parameters. For instance, if an input parameter is the EAX register then EAX can also be an output parameter, such as during a Linux system call where the input is the system call number and the output is the system call return value. Outputs written to the stack need not be enumerated in the calling convention dictionary. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00221">221</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae2d521e08b220dfef241415ffdfaa3b5">appendOutputParameter()</a>.</p>

</div>
</div>
<a id="a64d676e036c51a276cbd1fbbc444ec95" name="a64d676e036c51a276cbd1fbbc444ec95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d676e036c51a276cbd1fbbc444ec95">&#9670;&#160;</a></span>appendOutputParameter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendOutputParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append output parameter. </p>
<p>This method appends a new output parameter. Output parameters may be the same as input parameters. For instance, if an input parameter is the EAX register then EAX can also be an output parameter, such as during a Linux system call where the input is the system call number and the output is the system call return value. Outputs written to the stack need not be enumerated in the calling convention dictionary. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00224">224</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae2d521e08b220dfef241415ffdfaa3b5">appendOutputParameter()</a>.</p>

</div>
</div>
<a id="ad43c1b9f8eebb579db8a313a6f6b2718" name="ad43c1b9f8eebb579db8a313a6f6b2718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c1b9f8eebb579db8a313a6f6b2718">&#9670;&#160;</a></span>appendOutputParameter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::appendOutputParameter </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append output parameter. </p>
<p>This method appends a new output parameter. Output parameters may be the same as input parameters. For instance, if an input parameter is the EAX register then EAX can also be an output parameter, such as during a Linux system call where the input is the system call number and the output is the system call return value. Outputs written to the stack need not be enumerated in the calling convention dictionary. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00227">227</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Definition.html#ae2d521e08b220dfef241415ffdfaa3b5">appendOutputParameter()</a>.</p>

</div>
</div>
<a id="a20bad253596039d6a0d2150cd574f479" name="a20bad253596039d6a0d2150cd574f479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bad253596039d6a0d2150cd574f479">&#9670;&#160;</a></span>stackParameterOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#aad5ead8d3159ae269bf3a14c3afd29a0">StackParameterOrder</a> Rose::BinaryAnalysis::CallingConvention::Definition::stackParameterOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Stack parameter order. </p>
<p>Stack-based input parameters need not be enumerated. If N input parameters are enumerated, numbered 0 through N-1, then parameters N and above are assumed to be on the stack and are called the "implied stack parameters". This stackParameterOrder property describes whether a source code statement like <code>function_call(a, b, c)</code> pushes <code>a</code> first (<code>LEFT_TO_RIGHT</code>) or <code>first</code> (<code>RIGHT_TO_LEFT</code>).</p>
<p>If the enumerated input parameter list contains any stack parameters then implied stack parameters are not allowed. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00242">242</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a254cbd0e054495dcaf54e8d81e6e2a02" name="a254cbd0e054495dcaf54e8d81e6e2a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254cbd0e054495dcaf54e8d81e6e2a02">&#9670;&#160;</a></span>stackParameterOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::stackParameterOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#aad5ead8d3159ae269bf3a14c3afd29a0">StackParameterOrder</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Stack parameter order. </p>
<p>Stack-based input parameters need not be enumerated. If N input parameters are enumerated, numbered 0 through N-1, then parameters N and above are assumed to be on the stack and are called the "implied stack parameters". This stackParameterOrder property describes whether a source code statement like <code>function_call(a, b, c)</code> pushes <code>a</code> first (<code>LEFT_TO_RIGHT</code>) or <code>first</code> (<code>RIGHT_TO_LEFT</code>).</p>
<p>If the enumerated input parameter list contains any stack parameters then implied stack parameters are not allowed. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00243">243</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a9c358a160b66ffdfb0f0213c3e0c685b" name="a9c358a160b66ffdfb0f0213c3e0c685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c358a160b66ffdfb0f0213c3e0c685b">&#9670;&#160;</a></span>stackPointerRegister() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::CallingConvention::Definition::stackPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Register for implied stack parameters. </p>
<p>This property holds the register that should be used for implied stack parameters. For instance, on 32-bit x86 this is probably ESP, where the base address is the ESP value immediately after the <code>call</code> instruction.</p>
<p>The value of this property defaults to the stack pointer register for the architecture. Setting the property to an empty register descriptor causes the default value from the architecture to be used instead. </p>

</div>
</div>
<a id="a8e3728e3f2ebeb5bc1066cfd5013a65b" name="a8e3728e3f2ebeb5bc1066cfd5013a65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3728e3f2ebeb5bc1066cfd5013a65b">&#9670;&#160;</a></span>stackPointerRegister() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::stackPointerRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Register for implied stack parameters. </p>
<p>This property holds the register that should be used for implied stack parameters. For instance, on 32-bit x86 this is probably ESP, where the base address is the ESP value immediately after the <code>call</code> instruction.</p>
<p>The value of this property defaults to the stack pointer register for the architecture. Setting the property to an empty register descriptor causes the default value from the architecture to be used instead. </p>

</div>
</div>
<a id="a7dedbc78553593a71f601574a9a915b6" name="a7dedbc78553593a71f601574a9a915b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dedbc78553593a71f601574a9a915b6">&#9670;&#160;</a></span>nonParameterStackSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::CallingConvention::Definition::nonParameterStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Size of non-parameter stack area. </p>
<p>This is the size in bytes of the final non-parameter information pushed onto the stack by the function call instruction. For instance, the 32-bit x86 <code>call</code> instruction pushes a 4-byte return address, but some architectures use a link register instead, pushing nothing onto the stack. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00266">266</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="ad3a914f5c905cd1b6614ea1472f7ba78" name="ad3a914f5c905cd1b6614ea1472f7ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a914f5c905cd1b6614ea1472f7ba78">&#9670;&#160;</a></span>nonParameterStackSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::nonParameterStackSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Size of non-parameter stack area. </p>
<p>This is the size in bytes of the final non-parameter information pushed onto the stack by the function call instruction. For instance, the 32-bit x86 <code>call</code> instruction pushes a 4-byte return address, but some architectures use a link register instead, pushing nothing onto the stack. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00269">269</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="acb7f994ffd7041c8e089eabb0465e25c" name="acb7f994ffd7041c8e089eabb0465e25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f994ffd7041c8e089eabb0465e25c">&#9670;&#160;</a></span>stackDirection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a> Rose::BinaryAnalysis::CallingConvention::Definition::stackDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Direction that stack grows for a push operation. </p>
<p>Most stacks grow downward for each push operation, so down is the default. Some odd architecture might grow up instead. In either case, it is assumed that the stack pointer is pointing to the last item pushed rather than one past the last item. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00281">281</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a8442f6972da46b9f394b8f3cb7601973" name="a8442f6972da46b9f394b8f3cb7601973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8442f6972da46b9f394b8f3cb7601973">&#9670;&#160;</a></span>stackDirection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::stackDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ae421cde0c57d1203fd94d1a6af9a8d43">StackDirection</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Direction that stack grows for a push operation. </p>
<p>Most stacks grow downward for each push operation, so down is the default. Some odd architecture might grow up instead. In either case, it is assumed that the stack pointer is pointing to the last item pushed rather than one past the last item. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00282">282</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a32b65950021e908228a5d559c15780dd" name="a32b65950021e908228a5d559c15780dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b65950021e908228a5d559c15780dd">&#9670;&#160;</a></span>byteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> Rose::BinaryAnalysis::CallingConvention::Definition::byteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Order of bytes for multi-byte values in memory. </p>
<p>This property is read only. It's value comes from the architecture set by the constructor. </p>

</div>
</div>
<a id="acf10c296ebf530cc268db8a4e734a60b" name="acf10c296ebf530cc268db8a4e734a60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf10c296ebf530cc268db8a4e734a60b">&#9670;&#160;</a></span>stackCleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ab6c85c1c76bcd6a3d106ee914ac0b163">StackCleanup</a> Rose::BinaryAnalysis::CallingConvention::Definition::stackCleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Who pops stack parameters. </p>
<p>This property indicates whether the caller is responsible for popping stack parameters, or whether the called function is responsible for popping stack parameters. In either case, the non-parameter stack area (usually a return address) is popped by the called function. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00297">297</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a02a5263312db73d95a6163af520c7fe5" name="a02a5263312db73d95a6163af520c7fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a5263312db73d95a6163af520c7fe5">&#9670;&#160;</a></span>stackCleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::stackCleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#ab6c85c1c76bcd6a3d106ee914ac0b163">StackCleanup</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Who pops stack parameters. </p>
<p>This property indicates whether the caller is responsible for popping stack parameters, or whether the called function is responsible for popping stack parameters. In either case, the non-parameter stack area (usually a return address) is popped by the called function. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00298">298</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a6e341bc20e9137eaccafc1f794521fad" name="a6e341bc20e9137eaccafc1f794521fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e341bc20e9137eaccafc1f794521fad">&#9670;&#160;</a></span>stackAlignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp; Rose::BinaryAnalysis::CallingConvention::Definition::stackAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack alignment. </p>
<p>This is the stack alignment measured in bytes for the stack pointer before the caller pushes any non-parameters (e.g., return address) or parameters. </p>

</div>
</div>
<a id="a1eb627142d723a786ba2cc5ec583c3d0" name="a1eb627142d723a786ba2cc5ec583c3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb627142d723a786ba2cc5ec583c3d0">&#9670;&#160;</a></span>stackAlignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::stackAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack alignment. </p>
<p>This is the stack alignment measured in bytes for the stack pointer before the caller pushes any non-parameters (e.g., return address) or parameters. </p>

</div>
</div>
<a id="a72d5e2e92f65274172704f87dd21436d" name="a72d5e2e92f65274172704f87dd21436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d5e2e92f65274172704f87dd21436d">&#9670;&#160;</a></span>thisParameter() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp; Rose::BinaryAnalysis::CallingConvention::Definition::thisParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Object pointer parameter. </p>
<p>Object oriented code has method calls that are usually implemented as functions that take an extra parameter that isn't always explicitly listed in the high-level source code. This property describes where the object pointer is located and should not be included in the list of input parameters. The reason for not including it in the list of input parameters is because of the rule that implicit input parameter are allowed only if there are no explicit stack-based input parameters, and we want to be able to support having a stack-based object pointer along with implicit input parameters.</p>
<p>It is permissible for an object method to not list its object pointer as an object pointer, but rather treat it as a normal explicit or implicit input parameter. Doing so will make the calling convention look like its a plain function rather than an object method. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00325">325</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Definition_8h_source.html#l00327">thisParameter()</a>, <a class="el" href="Definition_8h_source.html#l00330">thisParameter()</a>, and <a class="el" href="Definition_8h_source.html#l00333">thisParameter()</a>.</p>

</div>
</div>
<a id="afa1fd286ad0f46a150f1678afced6794" name="afa1fd286ad0f46a150f1678afced6794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1fd286ad0f46a150f1678afced6794">&#9670;&#160;</a></span>thisParameter() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::thisParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Object pointer parameter. </p>
<p>Object oriented code has method calls that are usually implemented as functions that take an extra parameter that isn't always explicitly listed in the high-level source code. This property describes where the object pointer is located and should not be included in the list of input parameters. The reason for not including it in the list of input parameters is because of the rule that implicit input parameter are allowed only if there are no explicit stack-based input parameters, and we want to be able to support having a stack-based object pointer along with implicit input parameters.</p>
<p>It is permissible for an object method to not list its object pointer as an object pointer, but rather treat it as a normal explicit or implicit input parameter. Doing so will make the calling convention look like its a plain function rather than an object method. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00326">326</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a1dfa6fcbb9a43ae2c797b044c781fb87" name="a1dfa6fcbb9a43ae2c797b044c781fb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfa6fcbb9a43ae2c797b044c781fb87">&#9670;&#160;</a></span>thisParameter() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::thisParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Object pointer parameter. </p>
<p>Object oriented code has method calls that are usually implemented as functions that take an extra parameter that isn't always explicitly listed in the high-level source code. This property describes where the object pointer is located and should not be included in the list of input parameters. The reason for not including it in the list of input parameters is because of the rule that implicit input parameter are allowed only if there are no explicit stack-based input parameters, and we want to be able to support having a stack-based object pointer along with implicit input parameters.</p>
<p>It is permissible for an object method to not list its object pointer as an object pointer, but rather treat it as a normal explicit or implicit input parameter. Doing so will make the calling convention look like its a plain function rather than an object method. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00327">327</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="Definition_8h_source.html#l00325">thisParameter()</a>.</p>

</div>
</div>
<a id="a1f6646673c790641b05d76a4dc27c2e6" name="a1f6646673c790641b05d76a4dc27c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6646673c790641b05d76a4dc27c2e6">&#9670;&#160;</a></span>thisParameter() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::thisParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Object pointer parameter. </p>
<p>Object oriented code has method calls that are usually implemented as functions that take an extra parameter that isn't always explicitly listed in the high-level source code. This property describes where the object pointer is located and should not be included in the list of input parameters. The reason for not including it in the list of input parameters is because of the rule that implicit input parameter are allowed only if there are no explicit stack-based input parameters, and we want to be able to support having a stack-based object pointer along with implicit input parameters.</p>
<p>It is permissible for an object method to not list its object pointer as an object pointer, but rather treat it as a normal explicit or implicit input parameter. Doing so will make the calling convention look like its a plain function rather than an object method. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00330">330</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="Definition_8h_source.html#l00325">thisParameter()</a>.</p>

</div>
</div>
<a id="af324a8293605cebb459b07ea0d38521e" name="af324a8293605cebb459b07ea0d38521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324a8293605cebb459b07ea0d38521e">&#9670;&#160;</a></span>thisParameter() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::thisParameter </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Object pointer parameter. </p>
<p>Object oriented code has method calls that are usually implemented as functions that take an extra parameter that isn't always explicitly listed in the high-level source code. This property describes where the object pointer is located and should not be included in the list of input parameters. The reason for not including it in the list of input parameters is because of the rule that implicit input parameter are allowed only if there are no explicit stack-based input parameters, and we want to be able to support having a stack-based object pointer along with implicit input parameters.</p>
<p>It is permissible for an object method to not list its object pointer as an object pointer, but rather treat it as a normal explicit or implicit input parameter. Doing so will make the calling convention look like its a plain function rather than an object method. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00333">333</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="Definition_8h_source.html#l00325">thisParameter()</a>.</p>

</div>
</div>
<a id="a953f5f29b6b5520c2f47b58928a8ed6a" name="a953f5f29b6b5520c2f47b58928a8ed6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f5f29b6b5520c2f47b58928a8ed6a">&#9670;&#160;</a></span>returnAddressLocation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp; Rose::BinaryAnalysis::CallingConvention::Definition::returnAddressLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of return address. </p>
<p>This property stores the location where the function return address is stored. I.e., the location contains the address to which this function returns after being called. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00344">344</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="aaf5a50277d72d3271e9513d6ca05916b" name="aaf5a50277d72d3271e9513d6ca05916b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5a50277d72d3271e9513d6ca05916b">&#9670;&#160;</a></span>returnAddressLocation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::returnAddressLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1ConcreteLocation.html">ConcreteLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of return address. </p>
<p>This property stores the location where the function return address is stored. I.e., the location contains the address to which this function returns after being called. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00345">345</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a67aae882510d3499ab5aa3d8f5518961" name="a67aae882510d3499ab5aa3d8f5518961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67aae882510d3499ab5aa3d8f5518961">&#9670;&#160;</a></span>instructionPointerRegister() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> Rose::BinaryAnalysis::CallingConvention::Definition::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Register that points to next instruction to execute. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00351">351</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a37ea9c50df469debee96f3b6c92f1d58" name="a37ea9c50df469debee96f3b6c92f1d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ea9c50df469debee96f3b6c92f1d58">&#9670;&#160;</a></span>instructionPointerRegister() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::instructionPointerRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Register that points to next instruction to execute. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00352">352</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a2d23a435cb5f7dfa7d2488e39e688307" name="a2d23a435cb5f7dfa7d2488e39e688307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d23a435cb5f7dfa7d2488e39e688307">&#9670;&#160;</a></span>calleeSavedRegisters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::calleeSavedRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Callee-saved registers. </p>
<p>This is the set of registers that the called function must preserve across the call, either by not modifying them or by saving and then restoring them. Registers that are used to return values should obviously not be listed here since they need to be modified in order to return a value.</p>
<p>Registers that are not restored but which are also not listed as output parameters (return values) are assumed to be scratch registers. Status flags are typically in this category, as are the stack pointer and instruction pointer. Most calling conventions have at least a few general purpose registers that can be used as scratch space. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00366">366</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a99465c3602edf940d89e24b4506a22d7" name="a99465c3602edf940d89e24b4506a22d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99465c3602edf940d89e24b4506a22d7">&#9670;&#160;</a></span>calleeSavedRegisters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::calleeSavedRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Callee-saved registers. </p>
<p>This is the set of registers that the called function must preserve across the call, either by not modifying them or by saving and then restoring them. Registers that are used to return values should obviously not be listed here since they need to be modified in order to return a value.</p>
<p>Registers that are not restored but which are also not listed as output parameters (return values) are assumed to be scratch registers. Status flags are typically in this category, as are the stack pointer and instruction pointer. Most calling conventions have at least a few general purpose registers that can be used as scratch space. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00367">367</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a2bcd9a2db21a73f830953471fa45f962" name="a2bcd9a2db21a73f830953471fa45f962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcd9a2db21a73f830953471fa45f962">&#9670;&#160;</a></span>scratchRegisters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::scratchRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Scratch registers. </p>
<p>This is the set of registers that are not parameters or return values but which are nonetheless can be modified and not restored by the called function. These are also known as caller-saved registers since the caller must save and restore the value across the call if necessary. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00380">380</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="a650d9740cf23e3e3f418ab3551016267" name="a650d9740cf23e3e3f418ab3551016267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650d9740cf23e3e3f418ab3551016267">&#9670;&#160;</a></span>scratchRegisters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> &gt; &amp; Rose::BinaryAnalysis::CallingConvention::Definition::scratchRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Scratch registers. </p>
<p>This is the set of registers that are not parameters or return values but which are nonetheless can be modified and not restored by the called function. These are also known as caller-saved registers since the caller must save and restore the value across the call if necessary. </p>

<p class="definition">Definition at line <a class="el" href="Definition_8h_source.html#l00381">381</a> of file <a class="el" href="Definition_8h_source.html">Definition.h</a>.</p>

</div>
</div>
<a id="ac20570f076da7e4572676115173aafbd" name="ac20570f076da7e4572676115173aafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20570f076da7e4572676115173aafbd">&#9670;&#160;</a></span>getUsedRegisterParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html">RegisterParts</a> Rose::BinaryAnalysis::CallingConvention::Definition::getUsedRegisterParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all registers mentioned in this definition. </p>
<p>The registers are returned as a <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterParts.html" title="Holds a set of registers without regard for register boundaries.">RegisterParts</a>, which tracks which bits of registers are present but not which individual registers were inserted into the container. For instance, if x86 AX is inserted first, then inserting the overlapping AL and AH registers is a no-op since their bits are already present.</p>
<p>The return value does not include registers that are incidental to a parameter's location. For instance, the stack pointer register is not included in this list unless its listed as a return register, callee-saved register, or scratch register. </p>

</div>
</div>
<a id="aa9c6fbbeb0fa181a4abebbcc5329565e" name="aa9c6fbbeb0fa181a4abebbcc5329565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c6fbbeb0fa181a4abebbcc5329565e">&#9670;&#160;</a></span>returnValueAllocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> Rose::BinaryAnalysis::CallingConvention::Definition::returnValueAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for return values. </p>
<p>Describes where/how return the value(s) are stored. </p>

</div>
</div>
<a id="af6b1c1462ea1daf2c3bd6b5c319bdf18" name="af6b1c1462ea1daf2c3bd6b5c319bdf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b1c1462ea1daf2c3bd6b5c319bdf18">&#9670;&#160;</a></span>returnValueAllocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::returnValueAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for return values. </p>
<p>Describes where/how return the value(s) are stored. </p>

</div>
</div>
<a id="a975e14584e97d969ea955450636c2268" name="a975e14584e97d969ea955450636c2268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975e14584e97d969ea955450636c2268">&#9670;&#160;</a></span>argumentValueAllocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> Rose::BinaryAnalysis::CallingConvention::Definition::argumentValueAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for argument values. </p>
<p>Describe where/how function arguments are stored. </p>

</div>
</div>
<a id="a90fab5db4252faadf2f16ee276034e52" name="a90fab5db4252faadf2f16ee276034e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fab5db4252faadf2f16ee276034e52">&#9670;&#160;</a></span>argumentValueAllocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::argumentValueAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a7cce9f8b747e08c059880da6c79b5e58">AllocatorPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Allocator.html" title="Allocates storage for an argument or return value.">Allocator</a> for argument values. </p>
<p>Describe where/how function arguments are stored. </p>

</div>
</div>
<a id="a888636d4de3d8b848e7e4682cae06416" name="a888636d4de3d8b848e7e4682cae06416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888636d4de3d8b848e7e4682cae06416">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print detailed information about this calling convention. </p>
<p>If a register dictionary is supplied then that dictionary is used instead of any dictionary already attached to this definition. This feature is mostly for backward compatibility. </p>

</div>
</div>
<a id="a6e5f67d5c962dfe62816e1b23426aee3" name="a6e5f67d5c962dfe62816e1b23426aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5f67d5c962dfe62816e1b23426aee3">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::CallingConvention::Definition::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>regDict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print detailed information about this calling convention. </p>
<p>If a register dictionary is supplied then that dictionary is used instead of any dictionary already attached to this definition. This feature is mostly for backward compatibility. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Definition_8h_source.html">Definition.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
