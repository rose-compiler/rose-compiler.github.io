<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: TransformationSupport Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classTransformationSupport-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TransformationSupport Class Reference<div class="ingroups"><a class="el" href="group__queryLib.html">Query Library</a> &raquo; <a class="el" href="group__localNodeQueryLib.html">Local Node Query Library</a> &raquo; <a class="el" href="group__transformationSupportLib.html">Transformation Support Library</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>This class simplifies the development of queries on the AST resulting in a list of AST nodes. </p>
<p>This class holds functions that are generally useful for a broad cross-section of transformations. Functionality specific to any specific transformation should be represented in a similar transformation support class that is a part of the preprocessor source code representing that specific transformation. </p>

<p class="definition">Definition at line <a class="el" href="transformationSupport_8h_source.html#l00024">24</a> of file <a class="el" href="transformationSupport_8h_source.html">transformationSupport.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="transformationSupport_8h_source.html">roseSupport/transformationSupport.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a000ec5ff5327c60bc00a7984c45758f4" id="r_a000ec5ff5327c60bc00a7984c45758f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a000ec5ff5327c60bc00a7984c45758f4">operatorCodeType</a> { <br />
&#160;&#160;<a class="el" href="classTransformationSupport.html#a000ec5ff5327c60bc00a7984c45758f4a1a2ccfb42b772b44038b48314437c98f">FUNCTION_CALL_OPERATOR_CODE</a> = 0
, <br />
&#160;&#160;<b>ADD_OPERATOR_CODE</b> = 1
, <br />
&#160;&#160;<b>SUBT_OPERATOR_CODE</b> = 2
, <br />
&#160;&#160;<b>MULT_OPERATOR_CODE</b> = 3
, <br />
&#160;&#160;<b>DIV_OPERATOR_CODE</b> = 4
, <br />
&#160;&#160;<b>INTEGER_DIV_OPERATOR_CODE</b> = 5
, <br />
&#160;&#160;<b>MOD_OPERATOR_CODE</b> = 6
, <br />
&#160;&#160;<b>AND_OPERATOR_CODE</b> = 7
, <br />
&#160;&#160;<b>OR_OPERATOR_CODE</b> = 8
, <br />
&#160;&#160;<b>BITXOR_OPERATOR_CODE</b> = 9
, <br />
&#160;&#160;<b>BITAND_OPERATOR_CODE</b> = 10
, <br />
&#160;&#160;<b>BITOR_OPERATOR_CODE</b> = 11
, <br />
&#160;&#160;<b>EQ_OPERATOR_CODE</b> = 12
, <br />
&#160;&#160;<b>LT_OPERATOR_CODE</b> = 13
, <br />
&#160;&#160;<b>GT_OPERATOR_CODE</b> = 14
, <br />
&#160;&#160;<b>NE_OPERATOR_CODE</b> = 15
, <br />
&#160;&#160;<b>LE_OPERATOR_CODE</b> = 16
, <br />
&#160;&#160;<b>GE_OPERATOR_CODE</b> = 17
, <br />
&#160;&#160;<b>ASSIGN_OPERATOR_CODE</b> = 18
, <br />
&#160;&#160;<b>PLUS_ASSIGN_OPERATOR_CODE</b> = 19
, <br />
&#160;&#160;<b>MINUS_ASSIGN_OPERATOR_CODE</b> = 20
, <br />
&#160;&#160;<b>AND_ASSIGN_OPERATOR_CODE</b> = 21
, <br />
&#160;&#160;<b>IOR_ASSIGN_OPERATOR_CODE</b> = 22
, <br />
&#160;&#160;<b>MULT_ASSIGN_OPERATOR_CODE</b> = 23
, <br />
&#160;&#160;<b>DIV_ASSIGN_OPERATOR_CODE</b> = 24
, <br />
&#160;&#160;<b>MOD_ASSIGN_OPERATOR_CODE</b> = 25
, <br />
&#160;&#160;<b>XOR_ASSIGN_OPERATOR_CODE</b> = 26
, <br />
&#160;&#160;<b>PARENTHESIS_OPERATOR_CODE</b> = 27
, <br />
&#160;&#160;<b>BRACKET_OPERATOR_CODE</b> = 28
, <br />
&#160;&#160;<b>NOT_OPERATOR_CODE</b> = 29
, <br />
&#160;&#160;<b>DEREFERENCE_OPERATOR_CODE</b> = 30
, <br />
&#160;&#160;<b>ADDRESS_OPERATOR_CODE</b> = 31
, <br />
&#160;&#160;<b>LSHIFT_OPERATOR_CODE</b> = 32
, <br />
&#160;&#160;<b>RSHIFT_OPERATOR_CODE</b> = 33
, <br />
&#160;&#160;<b>LSHIFT_ASSIGN_OPERATOR_CODE</b> = 34
, <br />
&#160;&#160;<b>RSHIFT_ASSIGN_OPERATOR_CODE</b> = 35
, <br />
&#160;&#160;<b>PREFIX_PLUSPLUS_OPERATOR_CODE</b> = 36
, <br />
&#160;&#160;<b>POSTFIX_PLUSPLUS_OPERATOR_CODE</b> = 37
, <br />
&#160;&#160;<b>PREFIX_MINUSMINUS_OPERATOR_CODE</b> = 38
, <br />
&#160;&#160;<b>POSTFIX_MINUSMINUS_OPERATOR_CODE</b> = 39
, <br />
&#160;&#160;<b>OPERATOR_CODE_LAST_TAG</b> = 99
<br />
 }</td></tr>
<tr class="separator:a000ec5ff5327c60bc00a7984c45758f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab052f299e1c2f9fcbc5eae7813b3a243" id="r_ab052f299e1c2f9fcbc5eae7813b3a243"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#ab052f299e1c2f9fcbc5eae7813b3a243">stringifyOperator</a> (std::string name)</td></tr>
<tr class="memdesc:ab052f299e1c2f9fcbc5eae7813b3a243"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates a source code string from operator name.  <br /></td></tr>
<tr class="separator:ab052f299e1c2f9fcbc5eae7813b3a243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ab368e870aaeb4d9fe66fe1bc1e27" id="r_a361ab368e870aaeb4d9fe66fe1bc1e27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTransformationSupport.html#a000ec5ff5327c60bc00a7984c45758f4">operatorCodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a361ab368e870aaeb4d9fe66fe1bc1e27">classifyOverloadedOperator</a> (std::string name, int numberOfParameters=0, bool prefixOperator=false)</td></tr>
<tr class="memdesc:a361ab368e870aaeb4d9fe66fe1bc1e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies operator and returns an operatorCodeType value (useful for switch statements).  <br /></td></tr>
<tr class="separator:a361ab368e870aaeb4d9fe66fe1bc1e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a6103f41687a2bd22b04fc0eeaa1fc" id="r_a58a6103f41687a2bd22b04fc0eeaa1fc"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a58a6103f41687a2bd22b04fc0eeaa1fc">buildOperatorString</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="memdesc:a58a6103f41687a2bd22b04fc0eeaa1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string representing operator node in AST.  <br /></td></tr>
<tr class="separator:a58a6103f41687a2bd22b04fc0eeaa1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2f56365a34fcbf6d76b523ebdb12a4" id="r_ade2f56365a34fcbf6d76b523ebdb12a4"><td class="memItemLeft" align="right" valign="top"><a id="ade2f56365a34fcbf6d76b523ebdb12a4" name="ade2f56365a34fcbf6d76b523ebdb12a4"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getFunctionName</b> (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *functionCallExp)</td></tr>
<tr class="memdesc:ade2f56365a34fcbf6d76b523ebdb12a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representing the function name (should be added to Sage III interface). <br /></td></tr>
<tr class="separator:ade2f56365a34fcbf6d76b523ebdb12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9850fe9903d4796d338895aa03966d" id="r_a6e9850fe9903d4796d338895aa03966d"><td class="memItemLeft" align="right" valign="top"><a id="a6e9850fe9903d4796d338895aa03966d" name="a6e9850fe9903d4796d338895aa03966d"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getTypeName</b> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>
<tr class="memdesc:a6e9850fe9903d4796d338895aa03966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representing the type name (should be added to Sage III interface). <br /></td></tr>
<tr class="separator:a6e9850fe9903d4796d338895aa03966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9fb0a5846daf0791d7c2b01aaf356" id="r_ad4d9fb0a5846daf0791d7c2b01aaf356"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#ad4d9fb0a5846daf0791d7c2b01aaf356">getFunctionTypeName</a> (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *functionCallExpression)</td></tr>
<tr class="memdesc:ad4d9fb0a5846daf0791d7c2b01aaf356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to getFunctionName(SgNode* astNode) above, but for member functions.  <br /></td></tr>
<tr class="separator:ad4d9fb0a5846daf0791d7c2b01aaf356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7ecca8a2c220dd8d702abb9d0971cb" id="r_a3f7ecca8a2c220dd8d702abb9d0971cb"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a3f7ecca8a2c220dd8d702abb9d0971cb">buildMacro</a> (std::string s)</td></tr>
<tr class="memdesc:a3f7ecca8a2c220dd8d702abb9d0971cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrap any string representing a macro into something that the unparser will unparse as a macro definition  <br /></td></tr>
<tr class="separator:a3f7ecca8a2c220dd8d702abb9d0971cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f897989f5641a6d53747c851a89c8ba" id="r_a6f897989f5641a6d53747c851a89c8ba"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a6f897989f5641a6d53747c851a89c8ba">internalSupportingGlobalDeclarations</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, std::string prefixString)</td></tr>
<tr class="memdesc:a6f897989f5641a6d53747c851a89c8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds variable declarations for all variable and types defined in subtree at astNode.  <br /></td></tr>
<tr class="separator:a6f897989f5641a6d53747c851a89c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cfc81c262dac4ad28e59dce03c75cd" id="r_af3cfc81c262dac4ad28e59dce03c75cd"><td class="memItemLeft" align="right" valign="top"><a id="af3cfc81c262dac4ad28e59dce03c75cd" name="af3cfc81c262dac4ad28e59dce03c75cd"></a>
static <a class="el" href="classSgProject.html">SgProject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getProject</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:af3cfc81c262dac4ad28e59dce03c75cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089e2f5bb8f226cf2645d57cbe1c52c" id="r_a4089e2f5bb8f226cf2645d57cbe1c52c"><td class="memItemLeft" align="right" valign="top"><a id="a4089e2f5bb8f226cf2645d57cbe1c52c" name="a4089e2f5bb8f226cf2645d57cbe1c52c"></a>
static <a class="el" href="classSgDirectory.html">SgDirectory</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getDirectory</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a4089e2f5bb8f226cf2645d57cbe1c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273e3db62cf6b2a0833732df34f9977b" id="r_a273e3db62cf6b2a0833732df34f9977b"><td class="memItemLeft" align="right" valign="top"><a id="a273e3db62cf6b2a0833732df34f9977b" name="a273e3db62cf6b2a0833732df34f9977b"></a>
static <a class="el" href="classSgFile.html">SgFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFile</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a273e3db62cf6b2a0833732df34f9977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e91257d4c8cb0e6f24fd8c0d377b866" id="r_a6e91257d4c8cb0e6f24fd8c0d377b866"><td class="memItemLeft" align="right" valign="top"><a id="a6e91257d4c8cb0e6f24fd8c0d377b866" name="a6e91257d4c8cb0e6f24fd8c0d377b866"></a>
static <a class="el" href="classSgSourceFile.html">SgSourceFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSourceFile</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a6e91257d4c8cb0e6f24fd8c0d377b866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d3c6aaf55d256b62923e5afae98f7" id="r_a507d3c6aaf55d256b62923e5afae98f7"><td class="memItemLeft" align="right" valign="top"><a id="a507d3c6aaf55d256b62923e5afae98f7" name="a507d3c6aaf55d256b62923e5afae98f7"></a>
static <a class="el" href="classSgGlobal.html">SgGlobal</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getGlobalScope</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a507d3c6aaf55d256b62923e5afae98f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928fd84d38d70bf8fd8470765a15a689" id="r_a928fd84d38d70bf8fd8470765a15a689"><td class="memItemLeft" align="right" valign="top"><a id="a928fd84d38d70bf8fd8470765a15a689" name="a928fd84d38d70bf8fd8470765a15a689"></a>
static <a class="el" href="classSgStatement.html">SgStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getStatement</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a928fd84d38d70bf8fd8470765a15a689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0913f89ca2138b705c17c3610316c0" id="r_aaf0913f89ca2138b705c17c3610316c0"><td class="memItemLeft" align="right" valign="top"><a id="aaf0913f89ca2138b705c17c3610316c0" name="aaf0913f89ca2138b705c17c3610316c0"></a>
static <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFunctionDeclaration</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:aaf0913f89ca2138b705c17c3610316c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91038695ad98d1b23906af921d949761" id="r_a91038695ad98d1b23906af921d949761"><td class="memItemLeft" align="right" valign="top"><a id="a91038695ad98d1b23906af921d949761" name="a91038695ad98d1b23906af921d949761"></a>
static <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getFunctionDefinition</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a91038695ad98d1b23906af921d949761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff254d4093e548b5ded54d26dd178d7" id="r_aeff254d4093e548b5ded54d26dd178d7"><td class="memItemLeft" align="right" valign="top"><a id="aeff254d4093e548b5ded54d26dd178d7" name="aeff254d4093e548b5ded54d26dd178d7"></a>
static <a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getClassDefinition</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:aeff254d4093e548b5ded54d26dd178d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519534fdca97f35c5b65f1642eec5109" id="r_a519534fdca97f35c5b65f1642eec5109"><td class="memItemLeft" align="right" valign="top"><a id="a519534fdca97f35c5b65f1642eec5109" name="a519534fdca97f35c5b65f1642eec5109"></a>
static <a class="el" href="classSgModuleStatement.html">SgModuleStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleStatement</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a519534fdca97f35c5b65f1642eec5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65284a376d0d2b48f95b22d01053fdaf" id="r_a65284a376d0d2b48f95b22d01053fdaf"><td class="memItemLeft" align="right" valign="top"><a id="a65284a376d0d2b48f95b22d01053fdaf" name="a65284a376d0d2b48f95b22d01053fdaf"></a>
static <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTemplateDeclaration</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="separator:a65284a376d0d2b48f95b22d01053fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1216d132e6a1955d4a42e57d7d693dcf" id="r_a1216d132e6a1955d4a42e57d7d693dcf"><td class="memItemLeft" align="right" valign="top"><a id="a1216d132e6a1955d4a42e57d7d693dcf" name="a1216d132e6a1955d4a42e57d7d693dcf"></a>
static <a class="el" href="classSgType.html">SgType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAssociatedType</b> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>
<tr class="memdesc:a1216d132e6a1955d4a42e57d7d693dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the associated type that might be a parent (through a parent chain) of the input <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>. <br /></td></tr>
<tr class="separator:a1216d132e6a1955d4a42e57d7d693dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Applications Specific Transformation Option Mechanism</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Supporting functions for reading transformation specifications (hints)</p>
<p>Preprocessors can optionally retrive hints embedded within the user's application. The mechanism is useful to provide additional information used to make more sophisticated optimizations than the knowledge of the semantics of abstractions might provide. It also is a way to pass on information as a substitution for program analysis. </p>
</div></td></tr>
<tr class="memitem:a8a2cd0217c339e7cc4ae85008c44555d" id="r_a8a2cd0217c339e7cc4ae85008c44555d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a8a2cd0217c339e7cc4ae85008c44555d">getTransformationOptions</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, std::list&lt; <a class="el" href="classOptionDeclaration.html">OptionDeclaration</a> &gt; &amp;variableNameList, std::string identifingTypeName)</td></tr>
<tr class="memdesc:a8a2cd0217c339e7cc4ae85008c44555d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface permits a more general specification of options using strings to identify the options and values to associate with the identified option.  <br /></td></tr>
<tr class="separator:a8a2cd0217c339e7cc4ae85008c44555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6060e0c7f69a025932f3631f86aa27" id="r_a0a6060e0c7f69a025932f3631f86aa27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a0a6060e0c7f69a025932f3631f86aa27">getTransformationOptions</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, std::list&lt; int &gt; &amp;variableNameList, std::string identifingTypeName)</td></tr>
<tr class="separator:a0a6060e0c7f69a025932f3631f86aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa01bfb26615f39004179e4fef28cf8e" id="r_afa01bfb26615f39004179e4fef28cf8e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#afa01bfb26615f39004179e4fef28cf8e">getTransformationOptionsFromVariableDeclarationConstructorArguments</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *variableDeclaration, std::list&lt; int &gt; &amp;returnList)</td></tr>
<tr class="separator:afa01bfb26615f39004179e4fef28cf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd935ea0a31219d69d7a4187fb06e46" id="r_a0dd935ea0a31219d69d7a4187fb06e46"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformationSupport.html#a0dd935ea0a31219d69d7a4187fb06e46">getTransformationOptionsFromVariableDeclarationConstructorArguments</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *variableDeclaration, std::list&lt; <a class="el" href="classOptionDeclaration.html">OptionDeclaration</a> &gt; &amp;returnList)</td></tr>
<tr class="separator:a0dd935ea0a31219d69d7a4187fb06e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a000ec5ff5327c60bc00a7984c45758f4" name="a000ec5ff5327c60bc00a7984c45758f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ec5ff5327c60bc00a7984c45758f4">&#9670;&#160;</a></span>operatorCodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTransformationSupport.html#a000ec5ff5327c60bc00a7984c45758f4">TransformationSupport::operatorCodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a000ec5ff5327c60bc00a7984c45758f4a1a2ccfb42b772b44038b48314437c98f" name="a000ec5ff5327c60bc00a7984c45758f4a1a2ccfb42b772b44038b48314437c98f"></a>FUNCTION_CALL_OPERATOR_CODE&#160;</td><td class="fielddoc"><p>normal function call (used as the default value) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="transformationSupport_8h_source.html#l00037">37</a> of file <a class="el" href="transformationSupport_8h_source.html">transformationSupport.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab052f299e1c2f9fcbc5eae7813b3a243" name="ab052f299e1c2f9fcbc5eae7813b3a243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab052f299e1c2f9fcbc5eae7813b3a243">&#9670;&#160;</a></span>stringifyOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TransformationSupport::stringifyOperator </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generates a source code string from operator name. </p>
<p>This function returns a string representing the elementwise operator (for primative types) that would be match that associated with the overloaded operator for a user-defined abstractions (e.g. identifyOperator("operator+()") returns "+"). </p>

</div>
</div>
<a id="a361ab368e870aaeb4d9fe66fe1bc1e27" name="a361ab368e870aaeb4d9fe66fe1bc1e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361ab368e870aaeb4d9fe66fe1bc1e27">&#9670;&#160;</a></span>classifyOverloadedOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTransformationSupport.html#a000ec5ff5327c60bc00a7984c45758f4">operatorCodeType</a> TransformationSupport::classifyOverloadedOperator </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfParameters</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefixOperator</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classifies operator and returns an operatorCodeType value (useful for switch statements). </p>
<p>This function is useful in switch statements to further refine the type of function based on the function name, number of parameters, and if it is a prefix or postfix operator. These are the minimum requirements to classify all possible C++ overloaded functions (though usually the name is sufficient so the additional parameters are optional). </p>

</div>
</div>
<a id="a58a6103f41687a2bd22b04fc0eeaa1fc" name="a58a6103f41687a2bd22b04fc0eeaa1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a6103f41687a2bd22b04fc0eeaa1fc">&#9670;&#160;</a></span>buildOperatorString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TransformationSupport::buildOperatorString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return string representing operator node in AST. </p>
<p>This function returns a string representing the operator associated with the SgNode* (assuming it is an SgExpression*). It calls the identifyOperator() function to convert overloaded functions to strings. </p>

</div>
</div>
<a id="ad4d9fb0a5846daf0791d7c2b01aaf356" name="ad4d9fb0a5846daf0791d7c2b01aaf356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9fb0a5846daf0791d7c2b01aaf356">&#9670;&#160;</a></span>getFunctionTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TransformationSupport::getFunctionTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *&#160;</td>
          <td class="paramname"><em>functionCallExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to getFunctionName(SgNode* astNode) above, but for member functions. </p>
<p>For member fuinctions this returns the class name of the class for which this functon is a member and for non-member functions this function returns the name of the class associated with the return type (this might be done better). </p>

</div>
</div>
<a id="a3f7ecca8a2c220dd8d702abb9d0971cb" name="a3f7ecca8a2c220dd8d702abb9d0971cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7ecca8a2c220dd8d702abb9d0971cb">&#9670;&#160;</a></span>buildMacro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TransformationSupport::buildMacro </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrap any string representing a macro into something that the unparser will unparse as a macro definition </p>
<p>This mechanism is a hack for now since it embeds a substring into a comment which the unparser presently will recognize. This needs to be fixed to work more cleanly. </p>

</div>
</div>
<a id="a8a2cd0217c339e7cc4ae85008c44555d" name="a8a2cd0217c339e7cc4ae85008c44555d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2cd0217c339e7cc4ae85008c44555d">&#9670;&#160;</a></span>getTransformationOptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TransformationSupport::getTransformationOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="classOptionDeclaration.html">OptionDeclaration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variableNameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>identifingTypeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This interface permits a more general specification of options using strings to identify the options and values to associate with the identified option. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOptionDeclaration.html">OptionDeclaration</a></dd></dl>
<p>This function is the only interface to the general mechanism that permits passing data from the user's application to a preprocessor. If this mechanism is used, the user's application is optionally annotated with declarations (which have no side-effect to the execution of the user's application) but which can be read and interpreted by a preprocessor. This function makes ... </p>

</div>
</div>
<a id="a0a6060e0c7f69a025932f3631f86aa27" name="a0a6060e0c7f69a025932f3631f86aa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6060e0c7f69a025932f3631f86aa27">&#9670;&#160;</a></span>getTransformationOptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TransformationSupport::getTransformationOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variableNameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>identifingTypeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa01bfb26615f39004179e4fef28cf8e" name="afa01bfb26615f39004179e4fef28cf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa01bfb26615f39004179e4fef28cf8e">&#9670;&#160;</a></span>getTransformationOptionsFromVariableDeclarationConstructorArguments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TransformationSupport::getTransformationOptionsFromVariableDeclarationConstructorArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>variableDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>returnList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dd935ea0a31219d69d7a4187fb06e46" name="a0dd935ea0a31219d69d7a4187fb06e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd935ea0a31219d69d7a4187fb06e46">&#9670;&#160;</a></span>getTransformationOptionsFromVariableDeclarationConstructorArguments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TransformationSupport::getTransformationOptionsFromVariableDeclarationConstructorArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&#160;</td>
          <td class="paramname"><em>variableDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="classOptionDeclaration.html">OptionDeclaration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>returnList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f897989f5641a6d53747c851a89c8ba" name="a6f897989f5641a6d53747c851a89c8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f897989f5641a6d53747c851a89c8ba">&#9670;&#160;</a></span>internalSupportingGlobalDeclarations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string TransformationSupport::internalSupportingGlobalDeclarations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td>
          <td class="paramname"><em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefixString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds variable declarations for all variable and types defined in subtree at astNode. </p>
<p>New variables and types introduced by way of a transformation need to be defined in the application before they are used. This sort of transofrmation can be generally automated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="transformationSupport_8h_source.html">transformationSupport.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:06 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
