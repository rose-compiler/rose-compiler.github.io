<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::SmtSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html">SmtSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1SmtSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::SmtSolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Interface to Satisfiability Modulo Theory (SMT) solvers. </p>
<p>The purpose of an SMT solver is to determine if an expression is satisfiable. Solvers are reference counted objects that are allocated with <code>instance</code> static methods or <code>create</code> virtual constructors and should not be explicitly deleted. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00039">39</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="SmtSolver_8h_source.html">Rose/BinaryAnalysis/SmtSolver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::SmtSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SmtSolver__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SmtSolver_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SmtSolver_inherit__map" id="aRose_1_1BinaryAnalysis_1_1SmtSolver_inherit__map">
<area shape="rect" title="Interface to Satisfiability Modulo Theory (SMT) solvers." alt="" coords="5,79,153,119"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html" title="Wrapper around solvers that speak SMT&#45;LIB." alt="" coords="5,167,153,207"/>
<area shape="poly" title=" " alt="" coords="82,133,82,166,77,166,77,133"/>
<area shape="rect" title=" " alt="" coords="12,5,147,31"/>
<area shape="poly" title=" " alt="" coords="82,44,82,78,77,78,77,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::SmtSolver:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SmtSolver__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SmtSolver_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SmtSolver_coll__map" id="aRose_1_1BinaryAnalysis_1_1SmtSolver_coll__map">
<area shape="rect" title="Interface to Satisfiability Modulo Theory (SMT) solvers." alt="" coords="675,231,823,271"/>
<area shape="rect" title=" " alt="" coords="365,5,499,31"/>
<area shape="poly" title=" " alt="" coords="513,10,548,12,585,18,620,30,652,48,674,67,692,90,720,141,738,191,748,230,743,231,733,192,715,143,688,93,670,71,649,52,618,35,583,23,548,17,513,15"/>
<area shape="rect" title=" " alt="" coords="392,55,472,80"/>
<area shape="poly" title=" " alt="" coords="486,61,525,62,568,67,612,79,652,98,686,128,712,164,732,200,744,230,739,232,727,202,708,167,682,132,649,103,610,84,567,73,524,67,486,66"/>
<area shape="rect" title=" " alt="" coords="362,167,502,207"/>
<area shape="poly" title=" " alt="" coords="516,202,651,229,675,234,674,239,650,234,515,207"/>
<area shape="rect" href="classSawyer_1_1SharedPointer.html" title="Reference&#45;counting intrusive smart pointer." alt="" coords="5,175,193,200"/>
<area shape="poly" title=" " alt="" coords="168,169,244,157,337,146,438,144,538,153,590,166,640,186,719,229,717,234,637,191,588,171,537,158,437,149,337,152,245,162,169,175"/>
<area shape="poly" title=" " alt="" coords="207,185,362,185,362,190,207,190"/>
<area shape="rect" href="classSawyer_1_1SharedPointer.html" title=" " alt="" coords="354,231,510,271"/>
<area shape="poly" title=" " alt="" coords="179,200,354,234,353,239,178,205"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html" title=" " alt="" coords="327,296,537,351"/>
<area shape="poly" title=" " alt="" coords="550,294,674,266,675,271,551,299"/>
<area shape="rect" href="classSawyer_1_1Container_1_1Map.html" title=" " alt="" coords="343,375,521,429"/>
<area shape="poly" title=" " alt="" coords="523,367,586,342,649,312,718,269,721,274,652,316,588,347,525,372"/>
<area shape="poly" title=" " alt="" coords="524,249,675,249,675,254,524,254"/>
<area shape="rect" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html" title="SMT solver statistics." alt="" coords="358,454,506,494"/>
<area shape="poly" title=" " alt="" coords="519,452,586,427,619,409,649,388,678,360,702,328,737,270,741,273,707,331,682,363,652,392,622,414,588,431,521,457"/>
<area shape="rect" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams." alt="" coords="343,519,521,544"/>
<area shape="poly" title=" " alt="" coords="533,515,595,494,623,479,649,459,669,437,686,413,713,360,731,310,742,271,747,272,736,312,718,362,690,416,673,440,652,463,626,483,597,499,535,520"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptions for all things SMT related.  <a href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html">Memoizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memoizes calls to an SMT solver.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1ParseError.html">ParseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Exception.html" title="Exceptions for all things SMT related.">Exception</a> for parse errors when reading SMT solver output.  <a href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1ParseError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1SExpr.html">SExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">S-Expr parsed from SMT solver text output.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1SExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMT solver statistics.  <a href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Transaction.html">Transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII guard for solver stack.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a780a2c523850a54f01939334bbab8a34" id="r_a780a2c523850a54f01939334bbab8a34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34ad6a15e3f1094e828dc01588f1ba8ae8c">LM_NONE</a> = 0x0000
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34aa425e79d261241b8ec455ec54d426495">LM_LIBRARY</a> = 0x0001
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34a32d2d5c22648c062713587db4a7a7449">LM_EXECUTABLE</a> = 0x0002
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34a19846bed3aa3fa0bc219ef5c503a27b4">LM_ANY</a> = 0x0003
<br />
 }</td></tr>
<tr class="memdesc:a780a2c523850a54f01939334bbab8a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags to indicate the kind of solver interface.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">More...</a><br /></td></tr>
<tr class="separator:a780a2c523850a54f01939334bbab8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfdcdf6867258024ec930056b4d74c4" id="r_a4bfdcdf6867258024ec930056b4d74c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Type</a> { <br />
&#160;&#160;<b>NO_TYPE</b>
, <br />
&#160;&#160;<b>BOOLEAN</b>
, <br />
&#160;&#160;<b>BIT_VECTOR</b>
, <br />
&#160;&#160;<b>MEM_STATE</b>
<br />
 }</td></tr>
<tr class="memdesc:a4bfdcdf6867258024ec930056b4d74c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type (sort) of expression.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">More...</a><br /></td></tr>
<tr class="separator:a4bfdcdf6867258024ec930056b4d74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807e813a7a89a77142a200b6621f7ee1" id="r_a807e813a7a89a77142a200b6621f7ee1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1ae3dd9347555a59adb9e97d22982cb4e3">SAT_NO</a> =0
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1ad1f780f83463eaa5e55d306ce9d7433c">SAT_YES</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1a548dad0f005ad6e9b698b0da2f012d44">SAT_UNKNOWN</a>
<br />
 }</td></tr>
<tr class="memdesc:a807e813a7a89a77142a200b6621f7ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Satisfiability constants.  <a href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">More...</a><br /></td></tr>
<tr class="separator:a807e813a7a89a77142a200b6621f7ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5acec3c7ca24097f71ffcabc8d376d" id="r_a0a5acec3c7ca24097f71ffcabc8d376d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> = std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt;</td></tr>
<tr class="memdesc:a0a5acec3c7ca24097f71ffcabc8d376d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list of expressions.  <br /></td></tr>
<tr class="separator:a0a5acec3c7ca24097f71ffcabc8d376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045f331681fb93516ed2c4c3fa5f689" id="r_a2045f331681fb93516ed2c4c3fa5f689"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a></td></tr>
<tr class="memdesc:a2045f331681fb93516ed2c4c3fa5f689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer for SMT solvers.  <br /></td></tr>
<tr class="separator:a2045f331681fb93516ed2c4c3fa5f689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02578f6f4e97d474006c9442cdc0a23b" id="r_a02578f6f4e97d474006c9442cdc0a23b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a02578f6f4e97d474006c9442cdc0a23b">Availability</a> = std::map&lt; std::string, bool &gt;</td></tr>
<tr class="memdesc:a02578f6f4e97d474006c9442cdc0a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver availability map.  <br /></td></tr>
<tr class="separator:a02578f6f4e97d474006c9442cdc0a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eb3b130a326ffe3a641e7bb768dc36" id="r_ae5eb3b130a326ffe3a641e7bb768dc36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ae5eb3b130a326ffe3a641e7bb768dc36">StringTypePair</a> = std::pair&lt; std::string, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Type</a> &gt;</td></tr>
<tr class="memdesc:ae5eb3b130a326ffe3a641e7bb768dc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps expression nodes to term names.  <br /></td></tr>
<tr class="separator:ae5eb3b130a326ffe3a641e7bb768dc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14e5e6cc7d57505a87eeac3f7e5959" id="r_adf14e5e6cc7d57505a87eeac3f7e5959"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#adf14e5e6cc7d57505a87eeac3f7e5959">TermNames</a> = <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ae5eb3b130a326ffe3a641e7bb768dc36">StringTypePair</a> &gt;</td></tr>
<tr class="separator:adf14e5e6cc7d57505a87eeac3f7e5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42b6c0684322672d59b936336b0b643" id="r_ad42b6c0684322672d59b936336b0b643"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">ExprExprMap</a> = <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt;</td></tr>
<tr class="memdesc:ad42b6c0684322672d59b936336b0b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps one symbolic expression to another.  <br /></td></tr>
<tr class="separator:ad42b6c0684322672d59b936336b0b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b4e71a51043fe53e63b375330a1f6f" id="r_ab8b4e71a51043fe53e63b375330a1f6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab8b4e71a51043fe53e63b375330a1f6f">VariableSet</a> = <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">SymbolicExpression::LeafPtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1CompareLeavesByName.html">CompareLeavesByName</a> &gt;</td></tr>
<tr class="memdesc:ab8b4e71a51043fe53e63b375330a1f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of variables.  <br /></td></tr>
<tr class="separator:ab8b4e71a51043fe53e63b375330a1f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c19ddb335c583f0fd967bb39f9f623" id="r_ad9c19ddb335c583f0fd967bb39f9f623"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad9c19ddb335c583f0fd967bb39f9f623">Definitions</a> = std::set&lt; uint64_t &gt;</td></tr>
<tr class="memdesc:ad9c19ddb335c583f0fd967bb39f9f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free variables that have been defined.  <br /></td></tr>
<tr class="separator:ad9c19ddb335c583f0fd967bb39f9f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3db6fecb9c16d0d6644fe1b5166837" id="r_aeb3db6fecb9c16d0d6644fe1b5166837"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aeb3db6fecb9c16d0d6644fe1b5166837">SExprTypePair</a> = std::pair&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Type</a> &gt;</td></tr>
<tr class="separator:aeb3db6fecb9c16d0d6644fe1b5166837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2afba34dae5518bd22d472d8c2fe327" id="r_ad2afba34dae5518bd22d472d8c2fe327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad2afba34dae5518bd22d472d8c2fe327">Evidence</a> = <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; std::string, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt;</td></tr>
<tr class="memdesc:ad2afba34dae5518bd22d472d8c2fe327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evidence of satisfiability.  <br /></td></tr>
<tr class="separator:ad2afba34dae5518bd22d472d8c2fe327"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48883315932977b0ce4533310fa7053e" id="r_a48883315932977b0ce4533310fa7053e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a48883315932977b0ce4533310fa7053e">create</a> () const =0</td></tr>
<tr class="memdesc:a48883315932977b0ce4533310fa7053e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor.  <br /></td></tr>
<tr class="separator:a48883315932977b0ce4533310fa7053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962437597417c76a66825aac16188fa8" id="r_a962437597417c76a66825aac16188fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a962437597417c76a66825aac16188fa8">linkage</a> () const</td></tr>
<tr class="memdesc:a962437597417c76a66825aac16188fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How ROSE communicates with the solver.  <br /></td></tr>
<tr class="separator:a962437597417c76a66825aac16188fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152ca6351bb7e1075a561cab6757e95c" id="r_a152ca6351bb7e1075a561cab6757e95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a152ca6351bb7e1075a561cab6757e95c">requireLinkage</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a>) const</td></tr>
<tr class="memdesc:a152ca6351bb7e1075a561cab6757e95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert required linkage.  <br /></td></tr>
<tr class="separator:a152ca6351bb7e1075a561cab6757e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9cad476bda3c8a678756552a1b0c90" id="r_a8b9cad476bda3c8a678756552a1b0c90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a8b9cad476bda3c8a678756552a1b0c90">timeout</a> (boost::chrono::duration&lt; double &gt; seconds)=0</td></tr>
<tr class="memdesc:a8b9cad476bda3c8a678756552a1b0c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for the solver.  <br /></td></tr>
<tr class="separator:a8b9cad476bda3c8a678756552a1b0c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772cf56406d1854751d28de1bc124ce" id="r_ab772cf56406d1854751d28de1bc124ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab772cf56406d1854751d28de1bc124ce">triviallySatisfiable</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;exprs)</td></tr>
<tr class="memdesc:ab772cf56406d1854751d28de1bc124ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if expressions are trivially satisfiable or unsatisfiable.  <br /></td></tr>
<tr class="separator:ab772cf56406d1854751d28de1bc124ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc34f946a14ad925ae4249dcc03b1d6" id="r_aecc34f946a14ad925ae4249dcc03b1d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aecc34f946a14ad925ae4249dcc03b1d6">reset</a> ()</td></tr>
<tr class="memdesc:aecc34f946a14ad925ae4249dcc03b1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset solver state.  <br /></td></tr>
<tr class="separator:aecc34f946a14ad925ae4249dcc03b1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b666913c0b2546f96c69e8dd1859b98" id="r_a9b666913c0b2546f96c69e8dd1859b98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a9b666913c0b2546f96c69e8dd1859b98">push</a> ()</td></tr>
<tr class="memdesc:a9b666913c0b2546f96c69e8dd1859b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a backtracking point.  <br /></td></tr>
<tr class="separator:a9b666913c0b2546f96c69e8dd1859b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535fd3f73911300296a15e770db30b1b" id="r_a535fd3f73911300296a15e770db30b1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a535fd3f73911300296a15e770db30b1b">pop</a> ()</td></tr>
<tr class="memdesc:a535fd3f73911300296a15e770db30b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a backtracking point.  <br /></td></tr>
<tr class="separator:a535fd3f73911300296a15e770db30b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd7fc2445b5d674b3142eb16aac98e0" id="r_a4fd7fc2445b5d674b3142eb16aac98e0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4fd7fc2445b5d674b3142eb16aac98e0">nLevels</a> () const</td></tr>
<tr class="memdesc:a4fd7fc2445b5d674b3142eb16aac98e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of backtracking levels.  <br /></td></tr>
<tr class="separator:a4fd7fc2445b5d674b3142eb16aac98e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db768bbae367e738572d1d89d0deda4" id="r_a3db768bbae367e738572d1d89d0deda4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a3db768bbae367e738572d1d89d0deda4">nAssertions</a> (size_t backtrackingLevel)</td></tr>
<tr class="memdesc:a3db768bbae367e738572d1d89d0deda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of assertions at a specific backtracking level.  <br /></td></tr>
<tr class="separator:a3db768bbae367e738572d1d89d0deda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfa92d7ed779f2ee3dfcdcfdee92fb0" id="r_a0dfa92d7ed779f2ee3dfcdcfdee92fb0"><td class="memItemLeft" align="right" valign="top"><a id="a0dfa92d7ed779f2ee3dfcdcfdee92fb0" name="a0dfa92d7ed779f2ee3dfcdcfdee92fb0"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nAssertions</b> () const</td></tr>
<tr class="memdesc:a0dfa92d7ed779f2ee3dfcdcfdee92fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of assertions across all backtracking levels. <br /></td></tr>
<tr class="separator:a0dfa92d7ed779f2ee3dfcdcfdee92fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9524916178fab6cdc424ac3a07e038" id="r_a2f9524916178fab6cdc424ac3a07e038"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2f9524916178fab6cdc424ac3a07e038">assertions</a> () const</td></tr>
<tr class="memdesc:a2f9524916178fab6cdc424ac3a07e038"><td class="mdescLeft">&#160;</td><td class="mdescRight">All assertions.  <br /></td></tr>
<tr class="separator:a2f9524916178fab6cdc424ac3a07e038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2109adb230579d3031c1b4734f67748" id="r_ad2109adb230579d3031c1b4734f67748"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad2109adb230579d3031c1b4734f67748">assertions</a> (size_t level) const</td></tr>
<tr class="memdesc:ad2109adb230579d3031c1b4734f67748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertions for a particular level.  <br /></td></tr>
<tr class="separator:ad2109adb230579d3031c1b4734f67748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab63165cc883488c31e606b9cb47ae" id="r_a36ab63165cc883488c31e606b9cb47ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a36ab63165cc883488c31e606b9cb47ae">check</a> ()</td></tr>
<tr class="memdesc:a36ab63165cc883488c31e606b9cb47ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check satisfiability of current stack.  <br /></td></tr>
<tr class="separator:a36ab63165cc883488c31e606b9cb47ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95102571ff65562ee7e1e5a95c10bb04" id="r_a95102571ff65562ee7e1e5a95c10bb04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a95102571ff65562ee7e1e5a95c10bb04">checkTrivial</a> ()</td></tr>
<tr class="memdesc:a95102571ff65562ee7e1e5a95c10bb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the stack of assertions is trivially satisfiable.  <br /></td></tr>
<tr class="separator:a95102571ff65562ee7e1e5a95c10bb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f29b86c1240f5d7f63128557e0ad2c2" id="r_a5f29b86c1240f5d7f63128557e0ad2c2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5f29b86c1240f5d7f63128557e0ad2c2">evidenceNames</a> () const</td></tr>
<tr class="memdesc:a5f29b86c1240f5d7f63128557e0ad2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names of items for which satisfiability evidence exists.  <br /></td></tr>
<tr class="separator:a5f29b86c1240f5d7f63128557e0ad2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0055bb39d27fa2b07f716dd0964de29" id="r_ac0055bb39d27fa2b07f716dd0964de29"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac0055bb39d27fa2b07f716dd0964de29">evidenceForName</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:ac0055bb39d27fa2b07f716dd0964de29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evidence of satisfiability for a variable or memory address.  <br /></td></tr>
<tr class="separator:ac0055bb39d27fa2b07f716dd0964de29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa681c6451c52ecdc6c792146ad1977ab" id="r_aa681c6451c52ecdc6c792146ad1977ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aa681c6451c52ecdc6c792146ad1977ab">clearEvidence</a> ()</td></tr>
<tr class="memdesc:aa681c6451c52ecdc6c792146ad1977ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears evidence information.  <br /></td></tr>
<tr class="separator:aa681c6451c52ecdc6c792146ad1977ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f037cbc3442782c8220e7009a2266d" id="r_a62f037cbc3442782c8220e7009a2266d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a62f037cbc3442782c8220e7009a2266d">evidenceForAddress</a> (uint64_t addr)</td></tr>
<tr class="memdesc:a62f037cbc3442782c8220e7009a2266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evidence of satisfiability for a memory address.  <br /></td></tr>
<tr class="separator:a62f037cbc3442782c8220e7009a2266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014757478748210d539221266ffead60" id="r_a014757478748210d539221266ffead60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a014757478748210d539221266ffead60">statistics</a> () const</td></tr>
<tr class="memdesc:a014757478748210d539221266ffead60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Statistics for this solver.  <br /></td></tr>
<tr class="separator:a014757478748210d539221266ffead60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ac7922bd68b344119f68d7be9ef66" id="r_a3f4ac7922bd68b344119f68d7be9ef66"><td class="memItemLeft" align="right" valign="top"><a id="a3f4ac7922bd68b344119f68d7be9ef66" name="a3f4ac7922bd68b344119f68d7be9ef66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetStatistics</b> ()</td></tr>
<tr class="memdesc:a3f4ac7922bd68b344119f68d7be9ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets statistics for this solver. <br /></td></tr>
<tr class="separator:a3f4ac7922bd68b344119f68d7be9ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae11114696b2314db156cb9c6d95ac" id="r_a2eae11114696b2314db156cb9c6d95ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2eae11114696b2314db156cb9c6d95ac">generateFile</a> (std::ostream &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;exprs, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad9c19ddb335c583f0fd967bb39f9f623">Definitions</a> *)=0</td></tr>
<tr class="memdesc:a2eae11114696b2314db156cb9c6d95ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an input file for for the solver.  <br /></td></tr>
<tr class="separator:a2eae11114696b2314db156cb9c6d95ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e240d87af8eddd013ab9642b88457" id="r_ad81e240d87af8eddd013ab9642b88457"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad81e240d87af8eddd013ab9642b88457">selfTest</a> ()</td></tr>
<tr class="memdesc:ad81e240d87af8eddd013ab9642b88457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit tests.  <br /></td></tr>
<tr class="separator:ad81e240d87af8eddd013ab9642b88457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0bf8180e9f5e82bd41a54f5005d1fe64" id="r_a0bf8180e9f5e82bd41a54f5005d1fe64"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0bf8180e9f5e82bd41a54f5005d1fe64">name</a> () const</td></tr>
<tr class="memdesc:a0bf8180e9f5e82bd41a54f5005d1fe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name of solver for debugging.  <br /></td></tr>
<tr class="separator:a0bf8180e9f5e82bd41a54f5005d1fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83781bc0a3685d9abe2a465506c5478" id="r_ad83781bc0a3685d9abe2a465506c5478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad83781bc0a3685d9abe2a465506c5478">name</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ad83781bc0a3685d9abe2a465506c5478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name of solver for debugging.  <br /></td></tr>
<tr class="separator:ad83781bc0a3685d9abe2a465506c5478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a249f70db11dd6106b570fc55a2199aee" id="r_a249f70db11dd6106b570fc55a2199aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a249f70db11dd6106b570fc55a2199aee">memoizer</a> () const</td></tr>
<tr class="memdesc:a249f70db11dd6106b570fc55a2199aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html" title="Memoizes calls to an SMT solver.">Memoizer</a>.  <br /></td></tr>
<tr class="separator:a249f70db11dd6106b570fc55a2199aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1e91d53c0df6161b11bb07e82528ab" id="r_a1a1e91d53c0df6161b11bb07e82528ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a1a1e91d53c0df6161b11bb07e82528ab">memoizer</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a1a1e91d53c0df6161b11bb07e82528ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html" title="Memoizes calls to an SMT solver.">Memoizer</a>.  <br /></td></tr>
<tr class="separator:a1a1e91d53c0df6161b11bb07e82528ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a60141955e19cd1f16dd7eadec44a4266" id="r_a60141955e19cd1f16dd7eadec44a4266"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a60141955e19cd1f16dd7eadec44a4266">satisfiable</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a60141955e19cd1f16dd7eadec44a4266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown.  <br /></td></tr>
<tr class="separator:a60141955e19cd1f16dd7eadec44a4266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa572d8aadc91a9508615fa5e18033182" id="r_aa572d8aadc91a9508615fa5e18033182"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aa572d8aadc91a9508615fa5e18033182">satisfiable</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;)</td></tr>
<tr class="memdesc:aa572d8aadc91a9508615fa5e18033182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown.  <br /></td></tr>
<tr class="separator:aa572d8aadc91a9508615fa5e18033182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac456162ac5598a3640580c144e6190a9" id="r_ac456162ac5598a3640580c144e6190a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac456162ac5598a3640580c144e6190a9">errorIfReset</a> () const</td></tr>
<tr class="memdesc:ac456162ac5598a3640580c144e6190a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Throw an exception if the solver is reset.  <br /></td></tr>
<tr class="separator:ac456162ac5598a3640580c144e6190a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500eb03915501b48a2d56b40392d0e1" id="r_a9500eb03915501b48a2d56b40392d0e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a9500eb03915501b48a2d56b40392d0e1">errorIfReset</a> (bool b)</td></tr>
<tr class="memdesc:a9500eb03915501b48a2d56b40392d0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Throw an exception if the solver is reset.  <br /></td></tr>
<tr class="separator:a9500eb03915501b48a2d56b40392d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acfd7ee82a90739fc1c859c8cef9565ca" id="r_acfd7ee82a90739fc1c859c8cef9565ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#acfd7ee82a90739fc1c859c8cef9565ca">insert</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:acfd7ee82a90739fc1c859c8cef9565ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert assertions.  <br /></td></tr>
<tr class="separator:acfd7ee82a90739fc1c859c8cef9565ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ed3185b4b538fd00e45a507c936a96" id="r_a96ed3185b4b538fd00e45a507c936a96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a96ed3185b4b538fd00e45a507c936a96">insert</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;)</td></tr>
<tr class="memdesc:a96ed3185b4b538fd00e45a507c936a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert assertions.  <br /></td></tr>
<tr class="separator:a96ed3185b4b538fd00e45a507c936a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4dc5ae93d1d92686b47a03bf6df402a3" id="r_a4dc5ae93d1d92686b47a03bf6df402a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad2afba34dae5518bd22d472d8c2fe327">Evidence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4dc5ae93d1d92686b47a03bf6df402a3">evidenceByName</a> () const</td></tr>
<tr class="memdesc:a4dc5ae93d1d92686b47a03bf6df402a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">All evidence of satisfiability.  <br /></td></tr>
<tr class="separator:a4dc5ae93d1d92686b47a03bf6df402a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8af263548d1c6f334525149ca666096" id="r_ac8af263548d1c6f334525149ca666096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">ExprExprMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac8af263548d1c6f334525149ca666096">evidence</a> () const</td></tr>
<tr class="memdesc:ac8af263548d1c6f334525149ca666096"><td class="mdescLeft">&#160;</td><td class="mdescRight">All evidence of satisfiability.  <br /></td></tr>
<tr class="separator:ac8af263548d1c6f334525149ca666096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad11c2b4e99e2f3cc4797aa7c98dafcb2" id="r_ad11c2b4e99e2f3cc4797aa7c98dafcb2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad11c2b4e99e2f3cc4797aa7c98dafcb2">evidenceForVariable</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;var)</td></tr>
<tr class="memdesc:ad11c2b4e99e2f3cc4797aa7c98dafcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evidence of satisfiability for a bitvector variable.  <br /></td></tr>
<tr class="separator:ad11c2b4e99e2f3cc4797aa7c98dafcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5973fcfa05a2babca12c1ed776332d" id="r_a4c5973fcfa05a2babca12c1ed776332d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4c5973fcfa05a2babca12c1ed776332d">evidenceForVariable</a> (uint64_t varno)</td></tr>
<tr class="memdesc:a4c5973fcfa05a2babca12c1ed776332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evidence of satisfiability for a bitvector variable.  <br /></td></tr>
<tr class="separator:a4c5973fcfa05a2babca12c1ed776332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0f9fb629030d0162c39b2f0d088e97d" id="r_ad0f9fb629030d0162c39b2f0d088e97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad0f9fb629030d0162c39b2f0d088e97d">progress</a> () const</td></tr>
<tr class="memdesc:ad0f9fb629030d0162c39b2f0d088e97d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> reporting object.  <br /></td></tr>
<tr class="separator:ad0f9fb629030d0162c39b2f0d088e97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ea4b1e3f18a12b3797c32d03f502bb" id="r_af8ea4b1e3f18a12b3797c32d03f502bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#af8ea4b1e3f18a12b3797c32d03f502bb">progress</a> (const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;progress)</td></tr>
<tr class="memdesc:af8ea4b1e3f18a12b3797c32d03f502bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> reporting object.  <br /></td></tr>
<tr class="separator:af8ea4b1e3f18a12b3797c32d03f502bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abbfcf879268981a3966596447af9bdc9" id="r_abbfcf879268981a3966596447af9bdc9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a02578f6f4e97d474006c9442cdc0a23b">Availability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#abbfcf879268981a3966596447af9bdc9">availability</a> ()</td></tr>
<tr class="memdesc:abbfcf879268981a3966596447af9bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Availability of all known solvers.  <br /></td></tr>
<tr class="separator:abbfcf879268981a3966596447af9bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6497e6c48f047fe9117437ccd8c2822d" id="r_a6497e6c48f047fe9117437ccd8c2822d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a6497e6c48f047fe9117437ccd8c2822d">instance</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0bf8180e9f5e82bd41a54f5005d1fe64">name</a>)</td></tr>
<tr class="memdesc:a6497e6c48f047fe9117437ccd8c2822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new solver by name.  <br /></td></tr>
<tr class="separator:a6497e6c48f047fe9117437ccd8c2822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b944c417a7193c00f1506d9b6df042" id="r_ab9b944c417a7193c00f1506d9b6df042"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab9b944c417a7193c00f1506d9b6df042">bestAvailable</a> ()</td></tr>
<tr class="memdesc:ab9b944c417a7193c00f1506d9b6df042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best available solver.  <br /></td></tr>
<tr class="separator:ab9b944c417a7193c00f1506d9b6df042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806b3235eb57b6727355b2d7e2367f39" id="r_a806b3235eb57b6727355b2d7e2367f39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a806b3235eb57b6727355b2d7e2367f39">bestLinkage</a> (unsigned linkages)</td></tr>
<tr class="memdesc:a806b3235eb57b6727355b2d7e2367f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bit vector of linkages, return the best one.  <br /></td></tr>
<tr class="separator:a806b3235eb57b6727355b2d7e2367f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603a0892f36a210700ebbf5b8b35cc8" id="r_a5603a0892f36a210700ebbf5b8b35cc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5603a0892f36a210700ebbf5b8b35cc8">classStatistics</a> ()</td></tr>
<tr class="memdesc:a5603a0892f36a210700ebbf5b8b35cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Statistics across all solvers.  <br /></td></tr>
<tr class="separator:a5603a0892f36a210700ebbf5b8b35cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb9fd83a5f015728aac73b76bde9be1" id="r_a0cb9fd83a5f015728aac73b76bde9be1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0cb9fd83a5f015728aac73b76bde9be1">resetClassStatistics</a> ()</td></tr>
<tr class="memdesc:a0cb9fd83a5f015728aac73b76bde9be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets statistics for the class.  <br /></td></tr>
<tr class="separator:a0cb9fd83a5f015728aac73b76bde9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2da45f24089272d6da39e98f536abc5" id="r_ab2da45f24089272d6da39e98f536abc5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab2da45f24089272d6da39e98f536abc5">initDiagnostics</a> ()</td></tr>
<tr class="memdesc:ab2da45f24089272d6da39e98f536abc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostic output facilities.  <br /></td></tr>
<tr class="separator:ab2da45f24089272d6da39e98f536abc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af0563f562e3525422d8a3563dd4bfa2d" id="r_af0563f562e3525422d8a3563dd4bfa2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#af0563f562e3525422d8a3563dd4bfa2d">mlog</a></td></tr>
<tr class="memdesc:af0563f562e3525422d8a3563dd4bfa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic facility.  <br /></td></tr>
<tr class="separator:af0563f562e3525422d8a3563dd4bfa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9a5e74d909a2152c7429babb91fdf750" id="r_a9a5e74d909a2152c7429babb91fdf750"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a9a5e74d909a2152c7429babb91fdf750">SmtSolver</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0bf8180e9f5e82bd41a54f5005d1fe64">name</a>, unsigned linkages)</td></tr>
<tr class="memdesc:a9a5e74d909a2152c7429babb91fdf750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with name and linkage.  <br /></td></tr>
<tr class="separator:a9a5e74d909a2152c7429babb91fdf750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8a868a65bffd3f5c5f7b7e6d92680" id="r_afad8a868a65bffd3f5c5f7b7e6d92680"><td class="memItemLeft" align="right" valign="top"><a id="afad8a868a65bffd3f5c5f7b7e6d92680" name="afad8a868a65bffd3f5c5f7b7e6d92680"></a>
virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>checkExe</b> ()</td></tr>
<tr class="memdesc:afad8a868a65bffd3f5c5f7b7e6d92680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check satisfiability using text files and an executable. <br /></td></tr>
<tr class="separator:afad8a868a65bffd3f5c5f7b7e6d92680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844e9d76d7fa5d86b3fd3202bc719345" id="r_a844e9d76d7fa5d86b3fd3202bc719345"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a844e9d76d7fa5d86b3fd3202bc719345">checkLib</a> ()</td></tr>
<tr class="memdesc:a844e9d76d7fa5d86b3fd3202bc719345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check satisfiability using a library API.  <br /></td></tr>
<tr class="separator:a844e9d76d7fa5d86b3fd3202bc719345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5240996e1a152d5cd49189e6df1837b" id="r_ae5240996e1a152d5cd49189e6df1837b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ae5240996e1a152d5cd49189e6df1837b">getErrorMessage</a> (int exitStatus)</td></tr>
<tr class="memdesc:ae5240996e1a152d5cd49189e6df1837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error message from running a solver executable.  <br /></td></tr>
<tr class="separator:ae5240996e1a152d5cd49189e6df1837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04e7dba9f62d6dc53b41c3290572f59" id="r_ab04e7dba9f62d6dc53b41c3290572f59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab04e7dba9f62d6dc53b41c3290572f59">findVariables</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab8b4e71a51043fe53e63b375330a1f6f">VariableSet</a> &amp;)</td></tr>
<tr class="memdesc:ab04e7dba9f62d6dc53b41c3290572f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all variables that need declarations.  <br /></td></tr>
<tr class="separator:ab04e7dba9f62d6dc53b41c3290572f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290d9506719093a1ddb7ca790efb954a" id="r_a290d9506719093a1ddb7ca790efb954a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a290d9506719093a1ddb7ca790efb954a">getCommand</a> (const std::string &amp;config_name)=0</td></tr>
<tr class="memdesc:a290d9506719093a1ddb7ca790efb954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the name of a configuration file, return the command that is needed to run the solver.  <br /></td></tr>
<tr class="separator:a290d9506719093a1ddb7ca790efb954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e303563d5767c0ddd9ae21bb9f20c0" id="r_ae9e303563d5767c0ddd9ae21bb9f20c0"><td class="memItemLeft" align="right" valign="top"><a id="ae9e303563d5767c0ddd9ae21bb9f20c0" name="ae9e303563d5767c0ddd9ae21bb9f20c0"></a>
std::vector&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parseSExpressions</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae9e303563d5767c0ddd9ae21bb9f20c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all SExprs from the specified string. <br /></td></tr>
<tr class="separator:ae9e303563d5767c0ddd9ae21bb9f20c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7683121f57c08b880b41aa4a956247f7" id="r_a7683121f57c08b880b41aa4a956247f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a7683121f57c08b880b41aa4a956247f7">parseEvidence</a> ()</td></tr>
<tr class="memdesc:a7683121f57c08b880b41aa4a956247f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses evidence of satisfiability.  <br /></td></tr>
<tr class="separator:a7683121f57c08b880b41aa4a956247f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a510ac449b4e13a912afc0f587bf9b9b6" id="r_a510ac449b4e13a912afc0f587bf9b9b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a510ac449b4e13a912afc0f587bf9b9b6">printSExpression</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a> &amp;)</td></tr>
<tr class="memdesc:a510ac449b4e13a912afc0f587bf9b9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an S-Expr for debugging.  <br /></td></tr>
<tr class="separator:a510ac449b4e13a912afc0f587bf9b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f39b867855d062ea47afcb5597ea32" id="r_a72f39b867855d062ea47afcb5597ea32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a72f39b867855d062ea47afcb5597ea32">normalizeVariables</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">SymbolicExpression::ExprExprHashMap</a> &amp;index)</td></tr>
<tr class="memdesc:a72f39b867855d062ea47afcb5597ea32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize expressions by renaming variables.  <br /></td></tr>
<tr class="separator:a72f39b867855d062ea47afcb5597ea32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd9c026630017eb67676b7483bbd488" id="r_a5fd9c026630017eb67676b7483bbd488"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5fd9c026630017eb67676b7483bbd488">undoNormalization</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;, const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">SymbolicExpression::ExprExprHashMap</a> &amp;index)</td></tr>
<tr class="memdesc:a5fd9c026630017eb67676b7483bbd488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the normalizations that were performed earlier.  <br /></td></tr>
<tr class="separator:a5fd9c026630017eb67676b7483bbd488"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a900e9e820b53c678943cd3805f63010a" id="r_a900e9e820b53c678943cd3805f63010a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a900e9e820b53c678943cd3805f63010a">linkage_</a></td></tr>
<tr class="separator:a900e9e820b53c678943cd3805f63010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca97eed5551b49b5f1d079e4e1cbac38" id="r_aca97eed5551b49b5f1d079e4e1cbac38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aca97eed5551b49b5f1d079e4e1cbac38">outputText_</a></td></tr>
<tr class="memdesc:aca97eed5551b49b5f1d079e4e1cbac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional output obtained by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a60141955e19cd1f16dd7eadec44a4266" title="Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown.">satisfiable()</a>.  <br /></td></tr>
<tr class="separator:aca97eed5551b49b5f1d079e4e1cbac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d87db0c975550aacbff88593e22d92" id="r_af7d87db0c975550aacbff88593e22d92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#af7d87db0c975550aacbff88593e22d92">parsedOutput_</a></td></tr>
<tr class="separator:af7d87db0c975550aacbff88593e22d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffaeab9833cc0ea00118ef183a9fdd3" id="r_a3ffaeab9833cc0ea00118ef183a9fdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">ExprExprMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a3ffaeab9833cc0ea00118ef183a9fdd3">evidence_</a></td></tr>
<tr class="separator:a3ffaeab9833cc0ea00118ef183a9fdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916d98436fb95b93980e4b43fe5ad14a" id="r_a916d98436fb95b93980e4b43fe5ad14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1Map.html">TermNames</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a916d98436fb95b93980e4b43fe5ad14a">termNames_</a></td></tr>
<tr class="separator:a916d98436fb95b93980e4b43fe5ad14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd72bbb76f667a99620f9875206d05f" id="r_a0bd72bbb76f667a99620f9875206d05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0bd72bbb76f667a99620f9875206d05f">memoizer_</a></td></tr>
<tr class="separator:a0bd72bbb76f667a99620f9875206d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e4fe511880a63357050d4057e6f34" id="r_a924e4fe511880a63357050d4057e6f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a924e4fe511880a63357050d4057e6f34">progress_</a></td></tr>
<tr class="separator:a924e4fe511880a63357050d4057e6f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f08e17df2557384eef889724aa6acfd" id="r_a7f08e17df2557384eef889724aa6acfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a7f08e17df2557384eef889724aa6acfd">stats</a></td></tr>
<tr class="separator:a7f08e17df2557384eef889724aa6acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3c72546087c31de016739042c6f40b10" id="r_a3c72546087c31de016739042c6f40b10"><td class="memItemLeft" align="right" valign="top">static boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a3c72546087c31de016739042c6f40b10">classStatsMutex</a></td></tr>
<tr class="separator:a3c72546087c31de016739042c6f40b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a03c7c76744fc65067b85bc6af6bc27" id="r_a5a03c7c76744fc65067b85bc6af6bc27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5a03c7c76744fc65067b85bc6af6bc27">classStats</a></td></tr>
<tr class="separator:a5a03c7c76744fc65067b85bc6af6bc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0a5acec3c7ca24097f71ffcabc8d376d" name="a0a5acec3c7ca24097f71ffcabc8d376d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5acec3c7ca24097f71ffcabc8d376d">&#9670;&#160;</a></span>ExprList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">Rose::BinaryAnalysis::SmtSolver::ExprList</a> =  std::vector&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered list of expressions. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00042">42</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a2045f331681fb93516ed2c4c3fa5f689" name="a2045f331681fb93516ed2c4c3fa5f689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2045f331681fb93516ed2c4c3fa5f689">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Rose::BinaryAnalysis::SmtSolver::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer for SMT solvers. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00045">45</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a02578f6f4e97d474006c9442cdc0a23b" name="a02578f6f4e97d474006c9442cdc0a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02578f6f4e97d474006c9442cdc0a23b">&#9670;&#160;</a></span>Availability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a02578f6f4e97d474006c9442cdc0a23b">Rose::BinaryAnalysis::SmtSolver::Availability</a> =  std::map&lt;std::string, bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solver availability map. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00048">48</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="ae5eb3b130a326ffe3a641e7bb768dc36" name="ae5eb3b130a326ffe3a641e7bb768dc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eb3b130a326ffe3a641e7bb768dc36">&#9670;&#160;</a></span>StringTypePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ae5eb3b130a326ffe3a641e7bb768dc36">Rose::BinaryAnalysis::SmtSolver::StringTypePair</a> =  std::pair&lt;std::string, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps expression nodes to term names. </p>
<p>This map is populated for common subexpressions. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00066">66</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="adf14e5e6cc7d57505a87eeac3f7e5959" name="adf14e5e6cc7d57505a87eeac3f7e5959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14e5e6cc7d57505a87eeac3f7e5959">&#9670;&#160;</a></span>TermNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Container_1_1Map.html">Rose::BinaryAnalysis::SmtSolver::TermNames</a> =  <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ae5eb3b130a326ffe3a641e7bb768dc36">StringTypePair</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00067">67</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="ad42b6c0684322672d59b936336b0b643" name="ad42b6c0684322672d59b936336b0b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42b6c0684322672d59b936336b0b643">&#9670;&#160;</a></span>ExprExprMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">Rose::BinaryAnalysis::SmtSolver::ExprExprMap</a> =  <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps one symbolic expression to another. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00070">70</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="ab8b4e71a51043fe53e63b375330a1f6f" name="ab8b4e71a51043fe53e63b375330a1f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b4e71a51043fe53e63b375330a1f6f">&#9670;&#160;</a></span>VariableSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab8b4e71a51043fe53e63b375330a1f6f">Rose::BinaryAnalysis::SmtSolver::VariableSet</a> =  <a class="el" href="classSawyer_1_1Container_1_1Set.html">Sawyer::Container::Set</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">SymbolicExpression::LeafPtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1CompareLeavesByName.html">CompareLeavesByName</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of variables. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00178">178</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="ad9c19ddb335c583f0fd967bb39f9f623" name="ad9c19ddb335c583f0fd967bb39f9f623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c19ddb335c583f0fd967bb39f9f623">&#9670;&#160;</a></span>Definitions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad9c19ddb335c583f0fd967bb39f9f623">Rose::BinaryAnalysis::SmtSolver::Definitions</a> =  std::set&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free variables that have been defined. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00180">180</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="aeb3db6fecb9c16d0d6644fe1b5166837" name="aeb3db6fecb9c16d0d6644fe1b5166837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3db6fecb9c16d0d6644fe1b5166837">&#9670;&#160;</a></span>SExprTypePair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Rose::BinaryAnalysis::SmtSolver::SExprTypePair =  std::pair&lt;<a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00202">202</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="ad2afba34dae5518bd22d472d8c2fe327" name="ad2afba34dae5518bd22d472d8c2fe327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2afba34dae5518bd22d472d8c2fe327">&#9670;&#160;</a></span>Evidence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad2afba34dae5518bd22d472d8c2fe327">Rose::BinaryAnalysis::SmtSolver::Evidence</a> =  <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;std::string , <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evidence of satisfiability. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00566">566</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a780a2c523850a54f01939334bbab8a34" name="a780a2c523850a54f01939334bbab8a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780a2c523850a54f01939334bbab8a34">&#9670;&#160;</a></span>LinkMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">Rose::BinaryAnalysis::SmtSolver::LinkMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit flags to indicate the kind of solver interface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a780a2c523850a54f01939334bbab8a34ad6a15e3f1094e828dc01588f1ba8ae8c" name="a780a2c523850a54f01939334bbab8a34ad6a15e3f1094e828dc01588f1ba8ae8c"></a>LM_NONE&#160;</td><td class="fielddoc"><p>No available linkage. </p>
</td></tr>
<tr><td class="fieldname"><a id="a780a2c523850a54f01939334bbab8a34aa425e79d261241b8ec455ec54d426495" name="a780a2c523850a54f01939334bbab8a34aa425e79d261241b8ec455ec54d426495"></a>LM_LIBRARY&#160;</td><td class="fielddoc"><p>A runtime library is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a780a2c523850a54f01939334bbab8a34a32d2d5c22648c062713587db4a7a7449" name="a780a2c523850a54f01939334bbab8a34a32d2d5c22648c062713587db4a7a7449"></a>LM_EXECUTABLE&#160;</td><td class="fielddoc"><p>An executable is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a780a2c523850a54f01939334bbab8a34a19846bed3aa3fa0bc219ef5c503a27b4" name="a780a2c523850a54f01939334bbab8a34a19846bed3aa3fa0bc219ef5c503a27b4"></a>LM_ANY&#160;</td><td class="fielddoc"><p>Any available mode. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00051">51</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a4bfdcdf6867258024ec930056b4d74c4" name="a4bfdcdf6867258024ec930056b4d74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfdcdf6867258024ec930056b4d74c4">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4bfdcdf6867258024ec930056b4d74c4">Rose::BinaryAnalysis::SmtSolver::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type (sort) of expression. </p>
<p>ROSE uses bit constants "#b1" and "#b0" (in SMT-LIB syntax) to represent Boolean true and false, but most solvers distinguish between bit vector and Boolean types and don't allow them to be mixed (e.g., "(and #b1 true)" is an error). </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00063">63</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a807e813a7a89a77142a200b6621f7ee1" name="a807e813a7a89a77142a200b6621f7ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807e813a7a89a77142a200b6621f7ee1">&#9670;&#160;</a></span>Satisfiable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Rose::BinaryAnalysis::SmtSolver::Satisfiable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Satisfiability constants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a807e813a7a89a77142a200b6621f7ee1ae3dd9347555a59adb9e97d22982cb4e3" name="a807e813a7a89a77142a200b6621f7ee1ae3dd9347555a59adb9e97d22982cb4e3"></a>SAT_NO&#160;</td><td class="fielddoc"><p>Provably unsatisfiable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a807e813a7a89a77142a200b6621f7ee1ad1f780f83463eaa5e55d306ce9d7433c" name="a807e813a7a89a77142a200b6621f7ee1ad1f780f83463eaa5e55d306ce9d7433c"></a>SAT_YES&#160;</td><td class="fielddoc"><p>Satisfiable and evidence of satisfiability may be available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a807e813a7a89a77142a200b6621f7ee1a548dad0f005ad6e9b698b0da2f012d44" name="a807e813a7a89a77142a200b6621f7ee1a548dad0f005ad6e9b698b0da2f012d44"></a>SAT_UNKNOWN&#160;</td><td class="fielddoc"><p>Could not be proved satisfiable or unsatisfiable. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00087">87</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a5e74d909a2152c7429babb91fdf750" name="a9a5e74d909a2152c7429babb91fdf750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5e74d909a2152c7429babb91fdf750">&#9670;&#160;</a></span>SmtSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::SmtSolver::SmtSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>linkages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with name and linkage. </p>
<p>Every solver should have a <code>name</code> that will appear in diagnostic messages, such as "z3", and a linkage mode that describes how ROSE communicates with the solver. The linkage mode is chosen as the least significant set bit of <code>linkages</code>, therefore the subclass should ensure that <code>linkages</code> contains only valid bits. If <code>linkages</code> is zero then the constructed object will be useless since it has no way to communicate with the solver. You can check for this situation by reading the <code>linkage</code> property, or just wait for one of the other methods to throw an <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Exception.html">SmtSolver::Exception</a>. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00359">359</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48883315932977b0ce4533310fa7053e" name="a48883315932977b0ce4533310fa7053e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48883315932977b0ce4533310fa7053e">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a> Rose::BinaryAnalysis::SmtSolver::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor. </p>
<p>The new solver will have the same settings as the source solver. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#aa564e048930b971f443330d152c805d1">Rose::BinaryAnalysis::SmtlibSolver</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#aac84bcbb1125d81f98959fe65fbaf9fa">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="abbfcf879268981a3966596447af9bdc9" name="abbfcf879268981a3966596447af9bdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfcf879268981a3966596447af9bdc9">&#9670;&#160;</a></span>availability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a02578f6f4e97d474006c9442cdc0a23b">Availability</a> Rose::BinaryAnalysis::SmtSolver::availability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Availability of all known solvers. </p>
<p>Returns a map whose keys are the names of the SMT solver APIs and whose value is true if the solver is avilable or false if not available. </p>

</div>
</div>
<a id="a6497e6c48f047fe9117437ccd8c2822d" name="a6497e6c48f047fe9117437ccd8c2822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6497e6c48f047fe9117437ccd8c2822d">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a> Rose::BinaryAnalysis::SmtSolver::instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new solver by name. </p>
<p>Create a new solver using one of the names returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#abbfcf879268981a3966596447af9bdc9">availability</a>. The special name "" means no solver (return null) and "best" means return <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab9b944c417a7193c00f1506d9b6df042">bestAvailable</a> (which might also be null). It may be possible to create solvers by name that are not available, but attempting to use such a solver will fail loudly by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a152ca6351bb7e1075a561cab6757e95c">requireLinkage</a>. If an invalid name is supplied then an <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Exception.html">SmtSolver::Exception</a> is thrown. </p>

</div>
</div>
<a id="ab9b944c417a7193c00f1506d9b6df042" name="ab9b944c417a7193c00f1506d9b6df042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b944c417a7193c00f1506d9b6df042">&#9670;&#160;</a></span>bestAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a2045f331681fb93516ed2c4c3fa5f689">Ptr</a> Rose::BinaryAnalysis::SmtSolver::bestAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Best available solver. </p>
<p>Returns a new solver, an instance of the best available solver. If no solver is possible then returns null. </p>

</div>
</div>
<a id="a0bf8180e9f5e82bd41a54f5005d1fe64" name="a0bf8180e9f5e82bd41a54f5005d1fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf8180e9f5e82bd41a54f5005d1fe64">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::SmtSolver::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Name of solver for debugging. </p>
<p>This name gets printed in various diagnostic messages. It's initialized to something reasonable by constructors, but can be changed at any time by the user. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00404">404</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SmtlibSolver_8h_source.html#l00041">Rose::BinaryAnalysis::SmtlibSolver::instance()</a>.</p>

</div>
</div>
<a id="ad83781bc0a3685d9abe2a465506c5478" name="ad83781bc0a3685d9abe2a465506c5478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83781bc0a3685d9abe2a465506c5478">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SmtSolver::name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Name of solver for debugging. </p>
<p>This name gets printed in various diagnostic messages. It's initialized to something reasonable by constructors, but can be changed at any time by the user. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00405">405</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a962437597417c76a66825aac16188fa8" name="a962437597417c76a66825aac16188fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962437597417c76a66825aac16188fa8">&#9670;&#160;</a></span>linkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a> Rose::BinaryAnalysis::SmtSolver::linkage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: How ROSE communicates with the solver. </p>
<p>The linkage is set when the solver object is created, and is read-only. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00411">411</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a152ca6351bb7e1075a561cab6757e95c" name="a152ca6351bb7e1075a561cab6757e95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152ca6351bb7e1075a561cab6757e95c">&#9670;&#160;</a></span>requireLinkage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SmtSolver::requireLinkage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert required linkage. </p>
<p>If the specified linkage is not available, then throw an exception. </p>

</div>
</div>
<a id="a806b3235eb57b6727355b2d7e2367f39" name="a806b3235eb57b6727355b2d7e2367f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806b3235eb57b6727355b2d7e2367f39">&#9670;&#160;</a></span>bestLinkage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a> Rose::BinaryAnalysis::SmtSolver::bestLinkage </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>linkages</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a bit vector of linkages, return the best one. </p>
<p>"Best" is defined as that with the best performance, which is usually direct calls to the solver's API. </p>

</div>
</div>
<a id="a249f70db11dd6106b570fc55a2199aee" name="a249f70db11dd6106b570fc55a2199aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f70db11dd6106b570fc55a2199aee">&#9670;&#160;</a></span>memoizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a> Rose::BinaryAnalysis::SmtSolver::memoizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html" title="Memoizes calls to an SMT solver.">Memoizer</a>. </p>
<p>The value of this property is a pointer to the object that caches the memoization for this solver. Setting it to a non-null pointer turns on memoization (using that object) and setting it to a null pointer turns off memoization. Memoization can be turned on or off at any time, and multiple SMT solvers can share the same memoizer. </p>

</div>
</div>
<a id="a1a1e91d53c0df6161b11bb07e82528ab" name="a1a1e91d53c0df6161b11bb07e82528ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1e91d53c0df6161b11bb07e82528ab">&#9670;&#160;</a></span>memoizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SmtSolver::memoizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html" title="Memoizes calls to an SMT solver.">Memoizer</a>. </p>
<p>The value of this property is a pointer to the object that caches the memoization for this solver. Setting it to a non-null pointer turns on memoization (using that object) and setting it to a null pointer turns off memoization. Memoization can be turned on or off at any time, and multiple SMT solvers can share the same memoizer. </p>

</div>
</div>
<a id="a8b9cad476bda3c8a678756552a1b0c90" name="a8b9cad476bda3c8a678756552a1b0c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9cad476bda3c8a678756552a1b0c90">&#9670;&#160;</a></span>timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::timeout </td>
          <td>(</td>
          <td class="paramtype">boost::chrono::duration&lt; double &gt;&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timeout for the solver. </p>
<p>This sets the maximum time that the solver will try to find a solution before returning "unknown". </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#ac5133ee3be151d64f826258b4398720d">Rose::BinaryAnalysis::SmtlibSolver</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#a84a56723d1be9917e675ac742190c498">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="ab772cf56406d1854751d28de1bc124ce" name="ab772cf56406d1854751d28de1bc124ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772cf56406d1854751d28de1bc124ce">&#9670;&#160;</a></span>triviallySatisfiable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::triviallySatisfiable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if expressions are trivially satisfiable or unsatisfiable. </p>
<p>If all expressions are known 1-bit values that are true, then this function returns SAT_YES. If any expression is a known 1-bit value that is false, then this function returns SAT_NO. Otherwise this function returns SAT_UNKNOWN.</p>
<p>This is a high-level abstraction that resets this object state so it contains a single assertion set on its stack, and clears evidence of satisfiability. </p>

</div>
</div>
<a id="a60141955e19cd1f16dd7eadec44a4266" name="a60141955e19cd1f16dd7eadec44a4266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60141955e19cd1f16dd7eadec44a4266">&#9670;&#160;</a></span>satisfiable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::satisfiable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown. </p>
<p>This is a high-level abstraction that starts a new SMT solver session. For text-based interfaces, this solver object is reset, a temporary text file is created, the solver is run with the file as input, text output is read, and the evidence of satisfiability is parsed and stored in this object. </p>

</div>
</div>
<a id="aa572d8aadc91a9508615fa5e18033182" name="aa572d8aadc91a9508615fa5e18033182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa572d8aadc91a9508615fa5e18033182">&#9670;&#160;</a></span>satisfiable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::satisfiable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown. </p>
<p>This is a high-level abstraction that starts a new SMT solver session. For text-based interfaces, this solver object is reset, a temporary text file is created, the solver is run with the file as input, text output is read, and the evidence of satisfiability is parsed and stored in this object. </p>

</div>
</div>
<a id="aecc34f946a14ad925ae4249dcc03b1d6" name="aecc34f946a14ad925ae4249dcc03b1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc34f946a14ad925ae4249dcc03b1d6">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset solver state. </p>
<p>Resets the solver to an initial state containing no assertions. The evidence of satisfiability is cleared. For API-based solvers, this function might also create a new solver and/or solver context. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#aee34bfa48893cf20b22b798d72bd6cf1">Rose::BinaryAnalysis::SmtlibSolver</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#aca0be6385ad4e00601cd0b1563288371">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="ac456162ac5598a3640580c144e6190a9" name="ac456162ac5598a3640580c144e6190a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac456162ac5598a3640580c144e6190a9">&#9670;&#160;</a></span>errorIfReset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SmtSolver::errorIfReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Throw an exception if the solver is reset. </p>
<p>This is used mostly for debugging solvers that are intending to use transactions. If the solver is ever reset, say by accidentally invoking its <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a60141955e19cd1f16dd7eadec44a4266">satisfiable</a> method, then an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00485">485</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a9500eb03915501b48a2d56b40392d0e1" name="a9500eb03915501b48a2d56b40392d0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9500eb03915501b48a2d56b40392d0e1">&#9670;&#160;</a></span>errorIfReset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SmtSolver::errorIfReset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Throw an exception if the solver is reset. </p>
<p>This is used mostly for debugging solvers that are intending to use transactions. If the solver is ever reset, say by accidentally invoking its <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a60141955e19cd1f16dd7eadec44a4266">satisfiable</a> method, then an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00488">488</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a9b666913c0b2546f96c69e8dd1859b98" name="a9b666913c0b2546f96c69e8dd1859b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b666913c0b2546f96c69e8dd1859b98">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::push </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a backtracking point. </p>
<p>Pushes a new, empty set of assertions onto the solver stack.</p>
<p>Note that although text-based solvers (executables) accept push and pop methods, they have no effect on the speed of the solver because ROSE invokes the executable in batch mode. In this case the push and pop apply to the stack within this solver object in ROSE.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a535fd3f73911300296a15e770db30b1b">pop</a>. </p>

</div>
</div>
<a id="a535fd3f73911300296a15e770db30b1b" name="a535fd3f73911300296a15e770db30b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535fd3f73911300296a15e770db30b1b">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop a backtracking point. </p>
<p>Pops the top set of assertions from the solver stack. It is not legal to call <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a535fd3f73911300296a15e770db30b1b">pop</a> when the assertion stack is only one level deep; use <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aecc34f946a14ad925ae4249dcc03b1d6">reset</a> in that case instead.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a9b666913c0b2546f96c69e8dd1859b98">push</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#aecc34f946a14ad925ae4249dcc03b1d6">reset</a>. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#a4ae2daebe689fab1a7a860be8b76f790">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="a4fd7fc2445b5d674b3142eb16aac98e0" name="a4fd7fc2445b5d674b3142eb16aac98e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd7fc2445b5d674b3142eb16aac98e0">&#9670;&#160;</a></span>nLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::SmtSolver::nLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of backtracking levels. </p>
<p>This is the number of sets of assertions. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a9b666913c0b2546f96c69e8dd1859b98">push</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a535fd3f73911300296a15e770db30b1b">pop</a> increment and decrement this number. The return valued is always positive. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00516">516</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a3db768bbae367e738572d1d89d0deda4" name="a3db768bbae367e738572d1d89d0deda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db768bbae367e738572d1d89d0deda4">&#9670;&#160;</a></span>nAssertions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::SmtSolver::nAssertions </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>backtrackingLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of assertions at a specific backtracking level. </p>
<p>Backtracking levels are numbered starting at zero up to one less than the value returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4fd7fc2445b5d674b3142eb16aac98e0">nLevels</a>. </p>

</div>
</div>
<a id="acfd7ee82a90739fc1c859c8cef9565ca" name="acfd7ee82a90739fc1c859c8cef9565ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd7ee82a90739fc1c859c8cef9565ca">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert assertions. </p>
<p>Inserts assertions into the set of assertions at the top of the backtracking stack. </p>

</div>
</div>
<a id="a96ed3185b4b538fd00e45a507c936a96" name="a96ed3185b4b538fd00e45a507c936a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ed3185b4b538fd00e45a507c936a96">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert assertions. </p>
<p>Inserts assertions into the set of assertions at the top of the backtracking stack. </p>

</div>
</div>
<a id="a2f9524916178fab6cdc424ac3a07e038" name="a2f9524916178fab6cdc424ac3a07e038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9524916178fab6cdc424ac3a07e038">&#9670;&#160;</a></span>assertions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> Rose::BinaryAnalysis::SmtSolver::assertions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All assertions. </p>
<p>Returns the list of all assertions across all backtracking points. </p>

</div>
</div>
<a id="ad2109adb230579d3031c1b4734f67748" name="ad2109adb230579d3031c1b4734f67748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2109adb230579d3031c1b4734f67748">&#9670;&#160;</a></span>assertions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp; Rose::BinaryAnalysis::SmtSolver::assertions </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assertions for a particular level. </p>
<p>Returns the assertions associated with a particular level of the stack. Level zero is the oldest entry in the stack; all smt objects have a level zero. See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a4fd7fc2445b5d674b3142eb16aac98e0">nLevels</a>. </p>

</div>
</div>
<a id="a36ab63165cc883488c31e606b9cb47ae" name="a36ab63165cc883488c31e606b9cb47ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab63165cc883488c31e606b9cb47ae">&#9670;&#160;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check satisfiability of current stack. </p>
<p>Checks whether all assertions in the entire stack of assertion sets are satisfiable. A set of no assertions is trivially satisfiable. Errors are emitted on <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#af0563f562e3525422d8a3563dd4bfa2d">mlog</a> once per error message and returned as <code>SAT_UNKNOWN</code>. </p>

</div>
</div>
<a id="a95102571ff65562ee7e1e5a95c10bb04" name="a95102571ff65562ee7e1e5a95c10bb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95102571ff65562ee7e1e5a95c10bb04">&#9670;&#160;</a></span>checkTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::checkTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the stack of assertions is trivially satisfiable. </p>
<p>This function returns true if all assertions have already been simplified in ROSE to the single bit "1", and returns true if so; false otherwise. If no assertions are present, this function returns true. This function does not invoke any functions in the underlying SMT solver. </p>

</div>
</div>
<a id="a5f29b86c1240f5d7f63128557e0ad2c2" name="a5f29b86c1240f5d7f63128557e0ad2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f29b86c1240f5d7f63128557e0ad2c2">&#9670;&#160;</a></span>evidenceNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::string &gt; Rose::BinaryAnalysis::SmtSolver::evidenceNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Names of items for which satisfiability evidence exists. </p>
<p>Returns a vector of strings (variable names or memory addresses) that can be passed to <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac0055bb39d27fa2b07f716dd0964de29">evidenceForName</a>. Not all SMT solvers can return this information, in which case they return an empty vector.</p>
<p>The returned names are only for those variables and addresses whose evidence of satisfiability can be parsed by ROSE. The subclasses provide additional methods for obtaining more detailed information. </p>

</div>
</div>
<a id="ac0055bb39d27fa2b07f716dd0964de29" name="ac0055bb39d27fa2b07f716dd0964de29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0055bb39d27fa2b07f716dd0964de29">&#9670;&#160;</a></span>evidenceForName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> Rose::BinaryAnalysis::SmtSolver::evidenceForName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evidence of satisfiability for a variable or memory address. </p>
<p>If the string starts with the letter 'v' then variable evidence is returned, otherwise the string must be an address. Valid strings are those returned by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5f29b86c1240f5d7f63128557e0ad2c2">evidenceNames</a> method; other strings result in a null return value. Subclasses might define additional methods for obtaining evidence of satisfiability. </p>

<p class="reference">Referenced by <a class="el" href="SmtSolver_8h_source.html#l00622">evidenceForVariable()</a>.</p>

</div>
</div>
<a id="a4dc5ae93d1d92686b47a03bf6df402a3" name="a4dc5ae93d1d92686b47a03bf6df402a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc5ae93d1d92686b47a03bf6df402a3">&#9670;&#160;</a></span>evidenceByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad2afba34dae5518bd22d472d8c2fe327">Evidence</a> Rose::BinaryAnalysis::SmtSolver::evidenceByName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All evidence of satisfiability. </p>
<p>The version that returns a map indexed by variable name is the same as calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5f29b86c1240f5d7f63128557e0ad2c2">evidenceNames</a> and then <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac0055bb39d27fa2b07f716dd0964de29">evidenceForName</a> for each of those names.</p>
<p>The version that returns a map indexed by symbolic expression returns all the evidence in symbolic form. The keys for that return value are symbolic expressions that are simply variables.</p>
<p>Evidence is only returned if the previous check was satisfiable. Otherwise the return value is an empty map. </p>

</div>
</div>
<a id="ac8af263548d1c6f334525149ca666096" name="ac8af263548d1c6f334525149ca666096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8af263548d1c6f334525149ca666096">&#9670;&#160;</a></span>evidence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">ExprExprMap</a> Rose::BinaryAnalysis::SmtSolver::evidence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All evidence of satisfiability. </p>
<p>The version that returns a map indexed by variable name is the same as calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a5f29b86c1240f5d7f63128557e0ad2c2">evidenceNames</a> and then <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac0055bb39d27fa2b07f716dd0964de29">evidenceForName</a> for each of those names.</p>
<p>The version that returns a map indexed by symbolic expression returns all the evidence in symbolic form. The keys for that return value are symbolic expressions that are simply variables.</p>
<p>Evidence is only returned if the previous check was satisfiable. Otherwise the return value is an empty map. </p>

</div>
</div>
<a id="aa681c6451c52ecdc6c792146ad1977ab" name="aa681c6451c52ecdc6c792146ad1977ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa681c6451c52ecdc6c792146ad1977ab">&#9670;&#160;</a></span>clearEvidence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::clearEvidence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears evidence information. </p>
<p>Evidence of satisfiability is cleared by calling this function or by calling any function that changes the state of the solver, such as pushing or popping assertion sets, inserting new assertions, or checking satisfiability. Checking satisfiability re-initializes the evidence. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#aa697bdfc122119ad24cafc8a284ad83b">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="ad11c2b4e99e2f3cc4797aa7c98dafcb2" name="ad11c2b4e99e2f3cc4797aa7c98dafcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c2b4e99e2f3cc4797aa7c98dafcb2">&#9670;&#160;</a></span>evidenceForVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> Rose::BinaryAnalysis::SmtSolver::evidenceForVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evidence of satisfiability for a bitvector variable. </p>
<p>If an expression is satisfiable, this function will return a value for the specified bitvector variable that satisfies the expression in conjunction with the other evidence. Not all SMT solvers can return this information. Returns the null pointer if no evidence is available for the variable. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00617">617</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

<p class="reference">References <a class="el" href="SmtSolver_8h_source.html#l00617">evidenceForVariable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SmtSolver_8h_source.html#l00617">evidenceForVariable()</a>.</p>

</div>
</div>
<a id="a4c5973fcfa05a2babca12c1ed776332d" name="a4c5973fcfa05a2babca12c1ed776332d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5973fcfa05a2babca12c1ed776332d">&#9670;&#160;</a></span>evidenceForVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> Rose::BinaryAnalysis::SmtSolver::evidenceForVariable </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>varno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evidence of satisfiability for a bitvector variable. </p>
<p>If an expression is satisfiable, this function will return a value for the specified bitvector variable that satisfies the expression in conjunction with the other evidence. Not all SMT solvers can return this information. Returns the null pointer if no evidence is available for the variable. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00622">622</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ac0055bb39d27fa2b07f716dd0964de29">evidenceForName()</a>.</p>

</div>
</div>
<a id="a62f037cbc3442782c8220e7009a2266d" name="a62f037cbc3442782c8220e7009a2266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f037cbc3442782c8220e7009a2266d">&#9670;&#160;</a></span>evidenceForAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> Rose::BinaryAnalysis::SmtSolver::evidenceForAddress </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evidence of satisfiability for a memory address. </p>
<p>If an expression is satisfiable, this function will return a value for the specified memory address that satisfies the expression in conjunction with the other evidence. Not all SMT solvers can return this information. Returns the null pointer if no evidence is available for the memory address. </p>

</div>
</div>
<a id="a014757478748210d539221266ffead60" name="a014757478748210d539221266ffead60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014757478748210d539221266ffead60">&#9670;&#160;</a></span>statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a> &amp; Rose::BinaryAnalysis::SmtSolver::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Statistics for this solver. </p>
<p>The statistics are not reset by this call, but continue to accumulate. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00645">645</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a5603a0892f36a210700ebbf5b8b35cc8" name="a5603a0892f36a210700ebbf5b8b35cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603a0892f36a210700ebbf5b8b35cc8">&#9670;&#160;</a></span>classStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a> Rose::BinaryAnalysis::SmtSolver::classStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Statistics across all solvers. </p>
<p>The class statistics are updated whenever a solver is destroyed or its <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a3f4ac7922bd68b344119f68d7be9ef66">resetStatistics</a> method is invoked. However, the nSolversCreated member is updated as soon as a solver is created.</p>
<p>The statistics are not reset by this call, but continue to accumulate. </p>

</div>
</div>
<a id="a0cb9fd83a5f015728aac73b76bde9be1" name="a0cb9fd83a5f015728aac73b76bde9be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb9fd83a5f015728aac73b76bde9be1">&#9670;&#160;</a></span>resetClassStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::SmtSolver::resetClassStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets statistics for the class. </p>
<p>Statistics are reset to initial values for the class as a whole. Resetting statistics for the class does not affect statistics of any particular SMT solver object. </p>

</div>
</div>
<a id="ad0f9fb629030d0162c39b2f0d088e97d" name="ad0f9fb629030d0162c39b2f0d088e97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f9fb629030d0162c39b2f0d088e97d">&#9670;&#160;</a></span>progress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> Rose::BinaryAnalysis::SmtSolver::progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> reporting object. </p>
<p>If non-null, certain types of actions are reported to this progress object by pushing subtask progress objects. </p>

</div>
</div>
<a id="af8ea4b1e3f18a12b3797c32d03f502bb" name="af8ea4b1e3f18a12b3797c32d03f502bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ea4b1e3f18a12b3797c32d03f502bb">&#9670;&#160;</a></span>progress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SmtSolver::progress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>progress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1Progress.html" title="A general, thread-safe way to report progress made on some task.">Progress</a> reporting object. </p>
<p>If non-null, certain types of actions are reported to this progress object by pushing subtask progress objects. </p>

</div>
</div>
<a id="a2eae11114696b2314db156cb9c6d95ac" name="a2eae11114696b2314db156cb9c6d95ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae11114696b2314db156cb9c6d95ac">&#9670;&#160;</a></span>generateFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::generateFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname"><em>exprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad9c19ddb335c583f0fd967bb39f9f623">Definitions</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an input file for for the solver. </p>
<p>Usually the input file will be SMT-LIB format, but subclasses might override this to generate some other kind of input. Throws Excecption if the solver does not support an operation that is necessary to determine the satisfiability.</p>
<p>This function is also useful for debugging because it will convert ROSE's symbolic expressions to whatever format is used by the SMT solver. </p>

</div>
</div>
<a id="a844e9d76d7fa5d86b3fd3202bc719345" name="a844e9d76d7fa5d86b3fd3202bc719345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844e9d76d7fa5d86b3fd3202bc719345">&#9670;&#160;</a></span>checkLib()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a807e813a7a89a77142a200b6621f7ee1">Satisfiable</a> Rose::BinaryAnalysis::SmtSolver::checkLib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check satisfiability using a library API. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#a63cf368e8fc18922e53d2ca0fcb67ac2">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="ae5240996e1a152d5cd49189e6df1837b" name="ae5240996e1a152d5cd49189e6df1837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5240996e1a152d5cd49189e6df1837b">&#9670;&#160;</a></span>getErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::SmtSolver::getErrorMessage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exitStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error message from running a solver executable. </p>
<p>Given the solver exit status and (implicitly) the output of the solver, either return an error message or the empty string. This can be overridden by subclasses because some solvers exit with non-zero status if you try to get the model when (check-sat) returns not-satisfiable. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#a97012169ed9d846d642cd2e725ce4e0a">Rose::BinaryAnalysis::SmtlibSolver</a>.</p>

</div>
</div>
<a id="ab04e7dba9f62d6dc53b41c3290572f59" name="ab04e7dba9f62d6dc53b41c3290572f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04e7dba9f62d6dc53b41c3290572f59">&#9670;&#160;</a></span>findVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::findVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">SymbolicExpression::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ab8b4e71a51043fe53e63b375330a1f6f">VariableSet</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all variables that need declarations. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#a53a7d36faa6f63753b9443ab5ba6aaf0">Rose::BinaryAnalysis::SmtlibSolver</a>.</p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00703">703</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a510ac449b4e13a912afc0f587bf9b9b6" name="a510ac449b4e13a912afc0f587bf9b9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ac449b4e13a912afc0f587bf9b9b6">&#9670;&#160;</a></span>printSExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::SmtSolver::printSExpression </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an S-Expr for debugging. </p>
<p>A null pointer is printed as "nil" and an empty list is printed as "()" in order to distinguish the two cases. There should be no null pointers though in well-formed S-Exprs. </p>

</div>
</div>
<a id="a290d9506719093a1ddb7ca790efb954a" name="a290d9506719093a1ddb7ca790efb954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290d9506719093a1ddb7ca790efb954a">&#9670;&#160;</a></span>getCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::SmtSolver::getCommand </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the name of a configuration file, return the command that is needed to run the solver. </p>
<p>The first line of stdout emitted by the solver should be the word "sat" or "unsat". </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#a4940be8e378f5e7d8b088772c4d015d3">Rose::BinaryAnalysis::SmtlibSolver</a>.</p>

</div>
</div>
<a id="a7683121f57c08b880b41aa4a956247f7" name="a7683121f57c08b880b41aa4a956247f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7683121f57c08b880b41aa4a956247f7">&#9670;&#160;</a></span>parseEvidence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::parseEvidence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses evidence of satisfiability. </p>
<p>Some solvers can emit information about what variable bindings satisfy the expression. This information is parsed by this function and added to a mapping of variable to value. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtlibSolver.html#ae74ded94a4175d779d3d09d8ce4c621c">Rose::BinaryAnalysis::SmtlibSolver</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#a2ddca2dca8e534b5bed16c045999c75d">Rose::BinaryAnalysis::Z3Solver</a>.</p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00720">720</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a72f39b867855d062ea47afcb5597ea32" name="a72f39b867855d062ea47afcb5597ea32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f39b867855d062ea47afcb5597ea32">&#9670;&#160;</a></span>normalizeVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> Rose::BinaryAnalysis::SmtSolver::normalizeVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">SymbolicExpression::ExprExprHashMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize expressions by renaming variables. </p>
<p>This is used during memoization to rename all the variables. It performs a depth-first search and renames each variable it encounters. The variables are renumbered starting at zero. The return value is a vector new new expressions, some of which may be the unmodified original expressions if there were no variables. The <code>index</code> is also a return value which indicates how original variables were mapped to new variables. </p>

</div>
</div>
<a id="a5fd9c026630017eb67676b7483bbd488" name="a5fd9c026630017eb67676b7483bbd488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd9c026630017eb67676b7483bbd488">&#9670;&#160;</a></span>undoNormalization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> Rose::BinaryAnalysis::SmtSolver::undoNormalization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a0a5acec3c7ca24097f71ffcabc8d376d">ExprList</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">SymbolicExpression::ExprExprHashMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Undo the normalizations that were performed earlier. </p>
<p>Each of the specified expressions are rewritten by undoing the variable renaming that was done by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a72f39b867855d062ea47afcb5597ea32">normalizeVariables</a>. The <code>index</code> is the same index as returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a72f39b867855d062ea47afcb5597ea32">normalizeVariables</a>, although the input expressions need not be those same expressions. For each input expression, the expression is rewritten by substituting the inverse of the index. That is, a depth first search is performed on the expression and if the subexpression matches a value of the index, then it's replaced by the corresponding key. </p>

</div>
</div>
<a id="ad81e240d87af8eddd013ab9642b88457" name="ad81e240d87af8eddd013ab9642b88457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81e240d87af8eddd013ab9642b88457">&#9670;&#160;</a></span>selfTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SmtSolver::selfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit tests. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Z3Solver.html#a20704f2a989d7c0d18300380d6928187">Rose::BinaryAnalysis::Z3Solver</a>.</p>

</div>
</div>
<a id="ab2da45f24089272d6da39e98f536abc5" name="ab2da45f24089272d6da39e98f536abc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2da45f24089272d6da39e98f536abc5">&#9670;&#160;</a></span>initDiagnostics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::SmtSolver::initDiagnostics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize diagnostic output facilities. </p>
<p>Called when the ROSE library is initialized. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a900e9e820b53c678943cd3805f63010a" name="a900e9e820b53c678943cd3805f63010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900e9e820b53c678943cd3805f63010a">&#9670;&#160;</a></span>linkage_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a780a2c523850a54f01939334bbab8a34">LinkMode</a> Rose::BinaryAnalysis::SmtSolver::linkage_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00312">312</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="aca97eed5551b49b5f1d079e4e1cbac38" name="aca97eed5551b49b5f1d079e4e1cbac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca97eed5551b49b5f1d079e4e1cbac38">&#9670;&#160;</a></span>outputText_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::SmtSolver::outputText_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional output obtained by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#a60141955e19cd1f16dd7eadec44a4266" title="Determines if the specified expressions are all satisfiable, unsatisfiable, or unknown.">satisfiable()</a>. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00313">313</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="af7d87db0c975550aacbff88593e22d92" name="af7d87db0c975550aacbff88593e22d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d87db0c975550aacbff88593e22d92">&#9670;&#160;</a></span>parsedOutput_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSawyer_1_1SharedPointer.html">SExpr::Ptr</a>&gt; Rose::BinaryAnalysis::SmtSolver::parsedOutput_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00314">314</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a3ffaeab9833cc0ea00118ef183a9fdd3" name="a3ffaeab9833cc0ea00118ef183a9fdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffaeab9833cc0ea00118ef183a9fdd3">&#9670;&#160;</a></span>evidence_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver.html#ad42b6c0684322672d59b936336b0b643">ExprExprMap</a> Rose::BinaryAnalysis::SmtSolver::evidence_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00315">315</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a916d98436fb95b93980e4b43fe5ad14a" name="a916d98436fb95b93980e4b43fe5ad14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916d98436fb95b93980e4b43fe5ad14a">&#9670;&#160;</a></span>termNames_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1Map.html">TermNames</a> Rose::BinaryAnalysis::SmtSolver::termNames_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00316">316</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a0bd72bbb76f667a99620f9875206d05f" name="a0bd72bbb76f667a99620f9875206d05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd72bbb76f667a99620f9875206d05f">&#9670;&#160;</a></span>memoizer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Memoizer.html#a3ba955525874a6733bdb2457c6cc89c7">Memoizer::Ptr</a> Rose::BinaryAnalysis::SmtSolver::memoizer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00317">317</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a924e4fe511880a63357050d4057e6f34" name="a924e4fe511880a63357050d4057e6f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924e4fe511880a63357050d4057e6f34">&#9670;&#160;</a></span>progress_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> Rose::BinaryAnalysis::SmtSolver::progress_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00318">318</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a3c72546087c31de016739042c6f40b10" name="a3c72546087c31de016739042c6f40b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c72546087c31de016739042c6f40b10">&#9670;&#160;</a></span>classStatsMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex Rose::BinaryAnalysis::SmtSolver::classStatsMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00321">321</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a5a03c7c76744fc65067b85bc6af6bc27" name="a5a03c7c76744fc65067b85bc6af6bc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a03c7c76744fc65067b85bc6af6bc27">&#9670;&#160;</a></span>classStats</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a> Rose::BinaryAnalysis::SmtSolver::classStats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00322">322</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="a7f08e17df2557384eef889724aa6acfd" name="a7f08e17df2557384eef889724aa6acfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f08e17df2557384eef889724aa6acfd">&#9670;&#160;</a></span>stats</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRose_1_1BinaryAnalysis_1_1SmtSolver_1_1Stats.html">Stats</a> Rose::BinaryAnalysis::SmtSolver::stats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00323">323</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<a id="af0563f562e3525422d8a3563dd4bfa2d" name="af0563f562e3525422d8a3563dd4bfa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0563f562e3525422d8a3563dd4bfa2d">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Rose::BinaryAnalysis::SmtSolver::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagnostic facility. </p>

<p class="definition">Definition at line <a class="el" href="SmtSolver_8h_source.html#l00327">327</a> of file <a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SmtSolver_8h_source.html">SmtSolver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
