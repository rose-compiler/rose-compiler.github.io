<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::PointerDetection Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1PointerDetection.html">PointerDetection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::PointerDetection Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Pointer detection analysis. </p>
<p>This analysis attempts to discover which memory addresses store pointer variables and whether those pointer variables point to code or data. The goal is to detect the storage location of things like "arg1", "arg2", and "var2" in the following C code after it is compiled into a binary:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">int</span> f1(<span class="keywordtype">bool</span> (*arg1)(), <span class="keywordtype">int</span> *arg2) {</div>
<div class="line">     <span class="keywordtype">int</span> *var2 = arg2;</div>
<div class="line">     <span class="keywordflow">return</span> arg1() ? 1 : *var2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Depending on how the binary is compiled (e.g., which compiler optimizations where applied), it may or may not be possible to detect all the pointer variables. On the other hand, the compiler may generate temporary pointers that don't exist in the source code. Since binary files have no explicit type information (except perhaps in debug tables upon which we don't want to depend), we have to discover that something is a pointer by how it's used. The property that distinguishes data pointers from non-pointers is that they're used as addresses when reading from or writing to memory.</p>
<h1><a class="anchor" id="binary_ptrdetect_algo"></a>
Algorithm</h1>
<p>The algorithm works by performing a data-flow analysis in the symbolic domain with each CFG vertex also keeping track of which memory locations are read. When the data-flow step completes, the algorithm scans all memory locations (across all CFG vertices) to get a list of addresses. Each address expression includes a list of all instructions that were used to define the address. For instance, given this simpler code:</p>
<div class="fragment"><div class="line">; <span class="keywordtype">int</span> deref(<span class="keywordtype">int</span> *ptr, <span class="keywordtype">int</span> index) { <span class="keywordflow">return</span> ptr[index]; }</div>
<div class="line">L0: push ebp</div>
<div class="line">L1: mov ebp, esp</div>
<div class="line">L3: mov eax, [ebp+8]</div>
<div class="line">L6: mov ecx, [ebp+12]</div>
<div class="line">L9: mov eax, [eax + ecx*4]</div>
<div class="line">Lc: leave</div>
<div class="line">Ld: ret</div>
</div><!-- fragment --><p>L9 reads from memory address <code>eax + ecx * 4</code>, and that address was calculated by previous instructions:</p>
<ul>
<li>L3 read a value from the stack, therefore L3 is a definer of EAX's value before L9 </li>
<li>L6 read a value from the stack, therefore L6 is a definer of ECX's value before L9 </li>
<li>L9 performed arithmetic on EAX and ECX, the result of which is defined by L3, L6, and L9.</li>
</ul>
<p>Other addresses in addition to the one read by L9 are:</p>
<ul>
<li>The return address stored at the top of the initial stack used by the <code>RET</code> instruction. Defined by L0 and Lc. </li>
<li>The location of the first program argument, defined by L0 and L3. </li>
<li>The location of the second program argument, defined by L0 and L6. </li>
<li>The location of the saved EBP, defined by L0.</li>
</ul>
<p>A second step (not requiring a second data-flow, but using information gathered by the first data flow), looks at addresses that were read by instructions that defined an address. For instance, L3, L6, and L9 are the instructions that defined the address used by L9, and all three of them read some memory:</p>
<ul>
<li>L3 read the first argument starting at four bytes past the original ESP. </li>
<li>L6 read the second argument starting at eight bytes past the original ESP. </li>
<li>L9 read an element of the array.</li>
</ul>
<p>Since L9 reads from the same address whose definers we are processing, we discard the information from L9, keeping only the two reads from L3 and L6. Both of these reads match the width of the stack pointer, therefore we keep both (this is an optional setting for this analysis) and the analysis deems them "addressses of data pointers". Incidentally, the width of the stack pointer is used as the width of data pointers, and the width of the instruction pointer is used as the width of code pointers. The result is that eight bytes on the stack are deemed addresses of data pointers. They are:</p>
<div class="fragment"><div class="line">(add[32] esp_0[32] 0x00000004[32])</div>
<div class="line">(add[32] esp_0[32] 0x00000005[32])</div>
<div class="line">(add[32] esp_0[32] 0x00000006[32])</div>
<div class="line">(add[32] esp_0[32] 0x00000007[32])</div>
<div class="line">(add[32] esp_0[32] 0x00000008[32])</div>
<div class="line">(add[32] esp_0[32] 0x00000009[32])</div>
<div class="line">(add[32] esp_0[32] 0x0000000a[32])</div>
<div class="line">(add[32] esp_0[32] 0x0000000b[32])</div>
</div><!-- fragment --><p>An astute observer will notice that the algorithm has detected that both "ptr" and "index" are detected as pointers. Although they are not "pointers" per se in the C language, they are indeed both pointers by some definition of assembly language: they're both used as indexes into a global memory address space.</p>
<p>The analysis also detects other pointers that are not evident from the C source code: EBP's stored location just below the original top-of-stack is a pointer, and the return address stored at the top of the stack is a pointer.</p>
<h1><a class="anchor" id="binary_ptrdetect_usage"></a>
Usage</h1>
<p>Like most binary analysis functionality, binary pointer detection is encapsulated in its own namespace. The main class, <a class="el" href="classAnalysis.html">Analysis</a>, performs most of the work. A user instantiates an analysis object giving it a certain configuration at the same time. He then invokes one of its analysis methods, such <a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Analysis.html#a13e7fe87888af986e0791531288e535d">Analysis::analyzeFunction</a>, one or more times and queries the results after each analysis. The results are returned as symbolic address expressions relative to some initial state.</p>
<p>The "testPointerDetection.C" tester has an example use case:</p>
<div class="fragment"></div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Analysis.html">Analysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer analysis.  <a href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Analysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1PointerDescriptor.html">PointerDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of one pointer.  <a href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1PointerDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Settings.html" title="Settings to control the pointer analysis.">Settings</a> to control the pointer analysis.  <a href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4eb9a9d830f3c946fbb36504c684bc0b" id="r_a4eb9a9d830f3c946fbb36504c684bc0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1PointerDetection.html#a4eb9a9d830f3c946fbb36504c684bc0b">PointerDescriptors</a> = std::list&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1PointerDescriptor.html">PointerDescriptor</a> &gt;</td></tr>
<tr class="memdesc:a4eb9a9d830f3c946fbb36504c684bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of pointers.  <br /></td></tr>
<tr class="separator:a4eb9a9d830f3c946fbb36504c684bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ae5ff85ab6d3d040d8ed7227d8bbc28" id="r_a6ae5ff85ab6d3d040d8ed7227d8bbc28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1PointerDetection.html#a6ae5ff85ab6d3d040d8ed7227d8bbc28">initDiagnostics</a> ()</td></tr>
<tr class="memdesc:a6ae5ff85ab6d3d040d8ed7227d8bbc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostics.  <br /></td></tr>
<tr class="separator:a6ae5ff85ab6d3d040d8ed7227d8bbc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae8d301d917a1f1635c732ad94559d9ef" id="r_ae8d301d917a1f1635c732ad94559d9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1PointerDetection.html#ae8d301d917a1f1635c732ad94559d9ef">mlog</a></td></tr>
<tr class="memdesc:ae8d301d917a1f1635c732ad94559d9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facility for diagnostic output.  <br /></td></tr>
<tr class="separator:ae8d301d917a1f1635c732ad94559d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4eb9a9d830f3c946fbb36504c684bc0b" name="a4eb9a9d830f3c946fbb36504c684bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb9a9d830f3c946fbb36504c684bc0b">&#9670;&#160;</a></span>PointerDescriptors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1PointerDetection.html#a4eb9a9d830f3c946fbb36504c684bc0b">Rose::BinaryAnalysis::PointerDetection::PointerDescriptors</a> = typedef std::list&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1PointerDetection_1_1PointerDescriptor.html">PointerDescriptor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of pointers. </p>

<p class="definition">Definition at line <a class="el" href="PointerDetection_8h_source.html#l00217">217</a> of file <a class="el" href="PointerDetection_8h_source.html">PointerDetection.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ae5ff85ab6d3d040d8ed7227d8bbc28" name="a6ae5ff85ab6d3d040d8ed7227d8bbc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae5ff85ab6d3d040d8ed7227d8bbc28">&#9670;&#160;</a></span>initDiagnostics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::PointerDetection::initDiagnostics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize diagnostics. </p>
<p>This is normally called as part of ROSE's diagnostics initialization, but it doesn't hurt to call it often. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae8d301d917a1f1635c732ad94559d9ef" name="ae8d301d917a1f1635c732ad94559d9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d301d917a1f1635c732ad94559d9ef">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Rose::BinaryAnalysis::PointerDetection::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Facility for diagnostic output. </p>
<p>The facility can be controlled directly or via ROSE's command-line. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
