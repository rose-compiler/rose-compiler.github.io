<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Binary analysis tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Binary analysis tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Getting started guide for binary analysis.</p>
<h1><a class="anchor" id="bintut_why"></a>
Why binary analysis?</h1>
<p>ROSE was originally designed as a source-to-source analysis and transformation system, but it turns out that parsing and analyzing a binary specimen shares many of the same basic ideas:</p>
<ul>
<li>A binary specimen usually lives in a container that describes areas of memory, symbols, and other things needed when the specimen is executed or linked. These various containers (executables, libraries, object files, core dumps) can be parsed by a ROSE frontend and result in an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) much like parsing of source code.</li>
</ul>
<ul>
<li>The machine instructions of a binary specimen can be parsed an have semantics similar to statements in a source language. They also result in abstract syntax trees.</li>
</ul>
<ul>
<li>Data areas in the specimen can be parsed and are similar to initialized data in a source language. These also become abstract syntax trees.</li>
</ul>
<ul>
<li>Analysis can be performed on an intermediate representation (IR) for both binaries and source code. One such intermediate representation is the abstract syntax tree.</li>
</ul>
<ul>
<li>Transformations modify the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> and the resulting <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> can be "unparsed" to create a new binary specimen, much like unparsing transformed source code results in a new implementation.</li>
</ul>
<p>Of course there are also many differences between source code and binary specimens, but ROSE is situated in the unique position of being able to process both. On the one hand, it can operate on a specimen for which no source code is available, and on the other it can perform analysis and transformations where both source and binary are available at once.</p>
<h1><a class="anchor" id="bintut_features"></a>
What binary analysis features are available?</h1>
<p>ROSE can parse a variety of binary inputs. It can parse executable formats such as Linux ELF executables, shared libraries, core dumps, object files, and library archives; and Microsoft Windows PE and DOS executables and libraries. It can parse memory initialization formats such as Motorola S-Records, Intel HEX files, and raw memory dumps. It can analyze running or paused programs on Linux. ROSE can also analyze combinations of these formats&amp;emdash;such as an ELF file extended by providing additional initialized memory from an S-Record file&amp;emdash;and has a mini command-line language for specifying this for all binary analysis tools.</p>
<p>The ROSE disassembler uses a hybrid linear sweep and recursive descent approach that handles things like overlapping instructions (on architectures where that's possible), interleaved functions, rewritten execution flow, and more. ROSE has instruction decoders for ARM, AMD64 (x86_64), Intel x86, MIPS, Motorola 68k, and PowerPC (32- and 64-bit). ROSE is designed so that most analysis is architecture independent.</p>
<p>ROSE understands semantics for common subsets of AMD64, Intel x86, Motorola 68k, and PowerPC (32- and 64-bit) and can therefore reason about how execution of instructions affects a machine's state. It can perform this reasoning symbolically, using only concrete values, using sets of intervals of concrete values, and many more special-purpose domains. If an Satisfiability Modulo Theory (SMT) solver is available, ROSE can use it to increase the fidelity of its analyses, including reasoning that's employed during the disassembly phase.</p>
<p>ROSE is able to construct control flow graphs and call graphs and has a number of pre-built analysis capabilities such as tainted flow analysis, edit distances, code statistics, memory maps, reasoning about register interactions, address usage maps, execution paths and their feasibility, generic inlining and interprocedural data-flow, no-op sequence detection, opaque predicate detection, algorithmic CFG rewriting, calling convention detection, function may-return analysis, address labeling passes, thunk detection and manipulating, switch statement analysis, interrupt vector processing, overlapping instructions, cross referencing, function stack delta analysis, register and memory usage analysis, magic numbers, static and dynamic string decoding, control flow dominance, pointer detection, DWARF parsing, library identification, etc.</p>
<p>Analysis results are available in a number of formats, depending on the analysis: through various APIs, decoration of the abstract syntax tree or control flow graph, commentary in assembly listings, databases, or to a certain extent as a new translated binary specimen.</p>
<p>This document only attempts to describe a few of the easiest features to get you started.</p>
<h1><a class="anchor" id="bintut_config"></a>
Installing and confguring ROSE for binary analysis</h1>
<p>The binary analysis features have a large number of software dependencies beyond what the source-to-source side of ROSE uses, but fortunately all of them are optional. If a software dependency is not available then the analysis that uses it is simply not available. In a few cases cases the analysis can use a different dependency or a slower or less accurate implementation. See installation for instructions on how to install ROSE. ROSE must be configured with "binaries" being one of the "--enable-languages" values.</p>
<h1><a class="anchor" id="bintut_helloworld"></a>
Hello, World!</h1>
<p>Every system needs a basic "Hello, World!" example, so here's that example for binary analysis within the ROSE framework. It parses a specimen from a variety of formats (see its "--help" output), then disassembles the instructions optionally using instruction semantics to help drive the disassembly, then partitions the instructions into functional units, and finally displays an assembly listing.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
</div><!-- fragment --><p>All programs start by including the main ROSE include file that declares most things that are common to source and binary analysis. This must be the first ROSE header to be included.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;AsmUnparser.h&gt;</span></div>
</div><!-- fragment --><p>ROSE's binary components are declared in individual header files that can only be included after including "rose.h". The binary headers themselves can be included in any order (after rose.h) since each header includes those other headers on which it depends. The binary analysis headers usually have the same names as the primary class they contain.</p>
<div class="fragment"><div class="line">    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line">    std::string purpose = <span class="stringliteral">&quot;disassembles a binary specimen&quot;</span>;</div>
<div class="line">    std::string description =</div>
<div class="line">        <span class="stringliteral">&quot;This tool disassembles the specified file and presents the results &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;as a pseudo assembly listing, a listing intended for human consumption &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;rather than assembling.  This implementation serves as the \&quot;Hello, &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;World!\&quot; example for binary analysis, so let&#39;s keep it simple!&quot;</span>;</div>
</div><!-- fragment --><p>The binary analysis uses a different command-line processor than most of the rest of ROSE because the command-line options for these tools don't typically interact with a compiler and therefore don't need to parse the host of compiler switches that the source tools need to recognize. This also frees the binary tool's command-line parser to be able to generate Unix man pages on the fly. For instance, if you invoke this tool with "--help" (or just "-h") you should see quite lengthy documentation about how to invoke the tool and what all its switches mean. A tool more advanced than "Hello, World!" can modify the command-line parser.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Rose::BinaryAnalysis::Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Rose::BinaryAnalysis::Partitioner2::EngineBinary::instance</a>();</div>
<div class="line">    <a class="code hl_class" href="classSgAsmBlock.html">SgAsmBlock</a> *gblock = engine-&gt;frontend(argc, argv, purpose, description);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary_html_aef732dc81b83ece242126488f91f1961"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Rose::BinaryAnalysis::Partitioner2::EngineBinary::instance</a></div><div class="ttdeci">static Ptr instance()</div><div class="ttdoc">Allocating constructor.</div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; Engine &gt;</a></div></div>
<div class="ttc" id="aclassSgAsmBlock_html"><div class="ttname"><a href="classSgAsmBlock.html">SgAsmBlock</a></div><div class="ttdoc">Instruction basic block.</div><div class="ttdef"><b>Definition</b> <a href="binaryInstruction_8C_source.html#l40507">binaryInstruction.C:40507</a></div></div>
</div><!-- fragment --><p>ROSE divides disassembly into two phases. Within ROSE, a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Disassembler.html">Disassembler</a> is responsible for parsing the bytes of a single machine instruction and turning them into an abstract syntax tree, while the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a> namespace contains the machinery for driving disassembly. The partitioner partitions the specimen's memory image into parts that are either instructions or data (actually, "partitioner" is a bit of a misnomer since instructions and data can also overlap, although they seldom do in practice).</p>
<p>The <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html" title="Binary function detection.">Partitioner2</a> namespace contains many classes, but <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> are the two most important classes. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Engine</a> is used to drive the disassembly process and create a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>, which holds the results in data structures that have better time complexities than an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> when it comes to most forms of analysis. In this example, we are invoking the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">Engine::frontend</a>, which is similar in nature to ROSE's global ::frontend in that it does everything necessary to make ROSE ready to do analysis: it parses, loads, disassembles, partitions, runs basic analysis, and checks consistency. In the end, it returns an abstract syntax tree (<a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>) instead of a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a>.</p>
<p><a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> nodes in ROSE all begin with the letters "Sg" (from "Sage"). Those nodes that are specific to binary analysis begin with "SgAsm" (from "Sage assembly"). Within source code analysis, source files combine to form a single <a class="el" href="classSgProject.html">SgProject</a> node, and the same is often true with binary analysis also. For specimens that have a container, like Linux ELF and Windows PE files, the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> has two large subtrees: one subtree describes the containers (there may be more than one), and another subtree describes the instructions organized into interpretation subtrees (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>). Interpretations organize instructions into coherent sets, such as the PE32 and DOS subcomponents of a Windows PE file. However not all specimen formats have containers, in which case the <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> is abbreviated and contains only the instructions rooted at a "global block" (<a class="el" href="classSgAsmBlock.html" title="Instruction basic block.">SgAsmBlock</a>).</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html">Rose::BinaryAnalysis::AsmUnparser</a> unparser;</div>
<div class="line">    unparser.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html#a9fa88140b2a5643d73b0f3cc9d795192">unparse</a>(std::cout, gblock);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1AsmUnparser_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html">Rose::BinaryAnalysis::AsmUnparser</a></div><div class="ttdoc">Unparses binary AST into text.</div><div class="ttdef"><b>Definition</b> <a href="AsmUnparser_8h_source.html#l00257">AsmUnparser.h:257</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1AsmUnparser_html_a9fa88140b2a5643d73b0f3cc9d795192"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html#a9fa88140b2a5643d73b0f3cc9d795192">Rose::BinaryAnalysis::AsmUnparser::unparse</a></div><div class="ttdeci">virtual size_t unparse(std::ostream &amp;, SgNode *ast)</div><div class="ttdoc">Unparse part of the AST.</div></div>
</div><!-- fragment --><p>Now that an abstract syntax tree has been created we can "unparse" it. Unparsing in a binary is slightly different than unparsing source code. Binary specimens are usually not transformed like source code, so the unparser for a binary generates a human-readable pseudo-assembly listing instead. We could have also called the global ::backend (same as source code) which would have produced a number of output files including a new executable, but backend only works on <a class="el" href="classSgProject.html" title="This class represents a source project, with a list of SgFile objects and global information about th...">SgProject</a> nodes which might not be present (see above). Note that there are better ways to obtain an unparser, and we'll see them later.</p>
<p>Here's the entire "Hello, World!" program:</p>
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span> </div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span> </div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;AsmUnparser.h&gt;</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span> </div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="keywordtype">int</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span>main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span>    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span>    std::string purpose = <span class="stringliteral">&quot;disassembles a binary specimen&quot;</span>;</div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span>    std::string description =</div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span>        <span class="stringliteral">&quot;This tool disassembles the specified file and presents the results &quot;</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span>        <span class="stringliteral">&quot;as a pseudo assembly listing, a listing intended for human consumption &quot;</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span>        <span class="stringliteral">&quot;rather than assembling.  This implementation serves as the \&quot;Hello, &quot;</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span>        <span class="stringliteral">&quot;World!\&quot; example for binary analysis, so let&#39;s keep it simple!&quot;</span>;</div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span> </div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Rose::BinaryAnalysis::Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Rose::BinaryAnalysis::Partitioner2::EngineBinary::instance</a>();</div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span>    <a class="code hl_class" href="classSgAsmBlock.html">SgAsmBlock</a> *gblock = engine-&gt;frontend(argc, argv, purpose, description);</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span> </div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html">Rose::BinaryAnalysis::AsmUnparser</a> unparser;</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>    unparser.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1AsmUnparser.html#a9fa88140b2a5643d73b0f3cc9d795192">unparse</a>(std::cout, gblock);</div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>}</div>
</div><!-- fragment --><h1><a class="anchor" id="bintut_compile"></a>
Compiling programs that use ROSE</h1>
<p>To compile this program you'll want to use the same compiler, preprocessor switches, compiler switches, and loader switches as are used when compiling ROSE. This is important! Since C++ has no official, documented application binary interface, mixing libraries compiled with different compilers, compiler versions, compiler optimization levels, or even other seemingly benign compiler switches is not guaranteed to work. The easiest way to compile the above example is to change directories to <code>$ROSE_BUILD/tutorial</code>, where $ROSE_BUILD is the top of your build tree, and run <code>make binaryHelloWorld</code>. Similar commands will work for the other examples in this tutorial.</p>
<p>On the other hand, if you've already installed the ROSE library and blown away your build tree, or if you're writing your own programs that use ROSE, you won't be able to leverage ROSE's own build system to compile your program, and you probably have no idea what compiler command was used to compile ROSE. Fear not, ROSE installed a "rose-config.cfg" file that has the information you need, and in a format that can be included directly into GNU make files. See <a class="el" href="group__tooldev.html">Developing ROSE-based tools</a> for an example Makefile.</p>
<h1><a class="anchor" id="bintut_fcfg"></a>
Generating a function control flow graph.</h1>
<p>This example shows how to load a specimen into analysis space and generate a control flow graph for each function. First we include <code>rose.h</code> and then any additional binary analysis header files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Rose/Diagnostics.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/BasicBlock.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/GraphViz.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Sawyer/CommandLine.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* purpose = <span class="stringliteral">&quot;obtains a function control flow graph from a binary specimen&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* description =</div>
<div class="line">    <span class="stringliteral">&quot;This tool disassembles the specified file and generates prints a control flow &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;graph to standard output for each function. It is intended as a demo of how to &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;obtain a function CFG; there are better ways to print graphs.&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a></div><div class="ttdoc">Binary analysis.</div><div class="ttdef"><b>Definition</b> <a href="BinaryTutorial_8dox_source.html#l00004">BinaryTutorial.dox:4</a></div></div>
<div class="ttc" id="anamespaceRose_1_1Diagnostics_html"><div class="ttname"><a href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a></div><div class="ttdoc">Controls diagnostic messages from ROSE.</div><div class="ttdef"><b>Definition</b> <a href="Diagnostics_8h_source.html#l00300">Diagnostics.h:300</a></div></div>
</div><!-- fragment --><p>Then, in the <code>main</code> program, we create a disassembling and partitioning engine and use it to parse the command-line. This allows our tool to easily support the multitude of partitioner settings and container formats. The command-line parser and its documentation is easily customizable for more advanced tools, but the following works fine for this tool:</p>
<div class="fragment"><div class="line">    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line">    std::vector&lt;std::string&gt; specimen = engine-&gt;parseCommandLine(argc, argv, purpose, description).unreachedArgs();</div>
<div class="line">    <span class="keywordflow">if</span> (specimen.empty()) {</div>
<div class="line">        mlog[FATAL] &lt;&lt;<span class="stringliteral">&quot;no binary specimen specified; see --help\n&quot;</span>;</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The "mlog[FATAL]" in the previous code uses ROSE's diagnostics facility, a large set of coordinated streams for different software components and message severity levels, all of which can be controlled from the command-line.</p>
<p>Next, now that the engine is configured and we know the name(s) or resources for the specimen, we can parse the specimen container, load the specimen into memory, disassemble, and discover functions. The results are stored in a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">Partitioner</a> object:</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Partitioner::Ptr</a> partitioner = engine-&gt;partition(specimen);</div>
</div><!-- fragment --><p>Finally, we'll iterate over those functions to create function control flow graphs and print each graph. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a398bf1dd74a7e6f3938eed10cf9f84e9">cfg</a> method returns a const reference to a global control flow graph, which normally serves as the starting point for many analyses. But in this case, we want only the subgraph that represents an individual function, so we copy the global CFG and then remove those vertices and edges that are uninteresting:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Function::Ptr</a> &amp;function : partitioner-&gt;functions()) {</div>
<div class="line">        <span class="comment">// global control flow graph</span></div>
<div class="line">        <a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Partitioner2::ControlFlowGraph</a> cfg = partitioner-&gt;cfg();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Erase all vertices that don&#39;t belong to the function of interest, and their incident edges</span></div>
<div class="line">        Partitioner2::ControlFlowGraph::VertexIterator vi = cfg.vertices().begin();</div>
<div class="line">        <span class="keywordflow">while</span> (vi != cfg.vertices().end()) {</div>
<div class="line">            <span class="keywordflow">if</span> (!vi-&gt;value().isOwningFunction(function)) {</div>
<div class="line">                cfg.eraseVertex(vi++);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                ++vi;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Print the results</span></div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;CFG for &quot;</span> &lt;&lt;function-&gt;printableName() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">                  &lt;&lt;<span class="stringliteral">&quot;  Vertices:\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Partitioner2::ControlFlowGraph::Vertex &amp;v : cfg.vertices())</div>
<div class="line">            std::cout &lt;&lt;<span class="stringliteral">&quot;    &quot;</span> &lt;&lt;partitioner-&gt;vertexName(v) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;  Edges:\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Partitioner2::ControlFlowGraph::Edge &amp;e : cfg.edges())</div>
<div class="line">            std::cout &lt;&lt;<span class="stringliteral">&quot;    &quot;</span> &lt;&lt;partitioner-&gt;edgeName(e) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1Graph_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph&lt; CfgVertex, CfgEdge &gt;</a></div></div>
</div><!-- fragment --><p>In the above code, the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a89ae81db0c94017acd9a2d94c5c41f04">Partitioner2::ControlFlowGraph</a> is a specialization of Sawyer::Graph, which is a generic yet easy-to-use graph implementation with very good time complexity for most operations. So the previous "for" loop has linear time complexity with respect to the total number of vertices and edges.</p>
<p>The <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html">Partitioner2::DataFlow</a> namespace has a <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1DataFlow.html#a87e44ecc99233bf07d131663d4874285">buldDfCfg</a> function that creates a slightly different kind of control flow graph&ndash;one that's more useful for data-flow&ndash;which also permits intra- and inter-procedural analysis based on user criteria.</p>
<p>Here's the entire program:</p>
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span> </div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#include &lt;Rose/Diagnostics.h&gt;</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/BasicBlock.h&gt;</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/GraphViz.h&gt;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="preprocessor">#include &lt;Sawyer/CommandLine.h&gt;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span> </div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* purpose = <span class="stringliteral">&quot;obtains a function control flow graph from a binary specimen&quot;</span>;</div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* description =</div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span>    <span class="stringliteral">&quot;This tool disassembles the specified file and generates prints a control flow &quot;</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span>    <span class="stringliteral">&quot;graph to standard output for each function. It is intended as a demo of how to &quot;</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span>    <span class="stringliteral">&quot;obtain a function CFG; there are better ways to print graphs.&quot;</span>;</div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span> </div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a>;</div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="keywordtype">int</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span>main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span>    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span>    std::vector&lt;std::string&gt; specimen = engine-&gt;parseCommandLine(argc, argv, purpose, description).unreachedArgs();</div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span>    <span class="keywordflow">if</span> (specimen.empty()) {</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>        mlog[FATAL] &lt;&lt;<span class="stringliteral">&quot;no binary specimen specified; see --help\n&quot;</span>;</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>        exit(1);</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span>    }</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>    </div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Partitioner::Ptr</a> partitioner = engine-&gt;partition(specimen);</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span> </div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Function::Ptr</a> &amp;function : partitioner-&gt;functions()) {</div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>        <span class="comment">// global control flow graph</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>        <a class="code hl_class" href="classSawyer_1_1Container_1_1Graph.html">Partitioner2::ControlFlowGraph</a> cfg = partitioner-&gt;cfg();</div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span> </div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>        <span class="comment">// Erase all vertices that don&#39;t belong to the function of interest, and their incident edges</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span>        Partitioner2::ControlFlowGraph::VertexIterator vi = cfg.vertices().begin();</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>        <span class="keywordflow">while</span> (vi != cfg.vertices().end()) {</div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span>            <span class="keywordflow">if</span> (!vi-&gt;value().isOwningFunction(function)) {</div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>                cfg.eraseVertex(vi++);</div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>                ++vi;</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>            }</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>        }</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span> </div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>        <span class="comment">// Print the results</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;CFG for &quot;</span> &lt;&lt;function-&gt;printableName() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>                  &lt;&lt;<span class="stringliteral">&quot;  Vertices:\n&quot;</span>;</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Partitioner2::ControlFlowGraph::Vertex &amp;v : cfg.vertices())</div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>            std::cout &lt;&lt;<span class="stringliteral">&quot;    &quot;</span> &lt;&lt;partitioner-&gt;vertexName(v) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;  Edges:\n&quot;</span>;</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Partitioner2::ControlFlowGraph::Edge &amp;e : cfg.edges())</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span>            std::cout &lt;&lt;<span class="stringliteral">&quot;    &quot;</span> &lt;&lt;partitioner-&gt;edgeName(e) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span>    }</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>}</div>
</div><!-- fragment --><h1><a class="anchor" id="bintut_cg"></a>
Generating a binary function call graph in GraphViz format.</h1>
<p>This example is similar to the <a class="el" href="binary_tutorial.html#bintut_helloworld">Hello, World!</a> example, but demonstrates how to analyze function call information to construct a function call graph (CG) and then emit that graph as a GraphViz file. The output can be converted to a picture with the "dot" command, or visualized interactively with ZGRViewer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Rose/Diagnostics.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/GraphViz.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Sawyer/CommandLine.h&gt;</span></div>
</div><!-- fragment --><p>As before, the "rose.h" header is the first of the ROSE headers to be included, followed by the binary analysis headers in any order.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose.html">Rose</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="ttc" id="anamespaceRose_html"><div class="ttname"><a href="namespaceRose.html">Rose</a></div><div class="ttdoc">The ROSE library.</div><div class="ttdef"><b>Definition</b> <a href="BinaryTutorial_8dox_source.html#l00003">BinaryTutorial.dox:3</a></div></div>
</div><!-- fragment --><p>This time we'll use a few namespaces to reduce our typing. The <a class="el" href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a> namespace brings into scope the diagnostic support (<code>mlog</code> and <code>FATAL</code> in this example) which is accessed through the "--log" command-line switches and controls what kinds of diagnostic output is produced. If you run this program with "--log=all" you'll get traces and debugging from all the ROSE components that use this mechanism (lots of output); see "--log=help" for info about fine tuning this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Settings {</div>
<div class="line">    std::string outputName;</div>
<div class="line"> </div>
<div class="line">    Settings()</div>
<div class="line">        : outputName(<span class="stringliteral">&quot;cg.dot&quot;</span>) {}</div>
<div class="line">};</div>
</div><!-- fragment --><p>Many of the binary analysis tools find that holding all command-line settings in a single struct is a convenient way to organize things. This example only has one tool-specific setting&ndash;the name of the output file for the call graph.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> std::vector&lt;std::string&gt;</div>
<div class="line">parseCommandLine(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a> &amp;engine, Settings &amp;settings) {</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceSawyer_1_1CommandLine.html">Sawyer::CommandLine</a>;</div>
<div class="line"> </div>
<div class="line">    std::string purpose = <span class="stringliteral">&quot;obtains a function call graph from a binary specimen&quot;</span>;</div>
<div class="line">    std::string description =</div>
<div class="line">        <span class="stringliteral">&quot;This tool disassembles the specified file and generates a function call &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;graph named \&quot;cg.dot\&quot; in the current working directory.  The dot file &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;can be processed with GraphViz commands or viewed directly with ZGRViewer.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser = engine.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a>(purpose, description);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> tool(<span class="stringliteral">&quot;Tool switches&quot;</span>);</div>
<div class="line">    tool.insert(<a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a>(<span class="stringliteral">&quot;output&quot;</span>, <span class="charliteral">&#39;O&#39;</span>)</div>
<div class="line">                .argument(<span class="stringliteral">&quot;filename&quot;</span>, anyParser(settings.outputName))</div>
<div class="line">                .<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c">doc</a>(<span class="stringliteral">&quot;Specifies the name of the call graph that is generated by &quot;</span></div>
<div class="line">                     <span class="stringliteral">&quot;this tool. The default is \&quot;&quot;</span> +</div>
<div class="line">                     <a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a3aed317913b7f65d80a2c76c5c019c8b">StringUtility::cEscape</a>(settings.outputName) + <span class="stringliteral">&quot;\&quot;&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> parser.<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#a150a5ad8e88776f5ba73df0a6b76a9d9">with</a>(tool).<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">parse</a>(argc, argv).<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b">apply</a>().<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#adbdafd6227ba5292448acf7792adfe90">unreachedArgs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Rose::BinaryAnalysis::Partitioner2::Engine</a></div><div class="ttdoc">Base class for engines driving the partitioner.</div><div class="ttdef"><b>Definition</b> <a href="Partitioner2_2Engine_8h_source.html#l00156">Partitioner2/Engine.h:156</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine_html_a15ec299a2c212759c27c10d848f65172"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">Rose::BinaryAnalysis::Partitioner2::Engine::commandLineParser</a></div><div class="ttdeci">virtual Sawyer::CommandLine::Parser commandLineParser(const std::string &amp;purpose, const std::string &amp;description)</div><div class="ttdoc">Creates a command-line parser.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_a193dc3b5dc738f0db4b69842ca56ba8b"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b">Sawyer::CommandLine::ParserResult::apply</a></div><div class="ttdeci">const ParserResult &amp; apply() const</div><div class="ttdoc">Saves parsed values in switch-specified locations.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1ParserResult_html_adbdafd6227ba5292448acf7792adfe90"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1ParserResult.html#adbdafd6227ba5292448acf7792adfe90">Sawyer::CommandLine::ParserResult::unreachedArgs</a></div><div class="ttdeci">std::vector&lt; std::string &gt; unreachedArgs() const</div><div class="ttdoc">Returns program arguments that were not reached during parsing.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a></div><div class="ttdoc">The parser for a program command line.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02756">Sawyer/CommandLine.h:2756</a></div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html_a150a5ad8e88776f5ba73df0a6b76a9d9"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html#a150a5ad8e88776f5ba73df0a6b76a9d9">Sawyer::CommandLine::Parser::with</a></div><div class="ttdeci">Parser &amp; with(const SwitchGroup &amp;sg)</div><div class="ttdoc">Add switch declarations.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02795">Sawyer/CommandLine.h:2795</a></div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html_acadfcac830d7855ae15b39ef9ce1aebb"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">Sawyer::CommandLine::Parser::parse</a></div><div class="ttdeci">ParserResult parse(int argc, char *argv[])</div><div class="ttdoc">Parse program arguments.</div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1SwitchGroup_html"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">Sawyer::CommandLine::SwitchGroup</a></div><div class="ttdoc">A collection of related switch declarations.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02569">Sawyer/CommandLine.h:2569</a></div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Switch_html"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Switch.html">Sawyer::CommandLine::Switch</a></div><div class="ttdoc">Describes one command-line switch.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02041">Sawyer/CommandLine.h:2041</a></div></div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Switch_html_add85ab50efbd3bd2ddd6f4af81e4412c"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c">Sawyer::CommandLine::Switch::doc</a></div><div class="ttdeci">Switch &amp; doc(const std::string &amp;s)</div><div class="ttdoc">Property: detailed description.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02185">Sawyer/CommandLine.h:2185</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a3aed317913b7f65d80a2c76c5c019c8b"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a3aed317913b7f65d80a2c76c5c019c8b">Rose::StringUtility::cEscape</a></div><div class="ttdeci">ROSE_UTIL_API std::string cEscape(const std::string &amp;, char context='&quot;')</div><div class="ttdoc">Escapes characters that are special to C/C++.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1CommandLine_html"><div class="ttname"><a href="namespaceSawyer_1_1CommandLine.html">Sawyer::CommandLine</a></div><div class="ttdoc">Parses program command line switches and arguments.</div><div class="ttdef"><b>Definition</b> <a href="FeasiblePath_8h_source.html#l00768">FeasiblePath.h:768</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="binary_tutorial.html#bintut_helloworld">Hello, World!</a> example showed the simplest way to parse a command-line, but this time we'll do something a little more complex. This time we want to augment the command-line parser so it knows about the switches that this tool supports. The parser itself comes from the <a href="https://github.com/matzke1/sawyer">Sawyer</a> library, part of which is distributed along with the ROSE source code. We obtain the default parser from the disassembly and partitioning engine, and augment it with a switch group containing the switches specific to this tool. Our "--output" or "-O" switch takes a single argument, a file name that can be any string. The "doc" property is the documentation for our switch and will appear in the Unix man page produced by running with "--help". Finally, we invoke the parser with our additional switch group on the argument list in <code>argv</code>. If the parsing is successful we apply the results to our <code>settings</code> and then return the rest of the command line (probably information about the specimen).</p>
<div class="fragment"><div class="line">    ROSE_INITIALIZE;</div>
<div class="line">    Settings settings;</div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line">    std::vector&lt;std::string&gt; specimen = parseCommandLine(argc, argv, *engine, settings);</div>
<div class="line">    <span class="keywordflow">if</span> (specimen.empty()) {</div>
<div class="line">        mlog[FATAL] &lt;&lt;<span class="stringliteral">&quot;no binary specimen specified; see --help\n&quot;</span>;</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>In the <code>main</code> program we initialize our <code>settings</code> and instantiate a disassembly/partitioning engine, then parse the command-line and get the list of non-switch arguments. If there are none, give the user some help; this is often an indication that the user invoked the command with no arguments at all in order to get an error message that hopefully contains some usage hints.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Partitioner::Ptr</a> partitioner = engine-&gt;partition(specimen);</div>
</div><!-- fragment --><p>Instead of calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">engine.frontend</a>, this time we call <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">engine.partition</a> in order to get access to the partitioning analysis results. No <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a> is created in this case, although we could get one if we wanted by querying the engine for it. The data structures used by the partitioner are much more efficiently tuned for analysis than an <a class="el" href="namespaceRose_1_1AST.html" title="Collection of functionalities performing global operations on the AST.">AST</a>, so we'll stick with the partitioner.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">Partitioner2::FunctionCallGraph</a> callgraph = partitioner-&gt;functionCallGraph(<a class="code hl_enumvalue" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html#adae60b3da31d72d5a31c6314dbbebcc3a0f999cc3c8658bc0be4723fa88925d9e">Partitioner2::AllowParallelEdges::NO</a>);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph</a></div><div class="ttdoc">Function call information.</div><div class="ttdef"><b>Definition</b> <a href="FunctionCallGraph_8h_source.html#l00021">FunctionCallGraph.h:21</a></div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges_html_adae60b3da31d72d5a31c6314dbbebcc3a0f999cc3c8658bc0be4723fa88925d9e"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html#adae60b3da31d72d5a31c6314dbbebcc3a0f999cc3c8658bc0be4723fa88925d9e">Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::NO</a></div><div class="ttdeci">@ NO</div><div class="ttdoc">Enum type for allowing parallel edges.</div><div class="ttdef"><b>Definition</b> <a href="Rose_2BinaryAnalysis_2Partitioner2_2BasicTypes_8h_source.html#l00045">Rose/BinaryAnalysis/Partitioner2/BasicTypes.h:45</a></div></div>
</div><!-- fragment --><p>The partitioner knows how to construct a call graph from its internal data structures. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">FunctionCallGraph</a> class can also be manipulated directly. Now's a good time to point out that many binary analysis data structures use pointers to shared objects. The objects are reference counted and deleted automatically. Classes that are used in this way do not have public constructors, but rather <code>instance</code> methods (and sometimes additional factories as well) that allocate and initialize the object and return a smart pointer. In this example, if we were to delete the <code>partitioner</code> or <code>engine</code> the <code>callgraph</code> would still point to valid functions, which still point to valid instructions, etc.</p>
<div class="fragment"><div class="line">    std::ofstream output(settings.outputName.c_str());</div>
<div class="line">    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CgEmitter.html">Partitioner2::GraphViz::CgEmitter</a> emitter(partitioner, callgraph);</div>
<div class="line">    emitter.emitCallGraph(output);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CgEmitter_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CgEmitter.html">Rose::BinaryAnalysis::Partitioner2::GraphViz::CgEmitter</a></div><div class="ttdoc">Emits a function call graph.</div><div class="ttdef"><b>Definition</b> <a href="GraphViz_8h_source.html#l00799">GraphViz.h:799</a></div></div>
</div><!-- fragment --><p>Finally we can emit the call graph as a GraphViz file. This is done through a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CgEmitter.html">CgEmitter</a> that specializes a more general GraphViz emitter. The emitter API allows you to fine tune the output by adjusting colors and other GraphViz edge and vertex properties.</p>
<p>Here's the full listing. Compile it using the same instructions as for the <a class="el" href="binary_tutorial.html#bintut_helloworld">Hello, World!</a> example.</p>
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span> </div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#include &lt;Rose/Diagnostics.h&gt;</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/GraphViz.h&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="preprocessor">#include &lt;Sawyer/CommandLine.h&gt;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span> </div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose.html">Rose</a>;</div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1Diagnostics.html">Rose::Diagnostics</a>;</div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="keyword">struct </span>Settings {</div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span>    std::string outputName;</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span>    Settings()</div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span>        : outputName(<span class="stringliteral">&quot;cg.dot&quot;</span>) {}</div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span>};</div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span> </div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="keyword">static</span> std::vector&lt;std::string&gt;</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>parseCommandLine(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html">Partitioner2::Engine</a> &amp;engine, Settings &amp;settings) {</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceSawyer_1_1CommandLine.html">Sawyer::CommandLine</a>;</div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span> </div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>    std::string purpose = <span class="stringliteral">&quot;obtains a function call graph from a binary specimen&quot;</span>;</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>    std::string description =</div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span>        <span class="stringliteral">&quot;This tool disassembles the specified file and generates a function call &quot;</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>        <span class="stringliteral">&quot;graph named \&quot;cg.dot\&quot; in the current working directory.  The dot file &quot;</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span>        <span class="stringliteral">&quot;can be processed with GraphViz commands or viewed directly with ZGRViewer.&quot;</span>;</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span> </div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span>    <a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser = engine.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a15ec299a2c212759c27c10d848f65172">commandLineParser</a>(purpose, description);</div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span> </div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>    <a class="code hl_class" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> tool(<span class="stringliteral">&quot;Tool switches&quot;</span>);</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>    tool.insert(<a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a>(<span class="stringliteral">&quot;output&quot;</span>, <span class="charliteral">&#39;O&#39;</span>)</div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>                .argument(<span class="stringliteral">&quot;filename&quot;</span>, <a class="code hl_function" href="group__sawyer__parser__factories.html#gacae2de0691a7091623edbc92bffcc89f">anyParser</a>(<a class="code hl_variable" href="namespaceRosebud.html#af576c5d42b1390aaa97e3101d45fb68c">settings</a>.outputName))</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>                .<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c">doc</a>(<span class="stringliteral">&quot;Specifies the name of the call graph that is generated by &quot;</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span>                     <span class="stringliteral">&quot;this tool. The default is \&quot;&quot;</span> +</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>                     <a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a3aed317913b7f65d80a2c76c5c019c8b">StringUtility::cEscape</a>(<a class="code hl_variable" href="namespaceRosebud.html#af576c5d42b1390aaa97e3101d45fb68c">settings</a>.outputName) + <span class="stringliteral">&quot;\&quot;&quot;</span>));</div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span> </div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>    <span class="keywordflow">return</span> parser.<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#a150a5ad8e88776f5ba73df0a6b76a9d9">with</a>(tool).<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">parse</a>(argc, argv).<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a193dc3b5dc738f0db4b69842ca56ba8b">apply</a>().<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1ParserResult.html#adbdafd6227ba5292448acf7792adfe90">unreachedArgs</a>();</div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>}</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span> </div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="keywordtype">int</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>    ROSE_INITIALIZE;</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>    Settings <a class="code hl_variable" href="namespaceRosebud.html#af576c5d42b1390aaa97e3101d45fb68c">settings</a>;</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>    std::vector&lt;std::string&gt; specimen = parseCommandLine(argc, argv, *engine, settings);</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span>    <span class="keywordflow">if</span> (specimen.empty()) {</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>        <a class="code hl_variable" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a>[<a class="code hl_enumvalue" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">FATAL</a>] &lt;&lt;<span class="stringliteral">&quot;no binary specimen specified; see --help\n&quot;</span>;</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span>        exit(1);</div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span>    }</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>    </div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Partitioner::Ptr</a> partitioner = engine-&gt;partition(specimen);</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span> </div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">Partitioner2::FunctionCallGraph</a> callgraph = partitioner-&gt;functionCallGraph(<a class="code hl_enumvalue" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2_1_1AllowParallelEdges.html#adae60b3da31d72d5a31c6314dbbebcc3a0f999cc3c8658bc0be4723fa88925d9e">Partitioner2::AllowParallelEdges::NO</a>);</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span> </div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span>    std::ofstream output(<a class="code hl_variable" href="namespaceRosebud.html#af576c5d42b1390aaa97e3101d45fb68c">settings</a>.outputName.c_str());</div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1GraphViz_1_1CgEmitter.html">Partitioner2::GraphViz::CgEmitter</a> emitter(partitioner, callgraph);</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>    emitter.emitCallGraph(output);</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>}</div>
<div class="ttc" id="agroup__sawyer__parser__factories_html_gacae2de0691a7091623edbc92bffcc89f"><div class="ttname"><a href="group__sawyer__parser__factories.html#gacae2de0691a7091623edbc92bffcc89f">Sawyer::CommandLine::anyParser</a></div><div class="ttdeci">AnyParser&lt; T &gt;::Ptr anyParser(T &amp;storage)</div><div class="ttdoc">Factory for value parsers.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l01430">Sawyer/CommandLine.h:1430</a></div></div>
<div class="ttc" id="anamespaceRose_1_1Diagnostics_html_a9d9ad83a4fd128e85197e5114e78da6e"><div class="ttname"><a href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">Rose::Diagnostics::mlog</a></div><div class="ttdeci">ROSE_DLL_API Sawyer::Message::Facility mlog</div><div class="ttdoc">Diagnostic facility for the ROSE library as a whole.</div><div class="ttdef"><b>Definition</b> <a href="sageBuilder_8C_source.html#l00058">sageBuilder.C:58</a></div></div>
<div class="ttc" id="anamespaceRosebud_html_af576c5d42b1390aaa97e3101d45fb68c"><div class="ttname"><a href="namespaceRosebud.html#af576c5d42b1390aaa97e3101d45fb68c">Rosebud::settings</a></div><div class="ttdeci">Settings settings</div><div class="ttdoc">Command-line settings for the rosebud tool.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">Sawyer::Message::FATAL</a></div><div class="ttdeci">@ FATAL</div><div class="ttdoc">Messages that indicate an abnormal situation from which the program was unable to recover.</div><div class="ttdef"><b>Definition</b> <a href="Message_8h_source.html#l00337">Message.h:332</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="bintut_strings"></a>
Finding static strings in a binary specimen</h1>
<p>This example parses and disassembles a binary specimen and search for all static strings, similar to the Unix "strings" command. This simple example can be a starting point for a more in depth strings analysis than what's possible with the Unix command.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Architecture/Base.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Disassembler/Base.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/String.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose.html">Rose</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
</div><!-- fragment --><p>Include headers. The "rose.h" must always be before other ROSE headers.</p>
<div class="fragment"><div class="line">    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line">    std::string purpose = <span class="stringliteral">&quot;finds static strings in a binary specimen&quot;</span>;</div>
<div class="line">    std::string description =</div>
<div class="line">        <span class="stringliteral">&quot;This tool disassembles a binary specimen and then scans the &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;read-only parts of memory to find static strings. It looks for &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;C-style NUL-termianted printable ASCII strings, zero-terminated &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;UTF-16 little-endian strings, two-byte little-endian length-encoded &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;ASCII strings, and some other common formats.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line">    std::vector&lt;std::string&gt; specimen =</div>
<div class="line">        engine-&gt;parseCommandLine(argc, argv, purpose, description).unreachedArgs();</div>
</div><!-- fragment --><p>Yet another way to parse a command-line. This time we're trying to avoid calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#a7578d0b2e81c599a3b4749bad2e54fb5">Partitioner2::Engine::frontend</a> because we don't actually need to disassemble or partition anything&ndash;string searching operates on raw memory rather than instructions, so we can save some time.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">MemoryMap::Ptr</a> map = engine-&gt;loadSpecimens(specimen);</div>
<div class="line">    <a class="code hl_enumeration" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> sex = engine-&gt;architecture()-&gt;byteOrder();</div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1ByteOrder_html_a936870e39bbf2fe6afa377992b9eea58"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">Rose::BinaryAnalysis::ByteOrder::Endianness</a></div><div class="ttdeci">Endianness</div><div class="ttdoc">Byte order.</div><div class="ttdef"><b>Definition</b> <a href="ByteOrder_8h_source.html#l00019">ByteOrder.h:19</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#ae4be5fcd45af5fcdfec6df6a416d7d28">engine.loadSpecimens</a> method parses the speicmen container if present (e.g., Linux ELF) and determines how the specimen should be mapped into memory. The result is a <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html">MemoryMap</a> that describes memory segments with addresses, permissions, names, etc. Try inserting a call to <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#ae22e797e2b3e14aef3200b03765917ea">MemoryMap::dump</a> here to get an idea of what it contains.</p>
<p>The byte order will be needed by the string decoder in order to know how to decode the multi-byte length fields. We could have gotten this same information any number of other ways, but this is the most convenient in this situation. Note that knowledge of the byte order depends upon knowledge of the specimen architecture even though we don't actually need to disassemble anything.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html">Strings::StringFinder</a> finder;       <span class="comment">// the string analyzer</span></div>
<div class="line">    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a8a28c7b811290c16ce1d99a74df088c2">settings</a>().<a class="code hl_variable" href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#aedb4cb3310988307164c9f58a3a6e171">minLength</a> = 5;    <span class="comment">// no strings shorter than 5 characters</span></div>
<div class="line">    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a8a28c7b811290c16ce1d99a74df088c2">settings</a>().<a class="code hl_variable" href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#ac82a28477036f2d40551bb206cf65974">maxLength</a> = 8192; <span class="comment">// no strings longer than 8k characters</span></div>
<div class="line">    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a4217b529abba1568dc5901817af6141a">insertCommonEncoders</a>(sex);   <span class="comment">// match common encodings of strings</span></div>
<div class="line">    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#aa36677cf2ed744556875f86db8b69781">find</a>(map-&gt;<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a>(MemoryMap::READABLE).prohibit(MemoryMap::WRITABLE));</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html">Rose::BinaryAnalysis::Strings::StringFinder</a></div><div class="ttdoc">Analysis to find encoded strings.</div><div class="ttdef"><b>Definition</b> <a href="String_8h_source.html#l00806">String.h:806</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_html_a4217b529abba1568dc5901817af6141a"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a4217b529abba1568dc5901817af6141a">Rose::BinaryAnalysis::Strings::StringFinder::insertCommonEncoders</a></div><div class="ttdeci">StringFinder &amp; insertCommonEncoders(ByteOrder::Endianness)</div><div class="ttdoc">Inserts common encodings.</div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_html_a8a28c7b811290c16ce1d99a74df088c2"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a8a28c7b811290c16ce1d99a74df088c2">Rose::BinaryAnalysis::Strings::StringFinder::settings</a></div><div class="ttdeci">const Settings &amp; settings() const</div><div class="ttdoc">Property: Analysis settings often set from a command-line.</div><div class="ttdef"><b>Definition</b> <a href="String_8h_source.html#l00866">String.h:866</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_html_aa36677cf2ed744556875f86db8b69781"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#aa36677cf2ed744556875f86db8b69781">Rose::BinaryAnalysis::Strings::StringFinder::find</a></div><div class="ttdeci">StringFinder &amp; find(const MemoryMap::ConstConstraints &amp;, Sawyer::Container::MatchFlags flags=0)</div><div class="ttdoc">Finds strings by searching memory.</div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1AddressMap_html_a82d01f0d9ff8007d7b88039153c2d52d"><div class="ttname"><a href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">Sawyer::Container::AddressMap::require</a></div><div class="ttdeci">AddressMapConstraints&lt; const AddressMap &gt; require(unsigned x) const</div><div class="ttdoc">Constraint: required access bits.</div><div class="ttdef"><b>Definition</b> <a href="AddressMap_8h_source.html#l01069">AddressMap.h:1069</a></div></div>
<div class="ttc" id="astructRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings_html_ac82a28477036f2d40551bb206cf65974"><div class="ttname"><a href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#ac82a28477036f2d40551bb206cf65974">Rose::BinaryAnalysis::Strings::StringFinder::Settings::maxLength</a></div><div class="ttdeci">size_t maxLength</div><div class="ttdoc">Maximum length of matched strings.</div><div class="ttdef"><b>Definition</b> <a href="String_8h_source.html#l00822">String.h:822</a></div></div>
<div class="ttc" id="astructRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings_html_aedb4cb3310988307164c9f58a3a6e171"><div class="ttname"><a href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#aedb4cb3310988307164c9f58a3a6e171">Rose::BinaryAnalysis::Strings::StringFinder::Settings::minLength</a></div><div class="ttdeci">size_t minLength</div><div class="ttdoc">Minimum length of matched strings.</div><div class="ttdef"><b>Definition</b> <a href="String_8h_source.html#l00816">String.h:816</a></div></div>
</div><!-- fragment --><p>Here we perform the string searching. Most binary analysis algorithms are packaged into a class. The idea is that one instantiates the analyzer, configures it, calls some method to perform the analysis (here it's <a class="el" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#aa36677cf2ed744556875f86db8b69781">find</a>), and then queries the results.</p>
<p>The <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">MemoryMap::require</a> and <a class="el" href="classSawyer_1_1Container_1_1AddressMap.html#a45d2f15072209b954e3c055bcacc2e4f">MemoryMap::prohibit</a> methods are a form of filtering. They're filtering the memory map so that the string analyzer only sees memory that's readable but not writable.</p>
<div class="fragment"><div class="line">    <span class="comment">// Output, or just do &quot;std::cout &lt;&lt;finder&quot; if you&#39;re not picky.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1EncodedString.html">Strings::EncodedString</a> &amp;<span class="keywordtype">string</span> : finder.strings()) {</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;string at &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.address() &lt;&lt;<span class="stringliteral">&quot; for &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.size() &lt;&lt;<span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;encoding: &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.encoder()-&gt;name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;narrow value: \&quot;&quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a3aed317913b7f65d80a2c76c5c019c8b">StringUtility::cEscape</a>(<span class="keywordtype">string</span>.narrow()) &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Strings_1_1EncodedString_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Strings_1_1EncodedString.html">Rose::BinaryAnalysis::Strings::EncodedString</a></div><div class="ttdoc">An encoder plus interval.</div><div class="ttdef"><b>Definition</b> <a href="String_8h_source.html#l00757">String.h:757</a></div></div>
</div><!-- fragment --><p>Generating the output is a matter of iterating over the strings that were found and printing some information. Most analyzer objects also know how to print themselves although those defaults are not always suitable for a polished tool.</p>
<p>Here's the entire program:</p>
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span> </div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Architecture/Base.h&gt;</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Disassembler/Base.h&gt;</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/String.h&gt;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span> </div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span> </div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose.html">Rose</a>;</div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a>;</div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span> </div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="keywordtype">int</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span>main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span>    ROSE_INITIALIZE;                                    <span class="comment">// see Rose::initialize</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span>    std::string purpose = <span class="stringliteral">&quot;finds static strings in a binary specimen&quot;</span>;</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span>    std::string description =</div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span>        <span class="stringliteral">&quot;This tool disassembles a binary specimen and then scans the &quot;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span>        <span class="stringliteral">&quot;read-only parts of memory to find static strings. It looks for &quot;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span>        <span class="stringliteral">&quot;C-style NUL-termianted printable ASCII strings, zero-terminated &quot;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span>        <span class="stringliteral">&quot;UTF-16 little-endian strings, two-byte little-endian length-encoded &quot;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span>        <span class="stringliteral">&quot;ASCII strings, and some other common formats.&quot;</span>;</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span> </div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Partitioner2::Engine::Ptr</a> engine = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1EngineBinary.html#aef732dc81b83ece242126488f91f1961">Partitioner2::EngineBinary::instance</a>();</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>    std::vector&lt;std::string&gt; specimen =</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>        engine-&gt;parseCommandLine(argc, argv, purpose, description).unreachedArgs();</div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span> </div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span>    <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">MemoryMap::Ptr</a> map = engine-&gt;loadSpecimens(specimen);</div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span>    <a class="code hl_enumeration" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> sex = engine-&gt;architecture()-&gt;byteOrder();</div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span> </div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span>    <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html">Strings::StringFinder</a> finder;       <span class="comment">// the string analyzer</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span>    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a8a28c7b811290c16ce1d99a74df088c2">settings</a>().<a class="code hl_variable" href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#aedb4cb3310988307164c9f58a3a6e171">minLength</a> = 5;    <span class="comment">// no strings shorter than 5 characters</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a8a28c7b811290c16ce1d99a74df088c2">settings</a>().<a class="code hl_variable" href="structRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder_1_1Settings.html#ac82a28477036f2d40551bb206cf65974">maxLength</a> = 8192; <span class="comment">// no strings longer than 8k characters</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#a4217b529abba1568dc5901817af6141a">insertCommonEncoders</a>(sex);   <span class="comment">// match common encodings of strings</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>    finder.<a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1StringFinder.html#aa36677cf2ed744556875f86db8b69781">find</a>(map-&gt;<a class="code hl_function" href="classSawyer_1_1Container_1_1AddressMap.html#a82d01f0d9ff8007d7b88039153c2d52d">require</a>(MemoryMap::READABLE).prohibit(MemoryMap::WRITABLE));</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span> </div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>    <span class="comment">// Output, or just do &quot;std::cout &lt;&lt;finder&quot; if you&#39;re not picky.</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Strings_1_1EncodedString.html">Strings::EncodedString</a> &amp;<span class="keywordtype">string</span> : finder.strings()) {</div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;string at &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.address() &lt;&lt;<span class="stringliteral">&quot; for &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.size() &lt;&lt;<span class="stringliteral">&quot; bytes\n&quot;</span>;</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;encoding: &quot;</span> &lt;&lt;<span class="keywordtype">string</span>.encoder()-&gt;name() &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;narrow value: \&quot;&quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a3aed317913b7f65d80a2c76c5c019c8b">StringUtility::cEscape</a>(<span class="keywordtype">string</span>.narrow()) &lt;&lt;<span class="stringliteral">&quot;\&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>    }</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>}</div>
</div><!-- fragment --><h1><a class="anchor" id="bintut_dominators"></a>
Graph dominators and post dominators</h1>
<p>Loosely speaking, the dominator of a vertex of a graph is another vertex that's visited on every path from some starting vertex to the vertex in question. Most of the time, we're interested in an immediate dominator, which is the closest dominator to the vertex in question. A more rigorous definition can be found in Wikipedia, among other places. Post-dominators are similar in that a post dominator of a vertex is some other vertex that's visited on every path from the vertex in question to some ending vertex.</p>
<p>ROSE uses the <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer Graph API</a> for all binary analysis graphs, and <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> has functions for calculating dominators and post-dominators. The following example is a tool that finds the dominator for each vertex in the control flow graph of each function.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *programPurpose = <span class="stringliteral">&quot;prints dominators for all function CFGs&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *programDescription =</div>
<div class="line">    <span class="stringliteral">&quot;The purpose of this tool is to demonstrate how to calculate dominators (and by extension, post-dominators) for all &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;vertices of a function control flow graph (and by extension, any Sawyer graph).  It parses, loads, disassembles, and &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;partitions a binary specimen and then iterates over the functions. For each function, it obtains a function CFG, &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;calculates the immediate dominator for each vertex, and shows the results.&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/BasicBlock.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>P2 = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a>;</div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1Partitioner2_html"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a></div><div class="ttdoc">Binary function detection.</div><div class="ttdef"><b>Definition</b> <a href="Partitioner2_8h_source.html#l00050">Partitioner2.h:50</a></div></div>
</div><!-- fragment --><p>The first step, above, is to include the appropriate declarations. Our convention for writing tools is to describe the tool with a couple of strings that appear at the very top of the source code. These strings are used later in the program to generate the documentation for the "--help" output.</p>
<p>This tool is so simple that everything else is in "main". First we initialize things:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    ROSE_INITIALIZE;</div>
<div class="line">    P2::Engine::Ptr engine = P2::EngineBinary::instance();</div>
<div class="line">    P2::Engine::Settings &amp;settings = engine-&gt;settings();</div>
<div class="line">    settings.partitioner.doingPostAnalysis = <span class="keyword">false</span>;      <span class="comment">// not needed for this tool, and faster without</span></div>
<div class="line">    settings.partitioner.namingSyscalls = <span class="keyword">false</span>;         <span class="comment">// for consistent results w.r.t. the answer file since the system...</span></div>
<div class="line">    settings.partitioner.syscallHeader = <span class="stringliteral">&quot;/dev/null&quot;</span>;    <span class="comment">// ...call mapping comes from run-time files.</span></div>
<div class="line">    std::vector&lt;std::string&gt; specimen = engine-&gt;parseCommandLine(argc, argv, programPurpose, programDescription).unreachedArgs();</div>
<div class="line">    P2::Partitioner::Ptr partitioner = engine-&gt;partition(specimen);</div>
</div><!-- fragment --><p>The <a class="el" href="namespaceRose.html#af33aa6af24a48a55a0664622f9ff27a9">ROSE_INITIALIZE</a> macro is always the first ROSE-related statement and checks that this tool was compiled with header files that are binary compatible with the ROSE library. Then we create a partitioning engine to parse the command-line to get the specimen resources. The specimen is some combination of a ELF or PE file name, raw memory dumps, S-Records, and/or process IDs. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Engine.html#af906e88cbeeebed28dd5f4250f3da920">engine.partition</a> call does all the hard work of parsing containers, loading data into the virtual address space, decoding CPU instructions, and creating basic blocks and functions. It returns a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html">partitioner</a> object that stores all the results, which include a global control flow graph.</p>
<p>Then we iterate over the functions:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (P2::Function::Ptr function : partitioner-&gt;functions()) {</div>
<div class="line">        std::cout &lt;&lt;<span class="stringliteral">&quot;CFG dominators for function &quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a>(function-&gt;address()) &lt;&lt;<span class="stringliteral">&quot;:\n&quot;</span>; <span class="comment">// or function-&gt;printableName()</span></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a1601608fa2856aa31397370b8b5923c4"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a></div><div class="ttdeci">ROSE_UTIL_API std::string addrToString(uint64_t value, size_t nbits=0)</div><div class="ttdoc">Convert a virtual address to a string.</div></div>
</div><!-- fragment --><p>We want to create a function CFG, but all we have from the partitioner is a global CFG. We can use the fact that a function CFG is a subset of the global CFG and therefore create the function CFG by copying the global CFG and removing all vertices and edges that are not part of the function CFG. Although this isn't the most efficient way to create function CFGs in a loop over all functions, it is very simple.</p>
<p>We'll need to know the entry vertex of the function's CFG:</p>
<div class="fragment"><div class="line">        P2::ControlFlowGraph cfg = partitioner-&gt;cfg();</div>
<div class="line">        P2::ControlFlowGraph::VertexIterator entryVertex = cfg.findVertex(partitioner-&gt;findPlaceholder(function-&gt;address())-&gt;id());</div>
</div><!-- fragment --><p>We found the entry vertex in the function CFG by first finding it in the global CFG and then using a feature of <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> graphs, namely, when a graph is copied its vertices and edges have the same IDs as those in the source graph, and we can obtain a vertex pointer (iterator) in constant time if we know its ID. We have to convert the ID to a vertex pointer before removing the non-function vertices because IDs are not stable across erase operations, but iterators are.</p>
<p>Next we erase the non-function vertices and edges:</p>
<div class="fragment"><div class="line">        P2::ControlFlowGraph::VertexIterator vi = cfg.vertices().begin();</div>
<div class="line">        <span class="keywordflow">while</span> (vi != cfg.vertices().end()) {</div>
<div class="line">            <span class="keywordflow">if</span> (!vi-&gt;value().isOwningFunction(function)) { <span class="comment">// a basic block can belong to multiple functions</span></div>
<div class="line">                ASSERT_forbid(vi == entryVertex);</div>
<div class="line">                cfg.eraseVertex(vi++);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                ++vi;</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>This is the simple way to build a function CFG from a global CFG. It's important to use a post-increment in the <code>eraseVertex</code> call. Since we're inside a loop iterating over every function, a more efficient implementation would have created all the function CFGs in a single pass over the global CFG. As of June 2017, ROSE does not have functions for returning function CFGs &ndash; it only has a global CFG &ndash; because there are many details that need to be considered depending on the situation (e.g., function calls and returns are two cases that typically need massaging in a function CFG depending on the purpose of the CFG).</p>
<p>Finally, we get to the real meat of this example: finding the immediate dominator for every vertex in the function CFG given the CFG's entry vertex:</p>
<div class="fragment"><div class="line">        std::vector&lt;P2::ControlFlowGraph::VertexIterator&gt; idoms = <a class="code hl_function" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a9c0daee888eb13edc6593d964b95615b">Sawyer::Container::Algorithm::graphDominators</a>(cfg, entryVertex);</div>
<div class="ttc" id="anamespaceSawyer_1_1Container_1_1Algorithm_html_a9c0daee888eb13edc6593d964b95615b"><div class="ttname"><a href="namespaceSawyer_1_1Container_1_1Algorithm.html#a9c0daee888eb13edc6593d964b95615b">Sawyer::Container::Algorithm::graphDominators</a></div><div class="ttdeci">std::vector&lt; typename GraphTraits&lt; Graph &gt;::VertexIterator &gt; graphDominators(Graph &amp;g, typename GraphTraits&lt; Graph &gt;::VertexIterator root)</div><div class="ttdoc">Find immediate pre-dominators.</div><div class="ttdef"><b>Definition</b> <a href="GraphAlgorithm_8h_source.html#l01362">GraphAlgorithm.h:1362</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a9c0daee888eb13edc6593d964b95615b">graphDominators</a> function can handle any type of <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> graph, thus we could also pass a function call graph or a data-flow graph.</p>
<p>The return value is a vector indexed by vertex ID, whose values point to either the corresponding immediate dominator or the vertex end iterator (not all vertices have an immediate dominator). Using a vector indexed by vertex ID is an idiom used throughout ROSE whenever we need to associated extra data with an existing graph. Since a vertex pointer (iterator) can be converted to a vertex ID in constant time, and indexing into the vector is constant time, we can always find the extra data in constant time. And since vertex IDs are consecutive integers beginning at zero, this is also a space-efficient way to represent data that's present for most, if not all, vertices.</p>
<p>Finally, let us iterate over the results to print them:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;idoms.size(); ++i) {</div>
<div class="line">            std::cout &lt;&lt;<span class="stringliteral">&quot;  function &quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a>(function-&gt;address())</div>
<div class="line">                      &lt;&lt;<span class="stringliteral">&quot; dominator of &quot;</span> &lt;&lt;P2::Partitioner::vertexName(*cfg.findVertex(i))</div>
<div class="line">                      &lt;&lt;<span class="stringliteral">&quot; is &quot;</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (cfg.isValidVertex(idoms[i])) {</div>
<div class="line">                std::cout &lt;&lt;P2::Partitioner::vertexName(*idoms[i]) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt;<span class="stringliteral">&quot;none\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>Since vector indexes are equivalent to vertex IDs, we can obtain a vertex with a constant-time <code>findVertex</code> call and a constant-time iterator dereference. Since this is a CFG from the partitioner (or at least a copy thereof), we can use the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ad939aa0645969e081565ad2414ef9449">vertexName</a> static method to print some info about it. Using the static method (that takes a vertex value) is important; the non-static method (that takes a vertex iterator) will think that we're handing it a pointer to some vertex in the partitioner's own global CFG.</p>
<p>Here's the entire program:</p>
<div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">// Extensive documentation for this program is in the Binary Analysis Tutorial in doxygen.</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">// Do not change the output format -- this tool is also used by tests/nonsmoke/functional/BinaryAnalysis</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span> </div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *programPurpose = <span class="stringliteral">&quot;prints dominators for all function CFGs&quot;</span>;</div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *programDescription =</div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span>    <span class="stringliteral">&quot;The purpose of this tool is to demonstrate how to calculate dominators (and by extension, post-dominators) for all &quot;</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span>    <span class="stringliteral">&quot;vertices of a function control flow graph (and by extension, any Sawyer graph).  It parses, loads, disassembles, and &quot;</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span>    <span class="stringliteral">&quot;partitions a binary specimen and then iterates over the functions. For each function, it obtains a function CFG, &quot;</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span>    <span class="stringliteral">&quot;calculates the immediate dominator for each vertex, and shows the results.&quot;</span>;</div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span> </div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="preprocessor">#include &lt;rose.h&gt;</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/BasicBlock.h&gt;</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/EngineBinary.h&gt;</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="preprocessor">#include &lt;Rose/BinaryAnalysis/Partitioner2/Partitioner.h&gt;</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="preprocessor">#include &lt;Sawyer/GraphAlgorithm.h&gt;</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span> </div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="keyword">namespace </span>P2 = <a class="code hl_namespace" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Rose::BinaryAnalysis::Partitioner2</a>;</div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span> </div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="keywordtype">int</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span>main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span>{</div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span>    ROSE_INITIALIZE;</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span>    P2::Engine::Ptr engine = P2::EngineBinary::instance();</div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span>    P2::Engine::Settings &amp;settings = engine-&gt;settings();</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span>    settings.partitioner.doingPostAnalysis = <span class="keyword">false</span>;      <span class="comment">// not needed for this tool, and faster without</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span>    settings.partitioner.namingSyscalls = <span class="keyword">false</span>;         <span class="comment">// for consistent results w.r.t. the answer file since the system...</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span>    settings.partitioner.syscallHeader = <span class="stringliteral">&quot;/dev/null&quot;</span>;    <span class="comment">// ...call mapping comes from run-time files.</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span>    std::vector&lt;std::string&gt; specimen = engine-&gt;parseCommandLine(argc, argv, programPurpose, programDescription).unreachedArgs();</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span>    P2::Partitioner::Ptr partitioner = engine-&gt;partition(specimen);</div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span> </div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span>    <span class="keywordflow">for</span> (P2::Function::Ptr function : partitioner-&gt;functions()) {</div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span>        std::cout &lt;&lt;<span class="stringliteral">&quot;CFG dominators for function &quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a>(function-&gt;address()) &lt;&lt;<span class="stringliteral">&quot;:\n&quot;</span>; <span class="comment">// or function-&gt;printableName()</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span> </div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span>        P2::ControlFlowGraph cfg = partitioner-&gt;cfg();</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>        P2::ControlFlowGraph::VertexIterator entryVertex = cfg.findVertex(partitioner-&gt;findPlaceholder(function-&gt;address())-&gt;id());</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>        ASSERT_require(cfg.isValidVertex(entryVertex));</div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span> </div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>        P2::ControlFlowGraph::VertexIterator vi = cfg.vertices().begin();</div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>        <span class="keywordflow">while</span> (vi != cfg.vertices().end()) {</div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span>            <span class="keywordflow">if</span> (!vi-&gt;value().isOwningFunction(function)) { <span class="comment">// a basic block can belong to multiple functions</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span>                ASSERT_forbid(vi == entryVertex);</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>                cfg.eraseVertex(vi++);</div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>                ++vi;</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>            }</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span>        }</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span> </div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span>        std::vector&lt;P2::ControlFlowGraph::VertexIterator&gt; idoms = <a class="code hl_function" href="namespaceSawyer_1_1Container_1_1Algorithm.html#a9c0daee888eb13edc6593d964b95615b">Sawyer::Container::Algorithm::graphDominators</a>(cfg, entryVertex);</div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span>        ASSERT_require(idoms.size() == cfg.nVertices());</div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span> </div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;idoms.size(); ++i) {</div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>            std::cout &lt;&lt;<span class="stringliteral">&quot;  function &quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a>(function-&gt;address())</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>                      &lt;&lt;<span class="stringliteral">&quot; dominator of &quot;</span> &lt;&lt;P2::Partitioner::vertexName(*cfg.findVertex(i))</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>                      &lt;&lt;<span class="stringliteral">&quot; is &quot;</span>;</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>            <span class="keywordflow">if</span> (cfg.isValidVertex(idoms[i])) {</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>                std::cout &lt;&lt;P2::Partitioner::vertexName(*idoms[i]) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>                std::cout &lt;&lt;<span class="stringliteral">&quot;none\n&quot;</span>;</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span>            }</div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span>        }</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span>    }</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>}</div>
</div><!-- fragment --><h1><a class="anchor" id="bintut_next"></a>
Next steps</h1>
<p>Most binary analysis capabilities are documented in the <a class="el" href="namespaceRose_1_1BinaryAnalysis.html">Rose::BinaryAnalysis</a> namespace. The test directory, "$ROSE_SOURCE/tests/nonsmoke/functional/roseTests/BinaryTests", also has many examples, some of which are slightly hard to read since there main purpose is to test rather than demonstrate. The "$ROSE_SOURCE/projects/BinaryAnalysisTools" directory (as well as some other project directories) has real programs that use the binary analysis interface. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:08:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
