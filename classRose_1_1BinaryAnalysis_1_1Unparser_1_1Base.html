<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Unparser::Base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Unparser.html">Unparser</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Unparser::Base Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Abstract base class for unparsers. </p>
<p>This defines the interface only. All data that's used during unparsing is provided to each function so that this interface is thread-safe. Only the configuration settings are stored in the unparser itself.</p>
<p>End users generally invoke the high-level output methods, which are provided by non-virtual function operators that are overloaded on the type of object being unparsed.</p>
<p>The high-level function operators each call a corresponding overloaded virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#acdb9073caa554ccf048def31a3cb3552">unparse</a> function that kicks things off by creating an unparse <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object, setting the front parser to the one whose <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#acdb9073caa554ccf048def31a3cb3552">unparse</a> method was called, and invoking an appropriate mid-level "emit" function in that front parser.</p>
<p>Mid-level "emit" functions use a combination of C++ virtual functions and unparser object chaining as described in the documentation for those functions. This permits two ways to override or augment behavior: behavior modification based on architecture (virtual functions) and behavior modification based on a filtering concept to support things like tables and HTML (chaining).</p>
<p>The following code is a starting point for creating your own unparser:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyUnparser: <span class="keyword">public</span> <a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">BinaryAnalysis::Unparser::Base</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">explicit</span> MyUnparser(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BinaryAnalysis::Unparser::Base::Ptr</a> &amp;next)</div>
<div class="line">        : BinaryAnalysis::Unparser::<a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a>(next) {</div>
<div class="line">        ASSERT_not_null(next);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt;MyUnparser&gt;</a> Ptr;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> Ptr instance(<span class="keyword">const</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BinaryAnalysis::Unparser::Base::Ptr</a> &amp;next) { <span class="keywordflow">return</span> Ptr(<span class="keyword">new</span> MyUnparser(next)); }</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BinaryAnalysis::Unparser::Base::Ptr</a> copy()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> Ptr(<span class="keyword">new</span> MyUnparser(nextUnparser()-&gt;copy())); }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code hl_struct" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">BinaryAnalysis::Unparser::Settings</a>&amp; settings()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> nextUnparser()-&gt;settings(); }</div>
<div class="line">    <span class="keyword">virtual</span> BinaryAnalysis::Unparser::Settings&amp; settings()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> nextUnparser()-&gt;settings(); }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// specialized output functions here...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Rose::BinaryAnalysis::Unparser::Base</a></div><div class="ttdoc">Abstract base class for unparsers.</div><div class="ttdef"><b>Definition</b> <a href="Unparser_2Base_8h_source.html#l00413">Unparser/Base.h:413</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; Base &gt;</a></div></div>
<div class="ttc" id="astructRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings_html"><div class="ttname"><a href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Rose::BinaryAnalysis::Unparser::Settings</a></div><div class="ttdoc">Settings that control unparsing.</div><div class="ttdef"><b>Definition</b> <a href="Unparser_2Settings_8h_source.html#l00030">Unparser/Settings.h:30</a></div></div>
</div><!-- fragment --><p>To instantiate this parser from a <code><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner2::Partitioner</a></code> object named <code>partitioner</code>, do this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">BinaryAnalysis::Unparser::Base::Ptr</a> unparser = partitioner-&gt;unparser();</div>
<div class="line">unparser-&gt;settings() = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a5f839d596d20b3af7ae852683f330309">settings</a>.unparser; <span class="comment">// See Rose::BinaryAnalysis::Unparser::Settings for starters</span></div>
<div class="line">unparser = MyUnparser::instance(unparser);</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_html_a5f839d596d20b3af7ae852683f330309"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a5f839d596d20b3af7ae852683f330309">Rose::BinaryAnalysis::Unparser::Base::settings</a></div><div class="ttdeci">virtual const Settings &amp; settings() const =0</div><div class="ttdoc">Property: Settings associated with this unparser.</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00413">413</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Unparser_2Base_8h_source.html">Rose/BinaryAnalysis/Unparser/Base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Unparser::Base:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_inherit__map">
<area shape="rect" title="Abstract base class for unparsers." alt="" coords="207,197,355,237"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Cil.html" title="Unparser for CIL." alt="" coords="403,5,551,45"/>
<area shape="poly" title=" " alt="" coords="296,184,339,120,368,86,401,55,420,43,423,48,404,59,372,89,343,123,300,187"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Jvm.html" title="Unparser for the JVM architecture." alt="" coords="403,69,551,109"/>
<area shape="poly" title=" " alt="" coords="311,186,353,152,401,119,424,107,426,112,404,124,356,156,315,190"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1M68k.html" title="Unparser for Motorola M68k and related instruction sets." alt="" coords="403,133,551,173"/>
<area shape="poly" title=" " alt="" coords="354,191,415,171,416,176,356,196"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Mips.html" title="Unparser for the MIPS instruction set." alt="" coords="403,197,551,237"/>
<area shape="poly" title=" " alt="" coords="368,215,402,215,402,220,368,220"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Null.html" title="Unparser for null architecture." alt="" coords="403,261,551,301"/>
<area shape="poly" title=" " alt="" coords="356,239,416,259,415,264,354,244"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Powerpc.html" title="Unparser for PowerPC instruction sets." alt="" coords="403,325,551,365"/>
<area shape="poly" title=" " alt="" coords="315,244,356,278,404,311,426,323,424,328,401,316,353,282,311,249"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html" title="Unparser for x86 instruction sets." alt="" coords="403,389,551,429"/>
<area shape="poly" title=" " alt="" coords="300,248,343,312,372,345,404,375,423,387,420,392,401,379,368,349,339,315,296,251"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,205,159,230"/>
<area shape="poly" title=" " alt="" coords="172,215,206,215,206,220,172,220"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Unparser::Base:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_coll__map" id="aRose_1_1BinaryAnalysis_1_1Unparser_1_1Base_coll__map">
<area shape="rect" title="Abstract base class for unparsers." alt="" coords="8,79,156,119"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,5,159,31"/>
<area shape="poly" title=" " alt="" coords="85,44,85,78,79,78,79,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae64cd92db064ac760b44b9431f4fa68b" id="r_ae64cd92db064ac760b44b9431f4fa68b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ae64cd92db064ac760b44b9431f4fa68b">Ptr</a></td></tr>
<tr class="separator:ae64cd92db064ac760b44b9431f4fa68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78f92defa780077885532d28f3e210a1" id="r_a78f92defa780077885532d28f3e210a1"><td class="memItemLeft" align="right" valign="top"><a id="a78f92defa780077885532d28f3e210a1" name="a78f92defa780077885532d28f3e210a1"></a>
virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> () const =0</td></tr>
<tr class="separator:a78f92defa780077885532d28f3e210a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb24b5c0c25eb7bae8fa1646f3a358" id="r_adbeb24b5c0c25eb7bae8fa1646f3a358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#adbeb24b5c0c25eb7bae8fa1646f3a358">architecture</a> () const</td></tr>
<tr class="memdesc:adbeb24b5c0c25eb7bae8fa1646f3a358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>.  <br /></td></tr>
<tr class="separator:adbeb24b5c0c25eb7bae8fa1646f3a358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5559a71e7ce520e05c8d635ba4bb857e" id="r_a5559a71e7ce520e05c8d635ba4bb857e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a5559a71e7ce520e05c8d635ba4bb857e">initializeState</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a5559a71e7ce520e05c8d635ba4bb857e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish initializing the unparser state.  <br /></td></tr>
<tr class="separator:a5559a71e7ce520e05c8d635ba4bb857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eb63b5fae5b7253de943d08d677244" id="r_af6eb63b5fae5b7253de943d08d677244"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#af6eb63b5fae5b7253de943d08d677244">updateIntraFunctionArrows</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:af6eb63b5fae5b7253de943d08d677244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate intra-function arrows.  <br /></td></tr>
<tr class="separator:af6eb63b5fae5b7253de943d08d677244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f839d596d20b3af7ae852683f330309" id="r_a5f839d596d20b3af7ae852683f330309"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a5f839d596d20b3af7ae852683f330309">settings</a> () const =0</td></tr>
<tr class="memdesc:a5f839d596d20b3af7ae852683f330309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser.  <br /></td></tr>
<tr class="separator:a5f839d596d20b3af7ae852683f330309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2a96ba8a7a9fc0809846312b373d31" id="r_a0c2a96ba8a7a9fc0809846312b373d31"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a0c2a96ba8a7a9fc0809846312b373d31">settings</a> ()=0</td></tr>
<tr class="memdesc:a0c2a96ba8a7a9fc0809846312b373d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser.  <br /></td></tr>
<tr class="separator:a0c2a96ba8a7a9fc0809846312b373d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c058b7634d007627710945696623d" id="r_a6d8c058b7634d007627710945696623d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a6d8c058b7634d007627710945696623d">settings</a> (const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp;s)</td></tr>
<tr class="memdesc:a6d8c058b7634d007627710945696623d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser.  <br /></td></tr>
<tr class="separator:a6d8c058b7634d007627710945696623d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a83700654e384e5e0e676104115ee7395" id="r_a83700654e384e5e0e676104115ee7395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> () const</td></tr>
<tr class="memdesc:a83700654e384e5e0e676104115ee7395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Next parser in chain.  <br /></td></tr>
<tr class="separator:a83700654e384e5e0e676104115ee7395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4a4c34488e84e55b98111ecc7f387" id="r_a87c4a4c34488e84e55b98111ecc7f387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a87c4a4c34488e84e55b98111ecc7f387">nextUnparser</a> (<a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a> next)</td></tr>
<tr class="memdesc:a87c4a4c34488e84e55b98111ecc7f387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Next parser in chain.  <br /></td></tr>
<tr class="separator:a87c4a4c34488e84e55b98111ecc7f387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5a241e9d6e5ec4c6855766234e69579" id="r_aa5a241e9d6e5ec4c6855766234e69579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa5a241e9d6e5ec4c6855766234e69579">operator()</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;) const</td></tr>
<tr class="memdesc:aa5a241e9d6e5ec4c6855766234e69579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:aa5a241e9d6e5ec4c6855766234e69579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c47ca04c96ded77b5fc9525fa220e25" id="r_a1c47ca04c96ded77b5fc9525fa220e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a1c47ca04c96ded77b5fc9525fa220e25">operator()</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a1c47ca04c96ded77b5fc9525fa220e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:a1c47ca04c96ded77b5fc9525fa220e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2471cec47071418206ac0d70b67d464f" id="r_a2471cec47071418206ac0d70b67d464f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a2471cec47071418206ac0d70b67d464f">operator()</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2471cec47071418206ac0d70b67d464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:a2471cec47071418206ac0d70b67d464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453aaefefd5c4628bad1b55126857808" id="r_a453aaefefd5c4628bad1b55126857808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a453aaefefd5c4628bad1b55126857808">operator()</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a453aaefefd5c4628bad1b55126857808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:a453aaefefd5c4628bad1b55126857808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afd27580ceab40794b80cd5c93e673" id="r_ab9afd27580ceab40794b80cd5c93e673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ab9afd27580ceab40794b80cd5c93e673">operator()</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ab9afd27580ceab40794b80cd5c93e673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:ab9afd27580ceab40794b80cd5c93e673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d51481a18067b7f1824ff042cd047d" id="r_a64d51481a18067b7f1824ff042cd047d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a64d51481a18067b7f1824ff042cd047d">operator()</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a64d51481a18067b7f1824ff042cd047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to an output stream.  <br /></td></tr>
<tr class="separator:a64d51481a18067b7f1824ff042cd047d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab43cbdd54a4df5ee41e74cacfc73e935" id="r_ab43cbdd54a4df5ee41e74cacfc73e935"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ab43cbdd54a4df5ee41e74cacfc73e935">operator()</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;=<a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()) const</td></tr>
<tr class="memdesc:ab43cbdd54a4df5ee41e74cacfc73e935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:ab43cbdd54a4df5ee41e74cacfc73e935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41ccb8712f4951290104958d2408c8f" id="r_ad41ccb8712f4951290104958d2408c8f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ad41ccb8712f4951290104958d2408c8f">operator()</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:ad41ccb8712f4951290104958d2408c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:ad41ccb8712f4951290104958d2408c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621073b0b3289a5c7129fe37707c46f9" id="r_a621073b0b3289a5c7129fe37707c46f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a621073b0b3289a5c7129fe37707c46f9">operator()</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a621073b0b3289a5c7129fe37707c46f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:a621073b0b3289a5c7129fe37707c46f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f875778832c599b20a29c5eec7dfadd" id="r_a2f875778832c599b20a29c5eec7dfadd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a2f875778832c599b20a29c5eec7dfadd">operator()</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a2f875778832c599b20a29c5eec7dfadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:a2f875778832c599b20a29c5eec7dfadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d02133490dd872d49ad76e8e4dbe2f" id="r_a97d02133490dd872d49ad76e8e4dbe2f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a97d02133490dd872d49ad76e8e4dbe2f">operator()</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a97d02133490dd872d49ad76e8e4dbe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:a97d02133490dd872d49ad76e8e4dbe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4760e143a20e3cb1289f6f95f02a83" id="r_a1b4760e143a20e3cb1289f6f95f02a83"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a1b4760e143a20e3cb1289f6f95f02a83">operator()</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a1b4760e143a20e3cb1289f6f95f02a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the entity to a string.  <br /></td></tr>
<tr class="separator:a1b4760e143a20e3cb1289f6f95f02a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acdb9073caa554ccf048def31a3cb3552" id="r_acdb9073caa554ccf048def31a3cb3552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#acdb9073caa554ccf048def31a3cb3552">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;=<a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()) const</td></tr>
<tr class="memdesc:acdb9073caa554ccf048def31a3cb3552"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:acdb9073caa554ccf048def31a3cb3552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77fd78831a030b61103a7e62a0ab917" id="r_ac77fd78831a030b61103a7e62a0ab917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ac77fd78831a030b61103a7e62a0ab917">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:ac77fd78831a030b61103a7e62a0ab917"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:ac77fd78831a030b61103a7e62a0ab917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55904a3a61fbb7efd8de917dba9b3a9" id="r_ad55904a3a61fbb7efd8de917dba9b3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ad55904a3a61fbb7efd8de917dba9b3a9">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ad55904a3a61fbb7efd8de917dba9b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:ad55904a3a61fbb7efd8de917dba9b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7318a8adcf24f803532dc27fcce8af" id="r_a6d7318a8adcf24f803532dc27fcce8af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a6d7318a8adcf24f803532dc27fcce8af">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a6d7318a8adcf24f803532dc27fcce8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a6d7318a8adcf24f803532dc27fcce8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4195b1fac40f97c6bab1c637edd97200" id="r_a4195b1fac40f97c6bab1c637edd97200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a4195b1fac40f97c6bab1c637edd97200">unparse</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a4195b1fac40f97c6bab1c637edd97200"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a4195b1fac40f97c6bab1c637edd97200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e74e7a0c10289d5a785d97e76bd5931" id="r_a3e74e7a0c10289d5a785d97e76bd5931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a3e74e7a0c10289d5a785d97e76bd5931">unparse</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a3e74e7a0c10289d5a785d97e76bd5931"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a3e74e7a0c10289d5a785d97e76bd5931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a6f6d14ac574d86de33b20bbc72d11" id="r_a72a6f6d14ac574d86de33b20bbc72d11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a72a6f6d14ac574d86de33b20bbc72d11">unparse</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;=<a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()) const</td></tr>
<tr class="memdesc:a72a6f6d14ac574d86de33b20bbc72d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a72a6f6d14ac574d86de33b20bbc72d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47648017a3d3a1461b1397da5ef466c" id="r_ab47648017a3d3a1461b1397da5ef466c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ab47648017a3d3a1461b1397da5ef466c">unparse</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:ab47648017a3d3a1461b1397da5ef466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:ab47648017a3d3a1461b1397da5ef466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f58bb69de5884142c02be7e82c0a4" id="r_a6f7f58bb69de5884142c02be7e82c0a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a6f7f58bb69de5884142c02be7e82c0a4">unparse</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a6f7f58bb69de5884142c02be7e82c0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a6f7f58bb69de5884142c02be7e82c0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80a084d2a86cf42c467f3a0494d8a86" id="r_aa80a084d2a86cf42c467f3a0494d8a86"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa80a084d2a86cf42c467f3a0494d8a86">unparse</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:aa80a084d2a86cf42c467f3a0494d8a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:aa80a084d2a86cf42c467f3a0494d8a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132cae097f326d326bf51902f45d23d3" id="r_a132cae097f326d326bf51902f45d23d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a132cae097f326d326bf51902f45d23d3">unparse</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;) const</td></tr>
<tr class="memdesc:a132cae097f326d326bf51902f45d23d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a132cae097f326d326bf51902f45d23d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d3cf2e953e517ba530d9d31129028" id="r_a464d3cf2e953e517ba530d9d31129028"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a464d3cf2e953e517ba530d9d31129028">unparse</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a464d3cf2e953e517ba530d9d31129028"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level unparsing function.  <br /></td></tr>
<tr class="separator:a464d3cf2e953e517ba530d9d31129028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22df544f6a5e717d8e4d77f69129e029" id="r_a22df544f6a5e717d8e4d77f69129e029"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a22df544f6a5e717d8e4d77f69129e029">emitFunction</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a22df544f6a5e717d8e4d77f69129e029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a22df544f6a5e717d8e4d77f69129e029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fd09df42cfe375b208e5c6dae38cd3" id="r_a55fd09df42cfe375b208e5c6dae38cd3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a55fd09df42cfe375b208e5c6dae38cd3">emitFunctionPrologue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a55fd09df42cfe375b208e5c6dae38cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a55fd09df42cfe375b208e5c6dae38cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94fb862bfe5138066a151814c0c578f" id="r_ad94fb862bfe5138066a151814c0c578f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ad94fb862bfe5138066a151814c0c578f">emitFunctionBody</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ad94fb862bfe5138066a151814c0c578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ad94fb862bfe5138066a151814c0c578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa989cc3e053ae6d552d65371ba72d" id="r_ad2fa989cc3e053ae6d552d65371ba72d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ad2fa989cc3e053ae6d552d65371ba72d">emitFunctionEpilogue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ad2fa989cc3e053ae6d552d65371ba72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ad2fa989cc3e053ae6d552d65371ba72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e79d1ff4725572238da5a9937f55e2" id="r_ae2e79d1ff4725572238da5a9937f55e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ae2e79d1ff4725572238da5a9937f55e2">emitFunctionSourceLocation</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae2e79d1ff4725572238da5a9937f55e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ae2e79d1ff4725572238da5a9937f55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40283dc6c2f6e8041cc2940458a87e81" id="r_a40283dc6c2f6e8041cc2940458a87e81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a40283dc6c2f6e8041cc2940458a87e81">emitFunctionReasons</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a40283dc6c2f6e8041cc2940458a87e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a40283dc6c2f6e8041cc2940458a87e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b59a70cb4755d795da92e415d303f" id="r_ac85b59a70cb4755d795da92e415d303f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ac85b59a70cb4755d795da92e415d303f">emitFunctionCallers</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ac85b59a70cb4755d795da92e415d303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ac85b59a70cb4755d795da92e415d303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14c18137e2cd0f8e2cc3837e0c248d4" id="r_ae14c18137e2cd0f8e2cc3837e0c248d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ae14c18137e2cd0f8e2cc3837e0c248d4">emitFunctionCallees</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae14c18137e2cd0f8e2cc3837e0c248d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ae14c18137e2cd0f8e2cc3837e0c248d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf28391ce18c27b558c276015f747b87" id="r_adf28391ce18c27b558c276015f747b87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#adf28391ce18c27b558c276015f747b87">emitFunctionComment</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:adf28391ce18c27b558c276015f747b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:adf28391ce18c27b558c276015f747b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06678db1358a00aaab58c8af50845a54" id="r_a06678db1358a00aaab58c8af50845a54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a06678db1358a00aaab58c8af50845a54">emitFunctionStackDelta</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a06678db1358a00aaab58c8af50845a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a06678db1358a00aaab58c8af50845a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f7dd983280dd1e7ed29cd77f3f3362" id="r_a49f7dd983280dd1e7ed29cd77f3f3362"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a49f7dd983280dd1e7ed29cd77f3f3362">emitFunctionCallingConvention</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a49f7dd983280dd1e7ed29cd77f3f3362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a49f7dd983280dd1e7ed29cd77f3f3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc08cc52af9c57091c6c59e80968c793" id="r_afc08cc52af9c57091c6c59e80968c793"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#afc08cc52af9c57091c6c59e80968c793">emitFunctionNoopAnalysis</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:afc08cc52af9c57091c6c59e80968c793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:afc08cc52af9c57091c6c59e80968c793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106b857859f29271165c2c6caaa59fe" id="r_aa106b857859f29271165c2c6caaa59fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa106b857859f29271165c2c6caaa59fe">emitFunctionMayReturn</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aa106b857859f29271165c2c6caaa59fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aa106b857859f29271165c2c6caaa59fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a2c1e851e6e708c11bc1da6d9e8823" id="r_aa4a2c1e851e6e708c11bc1da6d9e8823"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa4a2c1e851e6e708c11bc1da6d9e8823">emitDataBlockSourceLocation</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aa4a2c1e851e6e708c11bc1da6d9e8823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aa4a2c1e851e6e708c11bc1da6d9e8823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a85d463a897553595a74905bb99770" id="r_a56a85d463a897553595a74905bb99770"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a56a85d463a897553595a74905bb99770">emitDataBlock</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a56a85d463a897553595a74905bb99770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a56a85d463a897553595a74905bb99770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320a6ee8f966e33bddddc3cb9c04f878" id="r_a320a6ee8f966e33bddddc3cb9c04f878"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a320a6ee8f966e33bddddc3cb9c04f878">emitDataBlockPrologue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a320a6ee8f966e33bddddc3cb9c04f878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a320a6ee8f966e33bddddc3cb9c04f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3408f98f6f3f6febc90d914a3060f4" id="r_a6e3408f98f6f3f6febc90d914a3060f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a6e3408f98f6f3f6febc90d914a3060f4">emitDataBlockBody</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a6e3408f98f6f3f6febc90d914a3060f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a6e3408f98f6f3f6febc90d914a3060f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e879a9bb500b0e6843d968c17595d4" id="r_a61e879a9bb500b0e6843d968c17595d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a61e879a9bb500b0e6843d968c17595d4">emitDataBlockEpilogue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a61e879a9bb500b0e6843d968c17595d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a61e879a9bb500b0e6843d968c17595d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe60193eb4d889df5e0fbab9198325b" id="r_abbe60193eb4d889df5e0fbab9198325b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#abbe60193eb4d889df5e0fbab9198325b">emitBasicBlock</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:abbe60193eb4d889df5e0fbab9198325b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:abbe60193eb4d889df5e0fbab9198325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b68f7e17b21eef1bd384320b640bee9" id="r_a8b68f7e17b21eef1bd384320b640bee9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a8b68f7e17b21eef1bd384320b640bee9">emitBasicBlockPrologue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a8b68f7e17b21eef1bd384320b640bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a8b68f7e17b21eef1bd384320b640bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbe35a22de5fe094b8d8f565e63368e" id="r_accbe35a22de5fe094b8d8f565e63368e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#accbe35a22de5fe094b8d8f565e63368e">emitBasicBlockBody</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:accbe35a22de5fe094b8d8f565e63368e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:accbe35a22de5fe094b8d8f565e63368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54aba3e1fd9b28c9308ad8fb60724b3" id="r_aa54aba3e1fd9b28c9308ad8fb60724b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa54aba3e1fd9b28c9308ad8fb60724b3">emitBasicBlockEpilogue</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aa54aba3e1fd9b28c9308ad8fb60724b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aa54aba3e1fd9b28c9308ad8fb60724b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6adc8fbba4e71e8a5db2890b374ef53" id="r_ac6adc8fbba4e71e8a5db2890b374ef53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ac6adc8fbba4e71e8a5db2890b374ef53">emitBasicBlockSourceLocation</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ac6adc8fbba4e71e8a5db2890b374ef53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ac6adc8fbba4e71e8a5db2890b374ef53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732539d9576d3c9495273dc9f5427c9c" id="r_a732539d9576d3c9495273dc9f5427c9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a732539d9576d3c9495273dc9f5427c9c">emitBasicBlockComment</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a732539d9576d3c9495273dc9f5427c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a732539d9576d3c9495273dc9f5427c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a82d6a35d593df9569ae158d3a9fc" id="r_a535a82d6a35d593df9569ae158d3a9fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a535a82d6a35d593df9569ae158d3a9fc">emitBasicBlockSharing</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a535a82d6a35d593df9569ae158d3a9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a535a82d6a35d593df9569ae158d3a9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fec53873726023088a11889c5cac3" id="r_abc9fec53873726023088a11889c5cac3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#abc9fec53873726023088a11889c5cac3">emitBasicBlockPredecessors</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:abc9fec53873726023088a11889c5cac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:abc9fec53873726023088a11889c5cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17352f289da60e7b1fb0e6c51e752fc3" id="r_a17352f289da60e7b1fb0e6c51e752fc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a17352f289da60e7b1fb0e6c51e752fc3">emitBasicBlockSuccessors</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a17352f289da60e7b1fb0e6c51e752fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a17352f289da60e7b1fb0e6c51e752fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9f60a3e70db64833ceb9cbd2d9d0d" id="r_a8ff9f60a3e70db64833ceb9cbd2d9d0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a8ff9f60a3e70db64833ceb9cbd2d9d0d">emitBasicBlockReachability</a> (std::ostream &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a8ff9f60a3e70db64833ceb9cbd2d9d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a8ff9f60a3e70db64833ceb9cbd2d9d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76f6aec912d7c18116616f78755776f" id="r_ad76f6aec912d7c18116616f78755776f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ad76f6aec912d7c18116616f78755776f">emitInstruction</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ad76f6aec912d7c18116616f78755776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ad76f6aec912d7c18116616f78755776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1418a8c9af214fbdc0c006406ef13777" id="r_a1418a8c9af214fbdc0c006406ef13777"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a1418a8c9af214fbdc0c006406ef13777">emitInstructionPrologue</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a1418a8c9af214fbdc0c006406ef13777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a1418a8c9af214fbdc0c006406ef13777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1c93f481ab732526ea46506e025eaf" id="r_a4c1c93f481ab732526ea46506e025eaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a4c1c93f481ab732526ea46506e025eaf">emitInstructionBody</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a4c1c93f481ab732526ea46506e025eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a4c1c93f481ab732526ea46506e025eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c76cce774e4fcc352139d190266103" id="r_a62c76cce774e4fcc352139d190266103"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a62c76cce774e4fcc352139d190266103">emitInstructionEpilogue</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a62c76cce774e4fcc352139d190266103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a62c76cce774e4fcc352139d190266103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8172736b1f968a5972b62e4685dd0b34" id="r_a8172736b1f968a5972b62e4685dd0b34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a8172736b1f968a5972b62e4685dd0b34">emitInstructionAddress</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a8172736b1f968a5972b62e4685dd0b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a8172736b1f968a5972b62e4685dd0b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866571530f15f3c0602e3b6cfbc4421" id="r_a7866571530f15f3c0602e3b6cfbc4421"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a7866571530f15f3c0602e3b6cfbc4421">emitInstructionBytes</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a7866571530f15f3c0602e3b6cfbc4421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a7866571530f15f3c0602e3b6cfbc4421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9bb1fae233c6ed717a2d0c33b3d4bc" id="r_aba9bb1fae233c6ed717a2d0c33b3d4bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aba9bb1fae233c6ed717a2d0c33b3d4bc">emitInstructionStackDelta</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aba9bb1fae233c6ed717a2d0c33b3d4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aba9bb1fae233c6ed717a2d0c33b3d4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca0875906074e59a221a0cb4d19ba45" id="r_adca0875906074e59a221a0cb4d19ba45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#adca0875906074e59a221a0cb4d19ba45">emitInstructionMnemonic</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:adca0875906074e59a221a0cb4d19ba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:adca0875906074e59a221a0cb4d19ba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd77fd7894947099d0cc08b2e6b3711" id="r_a3bd77fd7894947099d0cc08b2e6b3711"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a3bd77fd7894947099d0cc08b2e6b3711">emitInstructionOperands</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a3bd77fd7894947099d0cc08b2e6b3711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a3bd77fd7894947099d0cc08b2e6b3711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9953ea2e36053164224a016979ce97" id="r_aab9953ea2e36053164224a016979ce97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aab9953ea2e36053164224a016979ce97">emitInstructionComment</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aab9953ea2e36053164224a016979ce97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aab9953ea2e36053164224a016979ce97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae870b49c4d649d16c0868741836eb9b7" id="r_ae870b49c4d649d16c0868741836eb9b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ae870b49c4d649d16c0868741836eb9b7">emitInstructionSemantics</a> (std::ostream &amp;, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae870b49c4d649d16c0868741836eb9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ae870b49c4d649d16c0868741836eb9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a59357e348f71d45de357567b9e54" id="r_a7d1a59357e348f71d45de357567b9e54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a7d1a59357e348f71d45de357567b9e54">emitOperand</a> (std::ostream &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a7d1a59357e348f71d45de357567b9e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a7d1a59357e348f71d45de357567b9e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef260e0a8075f080f33eb360cc95237e" id="r_aef260e0a8075f080f33eb360cc95237e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aef260e0a8075f080f33eb360cc95237e">emitOperandPrologue</a> (std::ostream &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:aef260e0a8075f080f33eb360cc95237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aef260e0a8075f080f33eb360cc95237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cafb6e965ca6dd6bd369aaf853ee1c" id="r_af8cafb6e965ca6dd6bd369aaf853ee1c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#af8cafb6e965ca6dd6bd369aaf853ee1c">emitOperandBody</a> (std::ostream &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:af8cafb6e965ca6dd6bd369aaf853ee1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:af8cafb6e965ca6dd6bd369aaf853ee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baef7d3bdb912b6a81465b0241138e0" id="r_a9baef7d3bdb912b6a81465b0241138e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a9baef7d3bdb912b6a81465b0241138e0">emitOperandEpilogue</a> (std::ostream &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a9baef7d3bdb912b6a81465b0241138e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a9baef7d3bdb912b6a81465b0241138e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab464c9535f0daf0cc33cd0992c37cab1" id="r_ab464c9535f0daf0cc33cd0992c37cab1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ab464c9535f0daf0cc33cd0992c37cab1">emitExpression</a> (std::ostream &amp;, <a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ab464c9535f0daf0cc33cd0992c37cab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ab464c9535f0daf0cc33cd0992c37cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac054343a9830b0bc9a9ba4a178d69e19" id="r_ac054343a9830b0bc9a9ba4a178d69e19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ac054343a9830b0bc9a9ba4a178d69e19">emitRegister</a> (std::ostream &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ac054343a9830b0bc9a9ba4a178d69e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:ac054343a9830b0bc9a9ba4a178d69e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91250a118bb056c2d5dc845f802e2d19" id="r_a91250a118bb056c2d5dc845f802e2d19"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a91250a118bb056c2d5dc845f802e2d19">emitUnsignedInteger</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a91250a118bb056c2d5dc845f802e2d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a91250a118bb056c2d5dc845f802e2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1632cdc2fd2e27b248f0f6250aa936" id="r_a6c1632cdc2fd2e27b248f0f6250aa936"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a6c1632cdc2fd2e27b248f0f6250aa936">emitSignedInteger</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a6c1632cdc2fd2e27b248f0f6250aa936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a6c1632cdc2fd2e27b248f0f6250aa936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad43d748db3f012290f0e8b9a417ff" id="r_a28ad43d748db3f012290f0e8b9a417ff"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a28ad43d748db3f012290f0e8b9a417ff">emitInteger</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;, bool isSigned) const</td></tr>
<tr class="memdesc:a28ad43d748db3f012290f0e8b9a417ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a28ad43d748db3f012290f0e8b9a417ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d660e22678fb726a8eb80d086b191c" id="r_aa7d660e22678fb726a8eb80d086b191c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#aa7d660e22678fb726a8eb80d086b191c">emitAddress</a> (std::ostream &amp;, rose_addr_t, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;, bool always=true) const</td></tr>
<tr class="memdesc:aa7d660e22678fb726a8eb80d086b191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:aa7d660e22678fb726a8eb80d086b191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24855a637cc5cda452ff125181bcd589" id="r_a24855a637cc5cda452ff125181bcd589"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a24855a637cc5cda452ff125181bcd589">emitAddress</a> (std::ostream &amp;, const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;, bool always=true) const</td></tr>
<tr class="memdesc:a24855a637cc5cda452ff125181bcd589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a24855a637cc5cda452ff125181bcd589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654bae1ee34f202075ba2f84464b5cda" id="r_a654bae1ee34f202075ba2f84464b5cda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a654bae1ee34f202075ba2f84464b5cda">emitCommentBlock</a> (std::ostream &amp;, const std::string &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;, const std::string &amp;prefix=&quot;;;; &quot;) const</td></tr>
<tr class="memdesc:a654bae1ee34f202075ba2f84464b5cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a654bae1ee34f202075ba2f84464b5cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423bafabbb2770f101cbda8d31a1c4d7" id="r_a423bafabbb2770f101cbda8d31a1c4d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a423bafabbb2770f101cbda8d31a1c4d7">emitTypeName</a> (std::ostream &amp;, <a class="el" href="classSgAsmType.html">SgAsmType</a> *, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a423bafabbb2770f101cbda8d31a1c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a423bafabbb2770f101cbda8d31a1c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f3a2bf42ea50225c9cb76f18728df" id="r_a816f3a2bf42ea50225c9cb76f18728df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a816f3a2bf42ea50225c9cb76f18728df">emitLinePrefix</a> (std::ostream &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a816f3a2bf42ea50225c9cb76f18728df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-level unparser function.  <br /></td></tr>
<tr class="separator:a816f3a2bf42ea50225c9cb76f18728df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec4d1e810b982f76d5177a55a6132e61" id="r_aec4d1e810b982f76d5177a55a6132e61"><td class="memItemLeft" align="right" valign="top"><a id="aec4d1e810b982f76d5177a55a6132e61" name="aec4d1e810b982f76d5177a55a6132e61"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>leftJustify</b> (const std::string &amp;, size_t nchars)</td></tr>
<tr class="memdesc:aec4d1e810b982f76d5177a55a6132e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a string left justified. <br /></td></tr>
<tr class="separator:aec4d1e810b982f76d5177a55a6132e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabb4aa4da8e7338b66d07a90c6e4305" id="r_acabb4aa4da8e7338b66d07a90c6e4305"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#acabb4aa4da8e7338b66d07a90c6e4305">juxtaposeColumns</a> (const std::vector&lt; std::string &gt; &amp;content, const std::vector&lt; size_t &gt; &amp;minWidths, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;colorEscapes, const std::string &amp;columnSeparator=&quot; &quot;)</td></tr>
<tr class="memdesc:acabb4aa4da8e7338b66d07a90c6e4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a table row.  <br /></td></tr>
<tr class="separator:acabb4aa4da8e7338b66d07a90c6e4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247106c8311dd6af1bcadb13e846f9a8" id="r_a247106c8311dd6af1bcadb13e846f9a8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a247106c8311dd6af1bcadb13e846f9a8">ascendingSourceAddress</a> (Partitioner2::ControlFlowGraph::ConstEdgeIterator a, Partitioner2::ControlFlowGraph::ConstEdgeIterator b)</td></tr>
<tr class="memdesc:a247106c8311dd6af1bcadb13e846f9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if edges are in order by source address.  <br /></td></tr>
<tr class="separator:a247106c8311dd6af1bcadb13e846f9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605c768d2209685fe16c8ebddb74be06" id="r_a605c768d2209685fe16c8ebddb74be06"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a605c768d2209685fe16c8ebddb74be06">ascendingTargetAddress</a> (Partitioner2::ControlFlowGraph::ConstEdgeIterator a, Partitioner2::ControlFlowGraph::ConstEdgeIterator b)</td></tr>
<tr class="memdesc:a605c768d2209685fe16c8ebddb74be06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if edges are in order by target address.  <br /></td></tr>
<tr class="separator:a605c768d2209685fe16c8ebddb74be06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f831f7252a81989cb033067c904ea6" id="r_a74f831f7252a81989cb033067c904ea6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Partitioner2::ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a74f831f7252a81989cb033067c904ea6">orderedBlockPredecessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a74f831f7252a81989cb033067c904ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered incoming CFG edges.  <br /></td></tr>
<tr class="separator:a74f831f7252a81989cb033067c904ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67f33c7f4ab359a1a706975ad288928" id="r_ab67f33c7f4ab359a1a706975ad288928"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Partitioner2::ControlFlowGraph::ConstEdgeIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#ab67f33c7f4ab359a1a706975ad288928">orderedBlockSuccessors</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:ab67f33c7f4ab359a1a706975ad288928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered outgoing CFG edges.  <br /></td></tr>
<tr class="separator:ab67f33c7f4ab359a1a706975ad288928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a79a8286224b2c65bf9673df4945fa358" id="r_a79a8286224b2c65bf9673df4945fa358"><td class="memItemLeft" align="right" valign="top"><a id="a79a8286224b2c65bf9673df4945fa358" name="a79a8286224b2c65bf9673df4945fa358"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> &amp;)</td></tr>
<tr class="separator:a79a8286224b2c65bf9673df4945fa358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e3dd26f5d2e56c1ee9c131f6ff2a7f" id="r_ab4e3dd26f5d2e56c1ee9c131f6ff2a7f"><td class="memItemLeft" align="right" valign="top"><a id="ab4e3dd26f5d2e56c1ee9c131f6ff2a7f" name="ab4e3dd26f5d2e56c1ee9c131f6ff2a7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const <a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a>)</td></tr>
<tr class="separator:ab4e3dd26f5d2e56c1ee9c131f6ff2a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae64cd92db064ac760b44b9431f4fa68b" name="ae64cd92db064ac760b44b9431f4fa68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64cd92db064ac760b44b9431f4fa68b">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer</a>&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html">Base</a>&gt; <a class="el" href="classSawyer_1_1SharedPointer.html">Rose::BinaryAnalysis::Unparser::Base::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00415">415</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5f839d596d20b3af7ae852683f330309" name="a5f839d596d20b3af7ae852683f330309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f839d596d20b3af7ae852683f330309">&#9670;&#160;</a></span>settings() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Unparser::Base::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser. </p>
<p>Most of these settings can also be configured from the command-line. They control features of the unparser directly without the programmer having to invervene by creating a subclss or chaining a new parser. Most of the switches simply turn things on and off.</p>
<p>Copying an unparser also copies its settings. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Cil.html#a22e7c862c1e8a13d7cf453ecaaa8bcd8">Rose::BinaryAnalysis::Unparser::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Jvm.html#a044a9fd909fef11e7bb7b5156efaf16a">Rose::BinaryAnalysis::Unparser::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1M68k.html#a3ac4fba889eaea2ccac2787a05fbad87">Rose::BinaryAnalysis::Unparser::M68k</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Mips.html#ad648fa63064d60bfa5c55712f3d5a9ef">Rose::BinaryAnalysis::Unparser::Mips</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Null.html#a0fa747f0a7695a7dad865b916ed64bac">Rose::BinaryAnalysis::Unparser::Null</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Powerpc.html#abf34531ab3978cab3298ff7444e0c56d">Rose::BinaryAnalysis::Unparser::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html#add125b476502b922d5b333b0a29d33ec">Rose::BinaryAnalysis::Unparser::X86</a>.</p>

<p class="reference">Referenced by <a class="el" href="Unparser_2Base_8h_source.html#l00440">settings()</a>.</p>

</div>
</div>
<a id="a0c2a96ba8a7a9fc0809846312b373d31" name="a0c2a96ba8a7a9fc0809846312b373d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2a96ba8a7a9fc0809846312b373d31">&#9670;&#160;</a></span>settings() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp; Rose::BinaryAnalysis::Unparser::Base::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser. </p>
<p>Most of these settings can also be configured from the command-line. They control features of the unparser directly without the programmer having to invervene by creating a subclss or chaining a new parser. Most of the switches simply turn things on and off.</p>
<p>Copying an unparser also copies its settings. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Cil.html#ad1333cdce1f279c02ebc17c7b7205a00">Rose::BinaryAnalysis::Unparser::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Jvm.html#aa637ce6be03b21994d967b39dcbfb9f3">Rose::BinaryAnalysis::Unparser::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1M68k.html#af0b0778dd62782f395fd78fb1f1cb7dc">Rose::BinaryAnalysis::Unparser::M68k</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Mips.html#aaf6f9cfbf992f846376baf5c4f68ee4c">Rose::BinaryAnalysis::Unparser::Mips</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Null.html#a3d0f5f7fbfc9e564b54c27fbd8a49213">Rose::BinaryAnalysis::Unparser::Null</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Powerpc.html#a7cb718b334f4e9f67e0b47495d0ea4ae">Rose::BinaryAnalysis::Unparser::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html#a013de11c4c9f6b39e6ce575b8446630a">Rose::BinaryAnalysis::Unparser::X86</a>.</p>

</div>
</div>
<a id="a6d8c058b7634d007627710945696623d" name="a6d8c058b7634d007627710945696623d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8c058b7634d007627710945696623d">&#9670;&#160;</a></span>settings() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::settings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html">Settings</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: <a class="el" href="structRose_1_1BinaryAnalysis_1_1Unparser_1_1Settings.html" title="Settings that control unparsing.">Settings</a> associated with this unparser. </p>
<p>Most of these settings can also be configured from the command-line. They control features of the unparser directly without the programmer having to invervene by creating a subclss or chaining a new parser. Most of the switches simply turn things on and off.</p>
<p>Copying an unparser also copies its settings. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00440">440</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a5f839d596d20b3af7ae852683f330309">settings()</a>.</p>

</div>
</div>
<a id="a83700654e384e5e0e676104115ee7395" name="a83700654e384e5e0e676104115ee7395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83700654e384e5e0e676104115ee7395">&#9670;&#160;</a></span>nextUnparser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a> Rose::BinaryAnalysis::Unparser::Base::nextUnparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Next parser in chain. </p>
<p>Parsers can be subclass and/or chained. Nearly all functions check for chaining and delegate to the next parser in the chain. When one function calls some other function, it uses the first parser of the chain. The chain can be created by supplying an argument to the constructor, or it can be constructed later by setting this property. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00452">452</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="a87c4a4c34488e84e55b98111ecc7f387" name="a87c4a4c34488e84e55b98111ecc7f387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c4a4c34488e84e55b98111ecc7f387">&#9670;&#160;</a></span>nextUnparser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::nextUnparser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1SharedPointer.html">Ptr</a>&#160;</td>
          <td class="paramname"><em>next</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Next parser in chain. </p>
<p>Parsers can be subclass and/or chained. Nearly all functions check for chaining and delegate to the next parser in the chain. When one function calls some other function, it uses the first parser of the chain. The chain can be created by supplying an argument to the constructor, or it can be constructed later by setting this property. </p>

<p class="definition">Definition at line <a class="el" href="Unparser_2Base_8h_source.html#l00453">453</a> of file <a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a>.</p>

</div>
</div>
<a id="adbeb24b5c0c25eb7bae8fa1646f3a358" name="adbeb24b5c0c25eb7bae8fa1646f3a358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbeb24b5c0c25eb7bae8fa1646f3a358">&#9670;&#160;</a></span>architecture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">Architecture::BaseConstPtr</a> Rose::BinaryAnalysis::Unparser::Base::architecture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a>. </p>
<p>A non-null pointer to the architecture that this unparser unparses. </p>

</div>
</div>
<a id="aa5a241e9d6e5ec4c6855766234e69579" name="aa5a241e9d6e5ec4c6855766234e69579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a241e9d6e5ec4c6855766234e69579">&#9670;&#160;</a></span>operator()() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="a1c47ca04c96ded77b5fc9525fa220e25" name="a1c47ca04c96ded77b5fc9525fa220e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c47ca04c96ded77b5fc9525fa220e25">&#9670;&#160;</a></span>operator()() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="a2471cec47071418206ac0d70b67d464f" name="a2471cec47071418206ac0d70b67d464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2471cec47071418206ac0d70b67d464f">&#9670;&#160;</a></span>operator()() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="a453aaefefd5c4628bad1b55126857808" name="a453aaefefd5c4628bad1b55126857808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453aaefefd5c4628bad1b55126857808">&#9670;&#160;</a></span>operator()() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="ab9afd27580ceab40794b80cd5c93e673" name="ab9afd27580ceab40794b80cd5c93e673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9afd27580ceab40794b80cd5c93e673">&#9670;&#160;</a></span>operator()() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="a64d51481a18067b7f1824ff042cd047d" name="a64d51481a18067b7f1824ff042cd047d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d51481a18067b7f1824ff042cd047d">&#9670;&#160;</a></span>operator()() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to an output stream. </p>
<p>Renders the third argument as text and sends it to the stream indicated by the first argument. The <code>partitioner</code> argument provides additional details about the thing being printed. The version of this function that takes only two arguments causes all functions to be emitted. </p>

</div>
</div>
<a id="ab43cbdd54a4df5ee41e74cacfc73e935" name="ab43cbdd54a4df5ee41e74cacfc73e935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43cbdd54a4df5ee41e74cacfc73e935">&#9670;&#160;</a></span>operator()() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="ad41ccb8712f4951290104958d2408c8f" name="ad41ccb8712f4951290104958d2408c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41ccb8712f4951290104958d2408c8f">&#9670;&#160;</a></span>operator()() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="a621073b0b3289a5c7129fe37707c46f9" name="a621073b0b3289a5c7129fe37707c46f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621073b0b3289a5c7129fe37707c46f9">&#9670;&#160;</a></span>operator()() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="a2f875778832c599b20a29c5eec7dfadd" name="a2f875778832c599b20a29c5eec7dfadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f875778832c599b20a29c5eec7dfadd">&#9670;&#160;</a></span>operator()() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="a97d02133490dd872d49ad76e8e4dbe2f" name="a97d02133490dd872d49ad76e8e4dbe2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d02133490dd872d49ad76e8e4dbe2f">&#9670;&#160;</a></span>operator()() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="a1b4760e143a20e3cb1289f6f95f02a83" name="a1b4760e143a20e3cb1289f6f95f02a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4760e143a20e3cb1289f6f95f02a83">&#9670;&#160;</a></span>operator()() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the entity to a string. </p>
<p>This is just a convenience wrapper around the three-argument form. </p>

</div>
</div>
<a id="acdb9073caa554ccf048def31a3cb3552" name="acdb9073caa554ccf048def31a3cb3552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb9073caa554ccf048def31a3cb3552">&#9670;&#160;</a></span>unparse() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="ac77fd78831a030b61103a7e62a0ab917" name="ac77fd78831a030b61103a7e62a0ab917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77fd78831a030b61103a7e62a0ab917">&#9670;&#160;</a></span>unparse() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="ad55904a3a61fbb7efd8de917dba9b3a9" name="ad55904a3a61fbb7efd8de917dba9b3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55904a3a61fbb7efd8de917dba9b3a9">&#9670;&#160;</a></span>unparse() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a6d7318a8adcf24f803532dc27fcce8af" name="a6d7318a8adcf24f803532dc27fcce8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7318a8adcf24f803532dc27fcce8af">&#9670;&#160;</a></span>unparse() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a4195b1fac40f97c6bab1c637edd97200" name="a4195b1fac40f97c6bab1c637edd97200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4195b1fac40f97c6bab1c637edd97200">&#9670;&#160;</a></span>unparse() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a3e74e7a0c10289d5a785d97e76bd5931" name="a3e74e7a0c10289d5a785d97e76bd5931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e74e7a0c10289d5a785d97e76bd5931">&#9670;&#160;</a></span>unparse() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a72a6f6d14ac574d86de33b20bbc72d11" name="a72a6f6d14ac574d86de33b20bbc72d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a6f6d14ac574d86de33b20bbc72d11">&#9670;&#160;</a></span>unparse() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classRose_1_1Progress.html#aa98a882b66bc733db53c75f0ddf713c1">Progress::Ptr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="ab47648017a3d3a1461b1397da5ef466c" name="ab47648017a3d3a1461b1397da5ef466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47648017a3d3a1461b1397da5ef466c">&#9670;&#160;</a></span>unparse() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a6f7f58bb69de5884142c02be7e82c0a4" name="a6f7f58bb69de5884142c02be7e82c0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7f58bb69de5884142c02be7e82c0a4">&#9670;&#160;</a></span>unparse() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="aa80a084d2a86cf42c467f3a0494d8a86" name="aa80a084d2a86cf42c467f3a0494d8a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80a084d2a86cf42c467f3a0494d8a86">&#9670;&#160;</a></span>unparse() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a132cae097f326d326bf51902f45d23d3" name="a132cae097f326d326bf51902f45d23d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132cae097f326d326bf51902f45d23d3">&#9670;&#160;</a></span>unparse() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a464d3cf2e953e517ba530d9d31129028" name="a464d3cf2e953e517ba530d9d31129028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d3cf2e953e517ba530d9d31129028">&#9670;&#160;</a></span>unparse() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Unparser::Base::unparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level unparsing function. </p>
<p>This function does the same thing as the function operator that has the same arguments. </p>

</div>
</div>
<a id="a22df544f6a5e717d8e4d77f69129e029" name="a22df544f6a5e717d8e4d77f69129e029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22df544f6a5e717d8e4d77f69129e029">&#9670;&#160;</a></span>emitFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunction </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a55fd09df42cfe375b208e5c6dae38cd3" name="a55fd09df42cfe375b208e5c6dae38cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fd09df42cfe375b208e5c6dae38cd3">&#9670;&#160;</a></span>emitFunctionPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionPrologue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ad94fb862bfe5138066a151814c0c578f" name="ad94fb862bfe5138066a151814c0c578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94fb862bfe5138066a151814c0c578f">&#9670;&#160;</a></span>emitFunctionBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionBody </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ad2fa989cc3e053ae6d552d65371ba72d" name="ad2fa989cc3e053ae6d552d65371ba72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa989cc3e053ae6d552d65371ba72d">&#9670;&#160;</a></span>emitFunctionEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionEpilogue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ae2e79d1ff4725572238da5a9937f55e2" name="ae2e79d1ff4725572238da5a9937f55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e79d1ff4725572238da5a9937f55e2">&#9670;&#160;</a></span>emitFunctionSourceLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionSourceLocation </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a40283dc6c2f6e8041cc2940458a87e81" name="a40283dc6c2f6e8041cc2940458a87e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40283dc6c2f6e8041cc2940458a87e81">&#9670;&#160;</a></span>emitFunctionReasons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionReasons </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ac85b59a70cb4755d795da92e415d303f" name="ac85b59a70cb4755d795da92e415d303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85b59a70cb4755d795da92e415d303f">&#9670;&#160;</a></span>emitFunctionCallers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionCallers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ae14c18137e2cd0f8e2cc3837e0c248d4" name="ae14c18137e2cd0f8e2cc3837e0c248d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14c18137e2cd0f8e2cc3837e0c248d4">&#9670;&#160;</a></span>emitFunctionCallees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionCallees </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="adf28391ce18c27b558c276015f747b87" name="adf28391ce18c27b558c276015f747b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf28391ce18c27b558c276015f747b87">&#9670;&#160;</a></span>emitFunctionComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionComment </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a06678db1358a00aaab58c8af50845a54" name="a06678db1358a00aaab58c8af50845a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06678db1358a00aaab58c8af50845a54">&#9670;&#160;</a></span>emitFunctionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionStackDelta </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a49f7dd983280dd1e7ed29cd77f3f3362" name="a49f7dd983280dd1e7ed29cd77f3f3362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f7dd983280dd1e7ed29cd77f3f3362">&#9670;&#160;</a></span>emitFunctionCallingConvention()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionCallingConvention </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="afc08cc52af9c57091c6c59e80968c793" name="afc08cc52af9c57091c6c59e80968c793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc08cc52af9c57091c6c59e80968c793">&#9670;&#160;</a></span>emitFunctionNoopAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionNoopAnalysis </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aa106b857859f29271165c2c6caaa59fe" name="aa106b857859f29271165c2c6caaa59fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa106b857859f29271165c2c6caaa59fe">&#9670;&#160;</a></span>emitFunctionMayReturn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitFunctionMayReturn </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">Partitioner2::FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aa4a2c1e851e6e708c11bc1da6d9e8823" name="aa4a2c1e851e6e708c11bc1da6d9e8823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a2c1e851e6e708c11bc1da6d9e8823">&#9670;&#160;</a></span>emitDataBlockSourceLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitDataBlockSourceLocation </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a56a85d463a897553595a74905bb99770" name="a56a85d463a897553595a74905bb99770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a85d463a897553595a74905bb99770">&#9670;&#160;</a></span>emitDataBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitDataBlock </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a320a6ee8f966e33bddddc3cb9c04f878" name="a320a6ee8f966e33bddddc3cb9c04f878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320a6ee8f966e33bddddc3cb9c04f878">&#9670;&#160;</a></span>emitDataBlockPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitDataBlockPrologue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a6e3408f98f6f3f6febc90d914a3060f4" name="a6e3408f98f6f3f6febc90d914a3060f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3408f98f6f3f6febc90d914a3060f4">&#9670;&#160;</a></span>emitDataBlockBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitDataBlockBody </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a61e879a9bb500b0e6843d968c17595d4" name="a61e879a9bb500b0e6843d968c17595d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e879a9bb500b0e6843d968c17595d4">&#9670;&#160;</a></span>emitDataBlockEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitDataBlockEpilogue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">Partitioner2::DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="abbe60193eb4d889df5e0fbab9198325b" name="abbe60193eb4d889df5e0fbab9198325b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe60193eb4d889df5e0fbab9198325b">&#9670;&#160;</a></span>emitBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlock </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a8b68f7e17b21eef1bd384320b640bee9" name="a8b68f7e17b21eef1bd384320b640bee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b68f7e17b21eef1bd384320b640bee9">&#9670;&#160;</a></span>emitBasicBlockPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockPrologue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="accbe35a22de5fe094b8d8f565e63368e" name="accbe35a22de5fe094b8d8f565e63368e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbe35a22de5fe094b8d8f565e63368e">&#9670;&#160;</a></span>emitBasicBlockBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockBody </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aa54aba3e1fd9b28c9308ad8fb60724b3" name="aa54aba3e1fd9b28c9308ad8fb60724b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54aba3e1fd9b28c9308ad8fb60724b3">&#9670;&#160;</a></span>emitBasicBlockEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockEpilogue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ac6adc8fbba4e71e8a5db2890b374ef53" name="ac6adc8fbba4e71e8a5db2890b374ef53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6adc8fbba4e71e8a5db2890b374ef53">&#9670;&#160;</a></span>emitBasicBlockSourceLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockSourceLocation </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a732539d9576d3c9495273dc9f5427c9c" name="a732539d9576d3c9495273dc9f5427c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732539d9576d3c9495273dc9f5427c9c">&#9670;&#160;</a></span>emitBasicBlockComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockComment </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a535a82d6a35d593df9569ae158d3a9fc" name="a535a82d6a35d593df9569ae158d3a9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535a82d6a35d593df9569ae158d3a9fc">&#9670;&#160;</a></span>emitBasicBlockSharing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockSharing </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="abc9fec53873726023088a11889c5cac3" name="abc9fec53873726023088a11889c5cac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fec53873726023088a11889c5cac3">&#9670;&#160;</a></span>emitBasicBlockPredecessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockPredecessors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a17352f289da60e7b1fb0e6c51e752fc3" name="a17352f289da60e7b1fb0e6c51e752fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17352f289da60e7b1fb0e6c51e752fc3">&#9670;&#160;</a></span>emitBasicBlockSuccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockSuccessors </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a8ff9f60a3e70db64833ceb9cbd2d9d0d" name="a8ff9f60a3e70db64833ceb9cbd2d9d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9f60a3e70db64833ceb9cbd2d9d0d">&#9670;&#160;</a></span>emitBasicBlockReachability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitBasicBlockReachability </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ad76f6aec912d7c18116616f78755776f" name="ad76f6aec912d7c18116616f78755776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76f6aec912d7c18116616f78755776f">&#9670;&#160;</a></span>emitInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstruction </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Cil.html#ab61ff06e9f607927b5ad81b3e2f6922b">Rose::BinaryAnalysis::Unparser::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1M68k.html#ad3c7733d2edbe9b78a1dc57f5d18c004">Rose::BinaryAnalysis::Unparser::M68k</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Mips.html#afce0a8fc9f384cf90ae2b23a73050f74">Rose::BinaryAnalysis::Unparser::Mips</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Powerpc.html#aaab9b135657f268af28143b3934451a3">Rose::BinaryAnalysis::Unparser::Powerpc</a>.</p>

</div>
</div>
<a id="a1418a8c9af214fbdc0c006406ef13777" name="a1418a8c9af214fbdc0c006406ef13777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1418a8c9af214fbdc0c006406ef13777">&#9670;&#160;</a></span>emitInstructionPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionPrologue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a4c1c93f481ab732526ea46506e025eaf" name="a4c1c93f481ab732526ea46506e025eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1c93f481ab732526ea46506e025eaf">&#9670;&#160;</a></span>emitInstructionBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionBody </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a62c76cce774e4fcc352139d190266103" name="a62c76cce774e4fcc352139d190266103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c76cce774e4fcc352139d190266103">&#9670;&#160;</a></span>emitInstructionEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionEpilogue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a8172736b1f968a5972b62e4685dd0b34" name="a8172736b1f968a5972b62e4685dd0b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8172736b1f968a5972b62e4685dd0b34">&#9670;&#160;</a></span>emitInstructionAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionAddress </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a7866571530f15f3c0602e3b6cfbc4421" name="a7866571530f15f3c0602e3b6cfbc4421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7866571530f15f3c0602e3b6cfbc4421">&#9670;&#160;</a></span>emitInstructionBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionBytes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aba9bb1fae233c6ed717a2d0c33b3d4bc" name="aba9bb1fae233c6ed717a2d0c33b3d4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9bb1fae233c6ed717a2d0c33b3d4bc">&#9670;&#160;</a></span>emitInstructionStackDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionStackDelta </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="adca0875906074e59a221a0cb4d19ba45" name="adca0875906074e59a221a0cb4d19ba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca0875906074e59a221a0cb4d19ba45">&#9670;&#160;</a></span>emitInstructionMnemonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionMnemonic </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Jvm.html#a938b885e8e05523d29c91395d7bdc290">Rose::BinaryAnalysis::Unparser::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Null.html#a002b90de7cd6a103eec1a0e98247c2e8">Rose::BinaryAnalysis::Unparser::Null</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html#aaf75166da2ea5b0b6fbcfab096b674bd">Rose::BinaryAnalysis::Unparser::X86</a>.</p>

</div>
</div>
<a id="a3bd77fd7894947099d0cc08b2e6b3711" name="a3bd77fd7894947099d0cc08b2e6b3711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd77fd7894947099d0cc08b2e6b3711">&#9670;&#160;</a></span>emitInstructionOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionOperands </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aab9953ea2e36053164224a016979ce97" name="aab9953ea2e36053164224a016979ce97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9953ea2e36053164224a016979ce97">&#9670;&#160;</a></span>emitInstructionComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionComment </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ae870b49c4d649d16c0868741836eb9b7" name="ae870b49c4d649d16c0868741836eb9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae870b49c4d649d16c0868741836eb9b7">&#9670;&#160;</a></span>emitInstructionSemantics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitInstructionSemantics </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a7d1a59357e348f71d45de357567b9e54" name="a7d1a59357e348f71d45de357567b9e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a59357e348f71d45de357567b9e54">&#9670;&#160;</a></span>emitOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitOperand </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aef260e0a8075f080f33eb360cc95237e" name="aef260e0a8075f080f33eb360cc95237e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef260e0a8075f080f33eb360cc95237e">&#9670;&#160;</a></span>emitOperandPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitOperandPrologue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="af8cafb6e965ca6dd6bd369aaf853ee1c" name="af8cafb6e965ca6dd6bd369aaf853ee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cafb6e965ca6dd6bd369aaf853ee1c">&#9670;&#160;</a></span>emitOperandBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitOperandBody </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Cil.html#a95f8c03c9cafefa1e2289707e7f6e889">Rose::BinaryAnalysis::Unparser::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Jvm.html#a845210bad3d32405ba7f9f80e5872211">Rose::BinaryAnalysis::Unparser::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1M68k.html#acdfc2ddf045603c8f7769d1131506375">Rose::BinaryAnalysis::Unparser::M68k</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Mips.html#a5a28ed09df2d55b42d88295cae9458be">Rose::BinaryAnalysis::Unparser::Mips</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Powerpc.html#a4f4d5e2ae0e2e95c1377f4d03d506083">Rose::BinaryAnalysis::Unparser::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html#afea89f438d95cd8a6d6e7689b62c08cd">Rose::BinaryAnalysis::Unparser::X86</a>.</p>

</div>
</div>
<a id="a9baef7d3bdb912b6a81465b0241138e0" name="a9baef7d3bdb912b6a81465b0241138e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baef7d3bdb912b6a81465b0241138e0">&#9670;&#160;</a></span>emitOperandEpilogue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitOperandEpilogue </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ab464c9535f0daf0cc33cd0992c37cab1" name="ab464c9535f0daf0cc33cd0992c37cab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab464c9535f0daf0cc33cd0992c37cab1">&#9670;&#160;</a></span>emitExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitExpression </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmExpression.html">SgAsmExpression</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="ac054343a9830b0bc9a9ba4a178d69e19" name="ac054343a9830b0bc9a9ba4a178d69e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac054343a9830b0bc9a9ba4a178d69e19">&#9670;&#160;</a></span>emitRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitRegister </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a91250a118bb056c2d5dc845f802e2d19" name="a91250a118bb056c2d5dc845f802e2d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91250a118bb056c2d5dc845f802e2d19">&#9670;&#160;</a></span>emitUnsignedInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::string &gt; Rose::BinaryAnalysis::Unparser::Base::emitUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a6c1632cdc2fd2e27b248f0f6250aa936" name="a6c1632cdc2fd2e27b248f0f6250aa936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1632cdc2fd2e27b248f0f6250aa936">&#9670;&#160;</a></span>emitSignedInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::string &gt; Rose::BinaryAnalysis::Unparser::Base::emitSignedInteger </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a28ad43d748db3f012290f0e8b9a417ff" name="a28ad43d748db3f012290f0e8b9a417ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad43d748db3f012290f0e8b9a417ff">&#9670;&#160;</a></span>emitInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::string &gt; Rose::BinaryAnalysis::Unparser::Base::emitInteger </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="aa7d660e22678fb726a8eb80d086b191c" name="aa7d660e22678fb726a8eb80d086b191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d660e22678fb726a8eb80d086b191c">&#9670;&#160;</a></span>emitAddress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Unparser::Base::emitAddress </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a24855a637cc5cda452ff125181bcd589" name="a24855a637cc5cda452ff125181bcd589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24855a637cc5cda452ff125181bcd589">&#9670;&#160;</a></span>emitAddress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Unparser::Base::emitAddress </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1BitVector.html">Sawyer::Container::BitVector</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a654bae1ee34f202075ba2f84464b5cda" name="a654bae1ee34f202075ba2f84464b5cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654bae1ee34f202075ba2f84464b5cda">&#9670;&#160;</a></span>emitCommentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitCommentBlock </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;;;;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a423bafabbb2770f101cbda8d31a1c4d7" name="a423bafabbb2770f101cbda8d31a1c4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423bafabbb2770f101cbda8d31a1c4d7">&#9670;&#160;</a></span>emitTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitTypeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmType.html">SgAsmType</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1X86.html#a7c37d81a4540e6f458e95dcb7bcd4efb">Rose::BinaryAnalysis::Unparser::X86</a>.</p>

</div>
</div>
<a id="a816f3a2bf42ea50225c9cb76f18728df" name="a816f3a2bf42ea50225c9cb76f18728df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f3a2bf42ea50225c9cb76f18728df">&#9670;&#160;</a></span>emitLinePrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::emitLinePrefix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mid-level unparser function. </p>
<p>This function emits some entity to the specified output stream. All call-specific state is supplied in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html" title="State for unparsing.">State</a> reference so that this function can be called with a const parser references and is thread safe per state object. The high-level functions create the state &ndash; states are not intended for end users &ndash; before calling this mid-level function.</p>
<p>This mid-level function uses a combination of C++ virtual function calls and object chaining. The virtual functions allow subclasses to override or augment behavior from the base class, so that, e.g., an x86 operand expression can be output in a different format than an m68k expression. The object chaining allows one unparser to override or augment the behavior of another function and is used, for example, to provide HTML wrapping around various entities.</p>
<p>The object chaining is implemented in two parts: every unparser object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a83700654e384e5e0e676104115ee7395">nextUnparser</a> pointer and the final unparser in the list has a null pointer for this property; the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">Unparser::State</a> object has a <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html#a70640faf0a631e23edcd578ce0218032">frontUnparser</a> method that returns the first unparser in this list. This mid-level function is expected to always invoke functions on the front unparser in order to give every parser in the chain a chance to influence behavior. The base implementation of this mid-level function defers to the next parser in the chain if there is one, otherwise it performs some default output that's hopefully appropriate for most unparsers.</p>
<p>All such chained and virtual emitters begin with the letters "emit". </p>

</div>
</div>
<a id="a5559a71e7ce520e05c8d635ba4bb857e" name="a5559a71e7ce520e05c8d635ba4bb857e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5559a71e7ce520e05c8d635ba4bb857e">&#9670;&#160;</a></span>initializeState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::initializeState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish initializing the unparser state. </p>
<p>This gets called by the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#acdb9073caa554ccf048def31a3cb3552">unparse</a> methods just after the state object is created. It can be used to adjust the state before any unparsing actually starts. One common use is to initialize the global margin arrows. The base implementation does nothing except chain to the next unparser. </p>

</div>
</div>
<a id="af6eb63b5fae5b7253de943d08d677244" name="af6eb63b5fae5b7253de943d08d677244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb63b5fae5b7253de943d08d677244">&#9670;&#160;</a></span>updateIntraFunctionArrows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::Unparser::Base::updateIntraFunctionArrows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate intra-function arrows. </p>
<p>This is the oppurtunity for the subclass to calculate the intra-function arrows that should appear in the left margin of the output. This function is invoked by the base parser after emitting the function prologue and after possibly calculating CFG intra-function arrows but before emitting any basic blocks or data blocks for the function. </p>

</div>
</div>
<a id="acabb4aa4da8e7338b66d07a90c6e4305" name="acabb4aa4da8e7338b66d07a90c6e4305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabb4aa4da8e7338b66d07a90c6e4305">&#9670;&#160;</a></span>juxtaposeColumns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Rose::BinaryAnalysis::Unparser::Base::juxtaposeColumns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>minWidths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>colorEscapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>columnSeparator</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render a table row. </p>
<p>Given a row of table data as a vector of cell contents, each of which could be multiple lines, return a string, also possibly multiple lines, that renders the row into columns. The <code>colorEscapes</code> are the pair of strings that should be emitted before and after each column and do not contribute to the width of the column. </p>

</div>
</div>
<a id="a247106c8311dd6af1bcadb13e846f9a8" name="a247106c8311dd6af1bcadb13e846f9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247106c8311dd6af1bcadb13e846f9a8">&#9670;&#160;</a></span>ascendingSourceAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Rose::BinaryAnalysis::Unparser::Base::ascendingSourceAddress </td>
          <td>(</td>
          <td class="paramtype">Partitioner2::ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Partitioner2::ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if edges are in order by source address. </p>
<p>If edge <code>a</code> has a source address that's less than the address of <code>b</code>, or if @ a has a source address and <code>b</code> has no source address, then return true; otherwise return false. Both edges must be valid edges, not end iterators. This defines the order that block prefixes are emitted. Source addresses are the last address of the source vertex. </p>

</div>
</div>
<a id="a605c768d2209685fe16c8ebddb74be06" name="a605c768d2209685fe16c8ebddb74be06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605c768d2209685fe16c8ebddb74be06">&#9670;&#160;</a></span>ascendingTargetAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Rose::BinaryAnalysis::Unparser::Base::ascendingTargetAddress </td>
          <td>(</td>
          <td class="paramtype">Partitioner2::ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Partitioner2::ControlFlowGraph::ConstEdgeIterator&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if edges are in order by target address. </p>
<p>If edge <code>a</code> has a target address that's less than the address of <code>b</code>, or if @ a has a target address and <code>b</code> has no target address, then return true; otherwise return false. Both edges must be valid edges, not end iterators. This defines the order that block suffixes are emitted. Target addresses are the first address of the target vertex. </p>

</div>
</div>
<a id="a74f831f7252a81989cb033067c904ea6" name="a74f831f7252a81989cb033067c904ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f831f7252a81989cb033067c904ea6">&#9670;&#160;</a></span>orderedBlockPredecessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; Partitioner2::ControlFlowGraph::ConstEdgeIterator &gt; Rose::BinaryAnalysis::Unparser::Base::orderedBlockPredecessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ordered incoming CFG edges. </p>
<p>Returns the incoming CFG edges for the specified basic block in the order that they should be displayed in the listing. The order is defined by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a247106c8311dd6af1bcadb13e846f9a8">ascendingSourceAddress</a>. </p>

</div>
</div>
<a id="ab67f33c7f4ab359a1a706975ad288928" name="ab67f33c7f4ab359a1a706975ad288928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67f33c7f4ab359a1a706975ad288928">&#9670;&#160;</a></span>orderedBlockSuccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; Partitioner2::ControlFlowGraph::ConstEdgeIterator &gt; Rose::BinaryAnalysis::Unparser::Base::orderedBlockSuccessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a461d763e33e7cf0364b64e0af0c267a0">Partitioner2::PartitionerConstPtr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae227a7c4cae4b57dc31f0dbbfaac051c">Partitioner2::BasicBlockPtr</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ordered outgoing CFG edges. </p>
<p>Returns the outgoing CFG edges for the specified basic block in the order that they should be displayed in the listing. The order is defined by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Unparser_1_1Base.html#a605c768d2209685fe16c8ebddb74be06">ascendingTargetAddress</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Unparser_2Base_8h_source.html">Unparser/Base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
