<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html">FunctionCallGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call information. </p>
<p>This class provides methods that operate on a function call graph, such as constructing a function call graph from a control flow graph. The graph vertices are function pointers (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9" title="Shared-ownership pointer for function.">Function::Ptr</a>) and the edges contain information about the type of inter-function edge (function call, function transfer, etc) and the number of such edges. <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call graphs can be built so that inter-function control transfer is represented by its own edge, or so that multiple transfers share an edge. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCallGraph_8h_source.html#l00021">21</a> of file <a class="el" href="FunctionCallGraph_8h_source.html">FunctionCallGraph.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="FunctionCallGraph_8h_source.html">Rose/BinaryAnalysis/Partitioner2/FunctionCallGraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about each edge in the call graph.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1VertexKey.html">VertexKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af33c6e120053200bb7b195a10e1a5a02" id="r_af33c6e120053200bb7b195a10e1a5a02"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1Edge.html">Edge</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1VertexKey.html">VertexKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af33c6e120053200bb7b195a10e1a5a02">Graph</a></td></tr>
<tr class="memdesc:af33c6e120053200bb7b195a10e1a5a02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call graph.  <br /></td></tr>
<tr class="separator:af33c6e120053200bb7b195a10e1a5a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a095af8f10bd07e93fd605a25c90354d3" id="r_a095af8f10bd07e93fd605a25c90354d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af33c6e120053200bb7b195a10e1a5a02">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a095af8f10bd07e93fd605a25c90354d3">graph</a> () const</td></tr>
<tr class="memdesc:a095af8f10bd07e93fd605a25c90354d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying function call graph.  <br /></td></tr>
<tr class="separator:a095af8f10bd07e93fd605a25c90354d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d7139583e0e315743358217e9ced68" id="r_aa9d7139583e0e315743358217e9ced68"><td class="memItemLeft" align="right" valign="top"><a id="aa9d7139583e0e315743358217e9ced68" name="aa9d7139583e0e315743358217e9ced68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FunctionCallGraph</b> ()</td></tr>
<tr class="memdesc:aa9d7139583e0e315743358217e9ced68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty function call graph. <br /></td></tr>
<tr class="separator:aa9d7139583e0e315743358217e9ced68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1aed66f255224872ff40cdb2230bc" id="r_a62b1aed66f255224872ff40cdb2230bc"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; Graph::ConstVertexValueIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a62b1aed66f255224872ff40cdb2230bc">functions</a> ()</td></tr>
<tr class="memdesc:a62b1aed66f255224872ff40cdb2230bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all functions in the call graph.  <br /></td></tr>
<tr class="separator:a62b1aed66f255224872ff40cdb2230bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a75118429136aacfcd7a9c0571d073" id="r_ad2a75118429136aacfcd7a9c0571d073"><td class="memItemLeft" align="right" valign="top">Graph::VertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#ad2a75118429136aacfcd7a9c0571d073">insertFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function)</td></tr>
<tr class="memdesc:ad2a75118429136aacfcd7a9c0571d073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a function vertex.  <br /></td></tr>
<tr class="separator:ad2a75118429136aacfcd7a9c0571d073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7246a7e10370468c10efa956c766347c" id="r_a7246a7e10370468c10efa956c766347c"><td class="memItemLeft" align="right" valign="top">Graph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a7246a7e10370468c10efa956c766347c">findFunction</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:a7246a7e10370468c10efa956c766347c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find function in call graph.  <br /></td></tr>
<tr class="separator:a7246a7e10370468c10efa956c766347c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6bd3c2bc45f62e18acfdebca972c5" id="r_af5c6bd3c2bc45f62e18acfdebca972c5"><td class="memItemLeft" align="right" valign="top">Graph::ConstVertexIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af5c6bd3c2bc45f62e18acfdebca972c5">findFunction</a> (rose_addr_t entryVa) const</td></tr>
<tr class="memdesc:af5c6bd3c2bc45f62e18acfdebca972c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find function in call graph.  <br /></td></tr>
<tr class="separator:af5c6bd3c2bc45f62e18acfdebca972c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac61337a357c4d6d98a2f0daeb1e6a22f" id="r_ac61337a357c4d6d98a2f0daeb1e6a22f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#ac61337a357c4d6d98a2f0daeb1e6a22f">exists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;function) const</td></tr>
<tr class="memdesc:ac61337a357c4d6d98a2f0daeb1e6a22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a function exists in the call graph.  <br /></td></tr>
<tr class="separator:ac61337a357c4d6d98a2f0daeb1e6a22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d908e2d93ea96f279a9e3308a0d849" id="r_ae3d908e2d93ea96f279a9e3308a0d849"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#ae3d908e2d93ea96f279a9e3308a0d849">exists</a> (rose_addr_t entryVa) const</td></tr>
<tr class="memdesc:ae3d908e2d93ea96f279a9e3308a0d849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a function exists in the call graph.  <br /></td></tr>
<tr class="separator:ae3d908e2d93ea96f279a9e3308a0d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a10295c22cf1f4b468b85c046712ea0b9" id="r_a10295c22cf1f4b468b85c046712ea0b9"><td class="memItemLeft" align="right" valign="top">Graph::EdgeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a10295c22cf1f4b468b85c046712ea0b9">insertCall</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;source, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;target, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a> type=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>, size_t edgeCount=0)</td></tr>
<tr class="memdesc:a10295c22cf1f4b468b85c046712ea0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a call edge.  <br /></td></tr>
<tr class="separator:a10295c22cf1f4b468b85c046712ea0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b16f1d3829670e81d519db5a3c20bf" id="r_a17b16f1d3829670e81d519db5a3c20bf"><td class="memItemLeft" align="right" valign="top">Graph::EdgeIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a17b16f1d3829670e81d519db5a3c20bf">insertCall</a> (const Graph::VertexIterator &amp;source, const Graph::VertexIterator &amp;target, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a> type=<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a>, size_t edgeCount=0)</td></tr>
<tr class="memdesc:a17b16f1d3829670e81d519db5a3c20bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a call edge.  <br /></td></tr>
<tr class="separator:a17b16f1d3829670e81d519db5a3c20bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2b1a49ddf24b14452a54b4208a49851c" id="r_a2b1a49ddf24b14452a54b4208a49851c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a2b1a49ddf24b14452a54b4208a49851c">callers</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;target) const</td></tr>
<tr class="memdesc:a2b1a49ddf24b14452a54b4208a49851c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all functions that call the specified function.  <br /></td></tr>
<tr class="separator:a2b1a49ddf24b14452a54b4208a49851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24fa1d1359b3d7496c59ea9cd5a9448" id="r_af24fa1d1359b3d7496c59ea9cd5a9448"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af24fa1d1359b3d7496c59ea9cd5a9448">callers</a> (const Graph::ConstVertexIterator &amp;target) const</td></tr>
<tr class="memdesc:af24fa1d1359b3d7496c59ea9cd5a9448"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all functions that call the specified function.  <br /></td></tr>
<tr class="separator:af24fa1d1359b3d7496c59ea9cd5a9448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f882a3edf60f09ea290c1ee4e902aaf" id="r_a6f882a3edf60f09ea290c1ee4e902aaf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a6f882a3edf60f09ea290c1ee4e902aaf">nCallers</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;target) const</td></tr>
<tr class="memdesc:a6f882a3edf60f09ea290c1ee4e902aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of functions that call the specified function.  <br /></td></tr>
<tr class="separator:a6f882a3edf60f09ea290c1ee4e902aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a58477500f755b7abbea3996f163325" id="r_a1a58477500f755b7abbea3996f163325"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a1a58477500f755b7abbea3996f163325">nCallers</a> (const Graph::ConstVertexIterator &amp;target) const</td></tr>
<tr class="memdesc:a1a58477500f755b7abbea3996f163325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of functions that call the specified function.  <br /></td></tr>
<tr class="separator:a1a58477500f755b7abbea3996f163325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a30b3f39031933d457f55e27ec4cffe6d" id="r_a30b3f39031933d457f55e27ec4cffe6d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a30b3f39031933d457f55e27ec4cffe6d">callees</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;source) const</td></tr>
<tr class="memdesc:a30b3f39031933d457f55e27ec4cffe6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all functions called by the specified function.  <br /></td></tr>
<tr class="separator:a30b3f39031933d457f55e27ec4cffe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa514a2d44856b2926a42813f8fa21af5" id="r_aa514a2d44856b2926a42813f8fa21af5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#aa514a2d44856b2926a42813f8fa21af5">callees</a> (const Graph::ConstVertexIterator &amp;source) const</td></tr>
<tr class="memdesc:aa514a2d44856b2926a42813f8fa21af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all functions called by the specified function.  <br /></td></tr>
<tr class="separator:aa514a2d44856b2926a42813f8fa21af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aca534349f0c5cd58c45a151d58deec02" id="r_aca534349f0c5cd58c45a151d58deec02"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#aca534349f0c5cd58c45a151d58deec02">nCallees</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;source) const</td></tr>
<tr class="memdesc:aca534349f0c5cd58c45a151d58deec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of functions that the specified function calls.  <br /></td></tr>
<tr class="separator:aca534349f0c5cd58c45a151d58deec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1553e72e9143797d6e956c1293a6f7" id="r_a5e1553e72e9143797d6e956c1293a6f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a5e1553e72e9143797d6e956c1293a6f7">nCallees</a> (const Graph::ConstVertexIterator &amp;source) const</td></tr>
<tr class="memdesc:a5e1553e72e9143797d6e956c1293a6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of functions that the specified function calls.  <br /></td></tr>
<tr class="separator:a5e1553e72e9143797d6e956c1293a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a865aac6eb467bdcfab5bb9f14de454fb" id="r_a865aac6eb467bdcfab5bb9f14de454fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a865aac6eb467bdcfab5bb9f14de454fb">nCallsIn</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;target) const</td></tr>
<tr class="memdesc:a865aac6eb467bdcfab5bb9f14de454fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls to a function.  <br /></td></tr>
<tr class="separator:a865aac6eb467bdcfab5bb9f14de454fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa71d1b2336ecc28620b4a4cb3b291f" id="r_a5fa71d1b2336ecc28620b4a4cb3b291f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a5fa71d1b2336ecc28620b4a4cb3b291f">nCallsIn</a> (const Graph::ConstVertexIterator &amp;target) const</td></tr>
<tr class="memdesc:a5fa71d1b2336ecc28620b4a4cb3b291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls to a function.  <br /></td></tr>
<tr class="separator:a5fa71d1b2336ecc28620b4a4cb3b291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9cb0604087fd87de756ae185ad2965ae" id="r_a9cb0604087fd87de756ae185ad2965ae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a9cb0604087fd87de756ae185ad2965ae">nCallsOut</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;source) const</td></tr>
<tr class="memdesc:a9cb0604087fd87de756ae185ad2965ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls from a function.  <br /></td></tr>
<tr class="separator:a9cb0604087fd87de756ae185ad2965ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52c71761320017a56ff70b55015a65" id="r_a1f52c71761320017a56ff70b55015a65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a1f52c71761320017a56ff70b55015a65">nCallsOut</a> (const Graph::ConstVertexIterator &amp;source) const</td></tr>
<tr class="memdesc:a1f52c71761320017a56ff70b55015a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of calls from a function.  <br /></td></tr>
<tr class="separator:a1f52c71761320017a56ff70b55015a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a53e1efc3bb74282d30ac6641be004dde" id="r_a53e1efc3bb74282d30ac6641be004dde"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a53e1efc3bb74282d30ac6641be004dde">nCalls</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;source, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;target) const</td></tr>
<tr class="memdesc:a53e1efc3bb74282d30ac6641be004dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of calls between two specific functions.  <br /></td></tr>
<tr class="separator:a53e1efc3bb74282d30ac6641be004dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571a087932287875efaef13101d25286" id="r_a571a087932287875efaef13101d25286"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#a571a087932287875efaef13101d25286">nCalls</a> (const Graph::ConstVertexIterator &amp;source, const Graph::ConstVertexIterator &amp;target) const</td></tr>
<tr class="memdesc:a571a087932287875efaef13101d25286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of calls between two specific functions.  <br /></td></tr>
<tr class="separator:a571a087932287875efaef13101d25286"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af33c6e120053200bb7b195a10e1a5a02" name="af33c6e120053200bb7b195a10e1a5a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33c6e120053200bb7b195a10e1a5a02">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">Sawyer::Container::Graph</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1Edge.html">Edge</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph_1_1VertexKey.html">VertexKey</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af33c6e120053200bb7b195a10e1a5a02">Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> call graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCallGraph_8h_source.html#l00048">48</a> of file <a class="el" href="FunctionCallGraph_8h_source.html">FunctionCallGraph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a095af8f10bd07e93fd605a25c90354d3" name="a095af8f10bd07e93fd605a25c90354d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095af8f10bd07e93fd605a25c90354d3">&#9670;&#160;</a></span>graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1FunctionCallGraph.html#af33c6e120053200bb7b195a10e1a5a02">Graph</a> &amp; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Underlying function call graph. </p>
<p>This returns the <a class="el" href="classSawyer_1_1Container_1_1Graph.html" title="Graph containing user-defined vertices and edges.">Sawyer::Container::Graph</a> representing inter-function edges. It is read-only since modifying the graph must be done in conjunction with updating the function-to-vertex index. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCallGraph_8h_source.html#l00058">58</a> of file <a class="el" href="FunctionCallGraph_8h_source.html">FunctionCallGraph.h</a>.</p>

</div>
</div>
<a id="a62b1aed66f255224872ff40cdb2230bc" name="a62b1aed66f255224872ff40cdb2230bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b1aed66f255224872ff40cdb2230bc">&#9670;&#160;</a></span>functions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; Graph::ConstVertexValueIterator &gt; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::functions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all functions in the call graph. </p>

<p class="definition">Definition at line <a class="el" href="FunctionCallGraph_8h_source.html#l00066">66</a> of file <a class="el" href="FunctionCallGraph_8h_source.html">FunctionCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="Graph_8h_source.html#l01565">Sawyer::Container::Graph&lt; V, E, VKey, EKey, Alloc &gt;::vertexValues()</a>.</p>

</div>
</div>
<a id="a7246a7e10370468c10efa956c766347c" name="a7246a7e10370468c10efa956c766347c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7246a7e10370468c10efa956c766347c">&#9670;&#160;</a></span>findFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::findFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find function in call graph. </p>
<p>Returns the call graph vertex (as an iterator) for the specified function, or the end vertex iterator if the function does not exist in the call graph. The function can be specified by its pointer or entry address. </p>

</div>
</div>
<a id="af5c6bd3c2bc45f62e18acfdebca972c5" name="af5c6bd3c2bc45f62e18acfdebca972c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c6bd3c2bc45f62e18acfdebca972c5">&#9670;&#160;</a></span>findFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::ConstVertexIterator Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::findFunction </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>entryVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find function in call graph. </p>
<p>Returns the call graph vertex (as an iterator) for the specified function, or the end vertex iterator if the function does not exist in the call graph. The function can be specified by its pointer or entry address. </p>

</div>
</div>
<a id="ac61337a357c4d6d98a2f0daeb1e6a22f" name="ac61337a357c4d6d98a2f0daeb1e6a22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61337a357c4d6d98a2f0daeb1e6a22f">&#9670;&#160;</a></span>exists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a function exists in the call graph. </p>
<p>Returns true if the function is a member of the call graph and false otherwise. A function can be a member of a call graph even if it has no incident edges. </p>

</div>
</div>
<a id="ae3d908e2d93ea96f279a9e3308a0d849" name="ae3d908e2d93ea96f279a9e3308a0d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d908e2d93ea96f279a9e3308a0d849">&#9670;&#160;</a></span>exists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::exists </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>entryVa</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a function exists in the call graph. </p>
<p>Returns true if the function is a member of the call graph and false otherwise. A function can be a member of a call graph even if it has no incident edges. </p>

</div>
</div>
<a id="ad2a75118429136aacfcd7a9c0571d073" name="ad2a75118429136aacfcd7a9c0571d073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a75118429136aacfcd7a9c0571d073">&#9670;&#160;</a></span>insertFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::VertexIterator Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::insertFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a function vertex. </p>
<p>Inserts the specified function into the call graph if it is not a member of the call graph, otherwise does nothing. In any case, it returns the vertex for the function. </p>

</div>
</div>
<a id="a10295c22cf1f4b468b85c046712ea0b9" name="a10295c22cf1f4b468b85c046712ea0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10295c22cf1f4b468b85c046712ea0b9">&#9670;&#160;</a></span>insertCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::EdgeIterator Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::insertCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeCount</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a call edge. </p>
<p>Inserts an edge representing a call from source (caller) to target (callee). The <code>type</code> can be <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5">E_FUNCTION_XFER</a>.</p>
<p>If <code>edgeCount</code> is non-zero and an edge of the correct type already exists between the <code>source</code> and <code>target</code>, then the count on that edge is incremented instead. Otherwise, when <code>edgeCount</code> is zero, a new edge with unit count is inserted even if it means creating an edge parallel to an existing edge.</p>
<p>Returns the edge that was inserted or incremented. </p>

</div>
</div>
<a id="a17b16f1d3829670e81d519db5a3c20bf" name="a17b16f1d3829670e81d519db5a3c20bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b16f1d3829670e81d519db5a3c20bf">&#9670;&#160;</a></span>insertCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::EdgeIterator Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::insertCall </td>
          <td>(</td>
          <td class="paramtype">const Graph::VertexIterator &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph::VertexIterator &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9">EdgeType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeCount</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a call edge. </p>
<p>Inserts an edge representing a call from source (caller) to target (callee). The <code>type</code> can be <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a4047f3536c492ccf71816eb8bb15c5b0">E_FUNCTION_CALL</a> or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a8c65d98b5dc4b8b62b640a77af63f6a9a6b0dc01951e022f4c28c824bc91d45f5">E_FUNCTION_XFER</a>.</p>
<p>If <code>edgeCount</code> is non-zero and an edge of the correct type already exists between the <code>source</code> and <code>target</code>, then the count on that edge is incremented instead. Otherwise, when <code>edgeCount</code> is zero, a new edge with unit count is inserted even if it means creating an edge parallel to an existing edge.</p>
<p>Returns the edge that was inserted or incremented. </p>

</div>
</div>
<a id="a2b1a49ddf24b14452a54b4208a49851c" name="a2b1a49ddf24b14452a54b4208a49851c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1a49ddf24b14452a54b4208a49851c">&#9670;&#160;</a></span>callers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::callers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all functions that call the specified function. </p>
<p>Returns a sorted list of distinct functions that call the specified function. </p>

</div>
</div>
<a id="af24fa1d1359b3d7496c59ea9cd5a9448" name="af24fa1d1359b3d7496c59ea9cd5a9448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24fa1d1359b3d7496c59ea9cd5a9448">&#9670;&#160;</a></span>callers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::callers </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all functions that call the specified function. </p>
<p>Returns a sorted list of distinct functions that call the specified function. </p>

</div>
</div>
<a id="a6f882a3edf60f09ea290c1ee4e902aaf" name="a6f882a3edf60f09ea290c1ee4e902aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f882a3edf60f09ea290c1ee4e902aaf">&#9670;&#160;</a></span>nCallers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of functions that call the specified function. </p>
<p>This is the number of distinct functions that call the specified <code>target</code> function. </p>

</div>
</div>
<a id="a1a58477500f755b7abbea3996f163325" name="a1a58477500f755b7abbea3996f163325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a58477500f755b7abbea3996f163325">&#9670;&#160;</a></span>nCallers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallers </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of functions that call the specified function. </p>
<p>This is the number of distinct functions that call the specified <code>target</code> function. </p>

</div>
</div>
<a id="a30b3f39031933d457f55e27ec4cffe6d" name="a30b3f39031933d457f55e27ec4cffe6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3f39031933d457f55e27ec4cffe6d">&#9670;&#160;</a></span>callees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::callees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all functions called by the specified function. </p>
<p>Returns a sorted list of distinct functions that call the function specified by entry address or call graph vertex. If the specified function does not exist in the call graph then an empty list is returned. </p>

</div>
</div>
<a id="aa514a2d44856b2926a42813f8fa21af5" name="aa514a2d44856b2926a42813f8fa21af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa514a2d44856b2926a42813f8fa21af5">&#9670;&#160;</a></span>callees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &gt; Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::callees </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all functions called by the specified function. </p>
<p>Returns a sorted list of distinct functions that call the function specified by entry address or call graph vertex. If the specified function does not exist in the call graph then an empty list is returned. </p>

</div>
</div>
<a id="aca534349f0c5cd58c45a151d58deec02" name="aca534349f0c5cd58c45a151d58deec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca534349f0c5cd58c45a151d58deec02">&#9670;&#160;</a></span>nCallees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of functions that the specified function calls. </p>
<p>This is the number of distinct functions called from the specified <code>source</code> function. </p>

</div>
</div>
<a id="a5e1553e72e9143797d6e956c1293a6f7" name="a5e1553e72e9143797d6e956c1293a6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1553e72e9143797d6e956c1293a6f7">&#9670;&#160;</a></span>nCallees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallees </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of functions that the specified function calls. </p>
<p>This is the number of distinct functions called from the specified <code>source</code> function. </p>

</div>
</div>
<a id="a865aac6eb467bdcfab5bb9f14de454fb" name="a865aac6eb467bdcfab5bb9f14de454fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865aac6eb467bdcfab5bb9f14de454fb">&#9670;&#160;</a></span>nCallsIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallsIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of calls to a function. </p>
<p>Returns the total number of calls to the specified function, counting each call when a single function calls more than once. I.e., it is the sum of the <code>count</code> fields of all the incoming edges for <code>target</code>. </p>

</div>
</div>
<a id="a5fa71d1b2336ecc28620b4a4cb3b291f" name="a5fa71d1b2336ecc28620b4a4cb3b291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa71d1b2336ecc28620b4a4cb3b291f">&#9670;&#160;</a></span>nCallsIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallsIn </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of calls to a function. </p>
<p>Returns the total number of calls to the specified function, counting each call when a single function calls more than once. I.e., it is the sum of the <code>count</code> fields of all the incoming edges for <code>target</code>. </p>

</div>
</div>
<a id="a9cb0604087fd87de756ae185ad2965ae" name="a9cb0604087fd87de756ae185ad2965ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb0604087fd87de756ae185ad2965ae">&#9670;&#160;</a></span>nCallsOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallsOut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of calls from a function. </p>
<p>Returns the total number of calls from the specified function, counting each call when a single function is called more than once. I.e., it is the sum of the <code>count</code> fields of all the outgoing edges for <code>source</code>. </p>

</div>
</div>
<a id="a1f52c71761320017a56ff70b55015a65" name="a1f52c71761320017a56ff70b55015a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52c71761320017a56ff70b55015a65">&#9670;&#160;</a></span>nCallsOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCallsOut </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of calls from a function. </p>
<p>Returns the total number of calls from the specified function, counting each call when a single function is called more than once. I.e., it is the sum of the <code>count</code> fields of all the outgoing edges for <code>source</code>. </p>

</div>
</div>
<a id="a53e1efc3bb74282d30ac6641be004dde" name="a53e1efc3bb74282d30ac6641be004dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e1efc3bb74282d30ac6641be004dde">&#9670;&#160;</a></span>nCalls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCalls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of calls between two specific functions. </p>
<p>This is the sum of the <code>count</code> fields for all edges between <code>source</code> and <code>target</code>. </p>

</div>
</div>
<a id="a571a087932287875efaef13101d25286" name="a571a087932287875efaef13101d25286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571a087932287875efaef13101d25286">&#9670;&#160;</a></span>nCalls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Partitioner2::FunctionCallGraph::nCalls </td>
          <td>(</td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph::ConstVertexIterator &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of calls between two specific functions. </p>
<p>This is the sum of the <code>count</code> fields for all edges between <code>source</code> and <code>target</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FunctionCallGraph_8h_source.html">FunctionCallGraph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
