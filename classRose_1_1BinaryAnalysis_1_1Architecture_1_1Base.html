<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Architecture::Base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html">Architecture</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html">Base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Architecture::Base Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html" title="Base class for architecture definitions.">Base</a> class for architecture definitions. </p>

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00022">22</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Architecture_2Base_8h_source.html">Rose/BinaryAnalysis/Architecture/Base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Architecture::Base:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_inherit__map">
<area shape="rect" title="Base class for architecture definitions." alt="" coords="191,165,339,205"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html" title="Architecture&#45;specific information for the Common Intermediate Language." alt="" coords="392,5,540,45"/>
<area shape="poly" title=" " alt="" coords="286,153,329,103,356,78,385,55,406,43,409,48,388,60,359,82,333,107,290,156"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html" title="Architecture&#45;specific information for the Java virtual machine." alt="" coords="392,69,540,109"/>
<area shape="poly" title=" " alt="" coords="311,157,386,119,413,107,415,112,388,124,314,161"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html" title="Architecture&#45;specific information for MIPS with 32&#45;bit word size." alt="" coords="391,133,541,173"/>
<area shape="poly" title=" " alt="" coords="352,169,390,163,391,168,353,174"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html" title="Base class for Motorola processors." alt="" coords="387,197,545,237"/>
<area shape="poly" title=" " alt="" coords="353,197,387,202,386,207,352,202"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html" title="Base class for PowerPC architectures." alt="" coords="387,261,545,301"/>
<area shape="poly" title=" " alt="" coords="314,209,388,247,415,259,413,264,386,252,311,214"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html" title="Common base class for all x86 architectures." alt="" coords="392,325,540,365"/>
<area shape="poly" title=" " alt="" coords="290,214,333,263,359,289,388,311,409,323,406,328,385,316,356,293,329,267,286,218"/>
<area shape="rect" title=" " alt="" coords="5,165,143,205"/>
<area shape="poly" title=" " alt="" coords="156,183,190,183,190,188,156,188"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Architecture::Base:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_coll__map" id="aRose_1_1BinaryAnalysis_1_1Architecture_1_1Base_coll__map">
<area shape="rect" title="Base class for architecture definitions." alt="" coords="412,99,560,139"/>
<area shape="rect" title=" " alt="" coords="55,5,193,45"/>
<area shape="poly" title=" " alt="" coords="206,21,296,29,343,37,389,51,430,72,464,96,461,101,427,76,387,56,342,43,295,34,206,27"/>
<area shape="rect" href="classSawyer_1_1Cached.html" title=" " alt="" coords="17,69,231,109"/>
<area shape="poly" title=" " alt="" coords="245,96,412,110,412,115,244,102"/>
<area shape="rect" href="classSawyer_1_1Cached.html" title=" " alt="" coords="5,133,243,173"/>
<area shape="poly" title=" " alt="" coords="256,140,388,128,411,125,412,131,388,133,257,146"/>
<area shape="rect" href="classSawyer_1_1Cached.html" title=" " alt="" coords="37,203,211,243"/>
<area shape="poly" title=" " alt="" coords="225,221,306,212,347,203,387,190,430,165,464,137,468,141,433,170,389,194,349,208,307,217,226,226"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac32fb431b1823b94185281598a6c2c03" id="r_ac32fb431b1823b94185281598a6c2c03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a025b1c1e4df943f851e04a421f9efe27">BasePtr</a></td></tr>
<tr class="memdesc:ac32fb431b1823b94185281598a6c2c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer.  <br /></td></tr>
<tr class="separator:ac32fb431b1823b94185281598a6c2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2ec9662e6ae405e8db81bf555f79f" id="r_a5bc2ec9662e6ae405e8db81bf555f79f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a> = <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">BaseConstPtr</a></td></tr>
<tr class="memdesc:a5bc2ec9662e6ae405e8db81bf555f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting pointer to const object.  <br /></td></tr>
<tr class="separator:a5bc2ec9662e6ae405e8db81bf555f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7758dd9b3ef45fe3bbacde31f25e0510" id="r_a7758dd9b3ef45fe3bbacde31f25e0510"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a> () const</td></tr>
<tr class="memdesc:a7758dd9b3ef45fe3bbacde31f25e0510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> definition name.  <br /></td></tr>
<tr class="separator:a7758dd9b3ef45fe3bbacde31f25e0510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fb30e615b5afd19f867e66768b7688" id="r_a02fb30e615b5afd19f867e66768b7688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a> () const</td></tr>
<tr class="memdesc:a02fb30e615b5afd19f867e66768b7688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Byte order for memory.  <br /></td></tr>
<tr class="separator:a02fb30e615b5afd19f867e66768b7688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a80559e394e92b20bbaf76951d5900" id="r_a06a80559e394e92b20bbaf76951d5900"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a06a80559e394e92b20bbaf76951d5900">registerDictionary</a> () const =0</td></tr>
<tr class="memdesc:a06a80559e394e92b20bbaf76951d5900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Register dictionary.  <br /></td></tr>
<tr class="separator:a06a80559e394e92b20bbaf76951d5900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47215e1c00810f5afb82f4bc04af5e4" id="r_ab47215e1c00810f5afb82f4bc04af5e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab47215e1c00810f5afb82f4bc04af5e4">interruptDictionary</a> () const</td></tr>
<tr class="memdesc:ab47215e1c00810f5afb82f4bc04af5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Interrupt dictionary.  <br /></td></tr>
<tr class="separator:ab47215e1c00810f5afb82f4bc04af5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000e445cbf23f56532f1bc5c7609dbac" id="r_a000e445cbf23f56532f1bc5c7609dbac"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a000e445cbf23f56532f1bc5c7609dbac">callingConventions</a> () const</td></tr>
<tr class="memdesc:a000e445cbf23f56532f1bc5c7609dbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Calling convention definitions.  <br /></td></tr>
<tr class="separator:a000e445cbf23f56532f1bc5c7609dbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7c3793592de8dfe7108c76245850c" id="r_a08f7c3793592de8dfe7108c76245850c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08f7c3793592de8dfe7108c76245850c">matchesName</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:a08f7c3793592de8dfe7108c76245850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a name.  <br /></td></tr>
<tr class="separator:a08f7c3793592de8dfe7108c76245850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3611147dd3024b6d0de51ce006740f" id="r_adc3611147dd3024b6d0de51ce006740f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#adc3611147dd3024b6d0de51ce006740f">matchesHeader</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *) const</td></tr>
<tr class="memdesc:adc3611147dd3024b6d0de51ce006740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this architecture matches a file header.  <br /></td></tr>
<tr class="separator:adc3611147dd3024b6d0de51ce006740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e848a4594e882ab63f9a68cdb68c170" id="r_a3e848a4594e882ab63f9a68cdb68c170"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e848a4594e882ab63f9a68cdb68c170">newInstructionDecoder</a> () const =0</td></tr>
<tr class="memdesc:a3e848a4594e882ab63f9a68cdb68c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction decoder.  <br /></td></tr>
<tr class="separator:a3e848a4594e882ab63f9a68cdb68c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59df18db2baae88452946dc47fa28a66" id="r_a59df18db2baae88452946dc47fa28a66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a59df18db2baae88452946dc47fa28a66">newUnparser</a> () const =0</td></tr>
<tr class="memdesc:a59df18db2baae88452946dc47fa28a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction unparser.  <br /></td></tr>
<tr class="separator:a59df18db2baae88452946dc47fa28a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f7bc3595c3d4258ba834ae991008d2" id="r_ac9f7bc3595c3d4258ba834ae991008d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9f7bc3595c3d4258ba834ae991008d2">newInstructionDispatcher</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ac9f7bc3595c3d4258ba834ae991008d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a new instruction dispatcher.  <br /></td></tr>
<tr class="separator:ac9f7bc3595c3d4258ba834ae991008d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7166b2e3ad595362e876ccda9ce2dd57" id="r_a7166b2e3ad595362e876ccda9ce2dd57"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7166b2e3ad595362e876ccda9ce2dd57">bytesPerInstruction</a> () const =0</td></tr>
<tr class="memdesc:a7166b2e3ad595362e876ccda9ce2dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid sizes for encoded machine instructions.  <br /></td></tr>
<tr class="separator:a7166b2e3ad595362e876ccda9ce2dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac610db2e1ce4866facad301b677e48" id="r_a8ac610db2e1ce4866facad301b677e48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8ac610db2e1ce4866facad301b677e48">instructionAlignment</a> () const =0</td></tr>
<tr class="memdesc:a8ac610db2e1ce4866facad301b677e48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions.  <br /></td></tr>
<tr class="separator:a8ac610db2e1ce4866facad301b677e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73177355070eeb5741e5bcbc9fc56f1" id="r_ad73177355070eeb5741e5bcbc9fc56f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ad73177355070eeb5741e5bcbc9fc56f1">instructionsCanOverlap</a> () const</td></tr>
<tr class="memdesc:ad73177355070eeb5741e5bcbc9fc56f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether instructions can overlap in memory.  <br /></td></tr>
<tr class="separator:ad73177355070eeb5741e5bcbc9fc56f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a56b4c385168bcf6804478700cc54ae" id="r_a3a56b4c385168bcf6804478700cc54ae"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3a56b4c385168bcf6804478700cc54ae">instructionMnemonic</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const =0</td></tr>
<tr class="memdesc:a3a56b4c385168bcf6804478700cc54ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mnemonic for an instruction.  <br /></td></tr>
<tr class="separator:a3a56b4c385168bcf6804478700cc54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2b8bd1499cc492f7e844f188ae970" id="r_a08e2b8bd1499cc492f7e844f188ae970"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a08e2b8bd1499cc492f7e844f188ae970">instructionDescription</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a08e2b8bd1499cc492f7e844f188ae970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description for an instruction.  <br /></td></tr>
<tr class="separator:a08e2b8bd1499cc492f7e844f188ae970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e44136d49e87a71ca1ffaa468439fb" id="r_a76e44136d49e87a71ca1ffaa468439fb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a76e44136d49e87a71ca1ffaa468439fb">isUnknown</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const =0</td></tr>
<tr class="memdesc:a76e44136d49e87a71ca1ffaa468439fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instruction is the special "unknown" instruction.  <br /></td></tr>
<tr class="separator:a76e44136d49e87a71ca1ffaa468439fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcbce03aea244dc9e5d9ac60554f000" id="r_a1fcbce03aea244dc9e5d9ac60554f000"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1fcbce03aea244dc9e5d9ac60554f000">terminatesBasicBlock</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const =0</td></tr>
<tr class="memdesc:a1fcbce03aea244dc9e5d9ac60554f000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the specified instruction normally terminates a basic block.  <br /></td></tr>
<tr class="separator:a1fcbce03aea244dc9e5d9ac60554f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743b63088a626a602c6e9bcc3a054797" id="r_a743b63088a626a602c6e9bcc3a054797"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a743b63088a626a602c6e9bcc3a054797">branchTarget</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a743b63088a626a602c6e9bcc3a054797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the virtual address for a branching instruction.  <br /></td></tr>
<tr class="separator:a743b63088a626a602c6e9bcc3a054797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57d491fecd502be6b814fcbf0be6d58" id="r_aa57d491fecd502be6b814fcbf0be6d58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aa57d491fecd502be6b814fcbf0be6d58">getSuccessors</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *, bool &amp;complete) const</td></tr>
<tr class="memdesc:aa57d491fecd502be6b814fcbf0be6d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a single instruction.  <br /></td></tr>
<tr class="separator:aa57d491fecd502be6b814fcbf0be6d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c963c4b3bb04cd747f9c84de49a48d2" id="r_a9c963c4b3bb04cd747f9c84de49a48d2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Partitioner2::FunctionPrologueMatcherPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9c963c4b3bb04cd747f9c84de49a48d2">functionPrologueMatchers</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a9c963c4b3bb04cd747f9c84de49a48d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction patterns matching function prologues.  <br /></td></tr>
<tr class="separator:a9c963c4b3bb04cd747f9c84de49a48d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db9046dabe9c47b53219f28941a082" id="r_a30db9046dabe9c47b53219f28941a082"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Partitioner2::BasicBlockCallbackPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a30db9046dabe9c47b53219f28941a082">basicBlockCreationHooks</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a30db9046dabe9c47b53219f28941a082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific basic block callbacks for partitioning.  <br /></td></tr>
<tr class="separator:a30db9046dabe9c47b53219f28941a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f3e45432a5fb2e8a109c0d6118a0d62" id="r_a5f3e45432a5fb2e8a109c0d6118a0d62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5f3e45432a5fb2e8a109c0d6118a0d62">registrationId</a> () const</td></tr>
<tr class="memdesc:a5f3e45432a5fb2e8a109c0d6118a0d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:a5f3e45432a5fb2e8a109c0d6118a0d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc31f520eac844e49767d0afe1ccf1fe" id="r_abc31f520eac844e49767d0afe1ccf1fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abc31f520eac844e49767d0afe1ccf1fe">registrationId</a> (const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;)</td></tr>
<tr class="memdesc:abc31f520eac844e49767d0afe1ccf1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Registration identification number.  <br /></td></tr>
<tr class="separator:abc31f520eac844e49767d0afe1ccf1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73b51aa09fc1b1a71c7f66346359d28b" id="r_a73b51aa09fc1b1a71c7f66346359d28b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a> () const</td></tr>
<tr class="memdesc:a73b51aa09fc1b1a71c7f66346359d28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a73b51aa09fc1b1a71c7f66346359d28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee891ea7b9a61214b14496e263bb948" id="r_a1ee891ea7b9a61214b14496e263bb948"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a1ee891ea7b9a61214b14496e263bb948">bitsPerWord</a> () const</td></tr>
<tr class="memdesc:a1ee891ea7b9a61214b14496e263bb948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Word size.  <br /></td></tr>
<tr class="separator:a1ee891ea7b9a61214b14496e263bb948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9a80fb8df16e13c9333b0227620c90a2" id="r_a9a80fb8df16e13c9333b0227620c90a2"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a9a80fb8df16e13c9333b0227620c90a2">toString</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:a9a80fb8df16e13c9333b0227620c90a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:a9a80fb8df16e13c9333b0227620c90a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7b2dad38bc3c6ca9fbb23096479292" id="r_aab7b2dad38bc3c6ca9fbb23096479292"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#aab7b2dad38bc3c6ca9fbb23096479292">toStringNoAddr</a> (const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *) const</td></tr>
<tr class="memdesc:aab7b2dad38bc3c6ca9fbb23096479292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse an instruction to a string.  <br /></td></tr>
<tr class="separator:aab7b2dad38bc3c6ca9fbb23096479292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7752a2ed38493ccb13a369c78d23988" id="r_ab7752a2ed38493ccb13a369c78d23988"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ab7752a2ed38493ccb13a369c78d23988">isFunctionCallFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const</td></tr>
<tr class="memdesc:ab7752a2ed38493ccb13a369c78d23988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:ab7752a2ed38493ccb13a369c78d23988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8d8c8b916e00cefa0f1b7634c1d839" id="r_a3e8d8c8b916e00cefa0f1b7634c1d839"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a3e8d8c8b916e00cefa0f1b7634c1d839">isFunctionCallSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;, rose_addr_t *target, rose_addr_t *ret) const</td></tr>
<tr class="memdesc:a3e8d8c8b916e00cefa0f1b7634c1d839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function call.  <br /></td></tr>
<tr class="separator:a3e8d8c8b916e00cefa0f1b7634c1d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abea57c49d0420f037021ff7b7afecd16" id="r_abea57c49d0420f037021ff7b7afecd16"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#abea57c49d0420f037021ff7b7afecd16">isFunctionReturnFast</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const</td></tr>
<tr class="memdesc:abea57c49d0420f037021ff7b7afecd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:abea57c49d0420f037021ff7b7afecd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf86e9095b6f586e06c65b99a14d44" id="r_a8abf86e9095b6f586e06c65b99a14d44"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a8abf86e9095b6f586e06c65b99a14d44">isFunctionReturnSlow</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;) const</td></tr>
<tr class="memdesc:a8abf86e9095b6f586e06c65b99a14d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified basic block looks like a function return.  <br /></td></tr>
<tr class="separator:a8abf86e9095b6f586e06c65b99a14d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0e39bd2d1ac89476495a77ba0ea1dbca" id="r_a0e39bd2d1ac89476495a77ba0ea1dbca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a0e39bd2d1ac89476495a77ba0ea1dbca">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete) const</td></tr>
<tr class="memdesc:a0e39bd2d1ac89476495a77ba0ea1dbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a0e39bd2d1ac89476495a77ba0ea1dbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a12a9280fadaea065516e3c0cb88b" id="r_a584a12a9280fadaea065516e3c0cb88b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a584a12a9280fadaea065516e3c0cb88b">getSuccessors</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;basicBlock, bool &amp;complete, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;initial_memory) const</td></tr>
<tr class="memdesc:a584a12a9280fadaea065516e3c0cb88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control flow successors for a basic block.  <br /></td></tr>
<tr class="separator:a584a12a9280fadaea065516e3c0cb88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a62d3f5f251ba258b83d8c63e84d72059" id="r_a62d3f5f251ba258b83d8c63e84d72059"><td class="memItemLeft" align="right" valign="top"><a id="a62d3f5f251ba258b83d8c63e84d72059" name="a62d3f5f251ba258b83d8c63e84d72059"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a7758dd9b3ef45fe3bbacde31f25e0510">name</a>, size_t <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a73b51aa09fc1b1a71c7f66346359d28b">bytesPerWord</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a02fb30e615b5afd19f867e66768b7688">byteOrder</a>)</td></tr>
<tr class="separator:a62d3f5f251ba258b83d8c63e84d72059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98621d1e395d5fca985c902287ec4f" id="r_a4a98621d1e395d5fca985c902287ec4f"><td class="memItemLeft" align="right" valign="top"><a id="a4a98621d1e395d5fca985c902287ec4f" name="a4a98621d1e395d5fca985c902287ec4f"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> ()</td></tr>
<tr class="separator:a4a98621d1e395d5fca985c902287ec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584136739b4573a9388e3903faafc562" id="r_a584136739b4573a9388e3903faafc562"><td class="memItemLeft" align="right" valign="top"><a id="a584136739b4573a9388e3903faafc562" name="a584136739b4573a9388e3903faafc562"></a>
<a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">ConstPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constPtr</b> () const</td></tr>
<tr class="separator:a584136739b4573a9388e3903faafc562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a23bc5455bc3df509e90af8f2337557ee" id="r_a23bc5455bc3df509e90af8f2337557ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a23bc5455bc3df509e90af8f2337557ee">registerDictionary_</a></td></tr>
<tr class="separator:a23bc5455bc3df509e90af8f2337557ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d3a8eb56136dfe58220836faa3f21" id="r_a058d3a8eb56136dfe58220836faa3f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a058d3a8eb56136dfe58220836faa3f21">interruptDictionary_</a></td></tr>
<tr class="separator:a058d3a8eb56136dfe58220836faa3f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9579050251c6bf0c3c836b0b999e7e0" id="r_ac9579050251c6bf0c3c836b0b999e7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac9579050251c6bf0c3c836b0b999e7e0">callingConventions_</a></td></tr>
<tr class="separator:ac9579050251c6bf0c3c836b0b999e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8432d213970666c785032171830d01" id="r_afe8432d213970666c785032171830d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#afe8432d213970666c785032171830d01">insnToString_</a></td></tr>
<tr class="separator:afe8432d213970666c785032171830d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dab3a55bc698d073cd54e190c4b459" id="r_a36dab3a55bc698d073cd54e190c4b459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a36dab3a55bc698d073cd54e190c4b459">insnToStringNoAddr_</a></td></tr>
<tr class="separator:a36dab3a55bc698d073cd54e190c4b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac32fb431b1823b94185281598a6c2c03" name="ac32fb431b1823b94185281598a6c2c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32fb431b1823b94185281598a6c2c03">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#ac32fb431b1823b94185281598a6c2c03">Rose::BinaryAnalysis::Architecture::Base::Ptr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a025b1c1e4df943f851e04a421f9efe27">BasePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer. </p>

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00025">25</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<a id="a5bc2ec9662e6ae405e8db81bf555f79f" name="a5bc2ec9662e6ae405e8db81bf555f79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc2ec9662e6ae405e8db81bf555f79f">&#9670;&#160;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Base.html#a5bc2ec9662e6ae405e8db81bf555f79f">Rose::BinaryAnalysis::Architecture::Base::ConstPtr</a> =  <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#aa711fd8ae3f4eb3297e6c8cfacdf952d">BaseConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference counting pointer to const object. </p>

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00028">28</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7758dd9b3ef45fe3bbacde31f25e0510" name="a7758dd9b3ef45fe3bbacde31f25e0510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7758dd9b3ef45fe3bbacde31f25e0510">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Architecture::Base::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html" title="Architecture-specific information and algorithms.">Architecture</a> definition name. </p>
<p>The name is used for lookups, but it need not be unique since lookups prefer the latest registered architecture. I.e., if two architectures A, and B, have the same name, and B was registered after A, then lookup by the name will return architecture B.</p>
<p>A best practice is to use only characters that are not special in shell scripts since architecture names often appear as arguments to command-line switches. Also, try to use only lower-case letters, decimal digits and hyphens for consistency across all architecture names. See the list of ROSE built-in architecture names for ideas (this list can be obtained from many binary analysis tools, or the <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Architecture.html#a368a669a774fff6a0ebb2d17159a7bf4">Architecture::registeredNames</a> function).</p>
<p>Thread safety: Thread safe. The name is specified during construction and is thereafter read-only. </p>

</div>
</div>
<a id="a5f3e45432a5fb2e8a109c0d6118a0d62" name="a5f3e45432a5fb2e8a109c0d6118a0d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3e45432a5fb2e8a109c0d6118a0d62">&#9670;&#160;</a></span>registrationId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp; Rose::BinaryAnalysis::Architecture::Base::registrationId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Registration identification number. </p>
<p>Architectures are identified by a small number that is automtically assigned when it is registered, and cleared when it is deregistered. </p>

</div>
</div>
<a id="abc31f520eac844e49767d0afe1ccf1fe" name="abc31f520eac844e49767d0afe1ccf1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc31f520eac844e49767d0afe1ccf1fe">&#9670;&#160;</a></span>registrationId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Architecture::Base::registrationId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Registration identification number. </p>
<p>Architectures are identified by a small number that is automtically assigned when it is registered, and cleared when it is deregistered. </p>

</div>
</div>
<a id="a73b51aa09fc1b1a71c7f66346359d28b" name="a73b51aa09fc1b1a71c7f66346359d28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b51aa09fc1b1a71c7f66346359d28b">&#9670;&#160;</a></span>bytesPerWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Architecture::Base::bytesPerWord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Word size. </p>
<p>This is the natural word size for the architecture, measured in bits or bytes (depending on the property name).</p>
<p>Thread safety: Thread safe. This property is set during construction and is thereafter read-only. </p>

</div>
</div>
<a id="a1ee891ea7b9a61214b14496e263bb948" name="a1ee891ea7b9a61214b14496e263bb948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee891ea7b9a61214b14496e263bb948">&#9670;&#160;</a></span>bitsPerWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::Architecture::Base::bitsPerWord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Word size. </p>
<p>This is the natural word size for the architecture, measured in bits or bytes (depending on the property name).</p>
<p>Thread safety: Thread safe. This property is set during construction and is thereafter read-only. </p>

</div>
</div>
<a id="a02fb30e615b5afd19f867e66768b7688" name="a02fb30e615b5afd19f867e66768b7688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fb30e615b5afd19f867e66768b7688">&#9670;&#160;</a></span>byteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1ByteOrder.html#a936870e39bbf2fe6afa377992b9eea58">ByteOrder::Endianness</a> Rose::BinaryAnalysis::Architecture::Base::byteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Byte order for memory. </p>
<p>When multi-byte values (such as 32-bit integral values) are stored in memory, this property is the order in which the value's bytes are stored. If the order is little endian, then the least significant byte is stored at the lowest address; if the order is big endian then the most significant byte is stored at the lowest address.</p>
<p>Thread safety: Thread safe. This property is set during construction and is thereafter read-only. </p>

</div>
</div>
<a id="a06a80559e394e92b20bbaf76951d5900" name="a06a80559e394e92b20bbaf76951d5900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a80559e394e92b20bbaf76951d5900">&#9670;&#160;</a></span>registerDictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> Rose::BinaryAnalysis::Architecture::Base::registerDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Register dictionary. </p>
<p>The register dictionary defines a mapping between register names and register descriptors (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>), and thus how the registers map into hardware.</p>
<p>Since dictionaries are generally not modified, it is permissible for this function to return the same dictionary every time it's called. The dictionary can be constructed on the first call.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#a1bb45954b66b8f7fe40ca26e8a415ef2">Rose::BinaryAnalysis::Architecture::Amd64</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a1c584d80e1b7145ba1fc8466f9a98ef6">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel80286.html#ac5f5ce14d2f02e20f6574ab26c3423c2">Rose::BinaryAnalysis::Architecture::Intel80286</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8086.html#a8d128272330edb95c3035202631d59da">Rose::BinaryAnalysis::Architecture::Intel8086</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8088.html#a59eb85f6617dc466710fdf5067251e81">Rose::BinaryAnalysis::Architecture::Intel8088</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI386.html#af24bd8adb4daf56e0bafcc2132fd07ba">Rose::BinaryAnalysis::Architecture::IntelI386</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI486.html#a67f14147ff665876428c14434ec572a4">Rose::BinaryAnalysis::Architecture::IntelI486</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium.html#a14fbc16a97a0df48dbe5d3c178739fd0">Rose::BinaryAnalysis::Architecture::IntelPentium</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium4.html#a3a9121017d5d8521b87c938e2d76f986">Rose::BinaryAnalysis::Architecture::IntelPentium4</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumii.html#a24a81070465c6e0099c2e0524b3243f7">Rose::BinaryAnalysis::Architecture::IntelPentiumii</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumiii.html#a54f6654bf0fddae0c938afa478b49ee1">Rose::BinaryAnalysis::Architecture::IntelPentiumiii</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a67d6d185dcef6b5838629c912f84db69">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a17a1126cc9b8ab319260db91bdbdae80">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola68040.html#af3f14872c9b050cfd572336a8eca89d8">Rose::BinaryAnalysis::Architecture::Motorola68040</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NxpColdfire.html#aaf12eb9e99144e80a139d31952ac3316">Rose::BinaryAnalysis::Architecture::NxpColdfire</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc32.html#ace9081bf63aa81e6e1a1284b0f84744c">Rose::BinaryAnalysis::Architecture::Powerpc32</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc64.html#a773cd137c98da0efa98181942c977152">Rose::BinaryAnalysis::Architecture::Powerpc64</a>.</p>

</div>
</div>
<a id="ab47215e1c00810f5afb82f4bc04af5e4" name="ab47215e1c00810f5afb82f4bc04af5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47215e1c00810f5afb82f4bc04af5e4">&#9670;&#160;</a></span>interruptDictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a> Rose::BinaryAnalysis::Architecture::Base::interruptDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Interrupt dictionary. </p>
<p>The interrupt dictionary (a kind of register dictionary) defines a mapping between interrupt names and descriptors (<a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a>), and thus how the interrupt names map to hardware. Interrupts are normally single-bit values that indicate whether the interrupt is in a raised or cleared state. Interrupts in ROSE have a major and minor number since they use the same addressing mechanism as registers.</p>
<p>Since dictionaries are generally not modified, it is permissible for this funtion to return the same dictionary every time it's called. The dictionary can be constructed on the first call.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a06178cf460799c7d2fb8f83c58dfb999">Rose::BinaryAnalysis::Architecture::Mips32</a>.</p>

</div>
</div>
<a id="a000e445cbf23f56532f1bc5c7609dbac" name="a000e445cbf23f56532f1bc5c7609dbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000e445cbf23f56532f1bc5c7609dbac">&#9670;&#160;</a></span>callingConventions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a> &amp; Rose::BinaryAnalysis::Architecture::Base::callingConventions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Calling convention definitions. </p>
<p>Returns a list of calling convention definitions used by this architecture. Since definitions are generally not modified, it is permissible for this function to return the same definitions every time it's called. The list can be constructed on the first call.</p>
<p>The default implementation returns an empty list.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#a3d2c82364ccf8a650ebc386ad8a5b078">Rose::BinaryAnalysis::Architecture::Amd64</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#ac8ef9233f873b8c3a7cada5904c80339">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a1aabadc55976594e61b60e63a1f7095a">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#acf95673d445b1198707bd7f3c2102aaf">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a08f7c3793592de8dfe7108c76245850c" name="a08f7c3793592de8dfe7108c76245850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f7c3793592de8dfe7108c76245850c">&#9670;&#160;</a></span>matchesName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::matchesName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this architecture matches a name. </p>
<p>Returns true if this architecture matches the specified name, and false otherwise.</p>
<p>The default implementation matches the name exactly, which is what one usually wants. </p>

</div>
</div>
<a id="adc3611147dd3024b6d0de51ce006740f" name="adc3611147dd3024b6d0de51ce006740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3611147dd3024b6d0de51ce006740f">&#9670;&#160;</a></span>matchesHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::matchesHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this architecture matches a file header. </p>
<p>Returns true if this architecture matches the specified file header, and false otherwise.</p>
<p>The default implementation always returns false. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#aa74f4345c65b571d676849fc04432cd0">Rose::BinaryAnalysis::Architecture::Amd64</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a0ef4d037af74674a8eed9a4b77fa24ec">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel80286.html#ab37652860eb3cffb3f14e45d2ce610ea">Rose::BinaryAnalysis::Architecture::Intel80286</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8086.html#ab78dabe6accbaa87610b6ac7164ee65a">Rose::BinaryAnalysis::Architecture::Intel8086</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Intel8088.html#a3045130e3e0f22527e3af7156391b00d">Rose::BinaryAnalysis::Architecture::Intel8088</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI386.html#a9add6cfd9be4986c768e64ea4185da0c">Rose::BinaryAnalysis::Architecture::IntelI386</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelI486.html#a958b28c11be25d21d3b2f64e70f2a101">Rose::BinaryAnalysis::Architecture::IntelI486</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium.html#ae60eb2aba28de92597c756f267bd68f4">Rose::BinaryAnalysis::Architecture::IntelPentium</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentium4.html#a8fcacf07155b22c895e022c5d5de13f2">Rose::BinaryAnalysis::Architecture::IntelPentium4</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumii.html#a16064454c391a272a0675bb57e05bcb9">Rose::BinaryAnalysis::Architecture::IntelPentiumii</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1IntelPentiumiii.html#a7ccb9cdc0005d335e65fa4f23f6ce9c6">Rose::BinaryAnalysis::Architecture::IntelPentiumiii</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a2d86d5b4085e0126677ce024f4bc86d7">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#af479fe1cb76a333db9840c8c1cc4ebc4">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola68040.html#a90ccd5cbc9caef47187b19365edc057e">Rose::BinaryAnalysis::Architecture::Motorola68040</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NxpColdfire.html#a75db3ac43694c9cc2ee52e8df163f61d">Rose::BinaryAnalysis::Architecture::NxpColdfire</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc32.html#a9f8a2e3b2f4a6112a46b01b61e8e4252">Rose::BinaryAnalysis::Architecture::Powerpc32</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc64.html#a606b9e09fa06a89c3e53fbd94ae5ffaf">Rose::BinaryAnalysis::Architecture::Powerpc64</a>.</p>

</div>
</div>
<a id="a3e848a4594e882ab63f9a68cdb68c170" name="a3e848a4594e882ab63f9a68cdb68c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e848a4594e882ab63f9a68cdb68c170">&#9670;&#160;</a></span>newInstructionDecoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Disassembler::BasePtr</a> Rose::BinaryAnalysis::Architecture::Base::newInstructionDecoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction decoder. </p>
<p>Returns a new decoder for this architecture if possible, otherwise a null pointer.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aac1dfa16531bfcd0309aedbb03192a09">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a7c3c1bb3f8a5b1b4dac5343668dd73d8">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#aa32883150fbed492edfb715afb07b4f0">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola68040.html#a739ee1e5c4868cd72a42d72fec73c8b4">Rose::BinaryAnalysis::Architecture::Motorola68040</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1NxpColdfire.html#ad1d4629212a5430a2ace3a4f80ebd98f">Rose::BinaryAnalysis::Architecture::NxpColdfire</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#addcaca270a83ac2c127fa9c5cdf2ece8">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a54df74476cfefab0e46ad4701c58c450">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a59df18db2baae88452946dc47fa28a66" name="a59df18db2baae88452946dc47fa28a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59df18db2baae88452946dc47fa28a66">&#9670;&#160;</a></span>newUnparser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::BasePtr</a> Rose::BinaryAnalysis::Architecture::Base::newUnparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction unparser. </p>
<p>An unparser is responsible for generating pseudo assembly listings.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a9f03c7eb098a0dfc12ef27d88db4095d">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#ae2292a6cae2bded23600cfc802c30811">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a5b58d52073b2bbcfdb081b277c208126">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a661312ff9e76a4444eb92175e478ebbd">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#ae552e2eb861d6687295e3b64111019bb">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#ab100802f579bb1cea8b898796bccf322">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="ac9f7bc3595c3d4258ba834ae991008d2" name="ac9f7bc3595c3d4258ba834ae991008d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f7bc3595c3d4258ba834ae991008d2">&#9670;&#160;</a></span>newInstructionDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> Rose::BinaryAnalysis::Architecture::Base::newInstructionDispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a0c0106c0f124bfd48cf9c198e6bd7d4b">InstructionSemantics::BaseSemantics::RiscOperatorsPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return a new instruction dispatcher. </p>
<p>The dispatcher knows the semantics for instructions, but not the low-level operators (arithmetic, memory I/O, etc), nor the domain (concrete, symbolic, etc) on which those operators operate. These other things are supplied by the argument, which also points to the states that are modified by executing the instructions.</p>
<p>The default implementation returns a null pointer, signifying that instruction semantics are not known.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a703541a8513c2431896cc47ae3e2bda1">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a20356523677435d5f77ff9b07795923e">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#ad117a64ac12be5b63faaf8d40cb923a2">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a4fba9a3638c6ea9962789e7b9e51218f">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a7166b2e3ad595362e876ccda9ce2dd57" name="a7166b2e3ad595362e876ccda9ce2dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7166b2e3ad595362e876ccda9ce2dd57">&#9670;&#160;</a></span>bytesPerInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Sawyer::Container::Interval</a>&lt; size_t &gt; Rose::BinaryAnalysis::Architecture::Base::bytesPerInstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Valid sizes for encoded machine instructions. </p>
<p>Returns the range of valid sizes for encoded machine instructions. For instance, an x86 instruction can be from one to 15 bytes in length, but a PowerPC PPC32 instruction is always exactly 4 bytes. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#aca9e89ffb3b380199a61023d15fb04aa">Rose::BinaryAnalysis::Architecture::Amd64</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a81f1702f6fa366a222fe1d72cd23dbb3">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a4f47887c12d59a8f25bcdd882a9d321f">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a1a356b09ff88fe1e0cd4348e1546fe7e">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a329cf0d4dedb68032e32e32ca030dc12">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#aa527d566a3a69e40ed9dc604cfeb31ed">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a6221d5beff9b0a3f10cdb8ef010d832a">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a8ac610db2e1ce4866facad301b677e48" name="a8ac610db2e1ce4866facad301b677e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac610db2e1ce4866facad301b677e48">&#9670;&#160;</a></span>instructionAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html">Alignment</a> Rose::BinaryAnalysis::Architecture::Base::instructionAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Alignment.html" title="Information about alignments.">Alignment</a> for encoded machine instructions. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Amd64.html#a7286199085f6791db601592d6bf6d3a7">Rose::BinaryAnalysis::Architecture::Amd64</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#ab5aaa5dfd05a3b3e3084a853a058a656">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a37a0dfb2dd26a78a41098a94f4bc1025">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a311e44cb47aa28841b4647f53daa68f5">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#aa93ede62a8a0ec555809b30eb88ce92f">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a8adc83bf16dc0348be4bfc85eaf5b208">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a100e0bdc3bf25aa2b58492956253fbef">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="ad73177355070eeb5741e5bcbc9fc56f1" name="ad73177355070eeb5741e5bcbc9fc56f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73177355070eeb5741e5bcbc9fc56f1">&#9670;&#160;</a></span>instructionsCanOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Architecture::Base::instructionsCanOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether instructions can overlap in memory. </p>
<p>Instructions cannot overlap if the alignment is greater than or equal to the maximum instruction size. Otherwise there is potential for instructions to overlap with one another in memory. </p>

</div>
</div>
<a id="a9a80fb8df16e13c9333b0227620c90a2" name="a9a80fb8df16e13c9333b0227620c90a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a80fb8df16e13c9333b0227620c90a2">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::Architecture::Base::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unparse an instruction to a string. </p>
<p>The returned string is a simple, one-line string with no leading or trailing white space and no line termination. If the instruction is null, then the word "null" is printed.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="aab7b2dad38bc3c6ca9fbb23096479292" name="aab7b2dad38bc3c6ca9fbb23096479292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7b2dad38bc3c6ca9fbb23096479292">&#9670;&#160;</a></span>toStringNoAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::Architecture::Base::toStringNoAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unparse an instruction to a string. </p>
<p>The returned string is a simple, one-line string with no leading or trailing white space and no line termination. If the instruction is null, then the word "null" is printed.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="a3a56b4c385168bcf6804478700cc54ae" name="a3a56b4c385168bcf6804478700cc54ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a56b4c385168bcf6804478700cc54ae">&#9670;&#160;</a></span>instructionMnemonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::Architecture::Base::instructionMnemonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mnemonic for an instruction. </p>
<p>Returns the mnemonic for a particular instruction.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a80f3cd80da6430bb398eda48c55292e9">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#afa587b6d032c4b146c3b6ea479225662">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#adf5b8334860d9b345d46230c9f0cdc79">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#acc15bee23ba99aaa307472be8223c85c">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#ac86a3ac2adc057c8d9adceb6d80ff16d">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a0b7fb29a2999d0e27e88d36e1299638b">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a08e2b8bd1499cc492f7e844f188ae970" name="a08e2b8bd1499cc492f7e844f188ae970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e2b8bd1499cc492f7e844f188ae970">&#9670;&#160;</a></span>instructionDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Rose::BinaryAnalysis::Architecture::Base::instructionDescription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Description for an instruction. </p>
<p>Returns the description for a particular instruction. The description must be a single line with no leading or trailing white space, no line termination characters, and no non-printable characters. Most subclasses will just return a string based on the instruction mnemonic, such as "push a value onto the stack" for a <code>PUSH</code> instruction. The instruction argument must not be a null pointer and must be valid for this architecture.</p>
<p>The default implementation returns an empty string.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aacc093994f54836601472229867b18a4">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a5997794841937a6a28d8d1da6401a4ed">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#acdcf6d6b7aa30f031975dfe714ba908e">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a93adb64112cb59c6c23caecf413513b1">Rose::BinaryAnalysis::Architecture::Motorola</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a82d70979190d910447db2ba98f5b4838">Rose::BinaryAnalysis::Architecture::Powerpc</a>.</p>

</div>
</div>
<a id="a76e44136d49e87a71ca1ffaa468439fb" name="a76e44136d49e87a71ca1ffaa468439fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e44136d49e87a71ca1ffaa468439fb">&#9670;&#160;</a></span>isUnknown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::isUnknown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instruction is the special "unknown" instruction. </p>
<p>Each instruction architecture in ROSE defines an "unknown" instruction to be used when the disassembler is unable to create a real instruction. This can happen, for instance, if the bit pattern does not represent a valid instruction for the architecture. The instruction must not be a null pointer, and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a5a4edcee3d81d3f3337b21af0206779c">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#acb6a2b00698e9650512f76d3dcf662ac">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a171b39a6096f4e701acde484bafcd4db">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#aa42c66d355a34e9e97ff5cb1038da2c5">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a6f14d9c5b41daf7a65085008ed303711">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a0c83c06b6b4ad50a04fb5743809824d1">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a1fcbce03aea244dc9e5d9ac60554f000" name="a1fcbce03aea244dc9e5d9ac60554f000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcbce03aea244dc9e5d9ac60554f000">&#9670;&#160;</a></span>terminatesBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::terminatesBasicBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the specified instruction normally terminates a basic block. </p>
<p>The analysis generally only looks at the individual instruction and therefore is not very sophisticated. For instance, a conditional branch will always terminate a basic block by this method even if its condition is opaque. The instruction argument must not be a null pointer and must be valid for this architecture.</p>
<p>Thread safety: Thread safe. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a8004e38713e51a8ac6531bc72d22a161">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a75aad3ccfce7fb06faeea2d40e76d72b">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a359819d1c3c0acaf2c0b9cb50224fc16">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a71a3e707414fa7252d2eaba15406bbac">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#ac43a6a4179559d8afa53f522e0bfc0f6">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#aac43aee05706dec13d3b7098d3212755">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="ab7752a2ed38493ccb13a369c78d23988" name="ab7752a2ed38493ccb13a369c78d23988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7752a2ed38493ccb13a369c78d23988">&#9670;&#160;</a></span>isFunctionCallFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::isFunctionCallFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function call. </p>
<p>If the basic block looks like a function call then this method returns true. If (and only if) the target address is known (i.e., the address of the called function) then <code>target</code> is set to this address (otherwise <code>target</code> is unmodified). If the return address is known or can be guessed, then return_va is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise the return_va is unmodified.</p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementation of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a7711c049bdb1223255603031f776de4d">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a23121ba4861ba56700e8cd1ac40b23dc">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a4fd761590a122fa1b6cca6143f3aa254">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a2a405a18063dd48428955a4931a4c0e1">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a0901d306f45c6c8dafbd84fce324c077">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#acb232255e5406935614d075e733e8392">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a3e8d8c8b916e00cefa0f1b7634c1d839" name="a3e8d8c8b916e00cefa0f1b7634c1d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8d8c8b916e00cefa0f1b7634c1d839">&#9670;&#160;</a></span>isFunctionCallSlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::isFunctionCallSlow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function call. </p>
<p>If the basic block looks like a function call then this method returns true. If (and only if) the target address is known (i.e., the address of the called function) then <code>target</code> is set to this address (otherwise <code>target</code> is unmodified). If the return address is known or can be guessed, then return_va is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise the return_va is unmodified.</p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementation of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a1370d5a6f1a5b204b77127ec05c69692">Rose::BinaryAnalysis::Architecture::Motorola</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#af2b9f736400fb3c64972b8356c1d0bc3">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="abea57c49d0420f037021ff7b7afecd16" name="abea57c49d0420f037021ff7b7afecd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea57c49d0420f037021ff7b7afecd16">&#9670;&#160;</a></span>isFunctionReturnFast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::isFunctionReturnFast </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function return. </p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementaiton of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a218fdc5287d307d5dd2c7fac7a915fbf">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a73d20a4563a4581bffc7380cdd138b77">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#ac90dc58bab730dd67c8936aeb44971b6">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a6d2f4fd5b8c3d7b203f5700e6bcd4f99">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a58df5539f05faa9c0186ff5ab82b6fd0">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a7643208cae42c0a6ccfc462c93fd11f0">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a8abf86e9095b6f586e06c65b99a14d44" name="a8abf86e9095b6f586e06c65b99a14d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abf86e9095b6f586e06c65b99a14d44">&#9670;&#160;</a></span>isFunctionReturnSlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::Architecture::Base::isFunctionReturnSlow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified basic block looks like a function return. </p>
<p>The "fast" and "slow" versions differ only in what kind of anlysis they do. The "fast" version typically looks only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.</p>
<p>The base implementaiton of the fast method always returns false. The base implementation of the slow method just calls the fast method.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="a743b63088a626a602c6e9bcc3a054797" name="a743b63088a626a602c6e9bcc3a054797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743b63088a626a602c6e9bcc3a054797">&#9670;&#160;</a></span>branchTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; rose_addr_t &gt; Rose::BinaryAnalysis::Architecture::Base::branchTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the virtual address for a branching instruction. </p>
<p>Returns the branch target address if the specified instruction is a branching instruction and the target is known; otherwise returns nothing.</p>
<p>The default implementation returns nothing.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#a637fbb6ad3e6ddb32dc06ad9921ca9f7">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#af0ed397104ae70982b9e903c3a8df88e">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a12746d44ae790dca483d5415130f6603">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a6c539eb7f7f1e45b3f75d3d6916836b6">Rose::BinaryAnalysis::Architecture::Motorola</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a23a512792e547d40728a385a8e1c4eb8">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="aa57d491fecd502be6b814fcbf0be6d58" name="aa57d491fecd502be6b814fcbf0be6d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57d491fecd502be6b814fcbf0be6d58">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::Base::getSuccessors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors for a single instruction. </p>
<p>The return value does not consider neighboring instructions, and therefore is quite naive. It returns only the information it can glean from this single instruction. If the returned set of virtual instructions is fully known then the <code>complete</code> argument will be set to true, otherwise false. The instruction must not be null, and must be valid for this architecture.</p>
<p>The default implementation always returns an empty set and clears <code>complete</code>.</p>
<p>Thread safety: Thread saafe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Cil.html#aeb83bc0dc36289f0d6843f8d6d0c538a">Rose::BinaryAnalysis::Architecture::Cil</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Jvm.html#a3f0d6e0e8db5033a98dc41b559042f58">Rose::BinaryAnalysis::Architecture::Jvm</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a9cdf8a8766f55d96ee55bb73aae5b2db">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a2915bc42b7eef63c0b9e74c24bfe4c7e">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#ae6ae74ed35945ddc7599337c922ee0c3">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a19d9ff9cb1b4ee8dd904b724651d6c81">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a0e39bd2d1ac89476495a77ba0ea1dbca" name="a0e39bd2d1ac89476495a77ba0ea1dbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39bd2d1ac89476495a77ba0ea1dbca">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::Base::getSuccessors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>basicBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control flow successors for a basic block. </p>
<p>The <code>basicBlock</code> argument is a vector of instructions that is assumed to be a basic block that is entered only at the first instruction and exits only at the last instruction. A memory map can supply initial values for the analysis' memory state. The return value is a set of control flow successor virtual addresses, and the <code>complete</code> argument return value indicates whether the returned set is known to be complete (aside from interrupts, faults, etc).</p>
<p>The default implementation calls the single-instruction version, so architecture-specific subclasses might want to override this to do something more sophisticated. However, if the basic block is empty then this function instead returns an empty set and sets <code>complete</code> to true.</p>
<p>Thread safety: Thread safe. </p>

</div>
</div>
<a id="a584a12a9280fadaea065516e3c0cb88b" name="a584a12a9280fadaea065516e3c0cb88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a12a9280fadaea065516e3c0cb88b">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a3cd2d3478c0e767ed68aba17a5e81f18">AddressSet</a> Rose::BinaryAnalysis::Architecture::Base::getSuccessors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>basicBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a42da9a4f43dd3049ae45e61b95705e4b">MemoryMapPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control flow successors for a basic block. </p>
<p>The <code>basicBlock</code> argument is a vector of instructions that is assumed to be a basic block that is entered only at the first instruction and exits only at the last instruction. A memory map can supply initial values for the analysis' memory state. The return value is a set of control flow successor virtual addresses, and the <code>complete</code> argument return value indicates whether the returned set is known to be complete (aside from interrupts, faults, etc).</p>
<p>The default implementation calls the single-instruction version, so architecture-specific subclasses might want to override this to do something more sophisticated. However, if the basic block is empty then this function instead returns an empty set and sets <code>complete</code> to true.</p>
<p>Thread safety: Thread safe. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a41c8c4f5b726bc2edffcce4d1f68cb39">Rose::BinaryAnalysis::Architecture::Motorola</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a3ac9ee6888ea775a49981f4b9874ea01">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a9c963c4b3bb04cd747f9c84de49a48d2" name="a9c963c4b3bb04cd747f9c84de49a48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c963c4b3bb04cd747f9c84de49a48d2">&#9670;&#160;</a></span>functionPrologueMatchers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a3b33641b1367157839de7546737ae099">Partitioner2::FunctionPrologueMatcherPtr</a> &gt; Rose::BinaryAnalysis::Architecture::Base::functionPrologueMatchers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruction patterns matching function prologues. </p>
<p>Returns a list of matchers that match sequences of instructions that are often generated by compilers as part of instruction prologues.</p>
<p>The default implementation returns an empty list. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Mips32.html#a7cc0c377ee61352df1df101b6b90b1fd">Rose::BinaryAnalysis::Architecture::Mips32</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#a5d8fc12100954abc9679c0406e74da47">Rose::BinaryAnalysis::Architecture::Motorola</a>, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Powerpc.html#a2c9d25e1e8c930809d2edfb5ec45c4c5">Rose::BinaryAnalysis::Architecture::Powerpc</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a297f4b29348217e0aa7c4779e886547e">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<a id="a30db9046dabe9c47b53219f28941a082" name="a30db9046dabe9c47b53219f28941a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30db9046dabe9c47b53219f28941a082">&#9670;&#160;</a></span>basicBlockCreationHooks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ab1de8cd858d089760eb1e1253e4ea045">Partitioner2::BasicBlockCallbackPtr</a> &gt; Rose::BinaryAnalysis::Architecture::Base::basicBlockCreationHooks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#ae3c0297052d619e690d7c3566b57c4eb">Partitioner2::EnginePtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Architecture-specific basic block callbacks for partitioning. </p>
<p>Returns a list of basic block callbacks used by the partitioner during disassembly.</p>
<p>The default implementation returns an empty list. </p>

<p>Reimplemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1Motorola.html#ab39ef6ca6c8b79c1dedbfedbfd0772eb">Rose::BinaryAnalysis::Architecture::Motorola</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1Architecture_1_1X86.html#a63cbe34ca708d8afbf0f6a313eaf5e61">Rose::BinaryAnalysis::Architecture::X86</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a23bc5455bc3df509e90af8f2337557ee" name="a23bc5455bc3df509e90af8f2337557ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bc5455bc3df509e90af8f2337557ee">&#9670;&#160;</a></span>registerDictionary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&gt; Rose::BinaryAnalysis::Architecture::Base::registerDictionary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00037">37</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<a id="a058d3a8eb56136dfe58220836faa3f21" name="a058d3a8eb56136dfe58220836faa3f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058d3a8eb56136dfe58220836faa3f21">&#9670;&#160;</a></span>interruptDictionary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ae8ae9a4f7ce2eb38a3ad2ef899a86124">RegisterDictionaryPtr</a>&gt; Rose::BinaryAnalysis::Architecture::Base::interruptDictionary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00038">38</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<a id="ac9579050251c6bf0c3c836b0b999e7e0" name="ac9579050251c6bf0c3c836b0b999e7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9579050251c6bf0c3c836b0b999e7e0">&#9670;&#160;</a></span>callingConventions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt;<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#af24c0b3f801def1eda31a124049b5e08">CallingConvention::Dictionary</a>&gt; Rose::BinaryAnalysis::Architecture::Base::callingConventions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00039">39</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<a id="afe8432d213970666c785032171830d01" name="afe8432d213970666c785032171830d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8432d213970666c785032171830d01">&#9670;&#160;</a></span>insnToString_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt;<a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a>&gt; Rose::BinaryAnalysis::Architecture::Base::insnToString_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00040">40</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<a id="a36dab3a55bc698d073cd54e190c4b459" name="a36dab3a55bc698d073cd54e190c4b459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dab3a55bc698d073cd54e190c4b459">&#9670;&#160;</a></span>insnToStringNoAddr_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt;<a class="el" href="classSawyer_1_1SharedPointer.html">Unparser::Base::Ptr</a>&gt; Rose::BinaryAnalysis::Architecture::Base::insnToStringNoAddr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Architecture_2Base_8h_source.html#l00040">40</a> of file <a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Architecture_2Base_8h_source.html">Architecture/Base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:09 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
