<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::DataFlow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html">DataFlow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1DataFlow-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::DataFlow Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Various tools for data-flow analysis. </p>
<h1><a class="anchor" id="binary_dataflow_s1"></a>
Comparison with source code data-flow</h1>
<p>Binary data-flow analysis differs from source code data-flow analysis in that source code has well-known, named variables and the analysis is often simplified by considering only those variables (e.g., whole arrays, not array element granularity), and by ignoring aliasing issues. But because binaries have no named variables but rather one large array of memory with computed addresses, a binary data-flow analysis <em>must</em> be at address granularity and account for aliasing. In fact, because of the rich set of addressing modes, it is very common that within a single instruction some of the inputs and/or outputs depend on other inputs.</p>
<p>Another difference is in the number of basic operations that need to be supported. Source-level languages typically have at most a few dozen basic operations for which data-flow must be explicitly encoded in the analysis, while binary analysis needs basic data-flow information about hundreds of CPU instructions across the supported architectures. In fact, there are so many unique instructions that the implementation here takes a different approach: it leverages the fact that ROSE has instruction semantics and is able to discern data-flow within an instruction (or even across an entire basic block) by executing the instruction (or block) in a special data-flow semantic domain. The domain is an aggregate domain consisting of a main user-specified domain (often symbolic), a domain to track data-flow, and any number of additional user-specified domains. This approach works to discover multiple data-flow within the executed item (instruction or basic block); most CPU instructions have multiple data flows (e.g., "PUSH" has at least three independent data flows: incrementing of the instruction pointer, moving data between stack and register, incrementing the stack pointer).</p>
<p>Two additional minor things to be aware of in binary data-flow are (1) the difference in size between registers and memory locations, and (2) the use of idioms to perform common tasks. For instance, a read from memory to a 32-bit register is actually four separate 8-bit reads at the data-flow level since memory holds 8-bit values. An example of an idiom is the "XOR EAX, EAX" instruction to set the EAX register to zero (this is important for taint analysis, since it effectively removes any taint from EAX).</p>
<h1><a class="anchor" id="binary_dataflow_s2"></a>
The major components</h1>
<p>The core component of the binary data-flow is an <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html">Engine</a> class template. Its purpose is to collect all the types and objects necessary for a data-flow analysis and to iteratively solve a data-flow equation.</p>
<p>Additional components provide functionality that's useful during the core solving process, but not necessary. For instance, one can use abstract locations (<a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a>) to represent variables. An abstract location is either a register or a memory address. Registers are represented by a <a class="el" href="classRose_1_1BinaryAnalysis_1_1RegisterDescriptor.html">RegisterDescriptor</a> while addresses are represented by a semantic value in some user-specified domain (often symbolic, see <a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SValue</a>).</p>
<h1><a class="anchor" id="s2"></a>
Prerequisites for the core data flow-engine</h1>
<p>See <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html">Engine</a> for how data-flow is solved. In short, data-flow consists of values (taken from a lattice) that are stored in variables (abstract locations, memory, registers). A set of variables and their values (a.k.a., state) is stored at each vertex in a control flow graph. The solver iterates over the control flow graph. It invokes a user-defined transfer function at each vertex. The transfer function takes an incoming state and produces an outgoing state. The incoming state for a vertex is calculated by merging the outgoing states of its predecessor vertices. When the iteration reaches a fixed point the analysis is complete. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00072">72</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="DataFlow_8h_source.html">Rose/BinaryAnalysis/DataFlow.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::DataFlow:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1DataFlow__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1DataFlow_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1DataFlow_coll__map" id="aRose_1_1BinaryAnalysis_1_1DataFlow_coll__map">
<area shape="rect" title="Various tools for data&#45;flow analysis." alt="" coords="20,93,168,133"/>
<area shape="rect" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams." alt="" coords="5,5,183,31"/>
<area shape="poly" title=" " alt="" coords="97,45,97,93,91,93,91,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1DefaultVertexUnpacker.html">DefaultVertexUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to return instructions for a cfg vertex.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1DefaultVertexUnpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html">Engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-flow engine.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-flow exception base class.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1NotConverging.html">NotConverging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptions when a fixed point is not reached.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1NotConverging.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1PathAlwaysFeasible.html">PathAlwaysFeasible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial path feasibility predicate.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1PathAlwaysFeasible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1SemanticsMerge.html">SemanticsMerge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic merge operation for instruction semantics.  <a href="classRose_1_1BinaryAnalysis_1_1DataFlow_1_1SemanticsMerge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a09ff55a94f808c8fc5bcc5ca85b30af2" id="r_a09ff55a94f808c8fc5bcc5ca85b30af2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">InstructionSemantics::DataFlowSemantics::DataFlowGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Graph</a></td></tr>
<tr class="memdesc:a09ff55a94f808c8fc5bcc5ca85b30af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-flow graph.  <br /></td></tr>
<tr class="separator:a09ff55a94f808c8fc5bcc5ca85b30af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ac64ab023e2948a301c07ab0d78ac" id="r_acb5ac64ab023e2948a301c07ab0d78ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#acb5ac64ab023e2948a301c07ab0d78ac">Variable</a></td></tr>
<tr class="memdesc:acb5ac64ab023e2948a301c07ab0d78ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable participating in data flow.  <br /></td></tr>
<tr class="separator:acb5ac64ab023e2948a301c07ab0d78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71788706bab45b01e534037dde1c6af2" id="r_a71788706bab45b01e534037dde1c6af2"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#acb5ac64ab023e2948a301c07ab0d78ac">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a71788706bab45b01e534037dde1c6af2">VariableList</a></td></tr>
<tr class="memdesc:a71788706bab45b01e534037dde1c6af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of variables.  <br /></td></tr>
<tr class="separator:a71788706bab45b01e534037dde1c6af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b403159cdb5000bad5fc6690dd235b" id="r_ad4b403159cdb5000bad5fc6690dd235b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt; size_t, <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a></td></tr>
<tr class="memdesc:ad4b403159cdb5000bad5fc6690dd235b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> from CFG vertex to data-flow graph.  <br /></td></tr>
<tr class="separator:ad4b403159cdb5000bad5fc6690dd235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbfda62e690c3edc1b26e0f1e5d00858" id="r_adbfda62e690c3edc1b26e0f1e5d00858"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#adbfda62e690c3edc1b26e0f1e5d00858">DataFlow</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> &amp;userDispatcher)</td></tr>
<tr class="memdesc:adbfda62e690c3edc1b26e0f1e5d00858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:adbfda62e690c3edc1b26e0f1e5d00858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ed8330807cfd1f4093e1e8d44a6ea8" id="r_a75ed8330807cfd1f4093e1e8d44a6ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a71788706bab45b01e534037dde1c6af2">VariableList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a75ed8330807cfd1f4093e1e8d44a6ea8">getUniqueVariables</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a> &amp;)</td></tr>
<tr class="memdesc:a75ed8330807cfd1f4093e1e8d44a6ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of unique variables.  <br /></td></tr>
<tr class="separator:a75ed8330807cfd1f4093e1e8d44a6ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae2088489a821263e68246ecdda650902" id="r_ae2088489a821263e68246ecdda650902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ae2088489a821263e68246ecdda650902">buildGraph</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;)</td></tr>
<tr class="memdesc:ae2088489a821263e68246ecdda650902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute data-flow.  <br /></td></tr>
<tr class="separator:ae2088489a821263e68246ecdda650902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac12d48092449ff032ac060591201971a" id="r_ac12d48092449ff032ac060591201971a"><td class="memTemplParams" colspan="2">template&lt;class CFG , class VertexUnpacker &gt; </td></tr>
<tr class="memitem:ac12d48092449ff032ac060591201971a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ac12d48092449ff032ac060591201971a">buildGraphPerVertex</a> (const CFG &amp;cfg, size_t startVertex, VertexUnpacker vertexUnpacker)</td></tr>
<tr class="memdesc:ac12d48092449ff032ac060591201971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute data-flow per CFG vertex.  <br /></td></tr>
<tr class="separator:ac12d48092449ff032ac060591201971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dd280c6568e61251a46e8342421f02" id="r_a72dd280c6568e61251a46e8342421f02"><td class="memTemplParams" colspan="2">template&lt;class CFG &gt; </td></tr>
<tr class="memitem:a72dd280c6568e61251a46e8342421f02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a72dd280c6568e61251a46e8342421f02">buildGraphPerVertex</a> (const CFG &amp;cfg, size_t startVertex)</td></tr>
<tr class="memdesc:a72dd280c6568e61251a46e8342421f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute data-flow per CFG vertex.  <br /></td></tr>
<tr class="separator:a72dd280c6568e61251a46e8342421f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf4f5fb2d4b4a5153b300caccba99d3a" id="r_aaf4f5fb2d4b4a5153b300caccba99d3a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#aaf4f5fb2d4b4a5153b300caccba99d3a">initDiagnostics</a> ()</td></tr>
<tr class="memdesc:aaf4f5fb2d4b4a5153b300caccba99d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostics.  <br /></td></tr>
<tr class="separator:aaf4f5fb2d4b4a5153b300caccba99d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aec277848dc1d0058f84c6931c5cfa47d" id="r_aec277848dc1d0058f84c6931c5cfa47d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#aec277848dc1d0058f84c6931c5cfa47d">mlog</a></td></tr>
<tr class="separator:aec277848dc1d0058f84c6931c5cfa47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a09ff55a94f808c8fc5bcc5ca85b30af2" name="a09ff55a94f808c8fc5bcc5ca85b30af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ff55a94f808c8fc5bcc5ca85b30af2">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Graph.html">InstructionSemantics::DataFlowSemantics::DataFlowGraph</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Rose::BinaryAnalysis::DataFlow::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data-flow graph. </p>
<p>Vertices are abstract locations (register descriptors and/or memory addresses) and edges indicate the flow of data from abstract location to another. The edge IDs are in the order they were added; each edge also has a sequence number that is initially equal to the edge ID, although edge IDs can change if edges are erased from the graph). </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00079">79</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<a id="acb5ac64ab023e2948a301c07ab0d78ac" name="acb5ac64ab023e2948a301c07ab0d78ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5ac64ab023e2948a301c07ab0d78ac">&#9670;&#160;</a></span>Variable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html">AbstractLocation</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#acb5ac64ab023e2948a301c07ab0d78ac">Rose::BinaryAnalysis::DataFlow::Variable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable participating in data flow. </p>
<p>A variable in binary data-flow analysis is an abstract location referencing either a register or memory cell. The address for memory locations is an arbitrary semantic expression (<a class="el" href="classRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SValue.html">Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::SValue</a>). </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00086">86</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<a id="a71788706bab45b01e534037dde1c6af2" name="a71788706bab45b01e534037dde1c6af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71788706bab45b01e534037dde1c6af2">&#9670;&#160;</a></span>VariableList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#acb5ac64ab023e2948a301c07ab0d78ac">Variable</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a71788706bab45b01e534037dde1c6af2">Rose::BinaryAnalysis::DataFlow::VariableList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of variables. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00089">89</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<a id="ad4b403159cdb5000bad5fc6690dd235b" name="ad4b403159cdb5000bad5fc6690dd235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b403159cdb5000bad5fc6690dd235b">&#9670;&#160;</a></span>VertexFlowGraphs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSawyer_1_1Container_1_1Map.html">Sawyer::Container::Map</a>&lt;size_t, <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Graph</a>&gt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">Rose::BinaryAnalysis::DataFlow::VertexFlowGraphs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMap.html" title="Extends std::map with methods that return optional values.">Map</a> from CFG vertex to data-flow graph. </p>
<p>This data structure holds a data-flow graph for each control flow graph vertex. The data-flow graph represents data-flow from one abstract location to another. The union of all abstract locations across all control flow vertices is the set of variables present in the specimen being analyzed. The map is keyed by CFG vertex IDs. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00096">96</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adbfda62e690c3edc1b26e0f1e5d00858" name="adbfda62e690c3edc1b26e0f1e5d00858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfda62e690c3edc1b26e0f1e5d00858">&#9670;&#160;</a></span>DataFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::DataFlow::DataFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#a75ee406f19167965f5217e58fe9dc707">InstructionSemantics::BaseSemantics::DispatcherPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>userDispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Constructs a new data-flow analysis framework using the specified user-level instruction semantics. The semantics should consist of an instruction dispatcher appropriate for the architecture being analyzed, and an associated semantic domain that will be used to calculate memory addresses. The SymbolicSemantics domain is typically used. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00125">125</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf4f5fb2d4b4a5153b300caccba99d3a" name="aaf4f5fb2d4b4a5153b300caccba99d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4f5fb2d4b4a5153b300caccba99d3a">&#9670;&#160;</a></span>initDiagnostics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rose::BinaryAnalysis::DataFlow::initDiagnostics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize diagnostics. </p>
<p>This is called by <a class="el" href="namespaceRose_1_1Diagnostics.html#af73708983cca75ce5a3bb8f9928b6e2c" title="Initialize diagnostics-related global variables.">Rose::Diagnostics::initialize</a>. </p>

</div>
</div>
<a id="ae2088489a821263e68246ecdda650902" name="ae2088489a821263e68246ecdda650902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2088489a821263e68246ecdda650902">&#9670;&#160;</a></span>buildGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a09ff55a94f808c8fc5bcc5ca85b30af2">Graph</a> Rose::BinaryAnalysis::DataFlow::buildGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute data-flow. </p>
<p>Computes and returns a graph describing how data-flow occurs for the specified instructions (which must have linear control flow, e.g., from a single basic block). The vertices of the returned graph contain the abstract locations that are referenced (read or written) and the edges indicate the data-flow. The edge values are integers imparting an ordering to the data-flow. </p>

<p class="reference">Referenced by <a class="el" href="DataFlow_8h_source.html#l00174">buildGraphPerVertex()</a>.</p>

</div>
</div>
<a id="ac12d48092449ff032ac060591201971a" name="ac12d48092449ff032ac060591201971a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12d48092449ff032ac060591201971a">&#9670;&#160;</a></span>buildGraphPerVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CFG , class VertexUnpacker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a> Rose::BinaryAnalysis::DataFlow::buildGraphPerVertex </td>
          <td>(</td>
          <td class="paramtype">const CFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexUnpacker&#160;</td>
          <td class="paramname"><em>vertexUnpacker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute data-flow per CFG vertex. </p>
<p>This method traverses the control flow graph to discover the abstract locations that are referenced by each vertex and the flow edges between those abstract locations.</p>
<p>The algorithm currently implemented here is to use an aggregate semantic domain consisting of a user-supplied semantic domain in conjunction with a data-flow discovery domain, and to process each CFG vertex one time in some arbitrary depth-first order. This isn't a rigorous analysis, but it is usually able to accurately identify local and global variables, although typically not through pointers or array indexing. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00174">174</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ae2088489a821263e68246ecdda650902">buildGraph()</a>, <a class="el" href="Sawyer_2Map_8h_source.html#l00646">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::insert()</a>, <a class="el" href="StringUtility_2Diagnostics_8h_source.html#l00088">Rose::StringUtility::plural()</a>, and <a class="el" href="Sawyer_2Map_8h_source.html#l00438">Sawyer::Container::Map&lt; K, T, Cmp, Alloc &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataFlow_8h_source.html#l00204">buildGraphPerVertex()</a>, and <a class="el" href="TaintedFlow_8h_source.html#l00212">Rose::BinaryAnalysis::TaintedFlow::computeFlowGraphs()</a>.</p>

</div>
</div>
<a id="a72dd280c6568e61251a46e8342421f02" name="a72dd280c6568e61251a46e8342421f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dd280c6568e61251a46e8342421f02">&#9670;&#160;</a></span>buildGraphPerVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CFG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a> Rose::BinaryAnalysis::DataFlow::buildGraphPerVertex </td>
          <td>(</td>
          <td class="paramtype">const CFG &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute data-flow per CFG vertex. </p>
<p>This method traverses the control flow graph to discover the abstract locations that are referenced by each vertex and the flow edges between those abstract locations.</p>
<p>The algorithm currently implemented here is to use an aggregate semantic domain consisting of a user-supplied semantic domain in conjunction with a data-flow discovery domain, and to process each CFG vertex one time in some arbitrary depth-first order. This isn't a rigorous analysis, but it is usually able to accurately identify local and global variables, although typically not through pointers or array indexing. </p>

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00204">204</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

<p class="reference">References <a class="el" href="DataFlow_8h_source.html#l00174">buildGraphPerVertex()</a>.</p>

</div>
</div>
<a id="a75ed8330807cfd1f4093e1e8d44a6ea8" name="a75ed8330807cfd1f4093e1e8d44a6ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed8330807cfd1f4093e1e8d44a6ea8">&#9670;&#160;</a></span>getUniqueVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#a71788706bab45b01e534037dde1c6af2">VariableList</a> Rose::BinaryAnalysis::DataFlow::getUniqueVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1DataFlow.html#ad4b403159cdb5000bad5fc6690dd235b">VertexFlowGraphs</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of unique variables. </p>
<p>This returns a list of unique variables by computing the union of all variables across the index. Uniqueness is determined by calling <a class="el" href="classRose_1_1BinaryAnalysis_1_1AbstractLocation.html#a6083ee550548c8218354acd73148f5a2" title="True if two abstract locations are certainly aliases.">AbstractLocation::mustAlias</a>. The variables are returned in no particular order. </p>

<p class="reference">Referenced by <a class="el" href="TaintedFlow_8h_source.html#l00212">Rose::BinaryAnalysis::TaintedFlow::computeFlowGraphs()</a>, and <a class="el" href="TaintedFlow_8h_source.html#l00239">Rose::BinaryAnalysis::TaintedFlow::vertexFlowGraphs()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aec277848dc1d0058f84c6931c5cfa47d" name="aec277848dc1d0058f84c6931c5cfa47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec277848dc1d0058f84c6931c5cfa47d">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> Rose::BinaryAnalysis::DataFlow::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataFlow_8h_source.html#l00117">117</a> of file <a class="el" href="DataFlow_8h_source.html">DataFlow.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="DataFlow_8h_source.html">DataFlow.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:08 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
