<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::SymbolicExpression::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html">SymbolicExpression</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::SymbolicExpression::Node Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Base class for symbolic expression nodes. </p>
<p>Every node has a specified width measured in bits that is constant over the life of the node. The width is always a concrete, positive value stored in a 64-bit field. The corollary of this invariant is that if an expression's result width depends on the <em>values</em> of some of its arguments, those arguments must be concrete and not wider than 64 bits. Only a few operators fall into this category since most expressions depend on the <em>widths</em> of their arguments rather than the <em>values</em> of their arguments.</p>
<p>In order that subtrees can be freely assigned as children of other nodes (provided the structure as a whole remains a lattice and not a graph with cycles), two things are required: First, expression tree nodes are always referenced through shared-ownership pointers that collectively own the expression node (expressions are never explicitly deleted). Second, expression nodes are immutable once they're instantiated. There are a handful of exceptions to the immutable rule: comments and attributes are allowed to change freely since they're not significant to hashing or arithmetic operations.</p>
<p>Each node has a bit flags property, the bits of which are defined by the user. New nodes are created having all bits cleared unless the user specifies a value in the constructor. Bits are significant for hashing. Simplifiers produce result expressions whose bits are set in a predictable manner with the following rules:</p>
<ul>
<li><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html" title="Base class for symbolic expression nodes.">Node</a> Rule: The flags for an interior node are the union of the flags of its subtrees.</li>
</ul>
<ul>
<li>Simplification Discard Rule: If a simplification discards a subtree then that subtree does not contribute flags to the result. E.g., cancellation of terms in an <code>add</code> operation.</li>
</ul>
<ul>
<li>Simplification Create Rule: If a simplification creates a new leaf node that doesn't depend on the input expression that new leaf node will have zero flags. E.g., XOR of an expression with itself; an add operation where all the terms cancel each other resulting in zero.</li>
</ul>
<ul>
<li>Simplification Folding Rule: If a simplification creates a new expression from some combination of incoming expressions then the flags of the new expression are the union of the flags from the expressions on which it depends. E.g., constant folding, which is therefore consistent with the <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html" title="Base class for symbolic expression nodes.">Node</a> Rule.</li>
</ul>
<ul>
<li>Hashing Rule: User-defined flags are significant for hashing. E.g., structural equivalence will return false if the two expressions have different flags since structural equivalence uses hashes.</li>
</ul>
<ul>
<li>Relational Operator Rule: Simplification of relational operators to produce a Boolean constant will act as if they are performing constant folding even if the simplification is on variables. E.g., <code>(ule v1 v1)</code> results in true with flags the same as <code>v1</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00455">455</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="SymbolicExpression_8h_source.html">Rose/BinaryAnalysis/SymbolicExpression.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::SymbolicExpression::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_inherit__map" id="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_inherit__map">
<area shape="rect" title="Base class for symbolic expression nodes." alt="" coords="224,85,412,125"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics." alt="" coords="477,41,626,96"/>
<area shape="poly" title=" " alt="" coords="425,85,476,78,477,83,426,91"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics." alt="" coords="460,121,643,161"/>
<area shape="poly" title=" " alt="" coords="426,119,460,124,459,129,425,124"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="14,5,167,31"/>
<area shape="poly" title=" " alt="" coords="151,32,177,41,276,82,274,87,175,46,149,37"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="5,55,176,95"/>
<area shape="poly" title=" " alt="" coords="191,86,224,90,224,95,190,91"/>
<area shape="rect" href="classSawyer_1_1SmallObject.html" title="Small object support." alt="" coords="18,120,163,145"/>
<area shape="poly" title=" " alt="" coords="177,119,223,114,224,119,178,125"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="19,170,162,210"/>
<area shape="poly" title=" " alt="" coords="156,163,264,122,266,127,158,168"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::SymbolicExpression::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_coll__map" id="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_coll__map">
<area shape="rect" title="Base class for symbolic expression nodes." alt="" coords="304,142,492,182"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="21,5,175,31"/>
<area shape="poly" title=" " alt="" coords="167,32,192,41,291,91,370,140,367,144,288,96,190,46,166,37"/>
<area shape="rect" href="classSawyer_1_1SharedFromThis.html" title=" " alt="" coords="13,55,183,95"/>
<area shape="poly" title=" " alt="" coords="182,97,329,139,328,144,180,102"/>
<area shape="rect" href="classSawyer_1_1SmallObject.html" title="Small object support." alt="" coords="25,120,171,145"/>
<area shape="poly" title=" " alt="" coords="185,138,304,150,303,155,184,144"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="27,170,169,210"/>
<area shape="poly" title=" " alt="" coords="183,179,304,168,304,173,183,185"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html" title="Type of symbolic expression." alt="" coords="5,234,191,274"/>
<area shape="poly" title=" " alt="" coords="178,228,279,197,334,180,336,185,281,202,179,233"/>
<area shape="rect" title=" " alt="" coords="58,299,138,324"/>
<area shape="poly" title=" " alt="" coords="151,296,190,284,241,260,291,232,369,180,372,185,294,237,244,265,192,288,152,301"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node with formatter.  <a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a827e86df13553322eba8111c6d1c5dc1" id="r_a827e86df13553322eba8111c6d1c5dc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a827e86df13553322eba8111c6d1c5dc1">EquivPairs</a> = std::map&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, bool &gt; &gt; &gt;</td></tr>
<tr class="separator:a827e86df13553322eba8111c6d1c5dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage" id="r_a6232bff42634b42d2dcd3b68ba39a39c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSawyer_1_1SynchronizationTraits.html">SynchronizationTraits</a>&lt; SyncTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a6232bff42634b42d2dcd3b68ba39a39c">Sync</a></td></tr>
<tr class="separator:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c8f48cfd3521023847cca801219dabd" id="r_a7c8f48cfd3521023847cca801219dabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a> () const</td></tr>
<tr class="memdesc:a7c8f48cfd3521023847cca801219dabd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html" title="Type of symbolic expression.">Type</a> of value.  <br /></td></tr>
<tr class="separator:a7c8f48cfd3521023847cca801219dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b0c0ee0a7451ee55c3bff01941ab8d" id="r_ab1b0c0ee0a7451ee55c3bff01941ab8d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab1b0c0ee0a7451ee55c3bff01941ab8d">mustEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())=0</td></tr>
<tr class="memdesc:ab1b0c0ee0a7451ee55c3bff01941ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two expressions must be equal (cannot be unequal).  <br /></td></tr>
<tr class="separator:ab1b0c0ee0a7451ee55c3bff01941ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bea89ce10dba2b96d83fe118ddeeae" id="r_ad5bea89ce10dba2b96d83fe118ddeeae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">mayEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())=0</td></tr>
<tr class="memdesc:ad5bea89ce10dba2b96d83fe118ddeeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two expressions might be equal, but not necessarily be equal.  <br /></td></tr>
<tr class="separator:ad5bea89ce10dba2b96d83fe118ddeeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34f8ffaccea6276a689a7005f1b777e" id="r_aa34f8ffaccea6276a689a7005f1b777e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa34f8ffaccea6276a689a7005f1b777e">isEquivalentTo</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other)=0</td></tr>
<tr class="memdesc:aa34f8ffaccea6276a689a7005f1b777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests two expressions for structural equivalence.  <br /></td></tr>
<tr class="separator:aa34f8ffaccea6276a689a7005f1b777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae393741530af5fdb0a4491fb93f22e06" id="r_ae393741530af5fdb0a4491fb93f22e06"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae393741530af5fdb0a4491fb93f22e06">compareStructure</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other)=0</td></tr>
<tr class="memdesc:ae393741530af5fdb0a4491fb93f22e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions structurally for sorting.  <br /></td></tr>
<tr class="separator:ae393741530af5fdb0a4491fb93f22e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb0e0a9fb89e55a4b33424d2ecbcc83" id="r_abbb0e0a9fb89e55a4b33424d2ecbcc83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abbb0e0a9fb89e55a4b33424d2ecbcc83">substitute</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;from, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;to, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())=0</td></tr>
<tr class="memdesc:abbb0e0a9fb89e55a4b33424d2ecbcc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute one value for another.  <br /></td></tr>
<tr class="separator:abbb0e0a9fb89e55a4b33424d2ecbcc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b59e5b6ef63515a74fad13d9badacea" id="r_a3b59e5b6ef63515a74fad13d9badacea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3b59e5b6ef63515a74fad13d9badacea">substituteMultiple</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;substitutions, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a3b59e5b6ef63515a74fad13d9badacea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite expression by substituting subexpressions.  <br /></td></tr>
<tr class="separator:a3b59e5b6ef63515a74fad13d9badacea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0c120a647a35eda4b476b65f63efbb" id="r_abf0c120a647a35eda4b476b65f63efbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abf0c120a647a35eda4b476b65f63efbb">renameVariables</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;index, size_t &amp;nextVariableId, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:abf0c120a647a35eda4b476b65f63efbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite using lowest numbered variable names.  <br /></td></tr>
<tr class="separator:abf0c120a647a35eda4b476b65f63efbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22eee8ff5d0eab13d24b95fb60c39e1" id="r_ad22eee8ff5d0eab13d24b95fb60c39e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad22eee8ff5d0eab13d24b95fb60c39e1">getOperator</a> () const =0</td></tr>
<tr class="memdesc:ad22eee8ff5d0eab13d24b95fb60c39e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for interior nodes.  <br /></td></tr>
<tr class="separator:ad22eee8ff5d0eab13d24b95fb60c39e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b729ec06f2275aba9d5c300511829f" id="r_a13b729ec06f2275aba9d5c300511829f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a13b729ec06f2275aba9d5c300511829f">nChildren</a> () const =0</td></tr>
<tr class="memdesc:a13b729ec06f2275aba9d5c300511829f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of arguments.  <br /></td></tr>
<tr class="separator:a13b729ec06f2275aba9d5c300511829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c19853fc3b1c94563eaf8f13e5007b" id="r_a70c19853fc3b1c94563eaf8f13e5007b"><td class="memItemLeft" align="right" valign="top">virtual const Nodes &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a70c19853fc3b1c94563eaf8f13e5007b">children</a> () const =0</td></tr>
<tr class="memdesc:a70c19853fc3b1c94563eaf8f13e5007b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments.  <br /></td></tr>
<tr class="separator:a70c19853fc3b1c94563eaf8f13e5007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab463224309cacaa21f359cf935929f75" id="r_ab463224309cacaa21f359cf935929f75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab463224309cacaa21f359cf935929f75">toUnsigned</a> () const =0</td></tr>
<tr class="memdesc:ab463224309cacaa21f359cf935929f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsigned integer value of the expression.  <br /></td></tr>
<tr class="separator:ab463224309cacaa21f359cf935929f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738401442bb723c3202f1687f6de671" id="r_a9738401442bb723c3202f1687f6de671"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a9738401442bb723c3202f1687f6de671">toSigned</a> () const =0</td></tr>
<tr class="memdesc:a9738401442bb723c3202f1687f6de671"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signed integer value of the expression.  <br /></td></tr>
<tr class="separator:a9738401442bb723c3202f1687f6de671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d445634c2ac85a3ae052cc4e249d71" id="r_ad1d445634c2ac85a3ae052cc4e249d71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad1d445634c2ac85a3ae052cc4e249d71">isIntegerExpr</a> () const</td></tr>
<tr class="memdesc:ad1d445634c2ac85a3ae052cc4e249d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of an integer type.  <br /></td></tr>
<tr class="separator:ad1d445634c2ac85a3ae052cc4e249d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5199dca72c6d392692b90e744adc263" id="r_ac5199dca72c6d392692b90e744adc263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ac5199dca72c6d392692b90e744adc263">isFloatingPointExpr</a> () const</td></tr>
<tr class="memdesc:ac5199dca72c6d392692b90e744adc263"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of a floating-point type.  <br /></td></tr>
<tr class="separator:ac5199dca72c6d392692b90e744adc263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea2b3523f2401682e3a9442bd781c15" id="r_abea2b3523f2401682e3a9442bd781c15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abea2b3523f2401682e3a9442bd781c15">isMemoryExpr</a> () const</td></tr>
<tr class="memdesc:abea2b3523f2401682e3a9442bd781c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of a memory type.  <br /></td></tr>
<tr class="separator:abea2b3523f2401682e3a9442bd781c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829b6434685caeec93f955ab9f7471f" id="r_ab829b6434685caeec93f955ab9f7471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab829b6434685caeec93f955ab9f7471f">isScalarExpr</a> () const</td></tr>
<tr class="memdesc:ab829b6434685caeec93f955ab9f7471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the expression is a scalar type.  <br /></td></tr>
<tr class="separator:ab829b6434685caeec93f955ab9f7471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df28fa6b71642a43fd1899529cca270" id="r_a0df28fa6b71642a43fd1899529cca270"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0df28fa6b71642a43fd1899529cca270">isConstant</a> () const =0</td></tr>
<tr class="memdesc:a0df28fa6b71642a43fd1899529cca270"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a constant.  <br /></td></tr>
<tr class="separator:a0df28fa6b71642a43fd1899529cca270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ecfa22d26e9724dccbf291c6669da0" id="r_a54ecfa22d26e9724dccbf291c6669da0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a54ecfa22d26e9724dccbf291c6669da0">isIntegerConstant</a> () const</td></tr>
<tr class="memdesc:a54ecfa22d26e9724dccbf291c6669da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is an integer constant.  <br /></td></tr>
<tr class="separator:a54ecfa22d26e9724dccbf291c6669da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5323cec0c40b5771584a9b2fd4ba7105" id="r_a5323cec0c40b5771584a9b2fd4ba7105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a5323cec0c40b5771584a9b2fd4ba7105">isFloatingPointConstant</a> () const</td></tr>
<tr class="memdesc:a5323cec0c40b5771584a9b2fd4ba7105"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this epxression is a floating-point constant.  <br /></td></tr>
<tr class="separator:a5323cec0c40b5771584a9b2fd4ba7105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e66d88572ecd51e879add8284fd0a64" id="r_a3e66d88572ecd51e879add8284fd0a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3e66d88572ecd51e879add8284fd0a64">isScalarConstant</a> () const</td></tr>
<tr class="memdesc:a3e66d88572ecd51e879add8284fd0a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a scalar constant.  <br /></td></tr>
<tr class="separator:a3e66d88572ecd51e879add8284fd0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d47d97801ab2bd9243c4556126ffb2e" id="r_a2d47d97801ab2bd9243c4556126ffb2e"><td class="memItemLeft" align="right" valign="top"><a id="a2d47d97801ab2bd9243c4556126ffb2e" name="a2d47d97801ab2bd9243c4556126ffb2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFloatingPointNan</b> () const</td></tr>
<tr class="memdesc:a2d47d97801ab2bd9243c4556126ffb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a floating-point NaN constant. <br /></td></tr>
<tr class="separator:a2d47d97801ab2bd9243c4556126ffb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfe6d4b7a2124abeece444aa3b0ddd1" id="r_aadfe6d4b7a2124abeece444aa3b0ddd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aadfe6d4b7a2124abeece444aa3b0ddd1">isVariable2</a> () const =0</td></tr>
<tr class="memdesc:aadfe6d4b7a2124abeece444aa3b0ddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a variable.  <br /></td></tr>
<tr class="separator:aadfe6d4b7a2124abeece444aa3b0ddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a36eb99cf5418d0c724180a9f25d593" id="r_a2a36eb99cf5418d0c724180a9f25d593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2a36eb99cf5418d0c724180a9f25d593">variableId</a> () const</td></tr>
<tr class="memdesc:a2a36eb99cf5418d0c724180a9f25d593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable ID number.  <br /></td></tr>
<tr class="separator:a2a36eb99cf5418d0c724180a9f25d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2763916848fd850d7d789b2b192d30" id="r_a0c2763916848fd850d7d789b2b192d30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0c2763916848fd850d7d789b2b192d30">isIntegerVariable</a> () const</td></tr>
<tr class="memdesc:a0c2763916848fd850d7d789b2b192d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is an integer variable.  <br /></td></tr>
<tr class="separator:a0c2763916848fd850d7d789b2b192d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d385c59ccbad2264cc262f4e7765be" id="r_a38d385c59ccbad2264cc262f4e7765be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a38d385c59ccbad2264cc262f4e7765be">isFloatingPointVariable</a> () const</td></tr>
<tr class="memdesc:a38d385c59ccbad2264cc262f4e7765be"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a floating-point variable.  <br /></td></tr>
<tr class="separator:a38d385c59ccbad2264cc262f4e7765be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679762843045af43cb32ac03dec41ef2" id="r_a679762843045af43cb32ac03dec41ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a679762843045af43cb32ac03dec41ef2">isMemoryVariable</a> () const</td></tr>
<tr class="memdesc:a679762843045af43cb32ac03dec41ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a memory state variable.  <br /></td></tr>
<tr class="separator:a679762843045af43cb32ac03dec41ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7f791741ff816e19268589f68bf8b6" id="r_a7a7f791741ff816e19268589f68bf8b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7a7f791741ff816e19268589f68bf8b6">isScalarVariable</a> () const</td></tr>
<tr class="memdesc:a7a7f791741ff816e19268589f68bf8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a scalar variable.  <br /></td></tr>
<tr class="separator:a7a7f791741ff816e19268589f68bf8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400e3a4c11a81e183dbfbc0a3c9016e" id="r_a9400e3a4c11a81e183dbfbc0a3c9016e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a9400e3a4c11a81e183dbfbc0a3c9016e">nBits</a> () const</td></tr>
<tr class="memdesc:a9400e3a4c11a81e183dbfbc0a3c9016e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of significant bits.  <br /></td></tr>
<tr class="separator:a9400e3a4c11a81e183dbfbc0a3c9016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5ef9fca6895de57fd49d4ed41ded9" id="r_ae2a5ef9fca6895de57fd49d4ed41ded9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a> () const</td></tr>
<tr class="memdesc:ae2a5ef9fca6895de57fd49d4ed41ded9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined bit flags.  <br /></td></tr>
<tr class="separator:ae2a5ef9fca6895de57fd49d4ed41ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552e6affeb1a82b2ff20a4f39a68d072" id="r_a552e6affeb1a82b2ff20a4f39a68d072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a552e6affeb1a82b2ff20a4f39a68d072">newFlags</a> (unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>) const</td></tr>
<tr class="memdesc:a552e6affeb1a82b2ff20a4f39a68d072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets flags.  <br /></td></tr>
<tr class="separator:a552e6affeb1a82b2ff20a4f39a68d072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb9599b465398f87191a448b11b5780" id="r_a0bb9599b465398f87191a448b11b5780"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0bb9599b465398f87191a448b11b5780">domainWidth</a> () const</td></tr>
<tr class="memdesc:a0bb9599b465398f87191a448b11b5780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Width for memory expressions.  <br /></td></tr>
<tr class="separator:a0bb9599b465398f87191a448b11b5780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab" id="r_a4e2eea5f7e1fe9f8b32e0ca3038cd4ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a4e2eea5f7e1fe9f8b32e0ca3038cd4ab">isScalar</a> () const</td></tr>
<tr class="memdesc:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether expression is scalar.  <br /></td></tr>
<tr class="separator:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa208affad817dc6d89e5f4b7ee552f94" id="r_aa208affad817dc6d89e5f4b7ee552f94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">VisitAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa208affad817dc6d89e5f4b7ee552f94">depthFirstTraversal</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html">Visitor</a> &amp;) const =0</td></tr>
<tr class="memdesc:aa208affad817dc6d89e5f4b7ee552f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the expression.  <br /></td></tr>
<tr class="separator:aa208affad817dc6d89e5f4b7ee552f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aace1a79aa431d6be1d1f19ded39c9" id="r_a90aace1a79aa431d6be1d1f19ded39c9"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a90aace1a79aa431d6be1d1f19ded39c9">nNodes</a> () const =0</td></tr>
<tr class="memdesc:a90aace1a79aa431d6be1d1f19ded39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of an expression by counting the number of nodes.  <br /></td></tr>
<tr class="separator:a90aace1a79aa431d6be1d1f19ded39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ddbc715c01d4c9db9ce7beb3870bd7" id="r_a37ddbc715c01d4c9db9ce7beb3870bd7"><td class="memItemLeft" align="right" valign="top"><a id="a37ddbc715c01d4c9db9ce7beb3870bd7" name="a37ddbc715c01d4c9db9ce7beb3870bd7"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>nNodesUnique</b> () const</td></tr>
<tr class="memdesc:a37ddbc715c01d4c9db9ce7beb3870bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of unique nodes in expression. <br /></td></tr>
<tr class="separator:a37ddbc715c01d4c9db9ce7beb3870bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4600680bf010f5c2c3e80cb57f8d8ab" id="r_ad4600680bf010f5c2c3e80cb57f8d8ab"><td class="memItemLeft" align="right" valign="top"><a id="ad4600680bf010f5c2c3e80cb57f8d8ab" name="ad4600680bf010f5c2c3e80cb57f8d8ab"></a>
std::set&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVariables</b> () const</td></tr>
<tr class="memdesc:ad4600680bf010f5c2c3e80cb57f8d8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variables appearing in the expression. <br /></td></tr>
<tr class="separator:ad4600680bf010f5c2c3e80cb57f8d8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9811180477b08c100b72965f99c3da" id="r_a2b9811180477b08c100b72965f99c3da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2b9811180477b08c100b72965f99c3da">isHashed</a> () const</td></tr>
<tr class="memdesc:a2b9811180477b08c100b72965f99c3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node has a hash value computed and cached.  <br /></td></tr>
<tr class="separator:a2b9811180477b08c100b72965f99c3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2587115bb1a247402f90dbb4bfbd533a" id="r_a2587115bb1a247402f90dbb4bfbd533a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2587115bb1a247402f90dbb4bfbd533a">hash</a> () const</td></tr>
<tr class="memdesc:a2587115bb1a247402f90dbb4bfbd533a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (and caches) the hash value for this node.  <br /></td></tr>
<tr class="separator:a2587115bb1a247402f90dbb4bfbd533a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520d58ea2374d0fdb5cb900d63b4842f" id="r_a520d58ea2374d0fdb5cb900d63b4842f"><td class="memItemLeft" align="right" valign="top"><a id="a520d58ea2374d0fdb5cb900d63b4842f" name="a520d58ea2374d0fdb5cb900d63b4842f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>) const</td></tr>
<tr class="separator:a520d58ea2374d0fdb5cb900d63b4842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12247d8fd79c4528fa10b5de51989d15" id="r_a12247d8fd79c4528fa10b5de51989d15"><td class="memItemLeft" align="right" valign="top"><a id="a12247d8fd79c4528fa10b5de51989d15" name="a12247d8fd79c4528fa10b5de51989d15"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> () const</td></tr>
<tr class="memdesc:a12247d8fd79c4528fa10b5de51989d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert expression to string. <br /></td></tr>
<tr class="separator:a12247d8fd79c4528fa10b5de51989d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac913729c72ab980b7cec178096fa8c3" id="r_aac913729c72ab980b7cec178096fa8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aac913729c72ab980b7cec178096fa8c3">assertAcyclic</a> () const</td></tr>
<tr class="memdesc:aac913729c72ab980b7cec178096fa8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that expressions are acyclic.  <br /></td></tr>
<tr class="separator:aac913729c72ab980b7cec178096fa8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae606f125a10a3787b5c8d615c25a1445" id="r_ae606f125a10a3787b5c8d615c25a1445"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae606f125a10a3787b5c8d615c25a1445">findCommonSubexpressions</a> () const</td></tr>
<tr class="memdesc:ae606f125a10a3787b5c8d615c25a1445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find common subexpressions.  <br /></td></tr>
<tr class="separator:ae606f125a10a3787b5c8d615c25a1445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f14e3470fc6f5b7d2923b8afa0559" id="r_aa38f14e3470fc6f5b7d2923b8afa0559"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa38f14e3470fc6f5b7d2923b8afa0559">matchAddVariableConstant</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;<a class="el" href="classvariable.html">variable</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;constant) const</td></tr>
<tr class="memdesc:aa38f14e3470fc6f5b7d2923b8afa0559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an expression is a variable plus a constant.  <br /></td></tr>
<tr class="separator:aa38f14e3470fc6f5b7d2923b8afa0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c3d320b448dc7594b1862d870236d6" id="r_a31c3d320b448dc7594b1862d870236d6"><td class="memItemLeft" align="right" valign="top"><a id="a31c3d320b448dc7594b1862d870236d6" name="a31c3d320b448dc7594b1862d870236d6"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isOperator</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a>) const</td></tr>
<tr class="memdesc:a31c3d320b448dc7594b1862d870236d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True (non-null) if this node is the specified operator. <br /></td></tr>
<tr class="separator:a31c3d320b448dc7594b1862d870236d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120d2457251ea4b658cb60e4af3d3449" id="r_a120d2457251ea4b658cb60e4af3d3449"><td class="memItemLeft" align="right" valign="top"><a id="a120d2457251ea4b658cb60e4af3d3449" name="a120d2457251ea4b658cb60e4af3d3449"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEquivalentHelper</b> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, EquivPairs &amp;)=0</td></tr>
<tr class="separator:a120d2457251ea4b658cb60e4af3d3449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae2d22be691cf45c4626ed4116eef6f30" id="r_ae2d22be691cf45c4626ed4116eef6f30"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2d22be691cf45c4626ed4116eef6f30">child</a> (size_t idx) const =0</td></tr>
<tr class="memdesc:ae2d22be691cf45c4626ed4116eef6f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument.  <br /></td></tr>
<tr class="separator:ae2d22be691cf45c4626ed4116eef6f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39684cbee10da1cf1e553182ad61d93e" id="r_a39684cbee10da1cf1e553182ad61d93e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a39684cbee10da1cf1e553182ad61d93e">childRaw</a> (size_t idx) const =0</td></tr>
<tr class="memdesc:a39684cbee10da1cf1e553182ad61d93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument.  <br /></td></tr>
<tr class="separator:a39684cbee10da1cf1e553182ad61d93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a98c6b16bcd8a718198fdcd8b874a26bf" id="r_a98c6b16bcd8a718198fdcd8b874a26bf"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a> () const</td></tr>
<tr class="memdesc:a98c6b16bcd8a718198fdcd8b874a26bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Comment.  <br /></td></tr>
<tr class="separator:a98c6b16bcd8a718198fdcd8b874a26bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67648c26b65adccb3710f8d2a88551dc" id="r_a67648c26b65adccb3710f8d2a88551dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a67648c26b65adccb3710f8d2a88551dc">comment</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a67648c26b65adccb3710f8d2a88551dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Comment.  <br /></td></tr>
<tr class="separator:a67648c26b65adccb3710f8d2a88551dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a80d4564d54dcc27002a51f5e83e575fa" id="r_a80d4564d54dcc27002a51f5e83e575fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a80d4564d54dcc27002a51f5e83e575fa">userData</a> (boost::any &amp;data)</td></tr>
<tr class="memdesc:a80d4564d54dcc27002a51f5e83e575fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined data.  <br /></td></tr>
<tr class="separator:a80d4564d54dcc27002a51f5e83e575fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82e5a3ef07ca2876f8b5a1b949480c" id="r_aeb82e5a3ef07ca2876f8b5a1b949480c"><td class="memItemLeft" align="right" valign="top">const boost::any &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aeb82e5a3ef07ca2876f8b5a1b949480c">userData</a> () const</td></tr>
<tr class="memdesc:aeb82e5a3ef07ca2876f8b5a1b949480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined data.  <br /></td></tr>
<tr class="separator:aeb82e5a3ef07ca2876f8b5a1b949480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a18c996a02b7c0f8ecfe3db379b0211e1" id="r_a18c996a02b7c0f8ecfe3db379b0211e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a18c996a02b7c0f8ecfe3db379b0211e1">isInteriorNode</a> () const</td></tr>
<tr class="memdesc:a18c996a02b7c0f8ecfe3db379b0211e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to an interior node.  <br /></td></tr>
<tr class="separator:a18c996a02b7c0f8ecfe3db379b0211e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca4b0d89020fd62390ae12d88231f1a" id="r_aaca4b0d89020fd62390ae12d88231f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aaca4b0d89020fd62390ae12d88231f1a">isInteriorNodeRaw</a> () const</td></tr>
<tr class="memdesc:aaca4b0d89020fd62390ae12d88231f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to an interior node.  <br /></td></tr>
<tr class="separator:aaca4b0d89020fd62390ae12d88231f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa51741dd7626aa6bf76c2fefc87ee15c" id="r_aa51741dd7626aa6bf76c2fefc87ee15c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa51741dd7626aa6bf76c2fefc87ee15c">isLeafNode</a> () const</td></tr>
<tr class="memdesc:aa51741dd7626aa6bf76c2fefc87ee15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to a leaf node.  <br /></td></tr>
<tr class="separator:aa51741dd7626aa6bf76c2fefc87ee15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867a0b78c5b62720b46513cb1e0e10f" id="r_ae867a0b78c5b62720b46513cb1e0e10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae867a0b78c5b62720b46513cb1e0e10f">isLeafNodeRaw</a> () const</td></tr>
<tr class="memdesc:ae867a0b78c5b62720b46513cb1e0e10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to a leaf node.  <br /></td></tr>
<tr class="separator:ae867a0b78c5b62720b46513cb1e0e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afd0edf10cd2ebf66cabd68609838553a" id="r_afd0edf10cd2ebf66cabd68609838553a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#afd0edf10cd2ebf66cabd68609838553a">withFormat</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:afd0edf10cd2ebf66cabd68609838553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a node with a formatter for printing.  <br /></td></tr>
<tr class="separator:afd0edf10cd2ebf66cabd68609838553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25faa0406d9ac372bea9e6cf86a91d2b" id="r_a25faa0406d9ac372bea9e6cf86a91d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a25faa0406d9ac372bea9e6cf86a91d2b">operator+</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:a25faa0406d9ac372bea9e6cf86a91d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a node with a formatter for printing.  <br /></td></tr>
<tr class="separator:a25faa0406d9ac372bea9e6cf86a91d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2364e3da620fa5afd424a0c48f35869d" id="r_a2364e3da620fa5afd424a0c48f35869d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2364e3da620fa5afd424a0c48f35869d">print</a> (std::ostream &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;) const =0</td></tr>
<tr class="memdesc:a2364e3da620fa5afd424a0c48f35869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the expression to a stream.  <br /></td></tr>
<tr class="separator:a2364e3da620fa5afd424a0c48f35869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daa64f5d1daa3110f60408bfd3d3e11" id="r_a3daa64f5d1daa3110f60408bfd3d3e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3daa64f5d1daa3110f60408bfd3d3e11">print</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a3daa64f5d1daa3110f60408bfd3d3e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the expression to a stream.  <br /></td></tr>
<tr class="separator:a3daa64f5d1daa3110f60408bfd3d3e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedFromThis"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedFromThis')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedFromThis.html">Sawyer::SharedFromThis&lt; Node &gt;</a></td></tr>
<tr class="memitem:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a5225cf4c7055339254ace1c62005ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a5225cf4c7055339254ace1c62005ac55">sharedFromThis</a> ()</td></tr>
<tr class="memdesc:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a8b829a965e98f9ccb1b22da4a68a6f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; const Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a8b829a965e98f9ccb1b22da4a68a6f76">sharedFromThis</a> () const</td></tr>
<tr class="memdesc:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae15492e36a2af8002023cab5afeaf671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae15492e36a2af8002023cab5afeaf671">Storage</a> ()</td></tr>
<tr class="memdesc:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9f66f01b292f92cdc70a18de1a7085ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9f66f01b292f92cdc70a18de1a7085ef">Storage</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae0dda357eaeee6b1974c3feae00c40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae0dda357eaeee6b1974c3feae00c40dd">operator=</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_abf3618e6d7c3a3f4bcc38ad23da3b8e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#abf3618e6d7c3a3f4bcc38ad23da3b8e9">attributeExists</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check attribute existence.  <br /></td></tr>
<tr class="separator:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a5a79e661eb48d0b9548bd0dacc63daba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a5a79e661eb48d0b9548bd0dacc63daba">eraseAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>)</td></tr>
<tr class="memdesc:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute.  <br /></td></tr>
<tr class="separator:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ab9276a22e706c4e76d65d45e715051e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ab9276a22e706c4e76d65d45e715051e0">clearAttributes</a> ()</td></tr>
<tr class="memdesc:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all attributes.  <br /></td></tr>
<tr class="separator:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9900916e61e6c0ce53e87803221962c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9900916e61e6c0ce53e87803221962c0">setAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute.  <br /></td></tr>
<tr class="separator:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a2143837f634be78ae5143e962d272fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a2143837f634be78ae5143e962d272fb8">setAttributeMaybe</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute if not already present.  <br /></td></tr>
<tr class="separator:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae39391002b59fc46db71a536cbe3e075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae39391002b59fc46db71a536cbe3e075">getAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute that is known to exist.  <br /></td></tr>
<tr class="separator:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a921b9ff8dc5cd78f751517bc22127496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a921b9ff8dc5cd78f751517bc22127496">attributeOrElse</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;dflt) const</td></tr>
<tr class="memdesc:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a specified value.  <br /></td></tr>
<tr class="separator:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a80072b861bfe95e1146934a3a53506ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a80072b861bfe95e1146934a3a53506ed">attributeOrDefault</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a default-constructed value.  <br /></td></tr>
<tr class="separator:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4277013fbe140a78e10182ca9053935c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4277013fbe140a78e10182ca9053935c">optionalAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute as an optional value.  <br /></td></tr>
<tr class="separator:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4b9e838c10d8c99838518457b35783ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4b9e838c10d8c99838518457b35783ac">nAttributes</a> () const</td></tr>
<tr class="memdesc:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <br /></td></tr>
<tr class="separator:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a1739a58e26f1dd40590fd9ee78936781"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a1739a58e26f1dd40590fd9ee78936781">attributeIds</a> () const</td></tr>
<tr class="memdesc:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ID numbers for all IDs stored in this container.  <br /></td></tr>
<tr class="separator:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:adc12dfd081952860a7ee91531f33ec0a" id="r_adc12dfd081952860a7ee91531f33ec0a"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#adc12dfd081952860a7ee91531f33ec0a">RESERVED_FLAGS</a> = 0x0000ffff</td></tr>
<tr class="memdesc:adc12dfd081952860a7ee91531f33ec0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">These flags are reserved for use within ROSE.  <br /></td></tr>
<tr class="separator:adc12dfd081952860a7ee91531f33ec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625ba620262131aa05e55c09710881b" id="r_ae625ba620262131aa05e55c09710881b"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae625ba620262131aa05e55c09710881b">INDETERMINATE</a> = 0x00000001</td></tr>
<tr class="memdesc:ae625ba620262131aa05e55c09710881b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value is somehow indeterminate.  <br /></td></tr>
<tr class="separator:ae625ba620262131aa05e55c09710881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748427bef1cc117706dbf9100e8cdf8" id="r_a1748427bef1cc117706dbf9100e8cdf8"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a1748427bef1cc117706dbf9100e8cdf8">UNSPECIFIED</a> = 0x00000002</td></tr>
<tr class="memdesc:a1748427bef1cc117706dbf9100e8cdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value is somehow unspecified.  <br /></td></tr>
<tr class="separator:a1748427bef1cc117706dbf9100e8cdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd3df8be8c21eebf285fd2295c170e9" id="r_abbd3df8be8c21eebf285fd2295c170e9"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abbd3df8be8c21eebf285fd2295c170e9">BOTTOM</a> = 0x00000004</td></tr>
<tr class="memdesc:abbd3df8be8c21eebf285fd2295c170e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value represents bottom in dataflow analysis.  <br /></td></tr>
<tr class="separator:abbd3df8be8c21eebf285fd2295c170e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9f5524dafe8a99d7f8b2b7cbfd086" id="r_a33b9f5524dafe8a99d7f8b2b7cbfd086"><td class="memItemLeft" align="right" valign="top">static boost::logic::tribool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a33b9f5524dafe8a99d7f8b2b7cbfd086">mayEqualCallback</a> )(const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;)</td></tr>
<tr class="memdesc:a33b9f5524dafe8a99d7f8b2b7cbfd086"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-supplied predicate to augment alias checking.  <br /></td></tr>
<tr class="separator:a33b9f5524dafe8a99d7f8b2b7cbfd086"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5d7a92fd29f1c48a6aa7e73beeba3f59" id="r_a5d7a92fd29f1c48a6aa7e73beeba3f59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a5d7a92fd29f1c48a6aa7e73beeba3f59">Node</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="separator:a5d7a92fd29f1c48a6aa7e73beeba3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702af6acfacf989ef5dbdde94d0d64d1" id="r_a702af6acfacf989ef5dbdde94d0d64d1"><td class="memItemLeft" align="right" valign="top"><a id="a702af6acfacf989ef5dbdde94d0d64d1" name="a702af6acfacf989ef5dbdde94d0d64d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printFlags</b> (std::ostream &amp;o, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>, char &amp;bracket) const</td></tr>
<tr class="separator:a702af6acfacf989ef5dbdde94d0d64d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2e9500e43872353ee8ca47ef77618bc7" id="r_a2e9500e43872353ee8ca47ef77618bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2e9500e43872353ee8ca47ef77618bc7">type_</a></td></tr>
<tr class="separator:a2e9500e43872353ee8ca47ef77618bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d313b2dbefb0562db93e9489571a62" id="r_a63d313b2dbefb0562db93e9489571a62"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a63d313b2dbefb0562db93e9489571a62">flags_</a></td></tr>
<tr class="memdesc:a63d313b2dbefb0562db93e9489571a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags.  <br /></td></tr>
<tr class="separator:a63d313b2dbefb0562db93e9489571a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0da3c3333c5085a1d462fe529796ff" id="r_a4d0da3c3333c5085a1d462fe529796ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a4d0da3c3333c5085a1d462fe529796ff">comment_</a></td></tr>
<tr class="memdesc:a4d0da3c3333c5085a1d462fe529796ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional comment.  <br /></td></tr>
<tr class="separator:a4d0da3c3333c5085a1d462fe529796ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e53001033983d1f6a7e9ad72d261502" id="r_a8e53001033983d1f6a7e9ad72d261502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a8e53001033983d1f6a7e9ad72d261502">hashval_</a></td></tr>
<tr class="memdesc:a8e53001033983d1f6a7e9ad72d261502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional hash used as a quick way to indicate that two expressions are different.  <br /></td></tr>
<tr class="separator:a8e53001033983d1f6a7e9ad72d261502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba13e8f5b635d9684e91ae88763f3a" id="r_a3cba13e8f5b635d9684e91ae88763f3a"><td class="memItemLeft" align="right" valign="top">boost::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3cba13e8f5b635d9684e91ae88763f3a">userData_</a></td></tr>
<tr class="memdesc:a3cba13e8f5b635d9684e91ae88763f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-specified data.  <br /></td></tr>
<tr class="separator:a3cba13e8f5b635d9684e91ae88763f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1SmallObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1SmallObject')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1SmallObject.html">Sawyer::SmallObject</a></td></tr>
<tr class="memitem:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_a2954194e69a758f9785ef5d00589e936"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceSawyer.html#acb97daf593e6c229322229d001a43784">SynchronizedPoolAllocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#a2954194e69a758f9785ef5d00589e936">poolAllocator</a> ()</td></tr>
<tr class="memdesc:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pool allocator for this class.  <br /></td></tr>
<tr class="separator:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead44427ee5b1c52ea7dea3e60d67fbf inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_aead44427ee5b1c52ea7dea3e60d67fbf"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#aead44427ee5b1c52ea7dea3e60d67fbf">operator new</a> (size_t size)</td></tr>
<tr class="separator:aead44427ee5b1c52ea7dea3e60d67fbf inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c539ee5d7754059adb13ecc8dd918a0 inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_a0c539ee5d7754059adb13ecc8dd918a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#a0c539ee5d7754059adb13ecc8dd918a0">operator delete</a> (void *ptr, size_t size)</td></tr>
<tr class="separator:a0c539ee5d7754059adb13ecc8dd918a0 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a827e86df13553322eba8111c6d1c5dc1" name="a827e86df13553322eba8111c6d1c5dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827e86df13553322eba8111c6d1c5dc1">&#9670;&#160;</a></span>EquivPairs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Rose::BinaryAnalysis::SymbolicExpression::Node::EquivPairs =  std::map&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a>*, std::vector&lt;std::pair&lt;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a>*, bool&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00878">878</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0577ea07b4e21ec6c6855bb5c3e59c5" name="ae0577ea07b4e21ec6c6855bb5c3e59c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0577ea07b4e21ec6c6855bb5c3e59c5">&#9670;&#160;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Rose::BinaryAnalysis::SymbolicExpression::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00503">503</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="af7ede3443e621574a6eb976fddf8b7fd" name="af7ede3443e621574a6eb976fddf8b7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ede3443e621574a6eb976fddf8b7fd">&#9670;&#160;</a></span>Node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::SymbolicExpression::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00506">506</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a5d7a92fd29f1c48a6aa7e73beeba3f59" name="a5d7a92fd29f1c48a6aa7e73beeba3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7a92fd29f1c48a6aa7e73beeba3f59">&#9670;&#160;</a></span>Node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rose::BinaryAnalysis::SymbolicExpression::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00508">508</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c8f48cfd3521023847cca801219dabd" name="a7c8f48cfd3521023847cca801219dabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8f48cfd3521023847cca801219dabd">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> Rose::BinaryAnalysis::SymbolicExpression::Node::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html" title="Type of symbolic expression.">Type</a> of value. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00513">513</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01329">Rose::BinaryAnalysis::SymbolicExpression::Leaf::isFloatingPointVariable()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l01324">Rose::BinaryAnalysis::SymbolicExpression::Leaf::isIntegerVariable()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l01337">Rose::BinaryAnalysis::SymbolicExpression::Leaf::isMemoryVariable()</a>.</p>

</div>
</div>
<a id="ab1b0c0ee0a7451ee55c3bff01941ab8d" name="ab1b0c0ee0a7451ee55c3bff01941ab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b0c0ee0a7451ee55c3bff01941ab8d">&#9670;&#160;</a></span>mustEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Node::mustEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if two expressions must be equal (cannot be unequal). </p>
<p>If an SMT solver is specified then that solver is used to answer this question, otherwise equality is established by looking only at the structure of the two expressions. Two expressions can be equal without being the same width (e.g., a 32-bit constant zero is equal to a 16-bit constant zero). </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a78c705d0f227ef34d22338b5ca64b00e">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#afa64d7153688402a3ba3e5c2e5600630">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="ad5bea89ce10dba2b96d83fe118ddeeae" name="ad5bea89ce10dba2b96d83fe118ddeeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bea89ce10dba2b96d83fe118ddeeae">&#9670;&#160;</a></span>mayEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Node::mayEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if two expressions might be equal, but not necessarily be equal. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a87408ef44dbfe818f9aaffc35a54eba3">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a6f9687a06f3f36f057c4d6f243330307">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="aa34f8ffaccea6276a689a7005f1b777e" name="aa34f8ffaccea6276a689a7005f1b777e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34f8ffaccea6276a689a7005f1b777e">&#9670;&#160;</a></span>isEquivalentTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Node::isEquivalentTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests two expressions for structural equivalence. </p>
<p>Two leaf nodes are equivalent if they are the same width and have equal values or are the same variable. Two interior nodes are equivalent if they are the same width, the same operation, have the same number of children, and those children are all pairwise equivalent. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0aef45221d7363ac51fda9a2317e7db2">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a70f260c19dcf691c2cebacf54f6f28dc">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="ae393741530af5fdb0a4491fb93f22e06" name="ae393741530af5fdb0a4491fb93f22e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae393741530af5fdb0a4491fb93f22e06">&#9670;&#160;</a></span>compareStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Rose::BinaryAnalysis::SymbolicExpression::Node::compareStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two expressions structurally for sorting. </p>
<p>Returns -1 if <code>this</code> is less than <code>other</code>, 0 if they are structurally equal, and 1 if <code>this</code> is greater than <code>other</code>. This function returns zero when an only when <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa34f8ffaccea6276a689a7005f1b777e">isEquivalentTo</a> returns zero, but <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa34f8ffaccea6276a689a7005f1b777e">isEquivalentTo</a> can be much faster since it uses hashing. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a4c7c5b048a77a09c7632f366b9d2d765">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a1643827373f98d28a537d43ad7e6266f">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="abbb0e0a9fb89e55a4b33424d2ecbcc83" name="abbb0e0a9fb89e55a4b33424d2ecbcc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb0e0a9fb89e55a4b33424d2ecbcc83">&#9670;&#160;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitute one value for another. </p>
<p>Finds all occurrances of <code>from</code> in this expression and replace them with <code>to</code>. If a substitution occurs, then a new expression is returned. The matching of <code>from</code> to sub-parts of this expression uses structural equivalence, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa34f8ffaccea6276a689a7005f1b777e">isEquivalentTo</a> predicate. The <code>from</code> and <code>to</code> expressions must have the same width. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a6e2da3652d6ed93d0fe44411683e6e30">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a499dc42389b6e0acecbaf54aa055c84f">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a3b59e5b6ef63515a74fad13d9badacea" name="a3b59e5b6ef63515a74fad13d9badacea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b59e5b6ef63515a74fad13d9badacea">&#9670;&#160;</a></span>substituteMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::substituteMultiple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite expression by substituting subexpressions. </p>
<p>This expression is rewritten by doing a depth-first traversal. At each step of the traversal, the subexpression is looked up by hash in the supplied substitutions table. If found, a new expression is created using the value found in the table and the traversal does not descend into the new expression. If no substitutions were performed then <code>this</code> expression is returned, otherwise a new expression is returned. An optional solver, which may be null, is used during the simplification step. </p>

</div>
</div>
<a id="abf0c120a647a35eda4b476b65f63efbb" name="abf0c120a647a35eda4b476b65f63efbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c120a647a35eda4b476b65f63efbb">&#9670;&#160;</a></span>renameVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::renameVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nextVariableId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite using lowest numbered variable names. </p>
<p>Given an expression, use the specified index to rewrite variables. The index uses expression hashes to look up the replacement expression. If the traversal finds a variable which is not in the index then a new variable is created. The new variable has the same type as the original variable, but it's name is generated starting at <code>nextVariableId</code> and incrementing after each replacement is generated. The optional solver is used during the simplification process and may be null. </p>

</div>
</div>
<a id="ad22eee8ff5d0eab13d24b95fb60c39e1" name="ad22eee8ff5d0eab13d24b95fb60c39e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22eee8ff5d0eab13d24b95fb60c39e1">&#9670;&#160;</a></span>getOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> Rose::BinaryAnalysis::SymbolicExpression::Node::getOperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for interior nodes. </p>
<p>Return the operator for interior nodes, or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a26e45d8a426be8586e6f5964a328306c">OP_NONE</a> for leaf nodes that have no operator. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#afddb0a222fca419f04f6d56f37cdfae8">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a761050c8c0b98def890c8c8bdd4a195d">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a13b729ec06f2275aba9d5c300511829f" name="a13b729ec06f2275aba9d5c300511829f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b729ec06f2275aba9d5c300511829f">&#9670;&#160;</a></span>nChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::SymbolicExpression::Node::nChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of arguments. </p>
<p>Returns the number of children for an interior node, zero for leaf nodes. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#ad40e56601b3af934ae9d096841ed7680">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a576a11973189821a35c073208b800d0c">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="ae2d22be691cf45c4626ed4116eef6f30" name="ae2d22be691cf45c4626ed4116eef6f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d22be691cf45c4626ed4116eef6f30">&#9670;&#160;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp; Rose::BinaryAnalysis::SymbolicExpression::Node::child </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument. </p>
<p>Returns the specified argument by index. If the index is out of range, then returns null. A leaf node always returns null since it never has children. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aaaab2064f1bb704bf1626253bbc22c94">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ae9a80bf2a6ade4d47454ac3625853d5b">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a39684cbee10da1cf1e553182ad61d93e" name="a39684cbee10da1cf1e553182ad61d93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39684cbee10da1cf1e553182ad61d93e">&#9670;&#160;</a></span>childRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> * Rose::BinaryAnalysis::SymbolicExpression::Node::childRaw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument. </p>
<p>Returns the specified argument by index. If the index is out of range, then returns null. A leaf node always returns null since it never has children. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a064e52c3ad7bfbbb02e97c16106aeffe">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a52c8fcf3ac69a4991cc7feef8eca6685">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a70c19853fc3b1c94563eaf8f13e5007b" name="a70c19853fc3b1c94563eaf8f13e5007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c19853fc3b1c94563eaf8f13e5007b">&#9670;&#160;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Nodes &amp; Rose::BinaryAnalysis::SymbolicExpression::Node::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Arguments. </p>
<p>Returns the arguments of an operation for an interior node, or an empty list for a leaf node. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#abec08aaef61e5b49b6c95127b8870307">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a0478c76516e85476c7f393d09abb68cf">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="ab463224309cacaa21f359cf935929f75" name="ab463224309cacaa21f359cf935929f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab463224309cacaa21f359cf935929f75">&#9670;&#160;</a></span>toUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; Rose::BinaryAnalysis::SymbolicExpression::Node::toUnsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unsigned integer value of the expression. </p>
<p>Returns nothing if the expression is not a concrete integer value or the value is too wide to be represented by the return type. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#ac6d456d1090a050bae2a3225bef6b0bd">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a9f8f3932a385c2c0cd9ffc787761157b">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a9738401442bb723c3202f1687f6de671" name="a9738401442bb723c3202f1687f6de671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9738401442bb723c3202f1687f6de671">&#9670;&#160;</a></span>toSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; int64_t &gt; Rose::BinaryAnalysis::SymbolicExpression::Node::toSigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The signed integer value of the expression. </p>
<p>Returns nothing if the expression is not a concrete integer value or the value doesn't fit in the return type. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a719924096a5750512c366e48f00ddaff">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#acf26833bb38a04fd9afc6b0163367e6d">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="ad1d445634c2ac85a3ae052cc4e249d71" name="ad1d445634c2ac85a3ae052cc4e249d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d445634c2ac85a3ae052cc4e249d71">&#9670;&#160;</a></span>isIntegerExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isIntegerExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is of an integer type. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00612">612</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00226">Rose::BinaryAnalysis::SymbolicExpression::Type::INTEGER</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00324">Rose::BinaryAnalysis::SymbolicExpression::Type::typeClass()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00637">isIntegerConstant()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00669">isIntegerVariable()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00629">isScalarExpr()</a>.</p>

</div>
</div>
<a id="ac5199dca72c6d392692b90e744adc263" name="ac5199dca72c6d392692b90e744adc263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5199dca72c6d392692b90e744adc263">&#9670;&#160;</a></span>isFloatingPointExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isFloatingPointExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is of a floating-point type. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00617">617</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00227">Rose::BinaryAnalysis::SymbolicExpression::Type::FP</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00324">Rose::BinaryAnalysis::SymbolicExpression::Type::typeClass()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00642">isFloatingPointConstant()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00674">isFloatingPointVariable()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00629">isScalarExpr()</a>.</p>

</div>
</div>
<a id="abea2b3523f2401682e3a9442bd781c15" name="abea2b3523f2401682e3a9442bd781c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea2b3523f2401682e3a9442bd781c15">&#9670;&#160;</a></span>isMemoryExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isMemoryExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is of a memory type. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00622">622</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00228">Rose::BinaryAnalysis::SymbolicExpression::Type::MEMORY</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00324">Rose::BinaryAnalysis::SymbolicExpression::Type::typeClass()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00679">isMemoryVariable()</a>.</p>

</div>
</div>
<a id="ab829b6434685caeec93f955ab9f7471f" name="ab829b6434685caeec93f955ab9f7471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab829b6434685caeec93f955ab9f7471f">&#9670;&#160;</a></span>isScalarExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isScalarExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the expression is a scalar type. </p>
<p>Integers and floating-point expressions are scalar, memory is not. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00629">629</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00617">isFloatingPointExpr()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00612">isIntegerExpr()</a>.</p>

</div>
</div>
<a id="a0df28fa6b71642a43fd1899529cca270" name="a0df28fa6b71642a43fd1899529cca270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df28fa6b71642a43fd1899529cca270">&#9670;&#160;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Node::isConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a constant. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#af6e2357995ee3c4526e69874314680d3">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a417489fab41e1db4673a90fed2c801c9">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00642">isFloatingPointConstant()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00637">isIntegerConstant()</a>.</p>

</div>
</div>
<a id="a54ecfa22d26e9724dccbf291c6669da0" name="a54ecfa22d26e9724dccbf291c6669da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ecfa22d26e9724dccbf291c6669da0">&#9670;&#160;</a></span>isIntegerConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isIntegerConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is an integer constant. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00637">637</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0df28fa6b71642a43fd1899529cca270">isConstant()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00612">isIntegerExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00649">isScalarConstant()</a>.</p>

</div>
</div>
<a id="a5323cec0c40b5771584a9b2fd4ba7105" name="a5323cec0c40b5771584a9b2fd4ba7105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5323cec0c40b5771584a9b2fd4ba7105">&#9670;&#160;</a></span>isFloatingPointConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isFloatingPointConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this epxression is a floating-point constant. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00642">642</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0df28fa6b71642a43fd1899529cca270">isConstant()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00617">isFloatingPointExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00649">isScalarConstant()</a>.</p>

</div>
</div>
<a id="a3e66d88572ecd51e879add8284fd0a64" name="a3e66d88572ecd51e879add8284fd0a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e66d88572ecd51e879add8284fd0a64">&#9670;&#160;</a></span>isScalarConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isScalarConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a scalar constant. </p>
<p>Integer and floating-point constants are scalar. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00649">649</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00642">isFloatingPointConstant()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00637">isIntegerConstant()</a>.</p>

</div>
</div>
<a id="aadfe6d4b7a2124abeece444aa3b0ddd1" name="aadfe6d4b7a2124abeece444aa3b0ddd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfe6d4b7a2124abeece444aa3b0ddd1">&#9670;&#160;</a></span>isVariable2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Node::isVariable2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a variable. </p>
<p>Warning: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> nodes have a deprecated isVariable method that returns false for memory state variables, thus this method has a "2" appended to its name. After a suitable period of deprecation for Leaf::isVariable, a new isVariable will be added to this class hiearchy and will have the same semantics as isVariable2, which will become deprecated. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a96e5fe9bba00fca957cc96b5ea520f7a">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a4b71c182555741a2e6418d83e49e8daa">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00674">isFloatingPointVariable()</a>, <a class="el" href="SymbolicExpression_8h_source.html#l00669">isIntegerVariable()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00679">isMemoryVariable()</a>.</p>

</div>
</div>
<a id="a2a36eb99cf5418d0c724180a9f25d593" name="a2a36eb99cf5418d0c724180a9f25d593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a36eb99cf5418d0c724180a9f25d593">&#9670;&#160;</a></span>variableId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; Rose::BinaryAnalysis::SymbolicExpression::Node::variableId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable ID number. </p>
<p>If this expression is a variable then returns the variable ID number, otherwise nothing. </p>

</div>
</div>
<a id="a0c2763916848fd850d7d789b2b192d30" name="a0c2763916848fd850d7d789b2b192d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2763916848fd850d7d789b2b192d30">&#9670;&#160;</a></span>isIntegerVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isIntegerVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is an integer variable. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00669">669</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00612">isIntegerExpr()</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aadfe6d4b7a2124abeece444aa3b0ddd1">isVariable2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00686">isScalarVariable()</a>.</p>

</div>
</div>
<a id="a38d385c59ccbad2264cc262f4e7765be" name="a38d385c59ccbad2264cc262f4e7765be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d385c59ccbad2264cc262f4e7765be">&#9670;&#160;</a></span>isFloatingPointVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isFloatingPointVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a floating-point variable. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00674">674</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00617">isFloatingPointExpr()</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aadfe6d4b7a2124abeece444aa3b0ddd1">isVariable2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00686">isScalarVariable()</a>.</p>

</div>
</div>
<a id="a679762843045af43cb32ac03dec41ef2" name="a679762843045af43cb32ac03dec41ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679762843045af43cb32ac03dec41ef2">&#9670;&#160;</a></span>isMemoryVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isMemoryVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a memory state variable. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00679">679</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00622">isMemoryExpr()</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aadfe6d4b7a2124abeece444aa3b0ddd1">isVariable2()</a>.</p>

</div>
</div>
<a id="a7a7f791741ff816e19268589f68bf8b6" name="a7a7f791741ff816e19268589f68bf8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7f791741ff816e19268589f68bf8b6">&#9670;&#160;</a></span>isScalarVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isScalarVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a scalar variable. </p>
<p>Integer and floating-point variables are scalar, memory variables are not. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00686">686</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00674">isFloatingPointVariable()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00669">isIntegerVariable()</a>.</p>

</div>
</div>
<a id="a98c6b16bcd8a718198fdcd8b874a26bf" name="a98c6b16bcd8a718198fdcd8b874a26bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c6b16bcd8a718198fdcd8b874a26bf">&#9670;&#160;</a></span>comment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::SymbolicExpression::Node::comment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Comment. </p>
<p>Comments can be changed after a node has been created since the comment is not intended to be used for anything but annotation and/or debugging. If many expressions are sharing the same node, then the comment is changed in all those expressions. Changing the comment property is allowed even though nodes are generally immutable because comments are not considered significant for comparisons, computing hash values, etc. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00698">698</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00463">comment_</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="a67648c26b65adccb3710f8d2a88551dc" name="a67648c26b65adccb3710f8d2a88551dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67648c26b65adccb3710f8d2a88551dc">&#9670;&#160;</a></span>comment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Node::comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Comment. </p>
<p>Comments can be changed after a node has been created since the comment is not intended to be used for anything but annotation and/or debugging. If many expressions are sharing the same node, then the comment is changed in all those expressions. Changing the comment property is allowed even though nodes are generally immutable because comments are not considered significant for comparisons, computing hash values, etc. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00701">701</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00463">comment_</a>.</p>

</div>
</div>
<a id="a80d4564d54dcc27002a51f5e83e575fa" name="a80d4564d54dcc27002a51f5e83e575fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d4564d54dcc27002a51f5e83e575fa">&#9670;&#160;</a></span>userData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Node::userData </td>
          <td>(</td>
          <td class="paramtype">boost::any &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: User-defined data. </p>
<p>User defined data is always optional and does not contribute to the hash value of an expression. The user-defined data can be changed at any time by the user even if the expression node to which it is attached is shared between many expressions. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00713">713</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00465">userData_</a>.</p>

</div>
</div>
<a id="aeb82e5a3ef07ca2876f8b5a1b949480c" name="aeb82e5a3ef07ca2876f8b5a1b949480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82e5a3ef07ca2876f8b5a1b949480c">&#9670;&#160;</a></span>userData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::any &amp; Rose::BinaryAnalysis::SymbolicExpression::Node::userData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: User-defined data. </p>
<p>User defined data is always optional and does not contribute to the hash value of an expression. The user-defined data can be changed at any time by the user even if the expression node to which it is attached is shared between many expressions. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00716">716</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00465">userData_</a>.</p>

</div>
</div>
<a id="a9400e3a4c11a81e183dbfbc0a3c9016e" name="a9400e3a4c11a81e183dbfbc0a3c9016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9400e3a4c11a81e183dbfbc0a3c9016e">&#9670;&#160;</a></span>nBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::SymbolicExpression::Node::nBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Number of significant bits. </p>
<p>An expression with a known value is guaranteed to have all higher-order bits cleared. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00724">724</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00332">Rose::BinaryAnalysis::SymbolicExpression::Type::nBits()</a>.</p>

</div>
</div>
<a id="ae2a5ef9fca6895de57fd49d4ed41ded9" name="ae2a5ef9fca6895de57fd49d4ed41ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a5ef9fca6895de57fd49d4ed41ded9">&#9670;&#160;</a></span>flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: User-defined bit flags. </p>
<p>This property is significant for hashing, comparisons, and possibly other operations, therefore it is immutable. To change the flags one must create a new expression; see <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a552e6affeb1a82b2ff20a4f39a68d072">newFlags</a>. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00732">732</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00462">flags_</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="a552e6affeb1a82b2ff20a4f39a68d072" name="a552e6affeb1a82b2ff20a4f39a68d072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552e6affeb1a82b2ff20a4f39a68d072">&#9670;&#160;</a></span>newFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::newFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets flags. </p>
<p>Since symbolic expressions are immutable it is not possible to change the flags directly. Therefore if the desired flags are different than the current flags a new expression is created that is the same in every other respect. If the flags are not changed then the original expression is returned. </p>

</div>
</div>
<a id="a0bb9599b465398f87191a448b11b5780" name="a0bb9599b465398f87191a448b11b5780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb9599b465398f87191a448b11b5780">&#9670;&#160;</a></span>domainWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rose::BinaryAnalysis::SymbolicExpression::Node::domainWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Width for memory expressions. </p>
<p>The return value is non-zero if and only if this tree node is a memory expression. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00744">744</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00340">Rose::BinaryAnalysis::SymbolicExpression::Type::addressWidth()</a>.</p>

</div>
</div>
<a id="a4e2eea5f7e1fe9f8b32e0ca3038cd4ab" name="a4e2eea5f7e1fe9f8b32e0ca3038cd4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2eea5f7e1fe9f8b32e0ca3038cd4ab">&#9670;&#160;</a></span>isScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether expression is scalar. </p>
<p>Everything is scalar except for memory. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00751">751</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00228">Rose::BinaryAnalysis::SymbolicExpression::Type::MEMORY</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00324">Rose::BinaryAnalysis::SymbolicExpression::Type::typeClass()</a>.</p>

</div>
</div>
<a id="aa208affad817dc6d89e5f4b7ee552f94" name="aa208affad817dc6d89e5f4b7ee552f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa208affad817dc6d89e5f4b7ee552f94">&#9670;&#160;</a></span>depthFirstTraversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">VisitAction</a> Rose::BinaryAnalysis::SymbolicExpression::Node::depthFirstTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the expression. </p>
<p>The expression is traversed in a depth-first visit. The final return value is the final return value of the last call to the visitor. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a173a216d4d603b4189f33d0d53cc05e1">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#a65578d97bc50c820c42a8db268eb2358">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a90aace1a79aa431d6be1d1f19ded39c9" name="a90aace1a79aa431d6be1d1f19ded39c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aace1a79aa431d6be1d1f19ded39c9">&#9670;&#160;</a></span>nNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t Rose::BinaryAnalysis::SymbolicExpression::Node::nNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size of an expression by counting the number of nodes. </p>
<p>Operates in constant time. Note that it is possible (even likely) for the 64-bit return value to overflow in expressions when many nodes are shared. For instance, the following loop will create an expression that contains more than 2^64 nodes:</p>
<div class="fragment"><div class="line">SymbolicExpression expr = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ae31d33b04101d29818bb5474919c8613">Leaf::createVariable</a>(32);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;64; ++i)</div>
<div class="line">    expr = <a class="code hl_function" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae5ceeb4b30f5e41fc1b1385025794280">makeAdd</a>(expr, expr)</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf_html_ae31d33b04101d29818bb5474919c8613"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ae31d33b04101d29818bb5474919c8613">Rose::BinaryAnalysis::SymbolicExpression::Leaf::createVariable</a></div><div class="ttdeci">static LeafPtr createVariable(const Type &amp;, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</div><div class="ttdoc">Create a new variable.</div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_html_ae5ceeb4b30f5e41fc1b1385025794280"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae5ceeb4b30f5e41fc1b1385025794280">Rose::BinaryAnalysis::SymbolicExpression::makeAdd</a></div><div class="ttdeci">Ptr makeAdd(const Ptr &amp;a, const Ptr &amp;b, const SmtSolverPtr &amp;solver=SmtSolverPtr(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</div><div class="ttdoc">Interior node constructor.</div></div>
</div><!-- fragment --><p>When an overflow occurs the result is meaningless.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a37ddbc715c01d4c9db9ce7beb3870bd7" title="Number of unique nodes in expression.">nNodesUnique</a> </dd></dl>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a74d09948ed3ac39201a6b9f13e3dab8f">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ab2f63e42138bebfd06f2be263393585c">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a18c996a02b7c0f8ecfe3db379b0211e1" name="a18c996a02b7c0f8ecfe3db379b0211e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c996a02b7c0f8ecfe3db379b0211e1">&#9670;&#160;</a></span>isInteriorNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::isInteriorNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic cast of this object to an interior node. </p>
<p>Returns null if the cast is not valid. </p>

</div>
</div>
<a id="aaca4b0d89020fd62390ae12d88231f1a" name="aaca4b0d89020fd62390ae12d88231f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca4b0d89020fd62390ae12d88231f1a">&#9670;&#160;</a></span>isInteriorNodeRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a> * Rose::BinaryAnalysis::SymbolicExpression::Node::isInteriorNodeRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic cast of this object to an interior node. </p>
<p>Returns null if the cast is not valid. </p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="aa51741dd7626aa6bf76c2fefc87ee15c" name="aa51741dd7626aa6bf76c2fefc87ee15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51741dd7626aa6bf76c2fefc87ee15c">&#9670;&#160;</a></span>isLeafNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> Rose::BinaryAnalysis::SymbolicExpression::Node::isLeafNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic cast of this object to a leaf node. </p>
<p>Returns null if the cast is not valid. </p>

</div>
</div>
<a id="ae867a0b78c5b62720b46513cb1e0e10f" name="ae867a0b78c5b62720b46513cb1e0e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867a0b78c5b62720b46513cb1e0e10f">&#9670;&#160;</a></span>isLeafNodeRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a> * Rose::BinaryAnalysis::SymbolicExpression::Node::isLeafNodeRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic cast of this object to a leaf node. </p>
<p>Returns null if the cast is not valid. </p>

</div>
</div>
<a id="a2b9811180477b08c100b72965f99c3da" name="a2b9811180477b08c100b72965f99c3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9811180477b08c100b72965f99c3da">&#9670;&#160;</a></span>isHashed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::isHashed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node has a hash value computed and cached. </p>
<p>The hash value zero is reserved to indicate that no hash has been computed; if a node happens to actually hash to zero, it will not be cached and will be recomputed for every call to hash(). </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00805">805</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00464">hashval_</a>.</p>

</div>
</div>
<a id="a2587115bb1a247402f90dbb4bfbd533a" name="a2587115bb1a247402f90dbb4bfbd533a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2587115bb1a247402f90dbb4bfbd533a">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a> Rose::BinaryAnalysis::SymbolicExpression::Node::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (and caches) the hash value for this node. </p>
<p>If a hash value is not cached in this node, then a new hash value is computed and cached. </p>

</div>
</div>
<a id="afd0edf10cd2ebf66cabd68609838553a" name="afd0edf10cd2ebf66cabd68609838553a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0edf10cd2ebf66cabd68609838553a">&#9670;&#160;</a></span>withFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a> Rose::BinaryAnalysis::SymbolicExpression::Node::withFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a node with a formatter for printing. </p>
<p>This is used for convenient printing with the "&lt;&lt;" operator. For instance:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> fmt;</div>
<div class="line">fmt.<a class="code hl_variable" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a0434625a3ceb97cc631723d308d76943">show_comments</a> = <a class="code hl_enumvalue" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a58dc437419a008be022514506fb29b08a85e8df5c27cc882f3a6e70848cc42c13">Formatter::CMT_AFTER</a>; <span class="comment">//show comments after the variable</span></div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a> expression = ...;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 1: &quot;</span>; expression-&gt;print(std::cout, fmt); std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 2: &quot;</span> &lt;&lt;expression-&gt;withFormat(fmt) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 3: &quot;</span> &lt;&lt;*expression+fmt &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter_html"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Rose::BinaryAnalysis::SymbolicExpression::Formatter</a></div><div class="ttdoc">Controls formatting of expression trees when printing.</div><div class="ttdef"><b>Definition</b> <a href="SymbolicExpression_8h_source.html#l00160">SymbolicExpression.h:160</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter_html_a0434625a3ceb97cc631723d308d76943"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a0434625a3ceb97cc631723d308d76943">Rose::BinaryAnalysis::SymbolicExpression::Formatter::show_comments</a></div><div class="ttdeci">ShowComments show_comments</div><div class="ttdoc">Show node comments when printing?</div><div class="ttdef"><b>Definition</b> <a href="SymbolicExpression_8h_source.html#l00171">SymbolicExpression.h:171</a></div></div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter_html_a58dc437419a008be022514506fb29b08a85e8df5c27cc882f3a6e70848cc42c13"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a58dc437419a008be022514506fb29b08a85e8df5c27cc882f3a6e70848cc42c13">Rose::BinaryAnalysis::SymbolicExpression::Formatter::CMT_AFTER</a></div><div class="ttdeci">@ CMT_AFTER</div><div class="ttdoc">Show comments after the node.</div><div class="ttdef"><b>Definition</b> <a href="SymbolicExpression_8h_source.html#l00164">SymbolicExpression.h:164</a></div></div>
<div class="ttc" id="aclassSawyer_1_1SharedPointer_html"><div class="ttname"><a href="classSawyer_1_1SharedPointer.html">Sawyer::SharedPointer&lt; Node &gt;</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00839">839</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SharedPointer_8h_source.html#l00407">Sawyer::SharedFromThis&lt; Node &gt;::sharedFromThis()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00840">operator+()</a>.</p>

</div>
</div>
<a id="a25faa0406d9ac372bea9e6cf86a91d2b" name="a25faa0406d9ac372bea9e6cf86a91d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25faa0406d9ac372bea9e6cf86a91d2b">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a> Rose::BinaryAnalysis::SymbolicExpression::Node::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines a node with a formatter for printing. </p>
<p>This is used for convenient printing with the "&lt;&lt;" operator. For instance:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> fmt;</div>
<div class="line">fmt.<a class="code hl_variable" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a0434625a3ceb97cc631723d308d76943">show_comments</a> = <a class="code hl_enumvalue" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html#a58dc437419a008be022514506fb29b08a85e8df5c27cc882f3a6e70848cc42c13">Formatter::CMT_AFTER</a>; <span class="comment">//show comments after the variable</span></div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1SharedPointer.html">Ptr</a> expression = ...;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 1: &quot;</span>; expression-&gt;print(std::cout, fmt); std::cout &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 2: &quot;</span> &lt;&lt;expression-&gt;withFormat(fmt) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt;<span class="stringliteral">&quot;method 3: &quot;</span> &lt;&lt;*expression+fmt &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00840">840</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00839">withFormat()</a>.</p>

</div>
</div>
<a id="a2364e3da620fa5afd424a0c48f35869d" name="a2364e3da620fa5afd424a0c48f35869d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2364e3da620fa5afd424a0c48f35869d">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SymbolicExpression::Node::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the expression to a stream. </p>
<p>The output is an S-expression with no line-feeds. The format of the output is controlled by the mutable <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html" title="Controls formatting of expression trees when printing.">Formatter</a> argument. </p>

<p>Implemented in <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0e3fdd53e186c07c07dbf935b597145e">Rose::BinaryAnalysis::SymbolicExpression::Interior</a>, and <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#abb875cc3b42dbf2514fd67732145d74e">Rose::BinaryAnalysis::SymbolicExpression::Leaf</a>.</p>

</div>
</div>
<a id="a3daa64f5d1daa3110f60408bfd3d3e11" name="a3daa64f5d1daa3110f60408bfd3d3e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3daa64f5d1daa3110f60408bfd3d3e11">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Node::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the expression to a stream. </p>
<p>The output is an S-expression with no line-feeds. The format of the output is controlled by the mutable <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html" title="Controls formatting of expression trees when printing.">Formatter</a> argument. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00848">848</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">References <a class="el" href="SymbolicExpression_8h_source.html#l00848">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00848">print()</a>.</p>

</div>
</div>
<a id="aac913729c72ab980b7cec178096fa8c3" name="aac913729c72ab980b7cec178096fa8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac913729c72ab980b7cec178096fa8c3">&#9670;&#160;</a></span>assertAcyclic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Node::assertAcyclic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that expressions are acyclic. </p>
<p>This is intended only for debugging. </p>

</div>
</div>
<a id="ae606f125a10a3787b5c8d615c25a1445" name="ae606f125a10a3787b5c8d615c25a1445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae606f125a10a3787b5c8d615c25a1445">&#9670;&#160;</a></span>findCommonSubexpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt; Rose::BinaryAnalysis::SymbolicExpression::Node::findCommonSubexpressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find common subexpressions. </p>
<p>Returns a vector of the largest common subexpressions. The list is computed by performing a depth-first search on this expression and adding expressions to the return vector whenever a subtree is encountered a second time. Therefore the if a common subexpression A contains another common subexpression B then B will appear earlier in the list than A. </p>

</div>
</div>
<a id="aa38f14e3470fc6f5b7d2923b8afa0559" name="aa38f14e3470fc6f5b7d2923b8afa0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38f14e3470fc6f5b7d2923b8afa0559">&#9670;&#160;</a></span>matchAddVariableConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::SymbolicExpression::Node::matchAddVariableConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether an expression is a variable plus a constant. </p>
<p>If this expression is of the form V + X or X + V where V is an integer variable and X is an integer constant, return true and make <code>variable</code> point to the variable and <code>constant</code> point to the constant. If the expression is not one of these forms, then return false without modifying the arguments. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2e9500e43872353ee8ca47ef77618bc7" name="a2e9500e43872353ee8ca47ef77618bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9500e43872353ee8ca47ef77618bc7">&#9670;&#160;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> Rose::BinaryAnalysis::SymbolicExpression::Node::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00461">461</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a63d313b2dbefb0562db93e9489571a62" name="a63d313b2dbefb0562db93e9489571a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d313b2dbefb0562db93e9489571a62">&#9670;&#160;</a></span>flags_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::flags_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit flags. </p>
<p>Meaning of flags is up to the user. Low-order 16 bits are reserved. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00462">462</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00732">flags()</a>.</p>

</div>
</div>
<a id="a4d0da3c3333c5085a1d462fe529796ff" name="a4d0da3c3333c5085a1d462fe529796ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0da3c3333c5085a1d462fe529796ff">&#9670;&#160;</a></span>comment_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::SymbolicExpression::Node::comment_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional comment. </p>
<p>Only for debugging; not significant for any calculation. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00463">463</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00698">comment()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00701">comment()</a>.</p>

</div>
</div>
<a id="a8e53001033983d1f6a7e9ad72d261502" name="a8e53001033983d1f6a7e9ad72d261502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e53001033983d1f6a7e9ad72d261502">&#9670;&#160;</a></span>hashval_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a> Rose::BinaryAnalysis::SymbolicExpression::Node::hashval_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional hash used as a quick way to indicate that two expressions are different. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00464">464</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00805">isHashed()</a>.</p>

</div>
</div>
<a id="a3cba13e8f5b635d9684e91ae88763f3a" name="a3cba13e8f5b635d9684e91ae88763f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba13e8f5b635d9684e91ae88763f3a">&#9670;&#160;</a></span>userData_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::any Rose::BinaryAnalysis::SymbolicExpression::Node::userData_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-specified data. </p>
<p>This is not part of the hash. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00465">465</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l00716">userData()</a>, and <a class="el" href="SymbolicExpression_8h_source.html#l00713">userData()</a>.</p>

</div>
</div>
<a id="adc12dfd081952860a7ee91531f33ec0a" name="adc12dfd081952860a7ee91531f33ec0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc12dfd081952860a7ee91531f33ec0a">&#9670;&#160;</a></span>RESERVED_FLAGS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::RESERVED_FLAGS = 0x0000ffff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These flags are reserved for use within ROSE. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00487">487</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="ae625ba620262131aa05e55c09710881b" name="ae625ba620262131aa05e55c09710881b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae625ba620262131aa05e55c09710881b">&#9670;&#160;</a></span>INDETERMINATE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::INDETERMINATE = 0x00000001</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value is somehow indeterminate. </p>
<p>E.g., read from writable memory. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00490">490</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a1748427bef1cc117706dbf9100e8cdf8" name="a1748427bef1cc117706dbf9100e8cdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1748427bef1cc117706dbf9100e8cdf8">&#9670;&#160;</a></span>UNSPECIFIED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::UNSPECIFIED = 0x00000002</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value is somehow unspecified. </p>
<p>A value that is intantiated as part of processing a machine instruction where the ISA documentation is incomplete or says that some result is unspecified or undefined. Intel documentation for the x86 shift and rotate instructions, for example, states that certain status bits have "undefined" values after the instruction executes. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00496">496</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TaintSemantics_8h_source.html#l00116">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_unspecified()</a>.</p>

</div>
</div>
<a id="abbd3df8be8c21eebf285fd2295c170e9" name="abbd3df8be8c21eebf285fd2295c170e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd3df8be8c21eebf285fd2295c170e9">&#9670;&#160;</a></span>BOTTOM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Rose::BinaryAnalysis::SymbolicExpression::Node::BOTTOM = 0x00000004</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value represents bottom in dataflow analysis. </p>
<p>If this flag is used by ROSE's dataflow engine to represent a bottom value in a lattice. </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00500">500</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TaintSemantics_8h_source.html#l00106">Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::SValue::instance_bottom()</a>.</p>

</div>
</div>
<a id="a33b9f5524dafe8a99d7f8b2b7cbfd086" name="a33b9f5524dafe8a99d7f8b2b7cbfd086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b9f5524dafe8a99d7f8b2b7cbfd086">&#9670;&#160;</a></span>mayEqualCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::logic::tribool(* Rose::BinaryAnalysis::SymbolicExpression::Node::mayEqualCallback) (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User-supplied predicate to augment alias checking. </p>
<p>If this pointer is non-null, then the <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">mayEqual</a> methods invoke this function. If this function returns true or false, then its return value becomes the return value of <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">mayEqual</a>, otherwise <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">mayEqual</a> continues as it normally would. This user-defined function is invoked by <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">mayEqual</a> after trivial situations are checked and before any calls to an SMT solver. The SMT solver argument is optional (may be null). </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l00523">523</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
