<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::CommandLine::Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1CommandLine.html">CommandLine</a></li><li class="navelem"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSawyer_1_1CommandLine_1_1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::CommandLine::Parser Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The parser for a program command line. </p>
<p>A parser is configured to describe the valid program switches, their arguments, and other information, and then the parser is then applied to a program command line to return a <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html" title="The result from parsing a command line.">ParserResult</a>. The process of parsing a command line is free of side-effects other than creating the result. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02756">2756</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a479b41f1272f8a56ec6dccd63d42b11a" id="r_a479b41f1272f8a56ec6dccd63d42b11a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11a">GroupingFlags</a> { <br />
&#160;&#160;<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11aae315e26ad76defa67bd1809e44af4559">DEFAULT_GROUPING</a> = 0
, <br />
&#160;&#160;<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11aaba0531812023c7b4c42c85915abd6743">PROHIBIT_EMPTY_GROUPS</a> = 0x0001
, <br />
&#160;&#160;<a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11aae9f806c78f3d510b9d75493144453ffc">SPLIT_SINGLE_GROUP</a> = 0x0002
<br />
 }</td></tr>
<tr class="memdesc:a479b41f1272f8a56ec6dccd63d42b11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags for argument grouping.  <a href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11a">More...</a><br /></td></tr>
<tr class="separator:a479b41f1272f8a56ec6dccd63d42b11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7758348f27970f02ca2685857022e6a9" id="r_a7758348f27970f02ca2685857022e6a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a7758348f27970f02ca2685857022e6a9">Parser</a> ()</td></tr>
<tr class="memdesc:a7758348f27970f02ca2685857022e6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a7758348f27970f02ca2685857022e6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea76762cd7eb3c99f7ac6a1ba850061" id="r_a9ea76762cd7eb3c99f7ac6a1ba850061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9ea76762cd7eb3c99f7ac6a1ba850061">switchGroupExists</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a9ea76762cd7eb3c99f7ac6a1ba850061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to determine whether a switch group exists.  <br /></td></tr>
<tr class="separator:a9ea76762cd7eb3c99f7ac6a1ba850061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b24492a68494753c03c9d508ad26c" id="r_ac08b24492a68494753c03c9d508ad26c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ac08b24492a68494753c03c9d508ad26c">eraseSwitchGroup</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ac08b24492a68494753c03c9d508ad26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove switch group from parser.  <br /></td></tr>
<tr class="separator:ac08b24492a68494753c03c9d508ad26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadfcac830d7855ae15b39ef9ce1aebb" id="r_acadfcac830d7855ae15b39ef9ce1aebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#acadfcac830d7855ae15b39ef9ce1aebb">parse</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:acadfcac830d7855ae15b39ef9ce1aebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse program arguments.  <br /></td></tr>
<tr class="separator:acadfcac830d7855ae15b39ef9ce1aebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0ac5eabe8e9e08cb6704be7d54f2af" id="r_a7a0ac5eabe8e9e08cb6704be7d54f2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a7a0ac5eabe8e9e08cb6704be7d54f2af">parse</a> (const std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:a7a0ac5eabe8e9e08cb6704be7d54f2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse program arguments.  <br /></td></tr>
<tr class="separator:a7a0ac5eabe8e9e08cb6704be7d54f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dd9dd921d66434ede313e15da672a" id="r_afc6dd9dd921d66434ede313e15da672a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afc6dd9dd921d66434ede313e15da672a">expandIncludedFiles</a> (const std::vector&lt; std::string &gt; &amp;args)</td></tr>
<tr class="memdesc:afc6dd9dd921d66434ede313e15da672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand file arguments.  <br /></td></tr>
<tr class="separator:afc6dd9dd921d66434ede313e15da672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa7ac025d7ddc43608f95157700615" id="r_a6daa7ac025d7ddc43608f95157700615"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a6daa7ac025d7ddc43608f95157700615">regroupArgs</a> (const std::vector&lt; std::string &gt; &amp;args, const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Container::Interval</a>&lt; size_t &gt; &amp;limits=<a class="el" href="classSawyer_1_1Container_1_1Interval.html">Container::Interval</a>&lt; size_t &gt;::whole(), unsigned flags=0)</td></tr>
<tr class="memdesc:a6daa7ac025d7ddc43608f95157700615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group arguments by "--" separators.  <br /></td></tr>
<tr class="separator:a6daa7ac025d7ddc43608f95157700615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941cbb15450a15ba137c9c420e0b7ba3" id="r_a941cbb15450a15ba137c9c420e0b7ba3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a941cbb15450a15ba137c9c420e0b7ba3">documentationMarkup</a> () const</td></tr>
<tr class="memdesc:a941cbb15450a15ba137c9c420e0b7ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full documentation.  <br /></td></tr>
<tr class="separator:a941cbb15450a15ba137c9c420e0b7ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae2a35c9edd8527da0cbfbe33a239b" id="r_a9dae2a35c9edd8527da0cbfbe33a239b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9dae2a35c9edd8527da0cbfbe33a239b">podDocumentation</a> () const</td></tr>
<tr class="memdesc:a9dae2a35c9edd8527da0cbfbe33a239b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Perl POD documentation.  <br /></td></tr>
<tr class="separator:a9dae2a35c9edd8527da0cbfbe33a239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b89f4d94a53a36bd641026708e5b14a" id="r_a7b89f4d94a53a36bd641026708e5b14a"><td class="memItemLeft" align="right" valign="top"><a id="a7b89f4d94a53a36bd641026708e5b14a" name="a7b89f4d94a53a36bd641026708e5b14a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>textDocumentation</b> () const</td></tr>
<tr class="memdesc:a7b89f4d94a53a36bd641026708e5b14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate plain text documentation. <br /></td></tr>
<tr class="separator:a7b89f4d94a53a36bd641026708e5b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3762e2e259b2473ba71e8e4bf88c3023" id="r_a3762e2e259b2473ba71e8e4bf88c3023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3762e2e259b2473ba71e8e4bf88c3023">emitDocumentationToPager</a> () const</td></tr>
<tr class="memdesc:a3762e2e259b2473ba71e8e4bf88c3023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print documentation to standard output.  <br /></td></tr>
<tr class="separator:a3762e2e259b2473ba71e8e4bf88c3023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab892aa54728067ea0f4600f46ef357fe" id="r_ab892aa54728067ea0f4600f46ef357fe"><td class="memTemplParams" colspan="2">template&lt;class Grammar &gt; </td></tr>
<tr class="memitem:ab892aa54728067ea0f4600f46ef357fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ab892aa54728067ea0f4600f46ef357fe">emitDocumentationToPager</a> () const</td></tr>
<tr class="separator:ab892aa54728067ea0f4600f46ef357fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8db56b2546fb17b09bb57d391f48a5" id="r_afa8db56b2546fb17b09bb57d391f48a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afa8db56b2546fb17b09bb57d391f48a5">insertLongSwitchStrings</a> (<a class="el" href="namespaceSawyer_1_1CommandLine.html#a0026e9ad4f6337fee94ca6661fc82aeb">Canonical</a>, <a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;index) const</td></tr>
<tr class="memdesc:afa8db56b2546fb17b09bb57d391f48a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert records for long switch strings.  <br /></td></tr>
<tr class="separator:afa8db56b2546fb17b09bb57d391f48a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee1665553c23dcda3d3419754c56cb" id="r_a4bee1665553c23dcda3d3419754c56cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4bee1665553c23dcda3d3419754c56cb">insertShortSwitchStrings</a> (<a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;index) const</td></tr>
<tr class="memdesc:a4bee1665553c23dcda3d3419754c56cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert records for short switch strings.  <br /></td></tr>
<tr class="separator:a4bee1665553c23dcda3d3419754c56cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fb6971c98bb4184bc7f4b3df06828c" id="r_a69fb6971c98bb4184bc7f4b3df06828c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a69fb6971c98bb4184bc7f4b3df06828c">insertSwitchStrings</a> (<a class="el" href="namespaceSawyer_1_1CommandLine.html#a0026e9ad4f6337fee94ca6661fc82aeb">Canonical</a>, <a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;index) const</td></tr>
<tr class="memdesc:a69fb6971c98bb4184bc7f4b3df06828c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert records for long and short switch strings.  <br /></td></tr>
<tr class="separator:a69fb6971c98bb4184bc7f4b3df06828c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07197e8b4e5589613f6277cb1b9124b4" id="r_a07197e8b4e5589613f6277cb1b9124b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a07197e8b4e5589613f6277cb1b9124b4">findAmbiguities</a> () const</td></tr>
<tr class="memdesc:a07197e8b4e5589613f6277cb1b9124b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find switch string ambiguities.  <br /></td></tr>
<tr class="separator:a07197e8b4e5589613f6277cb1b9124b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f6c7a8d09cd86c864e2b23eb432eed" id="r_aa1f6c7a8d09cd86c864e2b23eb432eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aa1f6c7a8d09cd86c864e2b23eb432eed">findUnresolvableAmbiguities</a> () const</td></tr>
<tr class="memdesc:aa1f6c7a8d09cd86c864e2b23eb432eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find unresolvable switch string ambiguities.  <br /></td></tr>
<tr class="separator:aa1f6c7a8d09cd86c864e2b23eb432eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b05906fa51b5d303eccbc65b23776c" id="r_a85b05906fa51b5d303eccbc65b23776c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structSawyer_1_1CommandLine_1_1ParsingProperties.html">ParsingProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85b05906fa51b5d303eccbc65b23776c">properties</a> () const</td></tr>
<tr class="separator:a85b05906fa51b5d303eccbc65b23776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a150a5ad8e88776f5ba73df0a6b76a9d9" id="r_a150a5ad8e88776f5ba73df0a6b76a9d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a150a5ad8e88776f5ba73df0a6b76a9d9">with</a> (const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;sg)</td></tr>
<tr class="memdesc:a150a5ad8e88776f5ba73df0a6b76a9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switch declarations.  <br /></td></tr>
<tr class="separator:a150a5ad8e88776f5ba73df0a6b76a9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dce3fb9349b9e75e2fd6f3861670515" id="r_a2dce3fb9349b9e75e2fd6f3861670515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a2dce3fb9349b9e75e2fd6f3861670515">with</a> (const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;sg, const std::string &amp;docKey)</td></tr>
<tr class="memdesc:a2dce3fb9349b9e75e2fd6f3861670515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switch declarations.  <br /></td></tr>
<tr class="separator:a2dce3fb9349b9e75e2fd6f3861670515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae667a46ad93774357a15942c8a2689ce" id="r_ae667a46ad93774357a15942c8a2689ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae667a46ad93774357a15942c8a2689ce">with</a> (const std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp;sgs)</td></tr>
<tr class="memdesc:ae667a46ad93774357a15942c8a2689ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switch declarations.  <br /></td></tr>
<tr class="separator:ae667a46ad93774357a15942c8a2689ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a4b4a9595b8f63d6baa5983e5f603" id="r_a3a0a4b4a9595b8f63d6baa5983e5f603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3a0a4b4a9595b8f63d6baa5983e5f603">with</a> (const <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &amp;sw)</td></tr>
<tr class="memdesc:a3a0a4b4a9595b8f63d6baa5983e5f603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switch declarations.  <br /></td></tr>
<tr class="separator:a3a0a4b4a9595b8f63d6baa5983e5f603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1cd0b7af341055ae1132c75a5b885b" id="r_aed1cd0b7af341055ae1132c75a5b885b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aed1cd0b7af341055ae1132c75a5b885b">with</a> (<a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> sw, const std::string &amp;docKey)</td></tr>
<tr class="memdesc:aed1cd0b7af341055ae1132c75a5b885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add switch declarations.  <br /></td></tr>
<tr class="separator:aed1cd0b7af341055ae1132c75a5b885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab705590caff906243a983125a01df793" id="r_ab705590caff906243a983125a01df793"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ab705590caff906243a983125a01df793">switchGroups</a> () const</td></tr>
<tr class="memdesc:ab705590caff906243a983125a01df793"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all switch groups.  <br /></td></tr>
<tr class="separator:ab705590caff906243a983125a01df793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fccf3c0fe522c622561f064a5522ac1" id="r_a0fccf3c0fe522c622561f064a5522ac1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a0fccf3c0fe522c622561f064a5522ac1">switchGroups</a> ()</td></tr>
<tr class="memdesc:a0fccf3c0fe522c622561f064a5522ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all switch groups.  <br /></td></tr>
<tr class="separator:a0fccf3c0fe522c622561f064a5522ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0d480cd6129adac4b0d3da94763914c" id="r_ac0d480cd6129adac4b0d3da94763914c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ac0d480cd6129adac4b0d3da94763914c">switchGroup</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac0d480cd6129adac4b0d3da94763914c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html" title="Describes one command-line switch.">Switch</a> group having specified name.  <br /></td></tr>
<tr class="separator:ac0d480cd6129adac4b0d3da94763914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8900450f66491c61a333761d03dfa7" id="r_a2d8900450f66491c61a333761d03dfa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a2d8900450f66491c61a333761d03dfa7">switchGroup</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2d8900450f66491c61a333761d03dfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html" title="Describes one command-line switch.">Switch</a> group having specified name.  <br /></td></tr>
<tr class="separator:a2d8900450f66491c61a333761d03dfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af68a22d65e33f5b254d799573882fc06" id="r_af68a22d65e33f5b254d799573882fc06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af68a22d65e33f5b254d799573882fc06">reportingAmbiguities</a> () const</td></tr>
<tr class="memdesc:af68a22d65e33f5b254d799573882fc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to report ambiguities.  <br /></td></tr>
<tr class="separator:af68a22d65e33f5b254d799573882fc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8095c65786896086d0c402f226b52c96" id="r_a8095c65786896086d0c402f226b52c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8095c65786896086d0c402f226b52c96">reportingAmbiguities</a> (bool b)</td></tr>
<tr class="memdesc:a8095c65786896086d0c402f226b52c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to report ambiguities.  <br /></td></tr>
<tr class="separator:a8095c65786896086d0c402f226b52c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1bcfe1e27264227116894ce0048001b" id="r_ae1bcfe1e27264227116894ce0048001b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae1bcfe1e27264227116894ce0048001b">groupNameSeparator</a> () const</td></tr>
<tr class="memdesc:ae1bcfe1e27264227116894ce0048001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: String separating group name from switch name.  <br /></td></tr>
<tr class="separator:ae1bcfe1e27264227116894ce0048001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc5870d65fccab4c1dec83a5257ddc" id="r_ae9fc5870d65fccab4c1dec83a5257ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae9fc5870d65fccab4c1dec83a5257ddc">groupNameSeparator</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae9fc5870d65fccab4c1dec83a5257ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: String separating group name from switch name.  <br /></td></tr>
<tr class="separator:ae9fc5870d65fccab4c1dec83a5257ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab808bb85559dc5b083d4dde1cc2927f7" id="r_ab808bb85559dc5b083d4dde1cc2927f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a23bda2bb5cdd8e62f60e13401cec9352">ShowGroupName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ab808bb85559dc5b083d4dde1cc2927f7">showingGroupNames</a> () const</td></tr>
<tr class="memdesc:ab808bb85559dc5b083d4dde1cc2927f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to show group names in switch documentation.  <br /></td></tr>
<tr class="separator:ab808bb85559dc5b083d4dde1cc2927f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1544b3bab64d9426d14a6d0a41aec0e" id="r_ae1544b3bab64d9426d14a6d0a41aec0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae1544b3bab64d9426d14a6d0a41aec0e">showingGroupNames</a> (<a class="el" href="namespaceSawyer_1_1CommandLine.html#a23bda2bb5cdd8e62f60e13401cec9352">ShowGroupName</a> x)</td></tr>
<tr class="memdesc:ae1544b3bab64d9426d14a6d0a41aec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to show group names in switch documentation.  <br /></td></tr>
<tr class="separator:ae1544b3bab64d9426d14a6d0a41aec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aace01d8f250dd64892582341613b90ae" id="r_aace01d8f250dd64892582341613b90ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aace01d8f250dd64892582341613b90ae">resetLongPrefixes</a> (const std::string &amp;s1=STR_NONE, const std::string &amp;s2=STR_NONE, const std::string &amp;s3=STR_NONE, const std::string &amp;s4=STR_NONE)</td></tr>
<tr class="memdesc:aace01d8f250dd64892582341613b90ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for long command-line switches.  <br /></td></tr>
<tr class="separator:aace01d8f250dd64892582341613b90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe6cb949af618d8efd91fe9db7b29f" id="r_a3cfe6cb949af618d8efd91fe9db7b29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3cfe6cb949af618d8efd91fe9db7b29f">longPrefix</a> (const std::string &amp;s1)</td></tr>
<tr class="memdesc:a3cfe6cb949af618d8efd91fe9db7b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for long command-line switches.  <br /></td></tr>
<tr class="separator:a3cfe6cb949af618d8efd91fe9db7b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133635a506d60e1dac763a21fd8d3ec" id="r_af133635a506d60e1dac763a21fd8d3ec"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af133635a506d60e1dac763a21fd8d3ec">longPrefixes</a> () const</td></tr>
<tr class="memdesc:af133635a506d60e1dac763a21fd8d3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for long command-line switches.  <br /></td></tr>
<tr class="separator:af133635a506d60e1dac763a21fd8d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a190fc175b9f4ce2d6078d484092b0675" id="r_a190fc175b9f4ce2d6078d484092b0675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a190fc175b9f4ce2d6078d484092b0675">resetShortPrefixes</a> (const std::string &amp;s1=STR_NONE, const std::string &amp;s2=STR_NONE, const std::string &amp;s3=STR_NONE, const std::string &amp;s4=STR_NONE)</td></tr>
<tr class="memdesc:a190fc175b9f4ce2d6078d484092b0675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for short command-line switches.  <br /></td></tr>
<tr class="separator:a190fc175b9f4ce2d6078d484092b0675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b569ce8188be4cbd356da4e328b36b" id="r_a61b569ce8188be4cbd356da4e328b36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a61b569ce8188be4cbd356da4e328b36b">shortPrefix</a> (const std::string &amp;s1)</td></tr>
<tr class="memdesc:a61b569ce8188be4cbd356da4e328b36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for short command-line switches.  <br /></td></tr>
<tr class="separator:a61b569ce8188be4cbd356da4e328b36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af697858e05d3112812f8a1d7bbf5f" id="r_a59af697858e05d3112812f8a1d7bbf5f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a59af697858e05d3112812f8a1d7bbf5f">shortPrefixes</a> () const</td></tr>
<tr class="memdesc:a59af697858e05d3112812f8a1d7bbf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefixes to use for short command-line switches.  <br /></td></tr>
<tr class="separator:a59af697858e05d3112812f8a1d7bbf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a85d28dc09342e027e7ed4d2158411597" id="r_a85d28dc09342e027e7ed4d2158411597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85d28dc09342e027e7ed4d2158411597">resetValueSeparators</a> (const std::string &amp;s1=STR_NONE, const std::string &amp;s2=STR_NONE, const std::string &amp;s3=STR_NONE, const std::string &amp;s4=STR_NONE)</td></tr>
<tr class="memdesc:a85d28dc09342e027e7ed4d2158411597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that separate a long switch from its value.  <br /></td></tr>
<tr class="separator:a85d28dc09342e027e7ed4d2158411597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6f9298cc874ce9c876064cbfc6c0be" id="r_a9a6f9298cc874ce9c876064cbfc6c0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9a6f9298cc874ce9c876064cbfc6c0be">valueSeparator</a> (const std::string &amp;s1)</td></tr>
<tr class="memdesc:a9a6f9298cc874ce9c876064cbfc6c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that separate a long switch from its value.  <br /></td></tr>
<tr class="separator:a9a6f9298cc874ce9c876064cbfc6c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a2d9ccae76a815a09f1421e546f79" id="r_a269a2d9ccae76a815a09f1421e546f79"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a269a2d9ccae76a815a09f1421e546f79">valueSeparators</a> () const</td></tr>
<tr class="memdesc:a269a2d9ccae76a815a09f1421e546f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that separate a long switch from its value.  <br /></td></tr>
<tr class="separator:a269a2d9ccae76a815a09f1421e546f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad5b0edbd2366eb638ba735ec101017fa" id="r_ad5b0edbd2366eb638ba735ec101017fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ad5b0edbd2366eb638ba735ec101017fa">resetTerminationSwitches</a> (const std::string &amp;s1=STR_NONE, const std::string &amp;s2=STR_NONE, const std::string &amp;s3=STR_NONE, const std::string &amp;s4=STR_NONE)</td></tr>
<tr class="memdesc:ad5b0edbd2366eb638ba735ec101017fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate the end of the argument list.  <br /></td></tr>
<tr class="separator:ad5b0edbd2366eb638ba735ec101017fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26429f6a315c8bd47d82f08f77f4c78" id="r_af26429f6a315c8bd47d82f08f77f4c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af26429f6a315c8bd47d82f08f77f4c78">terminationSwitch</a> (const std::string &amp;s1)</td></tr>
<tr class="memdesc:af26429f6a315c8bd47d82f08f77f4c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate the end of the argument list.  <br /></td></tr>
<tr class="separator:af26429f6a315c8bd47d82f08f77f4c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d43a2f13353aa22abac3d3e1b9975b8" id="r_a5d43a2f13353aa22abac3d3e1b9975b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a5d43a2f13353aa22abac3d3e1b9975b8">terminationSwitches</a> () const</td></tr>
<tr class="memdesc:a5d43a2f13353aa22abac3d3e1b9975b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate the end of the argument list.  <br /></td></tr>
<tr class="separator:a5d43a2f13353aa22abac3d3e1b9975b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4733cab32eeb6b0f353dc9ea99e6cd0d" id="r_a4733cab32eeb6b0f353dc9ea99e6cd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4733cab32eeb6b0f353dc9ea99e6cd0d">shortMayNestle</a> (bool b)</td></tr>
<tr class="memdesc:a4733cab32eeb6b0f353dc9ea99e6cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether short switches can nestle together.  <br /></td></tr>
<tr class="separator:a4733cab32eeb6b0f353dc9ea99e6cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d8677d55d933a756971a19ea9f3e36" id="r_af4d8677d55d933a756971a19ea9f3e36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af4d8677d55d933a756971a19ea9f3e36">shortMayNestle</a> () const</td></tr>
<tr class="memdesc:af4d8677d55d933a756971a19ea9f3e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether short switches can nestle together.  <br /></td></tr>
<tr class="separator:af4d8677d55d933a756971a19ea9f3e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23dff1a3c8992e71ca95f220c6be3c98" id="r_a23dff1a3c8992e71ca95f220c6be3c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a23dff1a3c8992e71ca95f220c6be3c98">resetInclusionPrefixes</a> (const std::string &amp;s1=STR_NONE, const std::string &amp;s2=STR_NONE, const std::string &amp;s3=STR_NONE, const std::string &amp;s4=STR_NONE)</td></tr>
<tr class="memdesc:a23dff1a3c8992e71ca95f220c6be3c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate that arguments are to be read from a file.  <br /></td></tr>
<tr class="separator:a23dff1a3c8992e71ca95f220c6be3c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7d6ca643f0061de1b22c1f9745388" id="r_a56c7d6ca643f0061de1b22c1f9745388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a56c7d6ca643f0061de1b22c1f9745388">inclusionPrefix</a> (const std::string &amp;s1)</td></tr>
<tr class="memdesc:a56c7d6ca643f0061de1b22c1f9745388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate that arguments are to be read from a file.  <br /></td></tr>
<tr class="separator:a56c7d6ca643f0061de1b22c1f9745388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f63b6436f7ee43b6df61091f261a6fc" id="r_a9f63b6436f7ee43b6df61091f261a6fc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9f63b6436f7ee43b6df61091f261a6fc">inclusionPrefixes</a> () const</td></tr>
<tr class="memdesc:a9f63b6436f7ee43b6df61091f261a6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings that indicate that arguments are to be read from a file.  <br /></td></tr>
<tr class="separator:a9f63b6436f7ee43b6df61091f261a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8713b988440015fe322df4ad7de1884a" id="r_a8713b988440015fe322df4ad7de1884a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8713b988440015fe322df4ad7de1884a">skippingNonSwitches</a> (bool b)</td></tr>
<tr class="memdesc:a8713b988440015fe322df4ad7de1884a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to skip over non-switch arguments when parsing.  <br /></td></tr>
<tr class="separator:a8713b988440015fe322df4ad7de1884a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238fbd4717b9e5451cc2b205906ec78a" id="r_a238fbd4717b9e5451cc2b205906ec78a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a238fbd4717b9e5451cc2b205906ec78a">skippingNonSwitches</a> () const</td></tr>
<tr class="memdesc:a238fbd4717b9e5451cc2b205906ec78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to skip over non-switch arguments when parsing.  <br /></td></tr>
<tr class="separator:a238fbd4717b9e5451cc2b205906ec78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8e30b8ff9d6edf9565c000245e36c595" id="r_a8e30b8ff9d6edf9565c000245e36c595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8e30b8ff9d6edf9565c000245e36c595">skippingUnknownSwitches</a> (bool b)</td></tr>
<tr class="memdesc:a8e30b8ff9d6edf9565c000245e36c595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to skip over unrecognized switches.  <br /></td></tr>
<tr class="separator:a8e30b8ff9d6edf9565c000245e36c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e8ed52db6587c679d63ea1048ddcec" id="r_a85e8ed52db6587c679d63ea1048ddcec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85e8ed52db6587c679d63ea1048ddcec">skippingUnknownSwitches</a> () const</td></tr>
<tr class="memdesc:a85e8ed52db6587c679d63ea1048ddcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to skip over unrecognized switches.  <br /></td></tr>
<tr class="separator:a85e8ed52db6587c679d63ea1048ddcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:add53661b05a756fedb1b1b19db7d911f" id="r_add53661b05a756fedb1b1b19db7d911f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> (const <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> &amp;stream)</td></tr>
<tr class="memdesc:add53661b05a756fedb1b1b19db7d911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a message stream to which errors are sent.  <br /></td></tr>
<tr class="separator:add53661b05a756fedb1b1b19db7d911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f04652793d967126c28615eb037efa" id="r_ae0f04652793d967126c28615eb037efa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae0f04652793d967126c28615eb037efa">errorStream</a> () const</td></tr>
<tr class="memdesc:ae0f04652793d967126c28615eb037efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a message stream to which errors are sent.  <br /></td></tr>
<tr class="separator:ae0f04652793d967126c28615eb037efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af091f262cc6c7c0f84aeab5b49bc5032" id="r_af091f262cc6c7c0f84aeab5b49bc5032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af091f262cc6c7c0f84aeab5b49bc5032">exitMessage</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:af091f262cc6c7c0f84aeab5b49bc5032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra text to print before exit.  <br /></td></tr>
<tr class="separator:af091f262cc6c7c0f84aeab5b49bc5032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924fc843f9e6013c515a5ee621fb2844" id="r_a924fc843f9e6013c515a5ee621fb2844"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a924fc843f9e6013c515a5ee621fb2844">exitMessage</a> () const</td></tr>
<tr class="memdesc:a924fc843f9e6013c515a5ee621fb2844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra text to print before exit.  <br /></td></tr>
<tr class="separator:a924fc843f9e6013c515a5ee621fb2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1b967e3ee7cfab7517acba72d9d1fa3" id="r_ae1b967e3ee7cfab7517acba72d9d1fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae1b967e3ee7cfab7517acba72d9d1fa3">environmentVariable</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae1b967e3ee7cfab7517acba72d9d1fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of environment variable holding initial arguments.  <br /></td></tr>
<tr class="separator:ae1b967e3ee7cfab7517acba72d9d1fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a699f5d5a266085ba40e9dd53047a21" id="r_a3a699f5d5a266085ba40e9dd53047a21"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3a699f5d5a266085ba40e9dd53047a21">environmentVariable</a> () const</td></tr>
<tr class="memdesc:a3a699f5d5a266085ba40e9dd53047a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of environment variable holding initial arguments.  <br /></td></tr>
<tr class="separator:a3a699f5d5a266085ba40e9dd53047a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb94abbccdbeffe70602d6763f7f6804" id="r_abb94abbccdbeffe70602d6763f7f6804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abb94abbccdbeffe70602d6763f7f6804">programName</a> (const std::string &amp;programName)</td></tr>
<tr class="memdesc:abb94abbccdbeffe70602d6763f7f6804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program name for documentation.  <br /></td></tr>
<tr class="separator:abb94abbccdbeffe70602d6763f7f6804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ca3259d7fc9a1a37278f0bb5a8d2b2" id="r_ab9ca3259d7fc9a1a37278f0bb5a8d2b2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ab9ca3259d7fc9a1a37278f0bb5a8d2b2">programName</a> () const</td></tr>
<tr class="memdesc:ab9ca3259d7fc9a1a37278f0bb5a8d2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program name for documentation.  <br /></td></tr>
<tr class="separator:ab9ca3259d7fc9a1a37278f0bb5a8d2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4f432e9e38d0c5c1966d521cc09e00c0" id="r_a4f432e9e38d0c5c1966d521cc09e00c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> (const std::string &amp;purpose)</td></tr>
<tr class="memdesc:a4f432e9e38d0c5c1966d521cc09e00c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program purpose.  <br /></td></tr>
<tr class="separator:a4f432e9e38d0c5c1966d521cc09e00c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e6ded376028cb255550931bc617f0" id="r_aea9e6ded376028cb255550931bc617f0"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aea9e6ded376028cb255550931bc617f0">purpose</a> () const</td></tr>
<tr class="memdesc:aea9e6ded376028cb255550931bc617f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program purpose.  <br /></td></tr>
<tr class="separator:aea9e6ded376028cb255550931bc617f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acac0cf7c0bae9d60c2eed98e5b057aac" id="r_acac0cf7c0bae9d60c2eed98e5b057aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#acac0cf7c0bae9d60c2eed98e5b057aac">version</a> (const std::string &amp;versionString, const std::string &amp;dateString=&quot;&quot;)</td></tr>
<tr class="memdesc:acac0cf7c0bae9d60c2eed98e5b057aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program version.  <br /></td></tr>
<tr class="separator:acac0cf7c0bae9d60c2eed98e5b057aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e55639d136b43f792ab57f764690d76" id="r_a5e55639d136b43f792ab57f764690d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a5e55639d136b43f792ab57f764690d76">version</a> (const std::pair&lt; std::string, std::string &gt; &amp;p)</td></tr>
<tr class="memdesc:a5e55639d136b43f792ab57f764690d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program version.  <br /></td></tr>
<tr class="separator:a5e55639d136b43f792ab57f764690d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42708f7f734dfba29967021e007c354" id="r_ac42708f7f734dfba29967021e007c354"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ac42708f7f734dfba29967021e007c354">version</a> () const</td></tr>
<tr class="memdesc:ac42708f7f734dfba29967021e007c354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program version.  <br /></td></tr>
<tr class="separator:ac42708f7f734dfba29967021e007c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab0ec43e75e4ef032931a7dcf7a0e3c73" id="r_ab0ec43e75e4ef032931a7dcf7a0e3c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ab0ec43e75e4ef032931a7dcf7a0e3c73">chapter</a> (int chapterNumber, const std::string &amp;chapterName=&quot;&quot;)</td></tr>
<tr class="memdesc:ab0ec43e75e4ef032931a7dcf7a0e3c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual chapter.  <br /></td></tr>
<tr class="separator:ab0ec43e75e4ef032931a7dcf7a0e3c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3fb0ee4d63c1d8a8e9b20c2b576311" id="r_afb3fb0ee4d63c1d8a8e9b20c2b576311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afb3fb0ee4d63c1d8a8e9b20c2b576311">chapter</a> (const std::pair&lt; int, std::string &gt; &amp;p)</td></tr>
<tr class="memdesc:afb3fb0ee4d63c1d8a8e9b20c2b576311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual chapter.  <br /></td></tr>
<tr class="separator:afb3fb0ee4d63c1d8a8e9b20c2b576311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cdebcff082e362fe72334e88f1ffd4" id="r_ae7cdebcff082e362fe72334e88f1ffd4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae7cdebcff082e362fe72334e88f1ffd4">chapter</a> () const</td></tr>
<tr class="memdesc:ae7cdebcff082e362fe72334e88f1ffd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual chapter.  <br /></td></tr>
<tr class="separator:ae7cdebcff082e362fe72334e88f1ffd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56af857b77487730fa558e40ca9763b6" id="r_a56af857b77487730fa558e40ca9763b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a56af857b77487730fa558e40ca9763b6">doc</a> (const std::string &amp;sectionName, const std::string &amp;docKey, const std::string &amp;text)</td></tr>
<tr class="memdesc:a56af857b77487730fa558e40ca9763b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:a56af857b77487730fa558e40ca9763b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4503f4074e25b954dd00d52a69d8fee" id="r_af4503f4074e25b954dd00d52a69d8fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af4503f4074e25b954dd00d52a69d8fee">doc</a> (const std::string &amp;sectionName, const std::string &amp;text)</td></tr>
<tr class="memdesc:af4503f4074e25b954dd00d52a69d8fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:af4503f4074e25b954dd00d52a69d8fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d68bda6078b8a58a98640e2f555923" id="r_aa8d68bda6078b8a58a98640e2f555923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aa8d68bda6078b8a58a98640e2f555923">doc</a> (const std::pair&lt; std::string, std::string &gt; &amp;)</td></tr>
<tr class="memdesc:aa8d68bda6078b8a58a98640e2f555923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:aa8d68bda6078b8a58a98640e2f555923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24d4506221914e9c0765fe7fea35cd" id="r_a6b24d4506221914e9c0765fe7fea35cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a6b24d4506221914e9c0765fe7fea35cd">docSections</a> () const</td></tr>
<tr class="memdesc:a6b24d4506221914e9c0765fe7fea35cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:a6b24d4506221914e9c0765fe7fea35cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a4c5ae593d8f8026970de57a78048" id="r_acf4a4c5ae593d8f8026970de57a78048"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#acf4a4c5ae593d8f8026970de57a78048">docForSwitches</a> () const</td></tr>
<tr class="memdesc:acf4a4c5ae593d8f8026970de57a78048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:acf4a4c5ae593d8f8026970de57a78048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84eadee351b8e4ac484784e779bd473" id="r_ac84eadee351b8e4ac484784e779bd473"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ac84eadee351b8e4ac484784e779bd473">docForSection</a> (const std::string &amp;sectionName) const</td></tr>
<tr class="memdesc:ac84eadee351b8e4ac484784e779bd473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documentation for a section of the manual.  <br /></td></tr>
<tr class="separator:ac84eadee351b8e4ac484784e779bd473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adba86f9a10d20a75922e6cbd27e06f75" id="r_adba86f9a10d20a75922e6cbd27e06f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a1e6d0ab89ea08ac8840a721625257477">SortOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#adba86f9a10d20a75922e6cbd27e06f75">switchGroupOrder</a> () const</td></tr>
<tr class="memdesc:adba86f9a10d20a75922e6cbd27e06f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to order switch groups in documentation.  <br /></td></tr>
<tr class="separator:adba86f9a10d20a75922e6cbd27e06f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd1353efaeda9488df40f005869f86" id="r_a42cd1353efaeda9488df40f005869f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a42cd1353efaeda9488df40f005869f86">switchGroupOrder</a> (<a class="el" href="namespaceSawyer_1_1CommandLine.html#a1e6d0ab89ea08ac8840a721625257477">SortOrder</a> order)</td></tr>
<tr class="memdesc:a42cd1353efaeda9488df40f005869f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: How to order switch groups in documentation.  <br /></td></tr>
<tr class="separator:a42cd1353efaeda9488df40f005869f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e97dd10737b064a1b1c376b458ab1e5" id="r_a4e97dd10737b064a1b1c376b458ab1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4e97dd10737b064a1b1c376b458ab1e5">removeMatchingSwitch</a> (const std::string &amp;arg)</td></tr>
<tr class="memdesc:a4e97dd10737b064a1b1c376b458ab1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the switch by matching parse sentence.  <br /></td></tr>
<tr class="separator:a4e97dd10737b064a1b1c376b458ab1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3576019bce9f072cf6733159307a28f3" id="r_a3576019bce9f072cf6733159307a28f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3576019bce9f072cf6733159307a28f3">removeMatchingSwitch</a> (const std::vector&lt; std::string &gt; &amp;args)</td></tr>
<tr class="memdesc:a3576019bce9f072cf6733159307a28f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the switch by matching parse sentence.  <br /></td></tr>
<tr class="separator:a3576019bce9f072cf6733159307a28f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9d10c91d23be28ccebb66173c28cd209" id="r_a9d10c91d23be28ccebb66173c28cd209"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9d10c91d23be28ccebb66173c28cd209">splitLineIntoWords</a> (std::string)</td></tr>
<tr class="memdesc:a9d10c91d23be28ccebb66173c28cd209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split line of text into words.  <br /></td></tr>
<tr class="separator:a9d10c91d23be28ccebb66173c28cd209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8e98d34d68232bd23b2dc2a6bca676" id="r_abd8e98d34d68232bd23b2dc2a6bca676"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:abd8e98d34d68232bd23b2dc2a6bca676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a text file to obtain arguments.  <br /></td></tr>
<tr class="separator:abd8e98d34d68232bd23b2dc2a6bca676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd0a95d736662c3caa1fa508cb9df87" id="r_a8dd0a95d736662c3caa1fa508cb9df87"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8dd0a95d736662c3caa1fa508cb9df87">readArgsFromEnvVar</a> (const std::string &amp;varName)</td></tr>
<tr class="memdesc:a8dd0a95d736662c3caa1fa508cb9df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an envrionment variable to obtain arguments.  <br /></td></tr>
<tr class="separator:a8dd0a95d736662c3caa1fa508cb9df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368d6de72dcab080ba14b2cec3ba7795" id="r_a368d6de72dcab080ba14b2cec3ba7795"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a368d6de72dcab080ba14b2cec3ba7795">printIndex</a> (std::ostream &amp;, const <a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;, const std::string &amp;linePrefix=&quot;&quot;)</td></tr>
<tr class="memdesc:a368d6de72dcab080ba14b2cec3ba7795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a switch index.  <br /></td></tr>
<tr class="separator:a368d6de72dcab080ba14b2cec3ba7795"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a479b41f1272f8a56ec6dccd63d42b11a" name="a479b41f1272f8a56ec6dccd63d42b11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479b41f1272f8a56ec6dccd63d42b11a">&#9670;&#160;</a></span>GroupingFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11a">Sawyer::CommandLine::Parser::GroupingFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit flags for argument grouping. </p>
<p>See <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a6daa7ac025d7ddc43608f95157700615">regroupArgs</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a479b41f1272f8a56ec6dccd63d42b11aae315e26ad76defa67bd1809e44af4559" name="a479b41f1272f8a56ec6dccd63d42b11aae315e26ad76defa67bd1809e44af4559"></a>DEFAULT_GROUPING&#160;</td><td class="fielddoc"><p>Zero, all flags are clear. </p>
</td></tr>
<tr><td class="fieldname"><a id="a479b41f1272f8a56ec6dccd63d42b11aaba0531812023c7b4c42c85915abd6743" name="a479b41f1272f8a56ec6dccd63d42b11aaba0531812023c7b4c42c85915abd6743"></a>PROHIBIT_EMPTY_GROUPS&#160;</td><td class="fielddoc"><p><a class="el" href="classSawyer_1_1Error.html" title="Error value.">Error</a> if any group is empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="a479b41f1272f8a56ec6dccd63d42b11aae9f806c78f3d510b9d75493144453ffc" name="a479b41f1272f8a56ec6dccd63d42b11aae9f806c78f3d510b9d75493144453ffc"></a>SPLIT_SINGLE_GROUP&#160;</td><td class="fielddoc"><p>Split single group into singleton groups. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03065">3065</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7758348f27970f02ca2685857022e6a9" name="a7758348f27970f02ca2685857022e6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7758348f27970f02ca2685857022e6a9">&#9670;&#160;</a></span>Parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sawyer::CommandLine::Parser::Parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The default constructor sets up a new parser with defaults suitable for the operating system. The switch declarations need to be added (via <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a150a5ad8e88776f5ba73df0a6b76a9d9">with</a>) before the parser is useful. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02785">2785</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l00174">Sawyer::CommandLine::INSERTION_ORDER</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a150a5ad8e88776f5ba73df0a6b76a9d9" name="a150a5ad8e88776f5ba73df0a6b76a9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150a5ad8e88776f5ba73df0a6b76a9d9">&#9670;&#160;</a></span>with() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switch declarations. </p>
<p>The specified switch declaration or group of switch declarations is copied into the parser. A documentation key can be supplied to override the sort order for the group or switch. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02795">2795</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a2dce3fb9349b9e75e2fd6f3861670515" name="a2dce3fb9349b9e75e2fd6f3861670515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dce3fb9349b9e75e2fd6f3861670515">&#9670;&#160;</a></span>with() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>docKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switch declarations. </p>
<p>The specified switch declaration or group of switch declarations is copied into the parser. A documentation key can be supplied to override the sort order for the group or switch. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02799">2799</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ae667a46ad93774357a15942c8a2689ce" name="ae667a46ad93774357a15942c8a2689ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae667a46ad93774357a15942c8a2689ce">&#9670;&#160;</a></span>with() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::with </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switch declarations. </p>
<p>The specified switch declaration or group of switch declarations is copied into the parser. A documentation key can be supplied to override the sort order for the group or switch. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02804">2804</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a3a0a4b4a9595b8f63d6baa5983e5f603" name="a3a0a4b4a9595b8f63d6baa5983e5f603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0a4b4a9595b8f63d6baa5983e5f603">&#9670;&#160;</a></span>with() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &amp;&#160;</td>
          <td class="paramname"><em>sw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switch declarations. </p>
<p>The specified switch declaration or group of switch declarations is copied into the parser. A documentation key can be supplied to override the sort order for the group or switch. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02808">2808</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="aed1cd0b7af341055ae1132c75a5b885b" name="aed1cd0b7af341055ae1132c75a5b885b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1cd0b7af341055ae1132c75a5b885b">&#9670;&#160;</a></span>with() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a>&#160;</td>
          <td class="paramname"><em>sw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>docKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add switch declarations. </p>
<p>The specified switch declaration or group of switch declarations is copied into the parser. A documentation key can be supplied to override the sort order for the group or switch. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02812">2812</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02193">Sawyer::CommandLine::Switch::docKey()</a>.</p>

</div>
</div>
<a id="ab705590caff906243a983125a01df793" name="ab705590caff906243a983125a01df793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab705590caff906243a983125a01df793">&#9670;&#160;</a></span>switchGroups() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp; Sawyer::CommandLine::Parser::switchGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of all switch groups. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02822">2822</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a0fccf3c0fe522c622561f064a5522ac1" name="a0fccf3c0fe522c622561f064a5522ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fccf3c0fe522c622561f064a5522ac1">&#9670;&#160;</a></span>switchGroups() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &gt; &amp; Sawyer::CommandLine::Parser::switchGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of all switch groups. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02825">2825</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a9ea76762cd7eb3c99f7ac6a1ba850061" name="a9ea76762cd7eb3c99f7ac6a1ba850061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea76762cd7eb3c99f7ac6a1ba850061">&#9670;&#160;</a></span>switchGroupExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::switchGroupExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate to determine whether a switch group exists. </p>
<p>Searches this parser for a switch group having the specified name and returns true if it exists. </p>

</div>
</div>
<a id="ac0d480cd6129adac4b0d3da94763914c" name="ac0d480cd6129adac4b0d3da94763914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d480cd6129adac4b0d3da94763914c">&#9670;&#160;</a></span>switchGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp; Sawyer::CommandLine::Parser::switchGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html" title="Describes one command-line switch.">Switch</a> group having specified name. </p>
<p>Searches this parser and returns the first switch group having the specified name. Throws a <a class="el" href="classSawyer_1_1Exception_1_1NotFound.html">Sawyer::Exception::NotFound</a> error if no such <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> exists in this parser. </p>

</div>
</div>
<a id="a2d8900450f66491c61a333761d03dfa7" name="a2d8900450f66491c61a333761d03dfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8900450f66491c61a333761d03dfa7">&#9670;&#160;</a></span>switchGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> &amp; Sawyer::CommandLine::Parser::switchGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html" title="Describes one command-line switch.">Switch</a> group having specified name. </p>
<p>Searches this parser and returns the first switch group having the specified name. Throws a <a class="el" href="classSawyer_1_1Exception_1_1NotFound.html">Sawyer::Exception::NotFound</a> error if no such <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a> exists in this parser. </p>

</div>
</div>
<a id="ac08b24492a68494753c03c9d508ad26c" name="ac08b24492a68494753c03c9d508ad26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08b24492a68494753c03c9d508ad26c">&#9670;&#160;</a></span>eraseSwitchGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::eraseSwitchGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove switch group from parser. </p>
<p>Removes the first switch group having the specified name from this parser. Returns true if a switch group was removed, false if nothing was removed. </p>

</div>
</div>
<a id="af68a22d65e33f5b254d799573882fc06" name="af68a22d65e33f5b254d799573882fc06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a22d65e33f5b254d799573882fc06">&#9670;&#160;</a></span>reportingAmbiguities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::reportingAmbiguities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether to report ambiguities. </p>
<p>If true, report ambiguous switches. Switches that can not be disambiguated are reported regardless of whether the switch is encountered on a commandline in order to help authors detect situations where it's impossible to control some setting from the command line. Switches that can be disambiguated are reported only when they occur on the commandline, and include a message about how to disambiguate them.</p>
<p>If false, then no ambiguities are checked or reported. When encountering an ambiguous switch, the first matching definition is used. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02862">2862</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a8095c65786896086d0c402f226b52c96" name="a8095c65786896086d0c402f226b52c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8095c65786896086d0c402f226b52c96">&#9670;&#160;</a></span>reportingAmbiguities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::reportingAmbiguities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Whether to report ambiguities. </p>
<p>If true, report ambiguous switches. Switches that can not be disambiguated are reported regardless of whether the switch is encountered on a commandline in order to help authors detect situations where it's impossible to control some setting from the command line. Switches that can be disambiguated are reported only when they occur on the commandline, and include a message about how to disambiguate them.</p>
<p>If false, then no ambiguities are checked or reported. When encountering an ambiguous switch, the first matching definition is used. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02863">2863</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ae1bcfe1e27264227116894ce0048001b" name="ae1bcfe1e27264227116894ce0048001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bcfe1e27264227116894ce0048001b">&#9670;&#160;</a></span>groupNameSeparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Sawyer::CommandLine::Parser::groupNameSeparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: String separating group name from switch name. </p>
<p>If switch group names are present, this property holds the string that separates the group name from the switch name. For instance, if the group name is "group" and the switch name is "switch", the prefix is "--" and the separator is "-", then the switch can be parsed as either "--switch" or as "--group-switch". </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02873">2873</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ae9fc5870d65fccab4c1dec83a5257ddc" name="ae9fc5870d65fccab4c1dec83a5257ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fc5870d65fccab4c1dec83a5257ddc">&#9670;&#160;</a></span>groupNameSeparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::groupNameSeparator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: String separating group name from switch name. </p>
<p>If switch group names are present, this property holds the string that separates the group name from the switch name. For instance, if the group name is "group" and the switch name is "switch", the prefix is "--" and the separator is "-", then the switch can be parsed as either "--switch" or as "--group-switch". </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02874">2874</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ab808bb85559dc5b083d4dde1cc2927f7" name="ab808bb85559dc5b083d4dde1cc2927f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab808bb85559dc5b083d4dde1cc2927f7">&#9670;&#160;</a></span>showingGroupNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a23bda2bb5cdd8e62f60e13401cec9352">ShowGroupName</a> Sawyer::CommandLine::Parser::showingGroupNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: How to show group names in switch documentation. </p>
<p>When generating a switch synopsis and the group containing the switch has a non-empty name, the group name can be added to the switch name. The default is to add the group name as an optional part of the switch, like "--[group-]switch" since the parser treats them as optional unless the abbreviated name is ambiguous.</p>
<p>See also, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae1bcfe1e27264227116894ce0048001b">groupNameSeparator</a>, <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html#a5b703e34f9ed086a9a2198f006dd99bc">SwitchGroup::name</a>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02886">2886</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ae1544b3bab64d9426d14a6d0a41aec0e" name="ae1544b3bab64d9426d14a6d0a41aec0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1544b3bab64d9426d14a6d0a41aec0e">&#9670;&#160;</a></span>showingGroupNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::showingGroupNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a23bda2bb5cdd8e62f60e13401cec9352">ShowGroupName</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: How to show group names in switch documentation. </p>
<p>When generating a switch synopsis and the group containing the switch has a non-empty name, the group name can be added to the switch name. The default is to add the group name as an optional part of the switch, like "--[group-]switch" since the parser treats them as optional unless the abbreviated name is ambiguous.</p>
<p>See also, <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ae1bcfe1e27264227116894ce0048001b">groupNameSeparator</a>, <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html#a5b703e34f9ed086a9a2198f006dd99bc">SwitchGroup::name</a>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02887">2887</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="aace01d8f250dd64892582341613b90ae" name="aace01d8f250dd64892582341613b90ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace01d8f250dd64892582341613b90ae">&#9670;&#160;</a></span>resetLongPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::resetLongPrefixes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s3</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s4</em> = <code>STR_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefixes to use for long command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aace01d8f250dd64892582341613b90ae">resetLongPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3cfe6cb949af618d8efd91fe9db7b29f">longPrefix</a> only adds another prefix to the list. The default long switch prefix on Unix-like systems is <code>--</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

</div>
</div>
<a id="a3cfe6cb949af618d8efd91fe9db7b29f" name="a3cfe6cb949af618d8efd91fe9db7b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe6cb949af618d8efd91fe9db7b29f">&#9670;&#160;</a></span>longPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::longPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefixes to use for long command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aace01d8f250dd64892582341613b90ae">resetLongPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3cfe6cb949af618d8efd91fe9db7b29f">longPrefix</a> only adds another prefix to the list. The default long switch prefix on Unix-like systems is <code>--</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02896">2896</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="af133635a506d60e1dac763a21fd8d3ec" name="af133635a506d60e1dac763a21fd8d3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af133635a506d60e1dac763a21fd8d3ec">&#9670;&#160;</a></span>longPrefixes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Sawyer::CommandLine::Parser::longPrefixes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefixes to use for long command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#aace01d8f250dd64892582341613b90ae">resetLongPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a3cfe6cb949af618d8efd91fe9db7b29f">longPrefix</a> only adds another prefix to the list. The default long switch prefix on Unix-like systems is <code>--</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02897">2897</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a190fc175b9f4ce2d6078d484092b0675" name="a190fc175b9f4ce2d6078d484092b0675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190fc175b9f4ce2d6078d484092b0675">&#9670;&#160;</a></span>resetShortPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::resetShortPrefixes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s3</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s4</em> = <code>STR_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefixes to use for short command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a190fc175b9f4ce2d6078d484092b0675">resetShortPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a61b569ce8188be4cbd356da4e328b36b">shortPrefix</a> only adds another prefix to the list. The default short switch prefix on Unix-like systems is <code>-</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

</div>
</div>
<a id="a61b569ce8188be4cbd356da4e328b36b" name="a61b569ce8188be4cbd356da4e328b36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b569ce8188be4cbd356da4e328b36b">&#9670;&#160;</a></span>shortPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::shortPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefixes to use for short command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a190fc175b9f4ce2d6078d484092b0675">resetShortPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a61b569ce8188be4cbd356da4e328b36b">shortPrefix</a> only adds another prefix to the list. The default short switch prefix on Unix-like systems is <code>-</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02906">2906</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a59af697858e05d3112812f8a1d7bbf5f" name="a59af697858e05d3112812f8a1d7bbf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59af697858e05d3112812f8a1d7bbf5f">&#9670;&#160;</a></span>shortPrefixes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Sawyer::CommandLine::Parser::shortPrefixes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefixes to use for short command-line switches. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a190fc175b9f4ce2d6078d484092b0675">resetShortPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a61b569ce8188be4cbd356da4e328b36b">shortPrefix</a> only adds another prefix to the list. The default short switch prefix on Unix-like systems is <code>-</code>, but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02907">2907</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a85d28dc09342e027e7ed4d2158411597" name="a85d28dc09342e027e7ed4d2158411597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d28dc09342e027e7ed4d2158411597">&#9670;&#160;</a></span>resetValueSeparators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::resetValueSeparators </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s3</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s4</em> = <code>STR_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strings that separate a long switch from its value. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85d28dc09342e027e7ed4d2158411597">resetValueSeparators</a> clears the list (and adds separators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9a6f9298cc874ce9c876064cbfc6c0be">valueSeparator</a> only adds another separator to the list. The separator " " is special: it indicates that the argument for a switch must appear in a separate program argument (i.e., <code>--author matzke</code> as opposed to <code>--author=matzke</code>). The default value separators on Unix-like systems are "=" and " ", but this can be overridden or augmented by switch groups and switch declarations. </p>

</div>
</div>
<a id="a9a6f9298cc874ce9c876064cbfc6c0be" name="a9a6f9298cc874ce9c876064cbfc6c0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6f9298cc874ce9c876064cbfc6c0be">&#9670;&#160;</a></span>valueSeparator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::valueSeparator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that separate a long switch from its value. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85d28dc09342e027e7ed4d2158411597">resetValueSeparators</a> clears the list (and adds separators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9a6f9298cc874ce9c876064cbfc6c0be">valueSeparator</a> only adds another separator to the list. The separator " " is special: it indicates that the argument for a switch must appear in a separate program argument (i.e., <code>--author matzke</code> as opposed to <code>--author=matzke</code>). The default value separators on Unix-like systems are "=" and " ", but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02918">2918</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a269a2d9ccae76a815a09f1421e546f79" name="a269a2d9ccae76a815a09f1421e546f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269a2d9ccae76a815a09f1421e546f79">&#9670;&#160;</a></span>valueSeparators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Sawyer::CommandLine::Parser::valueSeparators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that separate a long switch from its value. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a85d28dc09342e027e7ed4d2158411597">resetValueSeparators</a> clears the list (and adds separators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a9a6f9298cc874ce9c876064cbfc6c0be">valueSeparator</a> only adds another separator to the list. The separator " " is special: it indicates that the argument for a switch must appear in a separate program argument (i.e., <code>--author matzke</code> as opposed to <code>--author=matzke</code>). The default value separators on Unix-like systems are "=" and " ", but this can be overridden or augmented by switch groups and switch declarations. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02919">2919</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ad5b0edbd2366eb638ba735ec101017fa" name="ad5b0edbd2366eb638ba735ec101017fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b0edbd2366eb638ba735ec101017fa">&#9670;&#160;</a></span>resetTerminationSwitches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::resetTerminationSwitches </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s3</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s4</em> = <code>STR_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strings that indicate the end of the argument list. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ad5b0edbd2366eb638ba735ec101017fa">resetTerminationSwitches</a> clears the list (and adds terminators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af26429f6a315c8bd47d82f08f77f4c78">terminationSwitch</a> only adds another terminator to the list. The default terminator on Unix-like systems is <code>--</code>. </p>

</div>
</div>
<a id="af26429f6a315c8bd47d82f08f77f4c78" name="af26429f6a315c8bd47d82f08f77f4c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26429f6a315c8bd47d82f08f77f4c78">&#9670;&#160;</a></span>terminationSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::terminationSwitch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that indicate the end of the argument list. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ad5b0edbd2366eb638ba735ec101017fa">resetTerminationSwitches</a> clears the list (and adds terminators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af26429f6a315c8bd47d82f08f77f4c78">terminationSwitch</a> only adds another terminator to the list. The default terminator on Unix-like systems is <code>--</code>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02928">2928</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a5d43a2f13353aa22abac3d3e1b9975b8" name="a5d43a2f13353aa22abac3d3e1b9975b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d43a2f13353aa22abac3d3e1b9975b8">&#9670;&#160;</a></span>terminationSwitches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Sawyer::CommandLine::Parser::terminationSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that indicate the end of the argument list. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#ad5b0edbd2366eb638ba735ec101017fa">resetTerminationSwitches</a> clears the list (and adds terminators) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#af26429f6a315c8bd47d82f08f77f4c78">terminationSwitch</a> only adds another terminator to the list. The default terminator on Unix-like systems is <code>--</code>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02929">2929</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a4733cab32eeb6b0f353dc9ea99e6cd0d" name="a4733cab32eeb6b0f353dc9ea99e6cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4733cab32eeb6b0f353dc9ea99e6cd0d">&#9670;&#160;</a></span>shortMayNestle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::shortMayNestle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether short switches can nestle together. </p>
<p>If short switches are allowed to nestle, then <code>-ab</code> is the same as <code>-a -b</code> in two separate program arguments. This even works if the short switch takes an argument as long as the argument parsing ends at the next short switch name. For instance, if "a" takes an integer argument then <code>-a100b</code> will be parsed as <code>-a100 -b</code>, but if "a" takes a string argument the entire "100b" will be parsed as the value for the "a" switch. The default on Unix-like systems is that short switches may nestle. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02939">2939</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="af4d8677d55d933a756971a19ea9f3e36" name="af4d8677d55d933a756971a19ea9f3e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d8677d55d933a756971a19ea9f3e36">&#9670;&#160;</a></span>shortMayNestle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::shortMayNestle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether short switches can nestle together. </p>
<p>If short switches are allowed to nestle, then <code>-ab</code> is the same as <code>-a -b</code> in two separate program arguments. This even works if the short switch takes an argument as long as the argument parsing ends at the next short switch name. For instance, if "a" takes an integer argument then <code>-a100b</code> will be parsed as <code>-a100 -b</code>, but if "a" takes a string argument the entire "100b" will be parsed as the value for the "a" switch. The default on Unix-like systems is that short switches may nestle. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02940">2940</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a23dff1a3c8992e71ca95f220c6be3c98" name="a23dff1a3c8992e71ca95f220c6be3c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dff1a3c8992e71ca95f220c6be3c98">&#9670;&#160;</a></span>resetInclusionPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::resetInclusionPrefixes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s3</em> = <code>STR_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s4</em> = <code>STR_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strings that indicate that arguments are to be read from a file. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a23dff1a3c8992e71ca95f220c6be3c98">resetInclusionPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a56c7d6ca643f0061de1b22c1f9745388">inclusionPrefix</a> only adds another prefix to the list. The default inclusion prefix on Unix-like systems is <code>@</code>. That is, a program argument <code>@foo.conf</code> will be replaced with arguments read from the file "foo.conf". See <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a> and <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afc6dd9dd921d66434ede313e15da672a">expandIncludedFiles</a> for details.</p>
<p>For instance, to make file inclusion look like a normal switch, </p><div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser();</div>
<div class="line">parser.resetInclusionPrefixes(<span class="stringliteral">&quot;--file=&quot;</span>);</div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html">Sawyer::CommandLine::Parser</a></div><div class="ttdoc">The parser for a program command line.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02756">Sawyer/CommandLine.h:2756</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a56c7d6ca643f0061de1b22c1f9745388" name="a56c7d6ca643f0061de1b22c1f9745388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c7d6ca643f0061de1b22c1f9745388">&#9670;&#160;</a></span>inclusionPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::inclusionPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that indicate that arguments are to be read from a file. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a23dff1a3c8992e71ca95f220c6be3c98">resetInclusionPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a56c7d6ca643f0061de1b22c1f9745388">inclusionPrefix</a> only adds another prefix to the list. The default inclusion prefix on Unix-like systems is <code>@</code>. That is, a program argument <code>@foo.conf</code> will be replaced with arguments read from the file "foo.conf". See <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a> and <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afc6dd9dd921d66434ede313e15da672a">expandIncludedFiles</a> for details.</p>
<p>For instance, to make file inclusion look like a normal switch, </p><div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser();</div>
<div class="line">parser.resetInclusionPrefixes(<span class="stringliteral">&quot;--file=&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02956">2956</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a9f63b6436f7ee43b6df61091f261a6fc" name="a9f63b6436f7ee43b6df61091f261a6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f63b6436f7ee43b6df61091f261a6fc">&#9670;&#160;</a></span>inclusionPrefixes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Sawyer::CommandLine::Parser::inclusionPrefixes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strings that indicate that arguments are to be read from a file. </p>
<p>The <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a23dff1a3c8992e71ca95f220c6be3c98">resetInclusionPrefixes</a> clears the list (and adds prefixes) while <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a56c7d6ca643f0061de1b22c1f9745388">inclusionPrefix</a> only adds another prefix to the list. The default inclusion prefix on Unix-like systems is <code>@</code>. That is, a program argument <code>@foo.conf</code> will be replaced with arguments read from the file "foo.conf". See <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a> and <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afc6dd9dd921d66434ede313e15da672a">expandIncludedFiles</a> for details.</p>
<p>For instance, to make file inclusion look like a normal switch, </p><div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser();</div>
<div class="line">parser.resetInclusionPrefixes(<span class="stringliteral">&quot;--file=&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02957">2957</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a8713b988440015fe322df4ad7de1884a" name="a8713b988440015fe322df4ad7de1884a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8713b988440015fe322df4ad7de1884a">&#9670;&#160;</a></span>skippingNonSwitches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::skippingNonSwitches </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to skip over non-switch arguments when parsing. </p>
<p>If false, parsing stops at the first non-switch, otherwise non-switches are simply skipped over and added to the parsing result that's eventually returned. In either case, parsing stops when a terminator switch (usually <code>--</code>) is found. Anything that looks like a switch but doesn't match a declaration continues to result in an error regardless of this property.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9bb901e803db01e9c44090e6bb0a96ef" title="Program arguments that were skipped over during parsing.">ParserResult::skippedArgs</a> <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a21efe65623aec328437b0ac52f2b64fc" title="Returns unparsed switches.">ParserResult::unparsedArgs</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02967">2967</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a238fbd4717b9e5451cc2b205906ec78a" name="a238fbd4717b9e5451cc2b205906ec78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238fbd4717b9e5451cc2b205906ec78a">&#9670;&#160;</a></span>skippingNonSwitches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::skippingNonSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to skip over non-switch arguments when parsing. </p>
<p>If false, parsing stops at the first non-switch, otherwise non-switches are simply skipped over and added to the parsing result that's eventually returned. In either case, parsing stops when a terminator switch (usually <code>--</code>) is found. Anything that looks like a switch but doesn't match a declaration continues to result in an error regardless of this property.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9bb901e803db01e9c44090e6bb0a96ef" title="Program arguments that were skipped over during parsing.">ParserResult::skippedArgs</a> <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a21efe65623aec328437b0ac52f2b64fc" title="Returns unparsed switches.">ParserResult::unparsedArgs</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02968">2968</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a8e30b8ff9d6edf9565c000245e36c595" name="a8e30b8ff9d6edf9565c000245e36c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e30b8ff9d6edf9565c000245e36c595">&#9670;&#160;</a></span>skippingUnknownSwitches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::skippingUnknownSwitches </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to skip over unrecognized switches. </p>
<p>An unrecognized switch is any program argument that looks like a switch but which doesn't match the name of any declared switch. When not skipping (the default) such program arguments throw an "unrecognized switch" <code>std::runtime_error</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9bb901e803db01e9c44090e6bb0a96ef" title="Program arguments that were skipped over during parsing.">ParserResult::skippedArgs</a> <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a21efe65623aec328437b0ac52f2b64fc" title="Returns unparsed switches.">ParserResult::unparsedArgs</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02977">2977</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a85e8ed52db6587c679d63ea1048ddcec" name="a85e8ed52db6587c679d63ea1048ddcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e8ed52db6587c679d63ea1048ddcec">&#9670;&#160;</a></span>skippingUnknownSwitches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sawyer::CommandLine::Parser::skippingUnknownSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to skip over unrecognized switches. </p>
<p>An unrecognized switch is any program argument that looks like a switch but which doesn't match the name of any declared switch. When not skipping (the default) such program arguments throw an "unrecognized switch" <code>std::runtime_error</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a9bb901e803db01e9c44090e6bb0a96ef" title="Program arguments that were skipped over during parsing.">ParserResult::skippedArgs</a> <a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html#a21efe65623aec328437b0ac52f2b64fc" title="Returns unparsed switches.">ParserResult::unparsedArgs</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02978">2978</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="add53661b05a756fedb1b1b19db7d911f" name="add53661b05a756fedb1b1b19db7d911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add53661b05a756fedb1b1b19db7d911f">&#9670;&#160;</a></span>errorStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::errorStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a message stream to which errors are sent. </p>
<p>If non-null, when a parse method encounters an error it writes the error message to this stream and exits. The default, when null, is that errors cause an <code>std::runtime_error</code> to be thrown. The various "skip" properties suppress certain kinds of errors entirely.</p>
<p>Note, <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> objects are intermediaries returned by the <code>[]</code> operator of <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Message::Facility</a>, and users don't normally interact with them explicitly. They're only present because c++11 <code>std::move</code> semantics aren't widely available yet.</p>
<p>For example, to cause command-line parsing errors to use the Sawyer-wide FATAL stream, say this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser;</div>
<div class="line">parser.<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a>(<a class="code hl_variable" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">Message::mlog</a>[<a class="code hl_enumvalue" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">Message::FATAL</a>]);</div>
<div class="ttc" id="aclassSawyer_1_1CommandLine_1_1Parser_html_add53661b05a756fedb1b1b19db7d911f"><div class="ttname"><a href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">Sawyer::CommandLine::Parser::errorStream</a></div><div class="ttdeci">Parser &amp; errorStream(const Message::SProxy &amp;stream)</div><div class="ttdoc">Specifies a message stream to which errors are sent.</div><div class="ttdef"><b>Definition</b> <a href="Sawyer_2CommandLine_8h_source.html#l02998">Sawyer/CommandLine.h:2998</a></div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_a26daa7a957cb93fe351393e5cc4ecfb0"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">Sawyer::Message::mlog</a></div><div class="ttdeci">Facility mlog</div><div class="ttdoc">Facility used by Sawyer components.</div></div>
<div class="ttc" id="anamespaceSawyer_1_1Message_html_abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7"><div class="ttname"><a href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">Sawyer::Message::FATAL</a></div><div class="ttdeci">@ FATAL</div><div class="ttdoc">Messages that indicate an abnormal situation from which the program was unable to recover.</div><div class="ttdef"><b>Definition</b> <a href="Message_8h_source.html#l00337">Message.h:332</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8713b988440015fe322df4ad7de1884a">skippingNonSwitches</a> <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8e30b8ff9d6edf9565c000245e36c595">skippingUnknownSwitches</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02998">2998</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CommandLineBoost_8h_source.html#l00106">Sawyer::CommandLine::Boost::command_line_parser::command_line_parser()</a>.</p>

</div>
</div>
<a id="ae0f04652793d967126c28615eb037efa" name="ae0f04652793d967126c28615eb037efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f04652793d967126c28615eb037efa">&#9670;&#160;</a></span>errorStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> &amp; Sawyer::CommandLine::Parser::errorStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a message stream to which errors are sent. </p>
<p>If non-null, when a parse method encounters an error it writes the error message to this stream and exits. The default, when null, is that errors cause an <code>std::runtime_error</code> to be thrown. The various "skip" properties suppress certain kinds of errors entirely.</p>
<p>Note, <a class="el" href="classSawyer_1_1Message_1_1SProxy.html">Message::SProxy</a> objects are intermediaries returned by the <code>[]</code> operator of <a class="el" href="classSawyer_1_1Message_1_1Facility.html" title="Collection of streams.">Message::Facility</a>, and users don't normally interact with them explicitly. They're only present because c++11 <code>std::move</code> semantics aren't widely available yet.</p>
<p>For example, to cause command-line parsing errors to use the Sawyer-wide FATAL stream, say this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> parser;</div>
<div class="line">parser.<a class="code hl_function" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a>(<a class="code hl_variable" href="namespaceSawyer_1_1Message.html#a26daa7a957cb93fe351393e5cc4ecfb0">Message::mlog</a>[<a class="code hl_enumvalue" href="namespaceSawyer_1_1Message.html#abfb4d3240797db3a74bbf691f708a1c9abb7c0d080435a4a981ba171d08dc3bb7">Message::FATAL</a>]);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8713b988440015fe322df4ad7de1884a">skippingNonSwitches</a> <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a8e30b8ff9d6edf9565c000245e36c595">skippingUnknownSwitches</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l02999">2999</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="af091f262cc6c7c0f84aeab5b49bc5032" name="af091f262cc6c7c0f84aeab5b49bc5032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af091f262cc6c7c0f84aeab5b49bc5032">&#9670;&#160;</a></span>exitMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::exitMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra text to print before exit. </p>
<p>This is only used when the <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> property is non-null. The default is to emit the message "invoke with '-\-help' to see usage information." if a switch with the name "help" is present, or nothing otherwise.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03008">3008</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a924fc843f9e6013c515a5ee621fb2844" name="a924fc843f9e6013c515a5ee621fb2844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924fc843f9e6013c515a5ee621fb2844">&#9670;&#160;</a></span>exitMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::CommandLine::Parser::exitMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra text to print before exit. </p>
<p>This is only used when the <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> property is non-null. The default is to emit the message "invoke with '-\-help' to see usage information." if a switch with the name "help" is present, or nothing otherwise.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03009">3009</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="ae1b967e3ee7cfab7517acba72d9d1fa3" name="ae1b967e3ee7cfab7517acba72d9d1fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b967e3ee7cfab7517acba72d9d1fa3">&#9670;&#160;</a></span>environmentVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::environmentVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of environment variable holding initial arguments. </p>
<p>If the environment variable is set and has a value, its value string is treated as command-line arguments in the same way that command-line arguments are read from files by <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03018">3018</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a3a699f5d5a266085ba40e9dd53047a21" name="a3a699f5d5a266085ba40e9dd53047a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a699f5d5a266085ba40e9dd53047a21">&#9670;&#160;</a></span>environmentVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Sawyer::CommandLine::Parser::environmentVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of environment variable holding initial arguments. </p>
<p>If the environment variable is set and has a value, its value string is treated as command-line arguments in the same way that command-line arguments are read from files by <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03019">3019</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="acadfcac830d7855ae15b39ef9ce1aebb" name="acadfcac830d7855ae15b39ef9ce1aebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadfcac830d7855ae15b39ef9ce1aebb">&#9670;&#160;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a> Sawyer::CommandLine::Parser::parse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse program arguments. </p>
<p>The first program argument, <code>argv[0]</code>, is considered to be the name of the program and is not parsed as a program argument. This function does not require that <code>argv[argc]</code> be a member of the argv array (normally, <code>argv[argc]==NULL</code> in <code>main</code>). </p>

<p class="reference">Referenced by <a class="el" href="CommandLineBoost_8h_source.html#l00128">Sawyer::CommandLine::Boost::command_line_parser::run()</a>.</p>

</div>
</div>
<a id="a7a0ac5eabe8e9e08cb6704be7d54f2af" name="a7a0ac5eabe8e9e08cb6704be7d54f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0ac5eabe8e9e08cb6704be7d54f2af">&#9670;&#160;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1ParserResult.html">ParserResult</a> Sawyer::CommandLine::Parser::parse </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse program arguments. </p>
<p>The vector should be only the program arguments, not a program name or final empty string. </p>

</div>
</div>
<a id="a9d10c91d23be28ccebb66173c28cd209" name="a9d10c91d23be28ccebb66173c28cd209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d10c91d23be28ccebb66173c28cd209">&#9670;&#160;</a></span>splitLineIntoWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::string &gt; Sawyer::CommandLine::Parser::splitLineIntoWords </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split line of text into words. </p>
<p>Line is split at white space, but honoring the usual convention of single and double quotes. </p>

</div>
</div>
<a id="abd8e98d34d68232bd23b2dc2a6bca676" name="abd8e98d34d68232bd23b2dc2a6bca676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e98d34d68232bd23b2dc2a6bca676">&#9670;&#160;</a></span>readArgsFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::string &gt; Sawyer::CommandLine::Parser::readArgsFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a text file to obtain arguments. </p>
<p>The specified file is opened and each line is read to obtain a vector of arguments. Blank lines and lines whose first non-space character is "#" are ignored. The remaining lines are split into one or more arguments at white space. Single and double quoted regions within a line are treated as single arguments (the quotes are removed). The backslash can be used to escape quotes, white space, and backslash; any other use of the backslash is not special. </p>

</div>
</div>
<a id="a8dd0a95d736662c3caa1fa508cb9df87" name="a8dd0a95d736662c3caa1fa508cb9df87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0a95d736662c3caa1fa508cb9df87">&#9670;&#160;</a></span>readArgsFromEnvVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::string &gt; Sawyer::CommandLine::Parser::readArgsFromEnvVar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an envrionment variable to obtain arguments. </p>
<p>This function behaves identically to <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#abd8e98d34d68232bd23b2dc2a6bca676">readArgsFromFile</a> except the content comes from the environment variable. An undefined variable is treated as an empty variable. </p>

</div>
</div>
<a id="afc6dd9dd921d66434ede313e15da672a" name="afc6dd9dd921d66434ede313e15da672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dd9dd921d66434ede313e15da672a">&#9670;&#160;</a></span>expandIncludedFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Sawyer::CommandLine::Parser::expandIncludedFiles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand file arguments. </p>
<p>Scans the specified argument list looking for file inclusion switches and replacing those switches with the the file. </p>

</div>
</div>
<a id="a6daa7ac025d7ddc43608f95157700615" name="a6daa7ac025d7ddc43608f95157700615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6daa7ac025d7ddc43608f95157700615">&#9670;&#160;</a></span>regroupArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::string &gt; &gt; Sawyer::CommandLine::Parser::regroupArgs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1Interval.html">Container::Interval</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>limits</em> = <code><a class="el" href="classSawyer_1_1Container_1_1Interval.html">Container::Interval</a>&lt;&#160;size_t&#160;&gt;::whole()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group arguments by "--" separators. </p>
<p>Given a vector of command-line arguments, regroup them into sub-vectors by using the special "--" arguments to separate the groups. The <code>flags</code> is a bit vector that controls some of the finer aspects of grouping (see <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a479b41f1272f8a56ec6dccd63d42b11a">GroupingFlags</a>). The number of returned groups (after flags are processed) must fall within the specified <code>limits</code>. If any error is encountered then either print an error message and exit, or throw an <code>std::runtime_error</code>, depending on whether an <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#add53661b05a756fedb1b1b19db7d911f">errorStream</a> is defined. </p>

</div>
</div>
<a id="abb94abbccdbeffe70602d6763f7f6804" name="abb94abbccdbeffe70602d6763f7f6804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb94abbccdbeffe70602d6763f7f6804">&#9670;&#160;</a></span>programName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::programName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>programName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program name for documentation. </p>
<p>If no program name is given (or it is set to the empty string) then the name is obtained from the operating system. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03086">3086</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03086">programName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03086">programName()</a>.</p>

</div>
</div>
<a id="ab9ca3259d7fc9a1a37278f0bb5a8d2b2" name="ab9ca3259d7fc9a1a37278f0bb5a8d2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ca3259d7fc9a1a37278f0bb5a8d2b2">&#9670;&#160;</a></span>programName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Sawyer::CommandLine::Parser::programName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program name for documentation. </p>
<p>If no program name is given (or it is set to the empty string) then the name is obtained from the operating system. </p>

</div>
</div>
<a id="a4f432e9e38d0c5c1966d521cc09e00c0" name="a4f432e9e38d0c5c1966d521cc09e00c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f432e9e38d0c5c1966d521cc09e00c0">&#9670;&#160;</a></span>purpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::purpose </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>purpose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program purpose. </p>
<p>This is a short, one-line description of the command that will appear in the "NAME" section of a Unix man page and picked up the the makewhatis(8) command. The string specified here should be the part that appears after the hyphen, as in "foo - frobnicate the bar library". </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03094">3094</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03094">purpose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03094">purpose()</a>.</p>

</div>
</div>
<a id="aea9e6ded376028cb255550931bc617f0" name="aea9e6ded376028cb255550931bc617f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9e6ded376028cb255550931bc617f0">&#9670;&#160;</a></span>purpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Sawyer::CommandLine::Parser::purpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program purpose. </p>
<p>This is a short, one-line description of the command that will appear in the "NAME" section of a Unix man page and picked up the the makewhatis(8) command. The string specified here should be the part that appears after the hyphen, as in "foo - frobnicate the bar library". </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03095">3095</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="acac0cf7c0bae9d60c2eed98e5b057aac" name="acac0cf7c0bae9d60c2eed98e5b057aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac0cf7c0bae9d60c2eed98e5b057aac">&#9670;&#160;</a></span>version() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::version </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>versionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dateString</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program version. </p>
<p>Every program should have a version string and a date of last change. If no version string is given then "alpha" is assumed; if no date is given then the current month and year are used. </p>

</div>
</div>
<a id="a5e55639d136b43f792ab57f764690d76" name="a5e55639d136b43f792ab57f764690d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e55639d136b43f792ab57f764690d76">&#9670;&#160;</a></span>version() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::version </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program version. </p>
<p>Every program should have a version string and a date of last change. If no version string is given then "alpha" is assumed; if no date is given then the current month and year are used. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03102">3102</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03102">version()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03102">version()</a>.</p>

</div>
</div>
<a id="ac42708f7f734dfba29967021e007c354" name="ac42708f7f734dfba29967021e007c354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42708f7f734dfba29967021e007c354">&#9670;&#160;</a></span>version() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; Sawyer::CommandLine::Parser::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program version. </p>
<p>Every program should have a version string and a date of last change. If no version string is given then "alpha" is assumed; if no date is given then the current month and year are used. </p>

</div>
</div>
<a id="ab0ec43e75e4ef032931a7dcf7a0e3c73" name="ab0ec43e75e4ef032931a7dcf7a0e3c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ec43e75e4ef032931a7dcf7a0e3c73">&#9670;&#160;</a></span>chapter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::chapter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chapterNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chapterName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual chapter. </p>
<p>Every Unix manual page belongs to a specific chapter. The chapters are:</p>
<ul>
<li><em>1</em> &ndash; User commands that may be started by everyone. </li>
<li><em>2</em> &ndash; System calls, that is, functions provided by the kernel. </li>
<li><em>3</em> &ndash; Subroutines, that is, library functions. </li>
<li><em>4</em> &ndash; Devices, that is, special files in the /dev directory. </li>
<li><em>5</em> &ndash; File format descriptions, e.g. /etc/passwd. </li>
<li><em>6</em> &ndash; Games, self-explanatory. </li>
<li><em>7</em> &ndash; Miscellaneous, e.g. macro packages, conventions. </li>
<li><em>8</em> &ndash; System administration tools that only root can execute. </li>
<li><em>9</em> &ndash; Another (Linux specific) place for kernel routine documentation.</li>
</ul>
<p>Do not use chapters "n", "o", or "l" (in fact, only those listed integers are accepted). If a name is supplied it overrides the default name of that chapter. If no chapter is specified, "1" is assumed. </p>

</div>
</div>
<a id="afb3fb0ee4d63c1d8a8e9b20c2b576311" name="afb3fb0ee4d63c1d8a8e9b20c2b576311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3fb0ee4d63c1d8a8e9b20c2b576311">&#9670;&#160;</a></span>chapter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::chapter </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manual chapter. </p>
<p>Every Unix manual page belongs to a specific chapter. The chapters are:</p>
<ul>
<li><em>1</em> &ndash; User commands that may be started by everyone. </li>
<li><em>2</em> &ndash; System calls, that is, functions provided by the kernel. </li>
<li><em>3</em> &ndash; Subroutines, that is, library functions. </li>
<li><em>4</em> &ndash; Devices, that is, special files in the /dev directory. </li>
<li><em>5</em> &ndash; File format descriptions, e.g. /etc/passwd. </li>
<li><em>6</em> &ndash; Games, self-explanatory. </li>
<li><em>7</em> &ndash; Miscellaneous, e.g. macro packages, conventions. </li>
<li><em>8</em> &ndash; System administration tools that only root can execute. </li>
<li><em>9</em> &ndash; Another (Linux specific) place for kernel routine documentation.</li>
</ul>
<p>Do not use chapters "n", "o", or "l" (in fact, only those listed integers are accepted). If a name is supplied it overrides the default name of that chapter. If no chapter is specified, "1" is assumed. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03122">3122</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03122">chapter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03122">chapter()</a>.</p>

</div>
</div>
<a id="ae7cdebcff082e362fe72334e88f1ffd4" name="ae7cdebcff082e362fe72334e88f1ffd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cdebcff082e362fe72334e88f1ffd4">&#9670;&#160;</a></span>chapter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, std::string &gt; Sawyer::CommandLine::Parser::chapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual chapter. </p>
<p>Every Unix manual page belongs to a specific chapter. The chapters are:</p>
<ul>
<li><em>1</em> &ndash; User commands that may be started by everyone. </li>
<li><em>2</em> &ndash; System calls, that is, functions provided by the kernel. </li>
<li><em>3</em> &ndash; Subroutines, that is, library functions. </li>
<li><em>4</em> &ndash; Devices, that is, special files in the /dev directory. </li>
<li><em>5</em> &ndash; File format descriptions, e.g. /etc/passwd. </li>
<li><em>6</em> &ndash; Games, self-explanatory. </li>
<li><em>7</em> &ndash; Miscellaneous, e.g. macro packages, conventions. </li>
<li><em>8</em> &ndash; System administration tools that only root can execute. </li>
<li><em>9</em> &ndash; Another (Linux specific) place for kernel routine documentation.</li>
</ul>
<p>Do not use chapters "n", "o", or "l" (in fact, only those listed integers are accepted). If a name is supplied it overrides the default name of that chapter. If no chapter is specified, "1" is assumed. </p>

</div>
</div>
<a id="a56af857b77487730fa558e40ca9763b6" name="a56af857b77487730fa558e40ca9763b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56af857b77487730fa558e40ca9763b6">&#9670;&#160;</a></span>doc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::doc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sectionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>docKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

</div>
</div>
<a id="af4503f4074e25b954dd00d52a69d8fee" name="af4503f4074e25b954dd00d52a69d8fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4503f4074e25b954dd00d52a69d8fee">&#9670;&#160;</a></span>doc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::doc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sectionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03165">3165</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

<p class="reference">References <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03165">doc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03165">doc()</a>.</p>

</div>
</div>
<a id="aa8d68bda6078b8a58a98640e2f555923" name="aa8d68bda6078b8a58a98640e2f555923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d68bda6078b8a58a98640e2f555923">&#9670;&#160;</a></span>doc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::doc </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

</div>
</div>
<a id="a6b24d4506221914e9c0765fe7fea35cd" name="a6b24d4506221914e9c0765fe7fea35cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b24d4506221914e9c0765fe7fea35cd">&#9670;&#160;</a></span>docSections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Sawyer::CommandLine::Parser::docSections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

</div>
</div>
<a id="acf4a4c5ae593d8f8026970de57a78048" name="acf4a4c5ae593d8f8026970de57a78048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a4c5ae593d8f8026970de57a78048">&#9670;&#160;</a></span>docForSwitches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::CommandLine::Parser::docForSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

</div>
</div>
<a id="ac84eadee351b8e4ac484784e779bd473" name="ac84eadee351b8e4ac484784e779bd473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84eadee351b8e4ac484784e779bd473">&#9670;&#160;</a></span>docForSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::CommandLine::Parser::docForSection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sectionName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documentation for a section of the manual. </p>
<p>The user may define any number of sections with any names. Names should be capitalized like titles (initial capital letter), although case is insensitive in the table that stores them. The sections of a manual page are sorted according to lower-case versions of either the <code>docKey</code> or the <code>sectionName</code>. If a section's documentation is completely empty (no user specified documentation and no automatically generated documentation) then it will not show up in the output.</p>
<p>Some sections have content that's generatated automatically. For these sections, setting the doc string will either override the generated content or augment the content as described below. Since setting the doc string to an empty string only suppresses any user-defined content and not the auto-generated content, this doesn't delete the section from the output. In order to delete the section, set its doc string to "delete" (this also works for sections that have no auto-generated content).</p>
<p>The following sections are always present in this order unless explicitly deleted by setting their doc string to "delete":</p>
<ul>
<li>"Name" contains the program name and purpose separated from one another by a single hyphen. By convention, the purpose should be a short string with no capitalization (except special words) and no terminating punctuation. If no user documentation is specified then this section is generated automatically from the parser's <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4f432e9e38d0c5c1966d521cc09e00c0">purpose</a> property.</li>
</ul>
<ul>
<li>"Synopsis" contains information about how to invoke the program. If the user does not provide documentation, then an automatically generated value is used, which says to invoke the program by its name followed by zero or more switches.</li>
</ul>
<ul>
<li>"Description" is the detailed description of the program. It has no automatically generated content.</li>
</ul>
<ul>
<li>"Switches" lists all the non-hidden switches organized by <a class="el" href="classSawyer_1_1CommandLine_1_1SwitchGroup.html">SwitchGroup</a>.</li>
</ul>
<ul>
<li>All user-defined sections are inserted next.</li>
</ul>
<ul>
<li>"See Also" lists other man pages that were referenced prior to this point in the documentation.</li>
</ul>
<ul>
<li>"Documentation Issues" lists any non-fatal problems found in the documentation up to this point, such as switches that were referenced but not declared (e.g., misspelled).</li>
</ul>
<p>The documentation is specified with a simple markup languge described by <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html#add85ab50efbd3bd2ddd6f4af81e4412c" title="Property: detailed description.">Switch::doc</a>. </p>

</div>
</div>
<a id="a941cbb15450a15ba137c9c420e0b7ba3" name="a941cbb15450a15ba137c9c420e0b7ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941cbb15450a15ba137c9c420e0b7ba3">&#9670;&#160;</a></span>documentationMarkup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::CommandLine::Parser::documentationMarkup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full documentation. </p>
<p>Combines all the documentation parts to return a string documenting the entire parser. The returned string contains markup in the Sawyer::Markup language, with some extensions specific to command-line parsing. </p>

</div>
</div>
<a id="a9dae2a35c9edd8527da0cbfbe33a239b" name="a9dae2a35c9edd8527da0cbfbe33a239b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dae2a35c9edd8527da0cbfbe33a239b">&#9670;&#160;</a></span>podDocumentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sawyer::CommandLine::Parser::podDocumentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Perl POD documentation. </p>
<p>Generates a Perl POD string for this parser. </p>

</div>
</div>
<a id="a3762e2e259b2473ba71e8e4bf88c3023" name="a3762e2e259b2473ba71e8e4bf88c3023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3762e2e259b2473ba71e8e4bf88c3023">&#9670;&#160;</a></span>emitDocumentationToPager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::CommandLine::Parser::emitDocumentationToPager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print documentation to standard output. </p>
<p>Use a pager if possible. </p>

</div>
</div>
<a id="ab892aa54728067ea0f4600f46ef357fe" name="ab892aa54728067ea0f4600f46ef357fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab892aa54728067ea0f4600f46ef357fe">&#9670;&#160;</a></span>emitDocumentationToPager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Grammar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::CommandLine::Parser::emitDocumentationToPager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03190">3190</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="adba86f9a10d20a75922e6cbd27e06f75" name="adba86f9a10d20a75922e6cbd27e06f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba86f9a10d20a75922e6cbd27e06f75">&#9670;&#160;</a></span>switchGroupOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a1e6d0ab89ea08ac8840a721625257477">SortOrder</a> Sawyer::CommandLine::Parser::switchGroupOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: How to order switch groups in documentation. </p>
<p>If the parser contains titled switch groups then switches will be organized into subsections based on the group titles, and this property controls how those subsections are ordered with respect to each other. The subsections can be sorted according to the order they were inserted into the parser, or alphabetically by their documentation keys or titles. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03203">3203</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="a42cd1353efaeda9488df40f005869f86" name="a42cd1353efaeda9488df40f005869f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cd1353efaeda9488df40f005869f86">&#9670;&#160;</a></span>switchGroupOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html">Parser</a> &amp; Sawyer::CommandLine::Parser::switchGroupOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a1e6d0ab89ea08ac8840a721625257477">SortOrder</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: How to order switch groups in documentation. </p>
<p>If the parser contains titled switch groups then switches will be organized into subsections based on the group titles, and this property controls how those subsections are ordered with respect to each other. The subsections can be sorted according to the order they were inserted into the parser, or alphabetically by their documentation keys or titles. </p>

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03204">3204</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<a id="afa8db56b2546fb17b09bb57d391f48a5" name="afa8db56b2546fb17b09bb57d391f48a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8db56b2546fb17b09bb57d391f48a5">&#9670;&#160;</a></span>insertLongSwitchStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::CommandLine::Parser::insertLongSwitchStrings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a0026e9ad4f6337fee94ca6661fc82aeb">Canonical</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert records for long switch strings. </p>
<p>Inserts records into the <code>index</code> for long switch strings depending on whether the switch string is canonical. </p>

</div>
</div>
<a id="a4bee1665553c23dcda3d3419754c56cb" name="a4bee1665553c23dcda3d3419754c56cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bee1665553c23dcda3d3419754c56cb">&#9670;&#160;</a></span>insertShortSwitchStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::CommandLine::Parser::insertShortSwitchStrings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert records for short switch strings. </p>
<p>Insert records into the <code>index</code> for short switch strings. </p>

</div>
</div>
<a id="a69fb6971c98bb4184bc7f4b3df06828c" name="a69fb6971c98bb4184bc7f4b3df06828c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb6971c98bb4184bc7f4b3df06828c">&#9670;&#160;</a></span>insertSwitchStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sawyer::CommandLine::Parser::insertSwitchStrings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#a0026e9ad4f6337fee94ca6661fc82aeb">Canonical</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert records for long and short switch strings. </p>
<p>Insert records into the <code>index</code> for both long and short switch strings. This is just a convenient way to invoke <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#afa8db56b2546fb17b09bb57d391f48a5">insertLongSwitchStrings</a> and <a class="el" href="classSawyer_1_1CommandLine_1_1Parser.html#a4bee1665553c23dcda3d3419754c56cb">insertShortSwitchStrings</a>. </p>

</div>
</div>
<a id="a368d6de72dcab080ba14b2cec3ba7795" name="a368d6de72dcab080ba14b2cec3ba7795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368d6de72dcab080ba14b2cec3ba7795">&#9670;&#160;</a></span>printIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Sawyer::CommandLine::Parser::printIndex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>linePrefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a switch index. </p>
<p>This is mostly for debugging. It's quite easy to traverse the <a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> object and print them yourself. </p>

</div>
</div>
<a id="a07197e8b4e5589613f6277cb1b9124b4" name="a07197e8b4e5589613f6277cb1b9124b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07197e8b4e5589613f6277cb1b9124b4">&#9670;&#160;</a></span>findAmbiguities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> Sawyer::CommandLine::Parser::findAmbiguities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find switch string ambiguities. </p>
<p>Return an index containing all switches that are ambiguous regardless of whether they're canonical. </p>

</div>
</div>
<a id="aa1f6c7a8d09cd86c864e2b23eb432eed" name="aa1f6c7a8d09cd86c864e2b23eb432eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f6c7a8d09cd86c864e2b23eb432eed">&#9670;&#160;</a></span>findUnresolvableAmbiguities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSawyer_1_1CommandLine.html#acb2813ae2c82bec73a484805cc889351">NamedSwitches</a> Sawyer::CommandLine::Parser::findUnresolvableAmbiguities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find unresolvable switch string ambiguities. </p>
<p>Return an index containing all switches that are ambiguous and which cannot be made unambiguous by qualifying them. </p>

</div>
</div>
<a id="a4e97dd10737b064a1b1c376b458ab1e5" name="a4e97dd10737b064a1b1c376b458ab1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e97dd10737b064a1b1c376b458ab1e5">&#9670;&#160;</a></span>removeMatchingSwitch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &gt; Sawyer::CommandLine::Parser::removeMatchingSwitch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the switch by matching parse sentence. </p>
<p>Removes from this parser whichever switch is able to parse the specified command-line. The input should be either a single command line argument string (like "--debug-level=5") or a vector of strings (like {"--debug-level", "5"}). Only long-name switches (not single-letter switches) can be removed this way. Only the first matched switch is removed from the parser.</p>
<p>Returns either nothing, or a copy of the switch parser that was removed. Since the switch parser is returned, it can then be modified and added back to the same parser or to a different parser. </p>

</div>
</div>
<a id="a3576019bce9f072cf6733159307a28f3" name="a3576019bce9f072cf6733159307a28f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3576019bce9f072cf6733159307a28f3">&#9670;&#160;</a></span>removeMatchingSwitch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; <a class="el" href="classSawyer_1_1CommandLine_1_1Switch.html">Switch</a> &gt; Sawyer::CommandLine::Parser::removeMatchingSwitch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the switch by matching parse sentence. </p>
<p>Removes from this parser whichever switch is able to parse the specified command-line. The input should be either a single command line argument string (like "--debug-level=5") or a vector of strings (like {"--debug-level", "5"}). Only long-name switches (not single-letter switches) can be removed this way. Only the first matched switch is removed from the parser.</p>
<p>Returns either nothing, or a copy of the switch parser that was removed. Since the switch parser is returned, it can then be modified and added back to the same parser or to a different parser. </p>

</div>
</div>
<a id="a85b05906fa51b5d303eccbc65b23776c" name="a85b05906fa51b5d303eccbc65b23776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b05906fa51b5d303eccbc65b23776c">&#9670;&#160;</a></span>properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structSawyer_1_1CommandLine_1_1ParsingProperties.html">ParsingProperties</a> &amp; Sawyer::CommandLine::Parser::properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Sawyer_2CommandLine_8h_source.html#l03255">3255</a> of file <a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Sawyer_2CommandLine_8h_source.html">Sawyer/CommandLine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
