<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::Diagnostics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1Diagnostics.html">Diagnostics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Rose::Diagnostics Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Controls diagnostic messages from ROSE. </p>
<p>ROSE uses the free <a href="http://github.com/matzke1/sawyer">Sawyer</a> library to emit diagnostic messages for events such as debugging, program tracing, informational messages, warning and error messages, progress reports, and runtime logic assertions. The <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> message support can be found in the <a class="el" href="namespaceSawyer_1_1Message.html" title="Formatted diagnostic messages emitted to various backends.">Sawyer::Message</a> name space in "Sawyer/Message.h", and the run-time logic assertions can be found in the <a class="el" href="namespaceSawyer_1_1Assert.html" title="Run-time logic assertions.">Sawyer::Assert</a> name space in "assert/Assert.h" (which also defines a number of C preprocessor macros whose names begin with "ASSERT_".</p>
<p>To this API more ROSE-like, we create some aliases. Unfortunately these aliases aren't entirely understood by Doxygen, so we list them here:</p>
<ul>
<li><code>Rose::Diagnostics::Facility</code> is an alias of <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> </li>
<li><code>Rose::Diagnostics::Stream</code> is an alias of <a class="el" href="classSawyer_1_1Message_1_1Stream.html">Sawyer::Message::Stream</a> </li>
<li><code>Rose::Diagnostics::mfacilities</code> is an alias of <a class="el" href="namespaceSawyer_1_1Message.html#a1bb51db7d9bc62c602f6104a24231490">Sawyer::Message::mfacilities</a></li>
</ul>
<p><a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> supports multiple instances of messaging facilities (<a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> / <code>Rose::Diagnostics::Facility</code>) each of which defines a <code>std::ostream</code> object for each of a number of message importance levels. ROSE defines one global library-wide facility, <a class="el" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">Rose::Diagnostics::mlog</a> whose string name (used in output) is simply "rose". Software layers within ROSE may define their own facilities and give them names indicative of the software layer, like "Rose::BinaryAnalysis::StackDelta. Tools that use ROSE can also define and register their own
 facilities.  All these facilities are then grouped together into a single @ref Sawyer::Message::Facilities object,
 @c Rose::Diagnostics::mfacilities, so they can be controlled collectively or individually from the ROSE command-line (e.g.,
 the @c frontend call).

@section diagnostics_cmdline_usage Command-line usage

 ROSE looks for the command-line switch (e.g., "-rose:log" for source analysis tools or "--log" for binary analysis tools) that
 takes one argument: @em what.  If @em what is the word "help" then usage information is displayed; if @em what is the word
 "list" then log settings are displayed.  Otherwise, @em what is expected to be a string to pass to the @ref
 Sawyer::Message::mfacilities (@c Rose::Diagnostics::mfacilities.control) function.  See the output from any tool that supports
 "--log help" for details about the syntax.

@section diagnostics_in_rose Adding a facility to ROSE

 Note: this section is about adding a new logging facility to the ROSE library proper. Adding a facility to a tool that uses
 ROSE is simpler and is described in a later section.

 As an example, let's say that a programmer wants to convert the BinaryLoader class to use its own logging facilities.  The
 first step is to declare a static data member for the facility. Adding a logging facility to a namespace or file is similar
 except the @c mlog would be declared in the namespace or as a file-scope (static or anonymous namespace) variable.

@code 
 // in BinaryLoader.h
 #include &lt;Rose/Diagnostics.h&gt;

 class BinaryLoader {
     ...
 protected:
     static Rose::Diagnostics::Facility mlog; // a.k.a., Sawyer::Message::Facility
 };
@endcode

 If we consistently name message facilities "mlog" then any unqualified reference to @c mlog in the source code will
 probably be the most appropriate (most narrowly scoped) facility.  Adding a new facility to a software component that
 already uses the rose-wide "mlog" is mostly a matter of defining a more narrowly scoped @c mlog, and the existing code will
 start using it (you probably also need to search for places where @c mlog usage was qualified). Specifically, we avoid
 using "log" as the name of any logging facility because it can conflict on some systems with the logorithm function @c log.

 The second step is to define the @c mlog static variable. Since the variable is statically allocated, it must be
 constructed only with the default constructor. Sawyer also has other Facility constructors, but these generally can't be
 used for static variables because there is no portable way to ensure that the C++ runtime is initialized before the
 Facility initialization happens.  If the initializations occur in the wrong order then bizarre behavior may result,
 including segmentation faults in STL container classes.

@code 
 // in BinaryLoader.C
 #include &lt;Rose/BinaryAnalysis/BinaryLoader.h&gt;
 Rose::Diagnostics::Facility BinaryLoader::mlog;
@endcode

 The third step is to initialize the @c mlog static variable after we're sure that the C++ runtime has been initialized. We
 can do this by defining a class method (a.k.a., static function member) that can be called from ROSE's initialization
 phase.  This is the point at which the mlog is given a name and connected to a destination(s).  The name is usually the
 fully qualified name of the component for which the @c mlog object serves as the logging facility, and may contain typical
 C++ symbol names, dots, and "::".  This name is used to enable/disable the facility from the command-line, and will show up
 as part of the output for any message emitted using this facility.  It is recommended that you also provide a comment in
 order to help people that are not ROSE developers to use ROSE-based tools. The comment should start with a gerund (verb
 ending with "ing"), be uncapitalized, and unpunctuated.

 The second, optional half of this step is to register the facility with the ROSE library so it can be controlled from the
 command-line. Although unregistered facilities are still useful, components of the ROSE library should almost always
 register their facility. The easiest way to do this consistently is to use @ref initAndRegister like this:

@code 
 // class method (static member function) in BinaryLoader.C
 void BinaryLoader::initDiagnostics() {
     static bool initialized = false;
     if (!initialized) {
         initialized = true;
         Diagnostics::initAndRegister(&amp;mlog, "<a class="el" href="classRose_1_1BinaryAnalysis_1_1BinaryLoader.html" title="Base class for loading a static or dynamic object.">Rose::BinaryAnalysis::BinaryLoader</a>");
         mlog.comment("mapping files into virtual memory");
     }
 }
@endcode

 If the class, namespace, or file containing you @c initDiagnostics function is conditionally compiled (e.g., binary
 analysis is not always enabled in ROSE), you'll want to add a dummy version of @c initDiagnostics that does nothing
 (preferrable to using conditional compilation in the next step).

 The fourth and final step is to add a call to &lt;code&gt;BinaryLoader::initDiagnostics&lt;/code&gt; from @ref
 Diagnostics::initialize. This function is defined in "src/roseSupport/Diagnostics.C". You probably don't need to include
 your entire header file in Diagnostics.C; a declarations should be sufficient and faster to compile.

@section diagnostics_in_tools Adding a facility to a tool

 Tools that are built on top of the ROSE library can use the same Sawyer messaging support, and the tool's Facility objects
 can be registered with ROSE and thus controlled along with the library's facilities.  Doing so is even easier than using
 the facility in part of the ROSE library: declare the facility, and initialize and register it.  Tools can create as many
 facilities as they like, although the description below assumes only one.

 The facility is usually declared as a static object so it can be available to all parts of the tool.  As with static
 facilities in the ROSE library itself (described above), it should be only default constructed.  Also, instead of using
 namespace @ref Rose::Diagnostics, the tool can optionally use namespace @ref Sawyer::Message::Common.  This avoids the
 ambiguity for @c mlog that would be created by importing @ref Rose::Diagnostics or @ref Sawyer::Message (the types and
 enums in these two namespaces are equivalent).

@code 
 #include &lt;Rose/Diagnostics.h&gt;
 using namespace Sawyer::Message::Common; // if you want unqualified DEBUG, WARN, ERROR, FATAL, etc.
 Sawyer::Message::Facility mlog; // a.k.a., Rose::Diagnostics::Facility
@endcode

 The second step, initialization and registration, is usually near the beginning of @c main right after initializing the
 ROSE library but before command-line processing.

@code 
 int main(int argc, char *argv[]) {
     ROSE_INITIALIZE;
     mlog = Rose::Diagnostics::initAndRegister(&amp;mlog, "name-of-my-tool");
@endcode

 If you want to globally adjust which levels of diagnostics are output by default (later modified by the command-line) you
 can do that by passing a string to the same function that's used by the command-line processing, such as:

@code 
 Sawyer::Message::mfacilities.control("none,&gt;=info");
@endcode

 Although initialization is required, the registering step is optional. Registering causes the tool's diagnostics to be
 conrollable from ROSE's command-line switches.  If you want to only initialize and not register, then use this:

@code 
 int main(int argc, char *argv[]) {
     ROSE_INITIALIZE;
     mlog = Sawyer::Message::Facility("name-of-my-tool", Rose::Diagnostics::destination);
@endcode


@section diagnostics_facility_usage Using a facility in the ROSE library or tools

 When using a message facility within the ROSE library source code, it is generally desirable to have a "using namespace <a class="el" href="namespaceRose_1_1Diagnostics.html" title="Controls diagnostic messages from ROSE.">Rose::Diagnostics</a>" in effect.  Not only does this alleviate the need to qualify the important levels (e.g.,
 &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARN&lt;/code&gt;, etc), but it also brings @ref Rose::Diagnostics::mlog, the library-wide logging
 facility, into scope.  Doing so will allow any software component to perform logging using the library-wide facility, and
 once a more local @c mlog is declared the more local symbol is automatically used.

 When using a message facility within a tool, importing the @ref Sawyer::Message::Common instead of @ref Rose::Diagnostics
 will prevent an ambiguity between the tool's global @c mlog and @ref Rose::Diagnostics::mlog. You can do which ever you
 prefer.

 Regardless of whether you're writing a ROSE library component or a tool, all one needs to do to use a facility is to write
 a C++ std::ostream-style output statement whose left-hand operand is a @ref Sawyer::Message::Stream.  Since streams are
 held in a @ref Sawyer::Message::Facility and since facilities usually have the C++ name "mlog", the statement will look
 something like this:

@code 
 using Rose::Diagnostics; // or using Sawyer::Message::Common
 mlog[INFO] &lt;&lt;"loading "" &lt;&lt;filename &lt;&lt;""<br  />
";
@endcode

 The default configuration will cause the message to be emitted on the standard error stream along with information about
 the name of the executable, the thread ID, the time in seconds relative to the start of the process, the name of the
 facility, and the message importance.  For example:

@code 
 identityTranslator[30603] 0.00949s BinaryLoader[INFO]: loading "/usr/lib32/libc.so"
@endcode

 ROSE also defines a global macro @c mprintf that is a drop-in replacement for @c printf.  This macro uses whatever
 &lt;code&gt;mlog[DEBUG]&lt;/code&gt; is in scope.  The @ref mfprintf function can be used as a replacement when a specific logging
 stream is desired.

 Sometimes one wants the right hand side of the output statements to be evaluated only in certain circumstances for
 performance reasons, and there are multiple ways to do that.  If you already use conditional compilation or "if" statements
 to generate diagnostic output, continue to do the same.  You can also use an "if" statement whose condition is the
 diagnostic stream since streams evaluated in a Boolean context return true or false depending on whether the stream is
 enabled or disabled:

@code 
 if (mlog[INFO])
     mlog[INFO] &lt;&lt;"loading "" &lt;&lt;filename &lt;&lt;""<br  />
";
@endcode

 Sawyer also has a SAWYER_MESG() macro that's used like this:

@code 
 SAWER_MESG(mlog[INFO]) &lt;&lt;"loading "" &lt;&lt;filename &lt;&lt;""<br  />
";
@endcode

 Another thing you can do is construct a new locally-declared stream with a shorter name.  Some parts of the ROSE library do
 things like this:

@code 
 using namespace Rose::Diagnostics;
 void doSomething() {
     Stream debug(mlog[DEBUG]); // get our own copy of a stream
     ...
     if (debug) {
         some_debugging_things();
         debug &lt;&lt;"debugging results...<br  />
";
     }
 }
@endcode

 Not only does this reduce typing a little, but since the function is using its own private message stream, partial
 messages emitted to that stream won't interfere with partial messages emitted to &lt;code&gt;mlog[DEBUG]&lt;/code&gt; by called
 functions (see next section).

 Another debugging trick is to create a local stream like above, and then explicitly enable or disable it based on some
 condition you're trying to debug:

@code 
 using namespace Rose::Diagnostics;
 void doSomething(int foo) {
     Stream debug(mlog[DEBUG]); // get our own copy of a stream
     debug.enable(5==foo); // enable it only in certain cases
     ...
     if (debug) {
         some_debugging_things();
         debug &lt;&lt;"debugging results...<br  />
";
     }
 }
@endcode

@section diagnostics_partial Partial messages

 A partial message is any message for which the linefeed, "<br  />
", hasn't been inserted.  If a message stream is unbuffered and
 another message is emitted to a different stream and ends up going to the same ultimate destination (e.g., standard error),
 then any previous partial message is interrupted, usually by appending "...", and re-emitted later when more text is added.

 Since each message stream creates messages sequentially in an incremental manner, we sometimes want to "save" a partial
 message, allow other messages to be emitted from the same stream, and then complete the original message later.  This most
 often happens when one function creates a partial message, and then calls another function that might use the same stream
 before the partial message is completed.  The best way to accomplish this is by creating a new, temporary message stream
 and moving any partial messages to the new stream.  The copy constructor can be used, like the example above, but even more
 conveniently, if the source stream in the copy constructor has an outstanding partial message then that partial message is
 moved (not copied) to the newly constructed stream.  This allows a partial message to be emitted in the same statement that
 constructs the local stream:

@code 
 Stream m1(mlog[INFO] &lt;&lt;"loading "" &lt;&lt;filename &lt;&lt;"""); //note no "<br  />
"
 Sawyer::Stopwatch timer;
 do_other_stuff_that_might_emit_info_messages();
 m1 &lt;&lt;"; took " &lt;&lt;timer &lt;&lt;"<br  />
"; //original message completed now
 // you may continue to use m1 for additional messages...
@endcode

 The documentation for @ref Sawyer::Message has additional hints and examples.

@section diagnostics_prefix Diagnostic prefix

 Each diagnostic message has a prefix that contains, by default, the process ID and time, among other things. Sometimes
 this information should be suppressed in order to more easily compare diagnostic messages between tools. This can be
 done by adjusting the @ref Rose::Diagnostics::mprefix, which is a pointer to a @ref Sawyer::Message::Prefix object. The
 adjustments should be done after the ROSE library is initialized (e.g., via ROSE_INITIALIZE, normally the first thing
 in "main").

@section diagnostics_destinations Sending output to other locations

 Diagnostic output always goes to standard error by default in ROSE and ROSE-based tools.  If you want to send your tool's
 output to a file instead, you can do something like follows instead of the usual call to @ref Rose::Diagnostics::initAndRegister.

@code 
 std::ofstream output("tool-errors.txt"); // must remain open for duration of run
 Sawyer::Message::DestinationPtr destination = Sawyer::Message::StreamSink::instance(output, Rose::Diagnostics::mprefix);
 mlog = Facility("tool", destination); // your tool's global diagnostic facility Sawyer::Message::mfacilities.insertAndAdjust(mlog); // so it can be controled by ROSE's command-line processing </p>
<p>Be sure to flush the file by closing it explicitly or implicitly since we didn't configure it to be unbuffered or line buffered. Failure to do any of these steps could result in your file not actually getting any diagnostic messages. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Diagnostics_1_1StreamPrintf.html">StreamPrintf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate class for printing to C++ ostreams with a printf-like API.  <a href="classRose_1_1Diagnostics_1_1StreamPrintf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af73708983cca75ce5a3bb8f9928b6e2c" id="r_af73708983cca75ce5a3bb8f9928b6e2c"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#af73708983cca75ce5a3bb8f9928b6e2c">initialize</a> ()</td></tr>
<tr class="memdesc:af73708983cca75ce5a3bb8f9928b6e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostics-related global variables.  <br /></td></tr>
<tr class="separator:af73708983cca75ce5a3bb8f9928b6e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec70bac7d7999b3b692b7ca531a678" id="r_a8eec70bac7d7999b3b692b7ca531a678"><td class="memItemLeft" align="right" valign="top"><a id="a8eec70bac7d7999b3b692b7ca531a678" name="a8eec70bac7d7999b3b692b7ca531a678"></a>
ROSE_DLL_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> ()</td></tr>
<tr class="memdesc:a8eec70bac7d7999b3b692b7ca531a678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if diagnostics-related global variables have been initialized. <br /></td></tr>
<tr class="separator:a8eec70bac7d7999b3b692b7ca531a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402521c016036e3b7e7df9322a886566" id="r_a402521c016036e3b7e7df9322a886566"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a402521c016036e3b7e7df9322a886566">initAndRegister</a> (<a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a> *<a class="el" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a>, const std::string &amp;name)</td></tr>
<tr class="memdesc:a402521c016036e3b7e7df9322a886566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and register a logging facility.  <br /></td></tr>
<tr class="separator:a402521c016036e3b7e7df9322a886566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237f88cae9daabf149c405b363f45ffe" id="r_a237f88cae9daabf149c405b363f45ffe"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a237f88cae9daabf149c405b363f45ffe">deregister</a> (<a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a> *<a class="el" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a>)</td></tr>
<tr class="memdesc:a237f88cae9daabf149c405b363f45ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister a facility.  <br /></td></tr>
<tr class="separator:a237f88cae9daabf149c405b363f45ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b26ba5d382cd9ee8e4f7fbc668023b" id="r_a85b26ba5d382cd9ee8e4f7fbc668023b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Diagnostics_1_1StreamPrintf.html">StreamPrintf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a85b26ba5d382cd9ee8e4f7fbc668023b">mfprintf</a> (std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a85b26ba5d382cd9ee8e4f7fbc668023b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to a C++ stream using a printf-like API.  <br /></td></tr>
<tr class="separator:a85b26ba5d382cd9ee8e4f7fbc668023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1ba0507284dc0ed4bf22f0a5f3fe5ac4" id="r_a1ba0507284dc0ed4bf22f0a5f3fe5ac4"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API <a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">Sawyer::Message::DestinationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a1ba0507284dc0ed4bf22f0a5f3fe5ac4">destination</a></td></tr>
<tr class="memdesc:a1ba0507284dc0ed4bf22f0a5f3fe5ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Collection of related streams, e.g., 'mlog'.  <br /></td></tr>
<tr class="separator:a1ba0507284dc0ed4bf22f0a5f3fe5ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6d205ca43c0ea7068fd17efd3dd100" id="r_a8d6d205ca43c0ea7068fd17efd3dd100"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API <a class="el" href="namespaceSawyer_1_1Message.html#a6f1076a1d90e2dfd1a50a3a74342d852">Sawyer::Message::PrefixPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a8d6d205ca43c0ea7068fd17efd3dd100">mprefix</a></td></tr>
<tr class="memdesc:a8d6d205ca43c0ea7068fd17efd3dd100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default line prefix for message sinks created in ROSE.  <br /></td></tr>
<tr class="separator:a8d6d205ca43c0ea7068fd17efd3dd100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9ad83a4fd128e85197e5114e78da6e" id="r_a9d9ad83a4fd128e85197e5114e78da6e"><td class="memItemLeft" align="right" valign="top">ROSE_DLL_API <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a></td></tr>
<tr class="memdesc:a9d9ad83a4fd128e85197e5114e78da6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic facility for the ROSE library as a whole.  <br /></td></tr>
<tr class="separator:a9d9ad83a4fd128e85197e5114e78da6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af73708983cca75ce5a3bb8f9928b6e2c" name="af73708983cca75ce5a3bb8f9928b6e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73708983cca75ce5a3bb8f9928b6e2c">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void Rose::Diagnostics::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize diagnostics-related global variables. </p>
<p>This should be called before any of the global variables in the <a class="el" href="namespaceRose_1_1Diagnostics.html" title="Controls diagnostic messages from ROSE.">Rose::Diagnostics</a> name space are used. It doesn't hurt to call this more than once. </p>

</div>
</div>
<a id="a402521c016036e3b7e7df9322a886566" name="a402521c016036e3b7e7df9322a886566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402521c016036e3b7e7df9322a886566">&#9670;&#160;</a></span>initAndRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void Rose::Diagnostics::initAndRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a> *&#160;</td>
          <td class="paramname"><em>mlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and register a logging facility. </p>
<p>Initializes the specified facility by giving it a name and pointing it to the same place as the other ROSE diagnostic streams. Then register the facility with ROSE's global list of facilities so it can be controlled from the command-line. Registering a facility does not copy it&ndash;it only saves a reference to it. Therefore, either facilties should be statically declared or they should be de-registered before they go out of scope. </p>

</div>
</div>
<a id="a237f88cae9daabf149c405b363f45ffe" name="a237f88cae9daabf149c405b363f45ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237f88cae9daabf149c405b363f45ffe">&#9670;&#160;</a></span>deregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API void Rose::Diagnostics::deregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Facility</a> *&#160;</td>
          <td class="paramname"><em>mlog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister a facility. </p>
<p>Do this before your facility goes out of scope. In general, you don't need to deregister a Facility object from a Facilities collection when the Facility object is destroyed because <a class="el" href="namespaceSawyer.html" title="Sawyer support library.">Sawyer</a> will notice the destruction automatically. However, the recognition is heuristic based on magic numbers manipulated by constructors and destructors and could potentially fail. The general safe, rule is that if a registered Facility object is destroyed other than at program exit, you should explicitly deregister it before it's destroyed. </p>

</div>
</div>
<a id="a85b26ba5d382cd9ee8e4f7fbc668023b" name="a85b26ba5d382cd9ee8e4f7fbc668023b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b26ba5d382cd9ee8e4f7fbc668023b">&#9670;&#160;</a></span>mfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Diagnostics_1_1StreamPrintf.html">StreamPrintf</a> Rose::Diagnostics::mfprintf </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print to a C++ stream using a printf-like API. </p>
<p>The mfprintf function is a partial function whose return value is the real function. It's argument can be any C++ <code>std::ostream</code> although it's intended mainly for <a class="el" href="classSawyer_1_1Message_1_1Stream.html" title="Converts text to messages.">Sawyer::Message::Stream</a> streams. It's used like this:</p>
<div class="fragment"><div class="line">uint64_t va = ...;</div>
<div class="line"><span class="comment">// C++ way of emitting a message</span></div>
<div class="line"><a class="code hl_variable" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a>[DEBUG] &lt;&lt;<span class="stringliteral">&quot;address is &quot;</span> &lt;&lt;<a class="code hl_function" href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">StringUtility::addrToString</a>(va) &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="comment">// C way of emitting a message</span></div>
<div class="line"><a class="code hl_function" href="namespaceRose_1_1Diagnostics.html#a85b26ba5d382cd9ee8e4f7fbc668023b">mfprintf</a>(<a class="code hl_variable" href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">mlog</a>[DEBUG])(<span class="stringliteral">&quot;address is 0x&quot;</span> PRIx64 <span class="stringliteral">&quot;\n&quot;</span>, va);</div>
<div class="line"><span class="comment">// Shortcut macro</span></div>
<div class="line">mprintf(<span class="stringliteral">&quot;address is 0x&quot;</span> PRIx64 <span class="stringliteral">&quot;\n&quot;</span>, va);</div>
<div class="ttc" id="anamespaceRose_1_1Diagnostics_html_a85b26ba5d382cd9ee8e4f7fbc668023b"><div class="ttname"><a href="namespaceRose_1_1Diagnostics.html#a85b26ba5d382cd9ee8e4f7fbc668023b">Rose::Diagnostics::mfprintf</a></div><div class="ttdeci">StreamPrintf mfprintf(std::ostream &amp;stream)</div><div class="ttdoc">Print to a C++ stream using a printf-like API.</div></div>
<div class="ttc" id="anamespaceRose_1_1Diagnostics_html_a9d9ad83a4fd128e85197e5114e78da6e"><div class="ttname"><a href="namespaceRose_1_1Diagnostics.html#a9d9ad83a4fd128e85197e5114e78da6e">Rose::Diagnostics::mlog</a></div><div class="ttdeci">ROSE_DLL_API Sawyer::Message::Facility mlog</div><div class="ttdoc">Diagnostic facility for the ROSE library as a whole.</div><div class="ttdef"><b>Definition</b> <a href="sageBuilder_8C_source.html#l00058">sageBuilder.C:58</a></div></div>
<div class="ttc" id="anamespaceRose_1_1StringUtility_html_a1601608fa2856aa31397370b8b5923c4"><div class="ttname"><a href="namespaceRose_1_1StringUtility.html#a1601608fa2856aa31397370b8b5923c4">Rose::StringUtility::addrToString</a></div><div class="ttdeci">ROSE_UTIL_API std::string addrToString(uint64_t value, size_t nbits=0)</div><div class="ttdoc">Convert a virtual address to a string.</div></div>
</div><!-- fragment --><p>The <code>mprintf</code> macro always uses <code>mlog[DEBUG]</code> without any name qualification in order to resolve to the most locally defined <code>mlog</code>. Therefore, a "using namespace Rose::Diagnostics" probably needs to be in effect. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1ba0507284dc0ed4bf22f0a5f3fe5ac4" name="a1ba0507284dc0ed4bf22f0a5f3fe5ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba0507284dc0ed4bf22f0a5f3fe5ac4">&#9670;&#160;</a></span>destination</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="namespaceSawyer_1_1Message.html#a8303ffa916b56acb3514453e07ea79b5">Sawyer::Message::DestinationPtr</a> Rose::Diagnostics::destination</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; Collection of related streams, e.g., 'mlog'. </p>
<p>Default destination for ROSE diagnostics. The user may set this explicitly before <a class="el" href="namespaceRose_1_1Diagnostics.html#af73708983cca75ce5a3bb8f9928b6e2c" title="Initialize diagnostics-related global variables.">Rose::Diagnostics::initialize</a> is called, otherwise that function will create a destination that points to standard error and uses the optional <a class="el" href="namespaceRose_1_1Diagnostics.html#a8d6d205ca43c0ea7068fd17efd3dd100" title="Default line prefix for message sinks created in ROSE.">Rose::Diagnostics::mprefix</a>. </p>

</div>
</div>
<a id="a8d6d205ca43c0ea7068fd17efd3dd100" name="a8d6d205ca43c0ea7068fd17efd3dd100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6d205ca43c0ea7068fd17efd3dd100">&#9670;&#160;</a></span>mprefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ROSE_DLL_API <a class="el" href="namespaceSawyer_1_1Message.html#a6f1076a1d90e2dfd1a50a3a74342d852">Sawyer::Message::PrefixPtr</a> Rose::Diagnostics::mprefix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default line prefix for message sinks created in ROSE. </p>
<p>For instance, if the library needs to create a default destination (<a class="el" href="namespaceRose_1_1Diagnostics.html#a1ba0507284dc0ed4bf22f0a5f3fe5ac4" title="&lt; Collection of related streams, e.g., &#39;mlog&#39;.">Rose::Diagnostics::destination</a>) then this prefix is used, and if null at that time then a default prefix is created and assigned to this variable. The user may assign a prefix before calling <a class="el" href="namespaceRose_1_1Diagnostics.html#af73708983cca75ce5a3bb8f9928b6e2c" title="Initialize diagnostics-related global variables.">Rose::Diagnostics::initialize</a>. </p>

</div>
</div>
<a id="a9d9ad83a4fd128e85197e5114e78da6e" name="a9d9ad83a4fd128e85197e5114e78da6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9ad83a4fd128e85197e5114e78da6e">&#9670;&#160;</a></span>mlog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a> SageBuilder::mlog</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagnostic facility for the ROSE library as a whole. </p>

<p class="definition">Definition at line <a class="el" href="sageBuilder_8C_source.html#l00058">58</a> of file <a class="el" href="sageBuilder_8C_source.html">sageBuilder.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="sageBuilder_8C_source.html#l04230">SageBuilder::buildProcedureHeaderStatement()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
