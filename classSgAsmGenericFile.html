<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: SgAsmGenericFile Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classSgAsmGenericFile-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SgAsmGenericFile Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Base class for binary files. </p>

<p class="definition">Definition at line <a class="el" href="binaryInstruction_8C_source.html#l15319">15319</a> of file <a class="el" href="binaryInstruction_8C_source.html">binaryInstruction.C</a>.</p>
</div><div class="dynheader">
Inheritance diagram for SgAsmGenericFile:</div>
<div class="dyncontent">
<div class="center"><img src="classSgAsmGenericFile__inherit__graph.png" border="0" usemap="#aSgAsmGenericFile_inherit__map" alt="Inheritance graph"/></div>
<map name="aSgAsmGenericFile_inherit__map" id="aSgAsmGenericFile_inherit__map">
<area shape="rect" title="Base class for binary files." alt="" coords="36,79,167,104"/>
<area shape="rect" href="classSgAsmExecutableFileFormat.html" title="Base class for many binary analysis nodes." alt="" coords="5,5,197,31"/>
<area shape="poly" title=" " alt="" coords="104,44,104,78,99,78,99,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SgAsmGenericFile:</div>
<div class="dyncontent">
<div class="center"><img src="classSgAsmGenericFile__coll__graph.png" border="0" usemap="#aSgAsmGenericFile_coll__map" alt="Collaboration graph"/></div>
<map name="aSgAsmGenericFile_coll__map" id="aSgAsmGenericFile_coll__map">
<area shape="rect" title="Base class for binary files." alt="" coords="36,79,167,104"/>
<area shape="rect" href="classSgAsmExecutableFileFormat.html" title="Base class for many binary analysis nodes." alt="" coords="5,5,197,31"/>
<area shape="poly" title=" " alt="" coords="104,44,104,78,99,78,99,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae86e310e8abb3d0a044ee16e1bc6c9eb" id="r_ae86e310e8abb3d0a044ee16e1bc6c9eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">AddressSpace</a> { <br />
&#160;&#160;<b>ADDRSP_MEMORY</b> = 0x0001
, <br />
&#160;&#160;<b>ADDRSP_FILE</b> = 0x0002
, <br />
&#160;&#160;<b>ADDRSP_ALL</b> = 0x0003
<br />
 }</td></tr>
<tr class="memdesc:ae86e310e8abb3d0a044ee16e1bc6c9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Section modification functions for <a class="el" href="classSgAsmGenericFile.html#a83384bc3cba90b97c33d64871edc901d">shiftExtend</a>.  <a href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">More...</a><br /></td></tr>
<tr class="separator:ae86e310e8abb3d0a044ee16e1bc6c9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29ae621857658ed39d2524011eef404" id="r_af29ae621857658ed39d2524011eef404"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">Elasticity</a> { <br />
&#160;&#160;<a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404a3118e0ab7640900385b0b6719c5e1b38">ELASTIC_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404a21e3926eefe9c11df0a7b9c7d0b2cf24">ELASTIC_UNREF</a> = 1
, <br />
&#160;&#160;<a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404a4f653980791bcbb59a1d18d808cd41a9">ELASTIC_HOLE</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:af29ae621857658ed39d2524011eef404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elasticity argument for <a class="el" href="classSgAsmGenericFile.html#a83384bc3cba90b97c33d64871edc901d">shiftExtend</a>.  <a href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">More...</a><br /></td></tr>
<tr class="separator:af29ae621857658ed39d2524011eef404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSgAsmExecutableFileFormat"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSgAsmExecutableFileFormat')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSgAsmExecutableFileFormat.html">SgAsmExecutableFileFormat</a></td></tr>
<tr class="memitem:aa4a1858391921731cd54cf531fcfa65d inherit pub_types_classSgAsmExecutableFileFormat" id="r_aa4a1858391921731cd54cf531fcfa65d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65d">ExecFamily</a> { <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65daca25c0e683cfc371ee7781fed7ef9734">FAMILY_UNSPECIFIED</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65da0ba9290c6e39c02894a520b752a09a5a">FAMILY_DOS</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65da028de89083a7ca5d7f5b64df7e9c265b">FAMILY_ELF</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65da496d2ddabd5c75d75a114ed667c1873d">FAMILY_JVM</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65dac35ad9e112b81d3dabbcc0c401a8ac30">FAMILY_LE</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65dade455ef53ca1fed7e30758f96b2e39d3">FAMILY_LX</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65da511d3b87524cd2707b487b55ac11b21b">FAMILY_NE</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65da369c120c89c5ff9a82d51f85a26ec6cc">FAMILY_PE</a>
<br />
 }</td></tr>
<tr class="memdesc:aa4a1858391921731cd54cf531fcfa65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture family.  <a href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65d">More...</a><br /></td></tr>
<tr class="separator:aa4a1858391921731cd54cf531fcfa65d inherit pub_types_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8624b5b893e68f75dceec02588a4cd17 inherit pub_types_classSgAsmExecutableFileFormat" id="r_a8624b5b893e68f75dceec02588a4cd17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17">ExecABI</a> { <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a1ebad99057b7191ac89dea93388cf28c">ABI_UNSPECIFIED</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a313e929067b64ff06b33b88999395216">ABI_OTHER</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a07695e2a88d952cb4a981d839c783bd0">ABI_86OPEN</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a57b03ee0dddc6e820c8875701ff6c2a9">ABI_AIX</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17aa5c3917d6c2f3c03c4ba81a7e3295f7a">ABI_ARM</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a13e3e24aba6e26369933f511adfe8346">ABI_FREEBSD</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a7ace980b3462a0bd57603d5aa8254281">ABI_HPUX</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a33762934578051ac3d8d1eaee271e140">ABI_IRIX</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17ade848a40cd4be1bc14c39db1cc6838fc">ABI_HURD</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a831ffc31e0549f5f50b00f0e58eb643a">ABI_JVM</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17af9dfe30f658f0ab59ee61d6f6bda231f">ABI_LINUX</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a97bc9cfd8937d459fd500af1d94c0ddf">ABI_MODESTO</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a84672ef65c1f1a8d8c6b9afc98f3e79e">ABI_MONTEREY</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a364b7f236eba2fdc2118220a3a9da80c">ABI_MSDOS</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17acf377c6370ef00694e9936f91c454527">ABI_NT</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17af834489318d5615a3f2ee73157028390">ABI_NETBSD</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17ad15ff5f564e938432cba57f09f196502">ABI_OS2</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17ac43c9983147c8f5b52e49bfef642d72d">ABI_SOLARIS</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17ac957bd5c2c372c5fc4bf66a3972abb9d">ABI_SYSV</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17aebf176943357440deeccc45f624a33f3">ABI_TRU64</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17a39eecdeb4068e81b7b6ae3550cd4936b">ABI_WIN386</a>
<br />
 }</td></tr>
<tr class="memdesc:a8624b5b893e68f75dceec02588a4cd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application binary interface.  <a href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17">More...</a><br /></td></tr>
<tr class="separator:a8624b5b893e68f75dceec02588a4cd17 inherit pub_types_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83545a0f1393e82be1225c168ba5224 inherit pub_types_classSgAsmExecutableFileFormat" id="r_ae83545a0f1393e82be1225c168ba5224"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">InsSetArchitecture</a> { <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a061502eb9ac07accd0def0e21645d692">ISA_UNSPECIFIED</a> = 0x0000
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a78cd05aac8651d850b331dd1fd399dc0">ISA_OTHER</a> = 0xffff
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ac0653d745152fe58b50850a431122c3d">ISA_FAMILY_MASK</a> = 0xff00
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a14512f95f1226a08f59252959f250fdd">ISA_IA32_Family</a> = 0x0100
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a04b1daf9fe82eb9b0693dbae56e244dc">ISA_IA32_286</a> = 0x0101
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a8d1f60a24fc227948a5cb39299408255">ISA_IA32_386</a> = 0x0102
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224aa4e586f9745096607a8669a6aacc7273">ISA_IA32_486</a> = 0x0103
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ac9b41bd7046b1f2652c88721ada04271">ISA_IA32_Pentium</a> = 0x0104
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ad6c5bd1fb058fe740e64886de97e32d7">ISA_IA32_Cyrix6x86</a> = 0x0105
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a1130731b31b847247a3a19719fb66dc6">ISA_IA32_AMDK5</a> = 0x0106
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224acb918071a7d03e0b39dd798e408c82f8">ISA_IA32_PentiumPro</a> = 0x0107
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a4735ba93e74f294c0e2ed9e432362da9">ISA_IA32_PentiumII</a> = 0x0108
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ab99535e938223b095cd6df917ea00ad9">ISA_IA32_Athlon</a> = 0x0109
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a6251c4f69c6d19f2739aff154d57b629">ISA_IA32_Pentium4</a> = 0x010a
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a9b2daa82a123dd0290ac1653490b51a0">ISA_IA32_PentiumM</a> = 0x010b
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224afdf251c7f6127b6db81f7c92d2b9eb3c">ISA_X8664_Family</a> = 0x0200
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a9b1b202966537a816490f1a716d24de2">ISA_X8664_Athlon64</a> = 0x0201
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a8efb5854e6b423cf7345a09b907e3863">ISA_X8664_Prescott</a> = 0x0202
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a244d01e48278d703a5d1104da5daedc2">ISA_X8664_IntelCore</a> = 0x0203
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a3d04c42794705ae7d9928c77ed1443dd">ISA_X8664_AMDPhenom</a> = 0x0204
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a7012f657c08fc65231436a5fe5dd02de">ISA_SPARC_Family</a> = 0x0300
, <br />
&#160;&#160;<b>ISA_SPARC_V7</b> = 0x0301
, <br />
&#160;&#160;<b>ISA_SPARC_V8</b> = 0x0302
, <br />
&#160;&#160;<b>ISA_SPARC_V8E</b> = 0x0303
, <br />
&#160;&#160;<b>ISA_SPARC_V9</b> = 0x0304
, <br />
&#160;&#160;<b>ISA_SPARC_V9JPS1</b> = 0x0305
, <br />
&#160;&#160;<b>ISA_SPARC_V9UA</b> = 0x0306
, <br />
&#160;&#160;<b>ISA_SPARC_V9JPS2</b> = 0x0307
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224aa27a09ce4d0787e9654bedb51339e5ec">ISA_M68K_Family</a> = 0x0400
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a23c2cde73e79fd5a0034cdd0208c769b">ISA_M68K_68000</a> = 0x0401
, <br />
&#160;&#160;<b>ISA_M68K_68EC000</b> = 0x0402
, <br />
&#160;&#160;<b>ISA_M68K_68HC000</b> = 0x0403
, <br />
&#160;&#160;<b>ISA_M68K_68008</b> = 0x0404
, <br />
&#160;&#160;<b>ISA_M68K_68010</b> = 0x0405
, <br />
&#160;&#160;<b>ISA_M68K_68012</b> = 0x0406
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a0bc097e9b25d0ece1b9778ca1c74288c">ISA_M68K_68020</a> = 0x0407
, <br />
&#160;&#160;<b>ISA_M68K_68EC020</b> = 0x0408
, <br />
&#160;&#160;<b>ISA_M68K_68030</b> = 0x0409
, <br />
&#160;&#160;<b>ISA_M68K_68EC030</b> = 0x040a
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a09bc9fd9205cb4fb42b057a42015c0af">ISA_M68K_68040</a> = 0x040b
, <br />
&#160;&#160;<b>ISA_M68K_68EC040</b> = 0x040c
, <br />
&#160;&#160;<b>ISA_M68K_68LC040</b> = 0x040d
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a943bf25d02eeed59637ee41c03d3e981">ISA_M68K_68060</a> = 0x040e
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a8b7980b5b6da3bf2ab8c348641db7979">ISA_M68K_ColdFire</a> = 0x040f
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a60ea65676579235866ad72d2c97242f9">ISA_M68K_DragonBall</a> = 0x0410
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a1bfafdcf8811cfcb8c1c7e0d126e2df9">ISA_M88K_Family</a> = 0x0500
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ae0825e0a943ea50f20e19961471b96f1">ISA_M88K_88100</a> = 0x0501
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ad56e60c122822d39d6bed00467f95775">ISA_M88K_88110</a> = 0x0502
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a1545869632c84c3077f20b83942b5d99">ISA_M88K_88110MP</a> = 0x0503
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a371ba80d44c14fadda289df5d638323a">ISA_M88K_88120</a> = 0x0504
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224af54d05d3e1cd44e300c8ba8f348f967d">ISA_MIPS_Family</a> = 0x0600
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224af4b18181eacc70b4efd0cafb4d597594">ISA_MIPS_MarkI</a> = 0x0601
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a5aa13caa288a436b88282068d7edf058">ISA_MIPS_MarkII</a> = 0x0602
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ae978454e991bb19a48b050cc1ad468ac">ISA_MIPS_MarkIII</a> = 0x0603
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a288b06cceb3c65ab8ae3ab66bd40acad">ISA_MIPS_R2000</a> = 0x0604
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ac263f7ba6538f3651c5f81bba3d8bbd6">ISA_MIPS_R3000</a> = 0x0605
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a87e6e460e635450045376788ffc2ab75">ISA_MIPS_R4000</a> = 0x0606
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a01f8d46b694465baa25eab3e837e9d17">ISA_MIPS_R4200</a> = 0x0607
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a93da7efff18c0810aaea1190ad9be6ce">ISA_MIPS_R4300</a> = 0x0608
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a5d78df7a0cece5cc912a4c0a0cee4921">ISA_MIPS_R4600</a> = 0x0609
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a605139c97c20c80282288b33dc297e59">ISA_MIPS_R4650</a> = 0x060a
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a3fd58eb7ad6c3b030a6e8407949e6fac">ISA_MIPS_R4700</a> = 0x060b
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a67deee2c6a831a27d1588697ec377552">ISA_MIPS_R5000</a> = 0x060c
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a75cc66fb834d54e12bc2bd5c9d1a89e5">ISA_MIPS_RM7000</a> = 0x060d
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a52c5c09df998ce2aff57e0062b4347c7">ISA_MIPS_R8000</a> = 0x060e
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a8823e012cf52f84fe57dd649cb82df46">ISA_MIPS_R10000</a> = 0x060f
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224af464e8559a97d8815a3e2f5f20bc661d">ISA_MIPS_R12000</a> = 0x0610
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a307e412e8153d2424335874085bea39c">ISA_MIPS_R14000</a> = 0x0611
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a2efdbf94de8e672f7224fc5125f93aac">ISA_MIPS_R16000</a> = 0x0612
, <br />
&#160;&#160;<b>ISA_MIPS_R16000A</b> = 0x0613
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a2c7fd1ea5620855be3c186a417c5cf88">ISA_MIPS_16</a> = 0x0614
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224abaa385d34311d94b6feeebc5901c884a">ISA_MIPS_FPU</a> = 0x0615
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a0191a9c5c803756e4de3629d092ab2da">ISA_MIPS_16FPU</a> = 0x0616
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224aa5f3a672178b377cf4363a74dd92f5ed">ISA_I860_Family</a> = 0x0700
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ae9d9dc085eedf933e8b939b62f2972a7">ISA_I860_860XR</a> = 0x0701
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a43bdd1267f7670e70e79d4aa77d2c8f9">ISA_I860_860XP</a> = 0x0702
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224af1d584b9a49272b787ba97ae20c1012e">ISA_IA64_Family</a> = 0x0800
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a798ab7f319483a6c768bb428a72d9285">ISA_IA64_Itanium</a> = 0x0801
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a86a0b1588ca9ae4bafda072942900c2c">ISA_IA64_Itanium2</a> = 0x0802
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a40290a2e66655c9bfc0e644efa4cd2eb">ISA_ARM_Family</a> = 0x0900
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a004ca507611b90b52a7194e299a78e95">ISA_ARM_ARM1</a> = 0x0901
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a9217f543d9799f7e64114ace2d9ee972">ISA_ARM_ARM2</a> = 0x0902
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ae3fd767265c2cfe6ea22934905fd79a3">ISA_ARM_ARM3</a> = 0x0903
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a8a50e8c7dfc4c5c7a355fd187a7754b7">ISA_ARM_ARM6</a> = 0x0904
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a1e3db5751c9e3640fc09effd7e918bd1">ISA_ARM_ARM7</a> = 0x0905
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ab1d1f83efc501432792799d90d785a48">ISA_ARM_ARM7TDMI</a> = 0x0906
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a1c145ca1bd2a67b3c25238f9b3e45adb">ISA_ARM_StrongARM</a> = 0x0907
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a4e06631cc81a1b17535a841346232b60">ISA_ARM_ARM8</a> = 0x0908
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224acc5e9a5d7f8b8b5ec86b233c8b5baa6f">ISA_ARM_ARM9TDMI</a> = 0x0909
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224ae6ccffca9d941145454c600a61083a02">ISA_ARM_ARM9E</a> = 0x090a
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a997af54ea90410ab60d5427c9b2f1e96">ISA_ARM_ARM10E</a> = 0x090b
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224acf81c9fc30b5d5b2aa0d2fe221adb42f">ISA_ARM_XScale</a> = 0x090c
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a652c9dfff0d6cf7af63e4826a94551d3">ISA_ARM_ARM11</a> = 0x090d
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a73035cc4285c74fc5be2ce28063ee66d">ISA_ARM_Cortex</a> = 0x090e
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a0b002d7d7b1cc9148012cbfe7ff3627f">ISA_ARM_A64</a> = 0x090f
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224a03dd867a5114692c4dcca3418fdfd47d">ISA_JVM</a> = 0x0a00
, <br />
&#160;&#160;<b>ISA_OTHER_Family</b> = 0xf000
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224afad799f53b1df66a98a140b445576d9e">ISA_ATT_WE_32100</a> = 0xf001
, <br />
&#160;&#160;<b>ISA_IBM_System_370</b> = 0xf002
, <br />
&#160;&#160;<b>ISA_HPPA</b> = 0xf003
, <br />
&#160;&#160;<b>ISA_Fujitsu_VPP500</b> = 0xf004
, <br />
&#160;&#160;<b>ISA_Sun_v8plus</b> = 0xf005
, <br />
&#160;&#160;<b>ISA_PowerPC</b> = 0xf006
, <br />
&#160;&#160;<b>ISA_PowerPC_64bit</b> = 0xf007
, <br />
&#160;&#160;<b>ISA_IBM_S390</b> = 0xf008
, <br />
&#160;&#160;<b>ISA_NEC_V800_series</b> = 0xf009
, <br />
&#160;&#160;<b>ISA_Fujitsu_FR20</b> = 0xf00a
, <br />
&#160;&#160;<b>ISA_TRW_RH_32</b> = 0xf00b
, <br />
&#160;&#160;<b>ISA_Motorola_RCE</b> = 0xf00c
, <br />
&#160;&#160;<b>ISA_Digital_Alpha_fake</b> = 0xf00e
, <br />
&#160;&#160;<b>ISA_Hitachi_SH</b> = 0xf00f
, <br />
&#160;&#160;<b>ISA_Siemens_Tricore</b> = 0xf010
, <br />
&#160;&#160;<b>ISA_Argonaut_RISC_Core</b> = 0xf011
, <br />
&#160;&#160;<b>ISA_Hitachi_H8_300</b> = 0xf012
, <br />
&#160;&#160;<b>ISA_Hitachi_H8_300H</b> = 0xf013
, <br />
&#160;&#160;<b>ISA_Hitachi_H8S</b> = 0xf014
, <br />
&#160;&#160;<b>ISA_Hitachi_H8_500</b> = 0xf015
, <br />
&#160;&#160;<b>ISA_Stanford_MIPS_X</b> = 0xf016
, <br />
&#160;&#160;<b>ISA_Motorola_M68HC12</b> = 0xf017
, <br />
&#160;&#160;<b>ISA_Fujitsu_MMA_Multimedia_Accelerator</b> =0xf018
, <br />
&#160;&#160;<b>ISA_Siemens_PCP</b> = 0xf019
, <br />
&#160;&#160;<b>ISA_Sony_nCPU_embeeded_RISC</b> = 0xf01a
, <br />
&#160;&#160;<b>ISA_Denso_NDR1_microprocessor</b> =0xf01b
, <br />
&#160;&#160;<b>ISA_Motorola_Start_Core_processor</b> =0xf01c
, <br />
&#160;&#160;<b>ISA_Toyota_ME16_processor</b> = 0xf01d
, <br />
&#160;&#160;<b>ISA_STMicroelectronic_ST100_processor</b> =0xf01e
, <br />
&#160;&#160;<b>ISA_Advanced_Logic_Corp_Tinyj_emb_family</b> =0xf01f
, <br />
&#160;&#160;<b>ISA_AMD_x86_64_architecture</b> = 0xf020
, <br />
&#160;&#160;<b>ISA_Sony_DSP_Processor</b> = 0xf021
, <br />
&#160;&#160;<b>ISA_Siemens_FX66_microcontroller</b> =0xf022
, <br />
&#160;&#160;<b>ISA_STMicroelectronics_ST9_plus_8_16_microcontroller</b> =0xf023
, <br />
&#160;&#160;<b>ISA_STMicroelectronics_ST7_8bit_microcontroller</b> =0xf024
, <br />
&#160;&#160;<b>ISA_Motorola_MC68HC16_microcontroller</b> =0xf025
, <br />
&#160;&#160;<b>ISA_Motorola_MC68HC11_microcontroller</b> =0xf026
, <br />
&#160;&#160;<b>ISA_Motorola_MC68HC08_microcontroller</b> =0xf027
, <br />
&#160;&#160;<b>ISA_Motorola_MC68HC05_microcontroller</b> =0xf028
, <br />
&#160;&#160;<b>ISA_Silicon_Graphics_SVx</b> = 0xf029
, <br />
&#160;&#160;<b>ISA_STMicroelectronics_ST19_8bit_microcontroller</b> =0xf02a
, <br />
&#160;&#160;<b>ISA_Digital_VAX</b> = 0xf02b
, <br />
&#160;&#160;<b>ISA_Axis_Communications_32bit_embedded_processor</b> =0xf02c
, <br />
&#160;&#160;<b>ISA_Infineon_Technologies_32bit_embedded_processor</b> =0xf02d
, <br />
&#160;&#160;<b>ISA_Element_14_64bit_DSP_Processor</b> =0xf02e
, <br />
&#160;&#160;<b>ISA_LSI_Logic_16bit_DSP_Processor</b> =0xf02f
, <br />
&#160;&#160;<b>ISA_Donald_Knuths_educational_64bit_processor</b> =0xf030
, <br />
&#160;&#160;<b>ISA_Harvard_University_machine_independent_object_files</b> =0xf031
, <br />
&#160;&#160;<b>ISA_SiTera_Prism</b> = 0xf032
, <br />
&#160;&#160;<b>ISA_Atmel_AVR_8bit_microcontroller</b> =0xf033
, <br />
&#160;&#160;<b>ISA_Fujitsu_FR30</b> = 0xf034
, <br />
&#160;&#160;<b>ISA_Mitsubishi_D10V</b> = 0xf035
, <br />
&#160;&#160;<b>ISA_Mitsubishi_D30V</b> = 0xf036
, <br />
&#160;&#160;<b>ISA_NEC_v850</b> = 0xf037
, <br />
&#160;&#160;<b>ISA_Mitsubishi_M32R</b> = 0xf038
, <br />
&#160;&#160;<b>ISA_Matsushita_MN10300</b> = 0xf039
, <br />
&#160;&#160;<b>ISA_Matsushita_MN10200</b> = 0xf03a
, <br />
&#160;&#160;<b>ISA_picoJava</b> = 0xf03b
, <br />
&#160;&#160;<b>ISA_OpenRISC_32bit_embedded_processor</b> =0xf03c
, <br />
&#160;&#160;<b>ISA_ARC_Cores_Tangent_A5</b> = 0xf03d
, <br />
&#160;&#160;<b>ISA_Tensilica_Xtensa_Architecture</b> =0xf03e
, <br />
&#160;&#160;<b>ISA_Digital_Alpha</b> = 0xf03f
, <br />
&#160;&#160;<b>ISA_Matsushita_AM33</b> = 0xf040
, <br />
&#160;&#160;<b>ISA_EFI_ByteCode</b> = 0xf041
<br />
 }</td></tr>
<tr class="memdesc:ae83545a0f1393e82be1225c168ba5224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction sets organized by families.  <a href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">More...</a><br /></td></tr>
<tr class="separator:ae83545a0f1393e82be1225c168ba5224 inherit pub_types_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fc70e134433bff16d86749ed5c732a inherit pub_types_classSgAsmExecutableFileFormat" id="r_a27fc70e134433bff16d86749ed5c732a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732a">ExecPurpose</a> { <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aa5292810546db875ee9dccbb6433616b2">PURPOSE_UNSPECIFIED</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aa50835893ece9f5d64638e16cad13b93f">PURPOSE_OTHER</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aa5cc69aef26eb1c6f0c09d2fe5d26bbec">PURPOSE_EXECUTABLE</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aad7e3c4a113111aaaa3e777fc34b8695d">PURPOSE_LIBRARY</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aa9f85bbaa9401438fd3dd8170f9767f33">PURPOSE_CORE_DUMP</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aa1d1fc525d73138992db143b7b9f96e2a">PURPOSE_OS_SPECIFIC</a>
, <br />
&#160;&#160;<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732aac21975ed7c05c154ac04acf20ffef745">PURPOSE_PROC_SPECIFIC</a>
<br />
 }</td></tr>
<tr class="memdesc:a27fc70e134433bff16d86749ed5c732a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose of a binary executable file.  <a href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732a">More...</a><br /></td></tr>
<tr class="separator:a27fc70e134433bff16d86749ed5c732a inherit pub_types_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e9c21a95121c9edd853af0d2fa811d inherit pub_types_classSgAsmExecutableFileFormat" id="r_a83e9c21a95121c9edd853af0d2fa811d"><td class="memItemLeft" align="right" valign="top">typedef struct stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a83e9c21a95121c9edd853af0d2fa811d">fileDetails</a></td></tr>
<tr class="memdesc:a83e9c21a95121c9edd853af0d2fa811d inherit pub_types_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the file in the filesystem.  <br /></td></tr>
<tr class="separator:a83e9c21a95121c9edd853af0d2fa811d inherit pub_types_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSgNode')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:a55d8b091c53268f6ce031fe0d04d0cb0 inherit pub_types_classSgNode" id="r_a55d8b091c53268f6ce031fe0d04d0cb0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>static_variant</b> = V_SgNode
 }</td></tr>
<tr class="memdesc:a55d8b091c53268f6ce031fe0d04d0cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">static variant value  <a href="classSgNode.html#a55d8b091c53268f6ce031fe0d04d0cb0">More...</a><br /></td></tr>
<tr class="separator:a55d8b091c53268f6ce031fe0d04d0cb0 inherit pub_types_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cc971c01289a0772880ed582af653f inherit pub_types_classSgNode" id="r_a36cc971c01289a0772880ed582af653f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>static_variant</b> = V_SgNode
 }</td></tr>
<tr class="memdesc:a36cc971c01289a0772880ed582af653f"><td class="mdescLeft">&#160;</td><td class="mdescRight">static variant value  <a href="classSgNode.html#a36cc971c01289a0772880ed582af653f">More...</a><br /></td></tr>
<tr class="separator:a36cc971c01289a0772880ed582af653f inherit pub_types_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab92996c6765d35e97ba032085548ae53" id="r_ab92996c6765d35e97ba032085548ae53"><td class="memItemLeft" align="right" valign="top"><a id="ab92996c6765d35e97ba032085548ae53" name="ab92996c6765d35e97ba032085548ae53"></a>
struct stat const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_sb</b> () const</td></tr>
<tr class="separator:ab92996c6765d35e97ba032085548ae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a3ff4d0d375f12ff4808da1dbb7f0d" id="r_ab7a3ff4d0d375f12ff4808da1dbb7f0d"><td class="memItemLeft" align="right" valign="top"><a id="ab7a3ff4d0d375f12ff4808da1dbb7f0d" name="ab7a3ff4d0d375f12ff4808da1dbb7f0d"></a>
<a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (std::string file_name)</td></tr>
<tr class="memdesc:ab7a3ff4d0d375f12ff4808da1dbb7f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads file contents into memory. <br /></td></tr>
<tr class="separator:ab7a3ff4d0d375f12ff4808da1dbb7f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac80d6d58329bef0b16742bebff5c8d" id="r_acac80d6d58329bef0b16742bebff5c8d"><td class="memItemLeft" align="right" valign="top"><a id="acac80d6d58329bef0b16742bebff5c8d" name="acac80d6d58329bef0b16742bebff5c8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reallocate</b> ()</td></tr>
<tr class="separator:acac80d6d58329bef0b16742bebff5c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76038fa98a5f4d96501e67de9e0cd1cb" id="r_a76038fa98a5f4d96501e67de9e0cd1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a76038fa98a5f4d96501e67de9e0cd1cb">unparse</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a76038fa98a5f4d96501e67de9e0cd1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirror image of parsing an executable file.  <br /></td></tr>
<tr class="separator:a76038fa98a5f4d96501e67de9e0cd1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469ed2b51ade57050d360d148db90c52" id="r_a469ed2b51ade57050d360d148db90c52"><td class="memItemLeft" align="right" valign="top"><a id="a469ed2b51ade57050d360d148db90c52" name="a469ed2b51ade57050d360d148db90c52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extendToEof</b> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a469ed2b51ade57050d360d148db90c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the output file by writing the last byte if it hasn't been written yet. <br /></td></tr>
<tr class="separator:a469ed2b51ade57050d360d148db90c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be2550dfa236c7568b43817fff210e6" id="r_a6be2550dfa236c7568b43817fff210e6"><td class="memItemLeft" align="right" valign="top"><a id="a6be2550dfa236c7568b43817fff210e6" name="a6be2550dfa236c7568b43817fff210e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (FILE *) const</td></tr>
<tr class="memdesc:a6be2550dfa236c7568b43817fff210e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print basic info about the sections of a file. <br /></td></tr>
<tr class="separator:a6be2550dfa236c7568b43817fff210e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6559122f82991a9e67cbaef2a0e81d14" id="r_a6559122f82991a9e67cbaef2a0e81d14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a6559122f82991a9e67cbaef2a0e81d14">dumpAll</a> (bool in_cwd=true, const char *ext=NULL)</td></tr>
<tr class="memdesc:a6559122f82991a9e67cbaef2a0e81d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print text file containing all known information about a binary file.  <br /></td></tr>
<tr class="separator:a6559122f82991a9e67cbaef2a0e81d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9615fd77720353c6730d9fbd632538" id="r_a1d9615fd77720353c6730d9fbd632538"><td class="memItemLeft" align="right" valign="top"><a id="a1d9615fd77720353c6730d9fbd632538" name="a1d9615fd77720353c6730d9fbd632538"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpAll</b> (const std::string &amp;dumpname)</td></tr>
<tr class="memdesc:a1d9615fd77720353c6730d9fbd632538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print text file containing all known information about a binary file. <br /></td></tr>
<tr class="separator:a1d9615fd77720353c6730d9fbd632538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5d032470e981ac779b7c58b77989f8" id="r_a8b5d032470e981ac779b7c58b77989f8"><td class="memItemLeft" align="right" valign="top"><a id="a8b5d032470e981ac779b7c58b77989f8" name="a8b5d032470e981ac779b7c58b77989f8"></a>
const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_unreferencedExtents</b> () const</td></tr>
<tr class="memdesc:a8b5d032470e981ac779b7c58b77989f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parts of the file that have never been referenced. <br /></td></tr>
<tr class="separator:a8b5d032470e981ac779b7c58b77989f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05855747809f3a77ee9ffa4f18499eeb" id="r_a05855747809f3a77ee9ffa4f18499eeb"><td class="memItemLeft" align="right" valign="top"><a id="a05855747809f3a77ee9ffa4f18499eeb" name="a05855747809f3a77ee9ffa4f18499eeb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>markReferencedExtent</b> (rose_addr_t start_rva, rose_addr_t size)</td></tr>
<tr class="memdesc:a05855747809f3a77ee9ffa4f18499eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks part of a file as having been referenced if tracking references. <br /></td></tr>
<tr class="separator:a05855747809f3a77ee9ffa4f18499eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e38b814dcd8322c4e2d7d69576ae73" id="r_a37e38b814dcd8322c4e2d7d69576ae73"><td class="memItemLeft" align="right" valign="top"><a id="a37e38b814dcd8322c4e2d7d69576ae73" name="a37e38b814dcd8322c4e2d7d69576ae73"></a>
rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_currentSize</b> () const</td></tr>
<tr class="memdesc:a37e38b814dcd8322c4e2d7d69576ae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current size of file based on section with highest ending address. <br /></td></tr>
<tr class="separator:a37e38b814dcd8322c4e2d7d69576ae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e98d61347aa86247f84ff5498accc2d" id="r_a1e98d61347aa86247f84ff5498accc2d"><td class="memItemLeft" align="right" valign="top"><a id="a1e98d61347aa86247f84ff5498accc2d" name="a1e98d61347aa86247f84ff5498accc2d"></a>
rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_originalSize</b> () const</td></tr>
<tr class="memdesc:a1e98d61347aa86247f84ff5498accc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns original size of file, based on file system. <br /></td></tr>
<tr class="separator:a1e98d61347aa86247f84ff5498accc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dba6143fa4c50272edea03b56bf8ee" id="r_a19dba6143fa4c50272edea03b56bf8ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a19dba6143fa4c50272edea03b56bf8ee">readContent</a> (rose_addr_t offset, void *dst_buf, rose_addr_t size, bool strict=true)</td></tr>
<tr class="memdesc:a19dba6143fa4c50272edea03b56bf8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a file.  <br /></td></tr>
<tr class="separator:a19dba6143fa4c50272edea03b56bf8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252f8814e2fe64cc3239b0e804997dbc" id="r_a252f8814e2fe64cc3239b0e804997dbc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a252f8814e2fe64cc3239b0e804997dbc">readContent</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;, rose_addr_t va, void *dst_buf, rose_addr_t size, bool strict=true)</td></tr>
<tr class="memdesc:a252f8814e2fe64cc3239b0e804997dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a file.  <br /></td></tr>
<tr class="separator:a252f8814e2fe64cc3239b0e804997dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2379f9b8d4fb276f799724bc22140c0" id="r_ac2379f9b8d4fb276f799724bc22140c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#ac2379f9b8d4fb276f799724bc22140c0">readContentString</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;, rose_addr_t va, bool strict=true)</td></tr>
<tr class="memdesc:ac2379f9b8d4fb276f799724bc22140c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from a file.  <br /></td></tr>
<tr class="separator:ac2379f9b8d4fb276f799724bc22140c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab040c5803ed38617694376851364b8b2" id="r_ab040c5803ed38617694376851364b8b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#ab040c5803ed38617694376851364b8b2">readContentString</a> (rose_addr_t abs_offset, bool strict=true)</td></tr>
<tr class="memdesc:ab040c5803ed38617694376851364b8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from a file.  <br /></td></tr>
<tr class="separator:ab040c5803ed38617694376851364b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde5f1c91419b93ebae83e10a9c2c02f" id="r_afde5f1c91419b93ebae83e10a9c2c02f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSgSharedVector.html">SgFileContentList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#afde5f1c91419b93ebae83e10a9c2c02f">content</a> ()</td></tr>
<tr class="memdesc:afde5f1c91419b93ebae83e10a9c2c02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Entire file contents.  <br /></td></tr>
<tr class="separator:afde5f1c91419b93ebae83e10a9c2c02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886919c377cb42bb88cf5c8a17085ba" id="r_a7886919c377cb42bb88cf5c8a17085ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgSharedVector.html">SgFileContentList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a7886919c377cb42bb88cf5c8a17085ba">content</a> (rose_addr_t offset, rose_addr_t size)</td></tr>
<tr class="memdesc:a7886919c377cb42bb88cf5c8a17085ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector that points to part of the file.  <br /></td></tr>
<tr class="separator:a7886919c377cb42bb88cf5c8a17085ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117fe311a5d178b43934ea7c75f6f360" id="r_a117fe311a5d178b43934ea7c75f6f360"><td class="memItemLeft" align="right" valign="top"><a id="a117fe311a5d178b43934ea7c75f6f360" name="a117fe311a5d178b43934ea7c75f6f360"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_mappedSections</b> () const</td></tr>
<tr class="memdesc:a117fe311a5d178b43934ea7c75f6f360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of all sections in the file that are memory mapped, including headers and holes. <br /></td></tr>
<tr class="separator:a117fe311a5d178b43934ea7c75f6f360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f516df9fd944e502724b4158563f06a" id="r_a9f516df9fd944e502724b4158563f06a"><td class="memItemLeft" align="right" valign="top"><a id="a9f516df9fd944e502724b4158563f06a" name="a9f516df9fd944e502724b4158563f06a"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections</b> (bool include_holes=true) const</td></tr>
<tr class="memdesc:a9f516df9fd944e502724b4158563f06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of all sections in the file (including headers, holes, etc). <br /></td></tr>
<tr class="separator:a9f516df9fd944e502724b4158563f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d75ba965bf4f41915c7de80016737" id="r_a091d75ba965bf4f41915c7de80016737"><td class="memItemLeft" align="right" valign="top"><a id="a091d75ba965bf4f41915c7de80016737" name="a091d75ba965bf4f41915c7de80016737"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sectionsById</b> (int id) const</td></tr>
<tr class="memdesc:a091d75ba965bf4f41915c7de80016737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sections having specified ID across all headers, including headers and holes. <br /></td></tr>
<tr class="separator:a091d75ba965bf4f41915c7de80016737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3210e4bf2a776bd660d2fafed3774c" id="r_a3f3210e4bf2a776bd660d2fafed3774c"><td class="memItemLeft" align="right" valign="top"><a id="a3f3210e4bf2a776bd660d2fafed3774c" name="a3f3210e4bf2a776bd660d2fafed3774c"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sectionsByName</b> (std::string, char sep='\0') const</td></tr>
<tr class="memdesc:a3f3210e4bf2a776bd660d2fafed3774c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all sections having specified name across all headers, including headers and holes. <br /></td></tr>
<tr class="separator:a3f3210e4bf2a776bd660d2fafed3774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdf8ef66f15bc944b97180903a65ad0" id="r_abfdf8ef66f15bc944b97180903a65ad0"><td class="memItemLeft" align="right" valign="top">SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#abfdf8ef66f15bc944b97180903a65ad0">get_sectionsByOffset</a> (rose_addr_t offset, rose_addr_t size) const</td></tr>
<tr class="memdesc:abfdf8ef66f15bc944b97180903a65ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find sections by their offset.  <br /></td></tr>
<tr class="separator:abfdf8ef66f15bc944b97180903a65ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40404103a545c1b130be6e14eb047039" id="r_a40404103a545c1b130be6e14eb047039"><td class="memItemLeft" align="right" valign="top">SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a40404103a545c1b130be6e14eb047039">get_sectionsByRva</a> (rose_addr_t rva) const</td></tr>
<tr class="memdesc:a40404103a545c1b130be6e14eb047039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find sections by address.  <br /></td></tr>
<tr class="separator:a40404103a545c1b130be6e14eb047039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46017e4d4b908a0f15cb946aa97d56e" id="r_af46017e4d4b908a0f15cb946aa97d56e"><td class="memItemLeft" align="right" valign="top">SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#af46017e4d4b908a0f15cb946aa97d56e">get_sectionsByVa</a> (rose_addr_t va) const</td></tr>
<tr class="memdesc:af46017e4d4b908a0f15cb946aa97d56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find sections by address.  <br /></td></tr>
<tr class="separator:af46017e4d4b908a0f15cb946aa97d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b7870ced16eb1c8428138fd9251731" id="r_aa4b7870ced16eb1c8428138fd9251731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#aa4b7870ced16eb1c8428138fd9251731">get_sectionById</a> (int id, size_t *nfound=0) const</td></tr>
<tr class="memdesc:aa4b7870ced16eb1c8428138fd9251731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section with specified ID.  <br /></td></tr>
<tr class="separator:aa4b7870ced16eb1c8428138fd9251731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfc09503c7e77aa3c0b5390ebf3a0dc" id="r_abdfc09503c7e77aa3c0b5390ebf3a0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#abdfc09503c7e77aa3c0b5390ebf3a0dc">get_sectionByName</a> (const std::string &amp;, char sep=0, size_t *nfound=0) const</td></tr>
<tr class="memdesc:abdfc09503c7e77aa3c0b5390ebf3a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section by name.  <br /></td></tr>
<tr class="separator:abdfc09503c7e77aa3c0b5390ebf3a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3237f487efa29c859f883a54a60f9ff6" id="r_a3237f487efa29c859f883a54a60f9ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a3237f487efa29c859f883a54a60f9ff6">get_sectionByOffset</a> (rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const</td></tr>
<tr class="memdesc:a3237f487efa29c859f883a54a60f9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section by file offset.  <br /></td></tr>
<tr class="separator:a3237f487efa29c859f883a54a60f9ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e30b67244bc4726b7da0e16be52af1" id="r_a44e30b67244bc4726b7da0e16be52af1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a44e30b67244bc4726b7da0e16be52af1">get_sectionByRva</a> (rose_addr_t rva, size_t *nfound=0) const</td></tr>
<tr class="memdesc:a44e30b67244bc4726b7da0e16be52af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section by address.  <br /></td></tr>
<tr class="separator:a44e30b67244bc4726b7da0e16be52af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c23913477cf2a8d4a644ecd615d8c" id="r_a951c23913477cf2a8d4a644ecd615d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a951c23913477cf2a8d4a644ecd615d8c">get_sectionByVa</a> (rose_addr_t va, size_t *nfound=0) const</td></tr>
<tr class="memdesc:a951c23913477cf2a8d4a644ecd615d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section by address.  <br /></td></tr>
<tr class="separator:a951c23913477cf2a8d4a644ecd615d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d262168c4fb85e97984fd72a61e4a5" id="r_a32d262168c4fb85e97984fd72a61e4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a32d262168c4fb85e97984fd72a61e4a5">get_bestSectionByVa</a> (rose_addr_t va, size_t *nfound=0) const</td></tr>
<tr class="memdesc:a32d262168c4fb85e97984fd72a61e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find section by address.  <br /></td></tr>
<tr class="separator:a32d262168c4fb85e97984fd72a61e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820c9f8bc6c6c8a422240104faa275be" id="r_a820c9f8bc6c6c8a422240104faa275be"><td class="memItemLeft" align="right" valign="top">rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a820c9f8bc6c6c8a422240104faa275be">get_nextSectionOffset</a> (rose_addr_t offset)</td></tr>
<tr class="memdesc:a820c9f8bc6c6c8a422240104faa275be"><td class="mdescLeft">&#160;</td><td class="mdescRight">File offset of next section.  <br /></td></tr>
<tr class="separator:a820c9f8bc6c6c8a422240104faa275be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19af530ae4e1701f18171eec1c761ee2" id="r_a19af530ae4e1701f18171eec1c761ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a19af530ae4e1701f18171eec1c761ee2">addHole</a> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *)</td></tr>
<tr class="memdesc:a19af530ae4e1701f18171eec1c761ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new hole to the file.  <br /></td></tr>
<tr class="separator:a19af530ae4e1701f18171eec1c761ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d3e9edc3e472e3c28ac7765d386d0" id="r_ac84d3e9edc3e472e3c28ac7765d386d0"><td class="memItemLeft" align="right" valign="top"><a id="ac84d3e9edc3e472e3c28ac7765d386d0" name="ac84d3e9edc3e472e3c28ac7765d386d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeHole</b> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *)</td></tr>
<tr class="memdesc:ac84d3e9edc3e472e3c28ac7765d386d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a hole from the list of holes in a file. <br /></td></tr>
<tr class="separator:ac84d3e9edc3e472e3c28ac7765d386d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eae5f0d37b7869a92c629b1f8a1aa9" id="r_a47eae5f0d37b7869a92c629b1f8a1aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a47eae5f0d37b7869a92c629b1f8a1aa9">fillHoles</a> ()</td></tr>
<tr class="memdesc:a47eae5f0d37b7869a92c629b1f8a1aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find holes in file and create sections to fill them.  <br /></td></tr>
<tr class="separator:a47eae5f0d37b7869a92c629b1f8a1aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3754c110e34d4af0c975c3536ee6a2" id="r_abe3754c110e34d4af0c975c3536ee6a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#abe3754c110e34d4af0c975c3536ee6a2">unfillHoles</a> ()</td></tr>
<tr class="memdesc:abe3754c110e34d4af0c975c3536ee6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes "hole" sections.  <br /></td></tr>
<tr class="separator:abe3754c110e34d4af0c975c3536ee6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5128083f0085f16312365c56faef78" id="r_a4e5128083f0085f16312365c56faef78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a4e5128083f0085f16312365c56faef78">addHeader</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="memdesc:a4e5128083f0085f16312365c56faef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new header to the file.  <br /></td></tr>
<tr class="separator:a4e5128083f0085f16312365c56faef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca66e5e9668e85c8c25370c12b7afb3" id="r_adca66e5e9668e85c8c25370c12b7afb3"><td class="memItemLeft" align="right" valign="top"><a id="adca66e5e9668e85c8c25370c12b7afb3" name="adca66e5e9668e85c8c25370c12b7afb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeHeader</b> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="memdesc:adca66e5e9668e85c8c25370c12b7afb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a header from the header list in a file. <br /></td></tr>
<tr class="separator:adca66e5e9668e85c8c25370c12b7afb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84a26d3f71091ae81f15d0f1451ebe9" id="r_ac84a26d3f71091ae81f15d0f1451ebe9"><td class="memItemLeft" align="right" valign="top"><a id="ac84a26d3f71091ae81f15d0f1451ebe9" name="ac84a26d3f71091ae81f15d0f1451ebe9"></a>
<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_header</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65d">SgAsmExecutableFileFormat::ExecFamily</a>)</td></tr>
<tr class="memdesc:ac84a26d3f71091ae81f15d0f1451ebe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the header for the specified format. <br /></td></tr>
<tr class="separator:ac84a26d3f71091ae81f15d0f1451ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411753a548cee3d6d5bee20dd4f73507" id="r_a411753a548cee3d6d5bee20dd4f73507"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a411753a548cee3d6d5bee20dd4f73507">formatName</a> () const</td></tr>
<tr class="memdesc:a411753a548cee3d6d5bee20dd4f73507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing the file format.  <br /></td></tr>
<tr class="separator:a411753a548cee3d6d5bee20dd4f73507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae988ce15aae53114dfd4c2dab4ee2ae3" id="r_ae988ce15aae53114dfd4c2dab4ee2ae3"><td class="memItemLeft" align="right" valign="top"><a id="ae988ce15aae53114dfd4c2dab4ee2ae3" name="ae988ce15aae53114dfd4c2dab4ee2ae3"></a>
<a class="el" href="classSgAsmDwarfCompilationUnitList.html">SgAsmDwarfCompilationUnitList</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwarf_info</b> () const</td></tr>
<tr class="separator:ae988ce15aae53114dfd4c2dab4ee2ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b6af3d1b04e4eb0e99d936cf947e3a" id="r_a49b6af3d1b04e4eb0e99d936cf947e3a"><td class="memItemLeft" align="right" valign="top"><a id="a49b6af3d1b04e4eb0e99d936cf947e3a" name="a49b6af3d1b04e4eb0e99d936cf947e3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dwarf_info</b> (<a class="el" href="classSgAsmDwarfCompilationUnitList.html">SgAsmDwarfCompilationUnitList</a> *)</td></tr>
<tr class="separator:a49b6af3d1b04e4eb0e99d936cf947e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d28a3da42112c6662a6091ee49fd20" id="r_af8d28a3da42112c6662a6091ee49fd20"><td class="memItemLeft" align="right" valign="top"><a id="af8d28a3da42112c6662a6091ee49fd20" name="af8d28a3da42112c6662a6091ee49fd20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_truncate_zeros</b> () const</td></tr>
<tr class="separator:af8d28a3da42112c6662a6091ee49fd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2133de91e38d5d409377a3b673220a99" id="r_a2133de91e38d5d409377a3b673220a99"><td class="memItemLeft" align="right" valign="top"><a id="a2133de91e38d5d409377a3b673220a99" name="a2133de91e38d5d409377a3b673220a99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_truncate_zeros</b> (bool)</td></tr>
<tr class="separator:a2133de91e38d5d409377a3b673220a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7a9f2ea57d47b2d56715abe44e9c0" id="r_a09c7a9f2ea57d47b2d56715abe44e9c0"><td class="memItemLeft" align="right" valign="top"><a id="a09c7a9f2ea57d47b2d56715abe44e9c0" name="a09c7a9f2ea57d47b2d56715abe44e9c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_tracking_references</b> () const</td></tr>
<tr class="separator:a09c7a9f2ea57d47b2d56715abe44e9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda406f9007dd89ed167a3eddc6638f0" id="r_adda406f9007dd89ed167a3eddc6638f0"><td class="memItemLeft" align="right" valign="top"><a id="adda406f9007dd89ed167a3eddc6638f0" name="adda406f9007dd89ed167a3eddc6638f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_tracking_references</b> (bool)</td></tr>
<tr class="separator:adda406f9007dd89ed167a3eddc6638f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf6685fbeecfcf7cd531b8d74a26c4e" id="r_aacf6685fbeecfcf7cd531b8d74a26c4e"><td class="memItemLeft" align="right" valign="top"><a id="aacf6685fbeecfcf7cd531b8d74a26c4e" name="aacf6685fbeecfcf7cd531b8d74a26c4e"></a>
const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_referenced_extents</b> () const</td></tr>
<tr class="separator:aacf6685fbeecfcf7cd531b8d74a26c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ddacdc8a0da4843b9102419590edbe" id="r_a97ddacdc8a0da4843b9102419590edbe"><td class="memItemLeft" align="right" valign="top"><a id="a97ddacdc8a0da4843b9102419590edbe" name="a97ddacdc8a0da4843b9102419590edbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_referenced_extents</b> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> &amp;)</td></tr>
<tr class="separator:a97ddacdc8a0da4843b9102419590edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdd74b49abbf2174b2d497a8fffb037" id="r_a2bdd74b49abbf2174b2d497a8fffb037"><td class="memItemLeft" align="right" valign="top"><a id="a2bdd74b49abbf2174b2d497a8fffb037" name="a2bdd74b49abbf2174b2d497a8fffb037"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extend_to_eof</b> (std::ostream &amp;) const</td></tr>
<tr class="separator:a2bdd74b49abbf2174b2d497a8fffb037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83ccea94a9dcb599c603a968378562f" id="r_ac83ccea94a9dcb599c603a968378562f"><td class="memItemLeft" align="right" valign="top"><a id="ac83ccea94a9dcb599c603a968378562f" name="ac83ccea94a9dcb599c603a968378562f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_all</b> (bool in_cwd=true, const char *ext=NULL)</td></tr>
<tr class="separator:ac83ccea94a9dcb599c603a968378562f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f0d00625222207aa5cd729a2c6813d" id="r_ab1f0d00625222207aa5cd729a2c6813d"><td class="memItemLeft" align="right" valign="top"><a id="ab1f0d00625222207aa5cd729a2c6813d" name="ab1f0d00625222207aa5cd729a2c6813d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_all</b> (const std::string &amp;dumpname)</td></tr>
<tr class="separator:ab1f0d00625222207aa5cd729a2c6813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e8fa00627beae4c57a9d474d45814" id="r_a5d7e8fa00627beae4c57a9d474d45814"><td class="memItemLeft" align="right" valign="top"><a id="a5d7e8fa00627beae4c57a9d474d45814" name="a5d7e8fa00627beae4c57a9d474d45814"></a>
const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_unreferenced_extents</b> () const</td></tr>
<tr class="separator:a5d7e8fa00627beae4c57a9d474d45814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bd6eaf1f42ffc0330de01b56349282" id="r_a69bd6eaf1f42ffc0330de01b56349282"><td class="memItemLeft" align="right" valign="top"><a id="a69bd6eaf1f42ffc0330de01b56349282" name="a69bd6eaf1f42ffc0330de01b56349282"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_referenced_extent</b> (rose_addr_t, rose_addr_t)</td></tr>
<tr class="separator:a69bd6eaf1f42ffc0330de01b56349282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca6d033f7cf4ebbb6ddd86a0bdb2830" id="r_adca6d033f7cf4ebbb6ddd86a0bdb2830"><td class="memItemLeft" align="right" valign="top"><a id="adca6d033f7cf4ebbb6ddd86a0bdb2830" name="adca6d033f7cf4ebbb6ddd86a0bdb2830"></a>
<a class="el" href="classDataConverter.html">DataConverter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_data_converter</b> () const</td></tr>
<tr class="separator:adca6d033f7cf4ebbb6ddd86a0bdb2830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f850b83b1b9aad4547a055f39c3f5a" id="r_ad5f850b83b1b9aad4547a055f39c3f5a"><td class="memItemLeft" align="right" valign="top"><a id="ad5f850b83b1b9aad4547a055f39c3f5a" name="ad5f850b83b1b9aad4547a055f39c3f5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_converter</b> (<a class="el" href="classDataConverter.html">DataConverter</a> *)</td></tr>
<tr class="separator:ad5f850b83b1b9aad4547a055f39c3f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da813db35eb44c1a2df428a3660549a" id="r_a4da813db35eb44c1a2df428a3660549a"><td class="memItemLeft" align="right" valign="top"><a id="a4da813db35eb44c1a2df428a3660549a" name="a4da813db35eb44c1a2df428a3660549a"></a>
rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_size</b> () const</td></tr>
<tr class="separator:a4da813db35eb44c1a2df428a3660549a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39029d7671187f74e37ade84f7a01b8" id="r_af39029d7671187f74e37ade84f7a01b8"><td class="memItemLeft" align="right" valign="top"><a id="af39029d7671187f74e37ade84f7a01b8" name="af39029d7671187f74e37ade84f7a01b8"></a>
rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_orig_size</b> () const</td></tr>
<tr class="separator:af39029d7671187f74e37ade84f7a01b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f80d4c4e2f782ed7a48aad1118816ce" id="r_a7f80d4c4e2f782ed7a48aad1118816ce"><td class="memItemLeft" align="right" valign="top"><a id="a7f80d4c4e2f782ed7a48aad1118816ce" name="a7f80d4c4e2f782ed7a48aad1118816ce"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_content</b> (rose_addr_t, void *, rose_addr_t, bool=true)</td></tr>
<tr class="separator:a7f80d4c4e2f782ed7a48aad1118816ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6828e1674de4a24a77688be4d3feb0c" id="r_af6828e1674de4a24a77688be4d3feb0c"><td class="memItemLeft" align="right" valign="top"><a id="af6828e1674de4a24a77688be4d3feb0c" name="af6828e1674de4a24a77688be4d3feb0c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_content</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;, rose_addr_t, void *, rose_addr_t, bool=true)</td></tr>
<tr class="separator:af6828e1674de4a24a77688be4d3feb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc95b3ea8fb9b85903bba9015a04f9e" id="r_afbc95b3ea8fb9b85903bba9015a04f9e"><td class="memItemLeft" align="right" valign="top"><a id="afbc95b3ea8fb9b85903bba9015a04f9e" name="afbc95b3ea8fb9b85903bba9015a04f9e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>read_content_str</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;, rose_addr_t, bool=true)</td></tr>
<tr class="separator:afbc95b3ea8fb9b85903bba9015a04f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c06583554e1be30e447cd3e08871fa" id="r_ac3c06583554e1be30e447cd3e08871fa"><td class="memItemLeft" align="right" valign="top"><a id="ac3c06583554e1be30e447cd3e08871fa" name="ac3c06583554e1be30e447cd3e08871fa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>read_content_str</b> (rose_addr_t, bool=true)</td></tr>
<tr class="separator:ac3c06583554e1be30e447cd3e08871fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6051c3bc3fb162cf1236aab60fdd4476" id="r_a6051c3bc3fb162cf1236aab60fdd4476"><td class="memItemLeft" align="right" valign="top"><a id="a6051c3bc3fb162cf1236aab60fdd4476" name="a6051c3bc3fb162cf1236aab60fdd4476"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_mapped_sections</b> () const</td></tr>
<tr class="separator:a6051c3bc3fb162cf1236aab60fdd4476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54874ddaaf0a2ad7bdb515ebdb069c2d" id="r_a54874ddaaf0a2ad7bdb515ebdb069c2d"><td class="memItemLeft" align="right" valign="top"><a id="a54874ddaaf0a2ad7bdb515ebdb069c2d" name="a54874ddaaf0a2ad7bdb515ebdb069c2d"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections_by_id</b> (int id) const</td></tr>
<tr class="separator:a54874ddaaf0a2ad7bdb515ebdb069c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53065a9c27ab705bafe5d18c755f069" id="r_ac53065a9c27ab705bafe5d18c755f069"><td class="memItemLeft" align="right" valign="top"><a id="ac53065a9c27ab705bafe5d18c755f069" name="ac53065a9c27ab705bafe5d18c755f069"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections_by_name</b> (std::string, char='\0') const</td></tr>
<tr class="separator:ac53065a9c27ab705bafe5d18c755f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e5d17da9a3ddf62fb28a17e0f3d253" id="r_ab9e5d17da9a3ddf62fb28a17e0f3d253"><td class="memItemLeft" align="right" valign="top"><a id="ab9e5d17da9a3ddf62fb28a17e0f3d253" name="ab9e5d17da9a3ddf62fb28a17e0f3d253"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections_by_offset</b> (rose_addr_t, rose_addr_t) const</td></tr>
<tr class="separator:ab9e5d17da9a3ddf62fb28a17e0f3d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dec1739fd3cd340332bcc32812ac7c" id="r_a26dec1739fd3cd340332bcc32812ac7c"><td class="memItemLeft" align="right" valign="top"><a id="a26dec1739fd3cd340332bcc32812ac7c" name="a26dec1739fd3cd340332bcc32812ac7c"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections_by_rva</b> (rose_addr_t) const</td></tr>
<tr class="separator:a26dec1739fd3cd340332bcc32812ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84645ade28de54c2d628a83f1e52c84f" id="r_a84645ade28de54c2d628a83f1e52c84f"><td class="memItemLeft" align="right" valign="top"><a id="a84645ade28de54c2d628a83f1e52c84f" name="a84645ade28de54c2d628a83f1e52c84f"></a>
SgAsmGenericSectionPtrList&#160;</td><td class="memItemRight" valign="bottom"><b>get_sections_by_va</b> (rose_addr_t) const</td></tr>
<tr class="separator:a84645ade28de54c2d628a83f1e52c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed7055b87cab60815d9f454c87530ef" id="r_a4ed7055b87cab60815d9f454c87530ef"><td class="memItemLeft" align="right" valign="top"><a id="a4ed7055b87cab60815d9f454c87530ef" name="a4ed7055b87cab60815d9f454c87530ef"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_section_by_id</b> (int, size_t *=nullptr) const</td></tr>
<tr class="separator:a4ed7055b87cab60815d9f454c87530ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caa1656b36fad3bebe26a49998c8644" id="r_a9caa1656b36fad3bebe26a49998c8644"><td class="memItemLeft" align="right" valign="top"><a id="a9caa1656b36fad3bebe26a49998c8644" name="a9caa1656b36fad3bebe26a49998c8644"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_section_by_name</b> (const std::string &amp;, char=0, size_t *=nullptr) const</td></tr>
<tr class="separator:a9caa1656b36fad3bebe26a49998c8644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717abffeb51b5e3052fe624a9ef515bd" id="r_a717abffeb51b5e3052fe624a9ef515bd"><td class="memItemLeft" align="right" valign="top"><a id="a717abffeb51b5e3052fe624a9ef515bd" name="a717abffeb51b5e3052fe624a9ef515bd"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_section_by_offset</b> (rose_addr_t, rose_addr_t, size_t *=nullptr) const</td></tr>
<tr class="separator:a717abffeb51b5e3052fe624a9ef515bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454ae964cedf9a029c29f34b27a57ca1" id="r_a454ae964cedf9a029c29f34b27a57ca1"><td class="memItemLeft" align="right" valign="top"><a id="a454ae964cedf9a029c29f34b27a57ca1" name="a454ae964cedf9a029c29f34b27a57ca1"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_section_by_rva</b> (rose_addr_t, size_t *=nullptr) const</td></tr>
<tr class="separator:a454ae964cedf9a029c29f34b27a57ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b81e931a60a9ab49bf7a1172d40a2" id="r_a078b81e931a60a9ab49bf7a1172d40a2"><td class="memItemLeft" align="right" valign="top"><a id="a078b81e931a60a9ab49bf7a1172d40a2" name="a078b81e931a60a9ab49bf7a1172d40a2"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_section_by_va</b> (rose_addr_t, size_t *=nullptr) const</td></tr>
<tr class="separator:a078b81e931a60a9ab49bf7a1172d40a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac096fbeaf3864adab7e55edb53110fb1" id="r_ac096fbeaf3864adab7e55edb53110fb1"><td class="memItemLeft" align="right" valign="top"><a id="ac096fbeaf3864adab7e55edb53110fb1" name="ac096fbeaf3864adab7e55edb53110fb1"></a>
<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_best_section_by_va</b> (rose_addr_t, size_t *=nullptr) const</td></tr>
<tr class="separator:ac096fbeaf3864adab7e55edb53110fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460ee7f00f4b7948ff31b68f1782e02" id="r_a7460ee7f00f4b7948ff31b68f1782e02"><td class="memItemLeft" align="right" valign="top"><a id="a7460ee7f00f4b7948ff31b68f1782e02" name="a7460ee7f00f4b7948ff31b68f1782e02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shift_extend</b> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *, rose_addr_t, rose_addr_t, <a class="el" href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">AddressSpace</a>, <a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">Elasticity</a>)</td></tr>
<tr class="separator:a7460ee7f00f4b7948ff31b68f1782e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d58050408e05bc9637a7158a070ce78" id="r_a6d58050408e05bc9637a7158a070ce78"><td class="memItemLeft" align="right" valign="top"><a id="a6d58050408e05bc9637a7158a070ce78" name="a6d58050408e05bc9637a7158a070ce78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shift_extend</b> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *, rose_addr_t, rose_addr_t)</td></tr>
<tr class="separator:a6d58050408e05bc9637a7158a070ce78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2602fe6a04b1aeb84e66890df9ee5" id="r_a66e2602fe6a04b1aeb84e66890df9ee5"><td class="memItemLeft" align="right" valign="top"><a id="a66e2602fe6a04b1aeb84e66890df9ee5" name="a66e2602fe6a04b1aeb84e66890df9ee5"></a>
rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_next_section_offset</b> (rose_addr_t)</td></tr>
<tr class="separator:a66e2602fe6a04b1aeb84e66890df9ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a159d280355340006e3ab6d6c5da9d" id="r_a16a159d280355340006e3ab6d6c5da9d"><td class="memItemLeft" align="right" valign="top"><a id="a16a159d280355340006e3ab6d6c5da9d" name="a16a159d280355340006e3ab6d6c5da9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_hole</b> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *)</td></tr>
<tr class="separator:a16a159d280355340006e3ab6d6c5da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33a19d17346da1629b9b9c5e7f9bcf" id="r_acb33a19d17346da1629b9b9c5e7f9bcf"><td class="memItemLeft" align="right" valign="top"><a id="acb33a19d17346da1629b9b9c5e7f9bcf" name="acb33a19d17346da1629b9b9c5e7f9bcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_hole</b> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *)</td></tr>
<tr class="separator:acb33a19d17346da1629b9b9c5e7f9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524370d0f037c862921248ac65bcbf5" id="r_ab524370d0f037c862921248ac65bcbf5"><td class="memItemLeft" align="right" valign="top"><a id="ab524370d0f037c862921248ac65bcbf5" name="ab524370d0f037c862921248ac65bcbf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_holes</b> ()</td></tr>
<tr class="separator:ab524370d0f037c862921248ac65bcbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc522a3cb0f5409f11694218dbdf6d5f" id="r_abc522a3cb0f5409f11694218dbdf6d5f"><td class="memItemLeft" align="right" valign="top"><a id="abc522a3cb0f5409f11694218dbdf6d5f" name="abc522a3cb0f5409f11694218dbdf6d5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unfill_holes</b> ()</td></tr>
<tr class="separator:abc522a3cb0f5409f11694218dbdf6d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e2ab575e1fb3ca0f89529ec1213437" id="r_a48e2ab575e1fb3ca0f89529ec1213437"><td class="memItemLeft" align="right" valign="top"><a id="a48e2ab575e1fb3ca0f89529ec1213437" name="a48e2ab575e1fb3ca0f89529ec1213437"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_header</b> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="separator:a48e2ab575e1fb3ca0f89529ec1213437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755e8a7fdf30799ef3b01c22d3b3db6" id="r_ad755e8a7fdf30799ef3b01c22d3b3db6"><td class="memItemLeft" align="right" valign="top"><a id="ad755e8a7fdf30799ef3b01c22d3b3db6" name="ad755e8a7fdf30799ef3b01c22d3b3db6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove_header</b> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>
<tr class="separator:ad755e8a7fdf30799ef3b01c22d3b3db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18adbcd2b159de6b1f236a42b83c896" id="r_ac18adbcd2b159de6b1f236a42b83c896"><td class="memItemLeft" align="right" valign="top"><a id="ac18adbcd2b159de6b1f236a42b83c896" name="ac18adbcd2b159de6b1f236a42b83c896"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>format_name</b> () const</td></tr>
<tr class="separator:ac18adbcd2b159de6b1f236a42b83c896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8051da9c3c4b96991317f422a2f194" id="r_a8a8051da9c3c4b96991317f422a2f194"><td class="memItemLeft" align="right" valign="top"><a id="a8a8051da9c3c4b96991317f422a2f194" name="a8a8051da9c3c4b96991317f422a2f194"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SgAsmGenericFile</b> ()</td></tr>
<tr class="memdesc:a8a8051da9c3c4b96991317f422a2f194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8a8051da9c3c4b96991317f422a2f194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0872e897f30d7955354ebaa7e316f8" id="r_aab0872e897f30d7955354ebaa7e316f8"><td class="memItemLeft" align="right" valign="top"><a id="aab0872e897f30d7955354ebaa7e316f8" name="aab0872e897f30d7955354ebaa7e316f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SgAsmGenericFile</b> ()</td></tr>
<tr class="memdesc:aab0872e897f30d7955354ebaa7e316f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aab0872e897f30d7955354ebaa7e316f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a46fa09ed9c4ff8d0d70ea7d410cf9f95" id="r_a46fa09ed9c4ff8d0d70ea7d410cf9f95"><td class="memItemLeft" align="right" valign="top"><a id="a46fa09ed9c4ff8d0d70ea7d410cf9f95" name="a46fa09ed9c4ff8d0d70ea7d410cf9f95"></a>
<a class="el" href="classSgAsmDwarfCompilationUnitList.html">SgAsmDwarfCompilationUnitList</a> *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwarfInfo</b> () const</td></tr>
<tr class="memdesc:a46fa09ed9c4ff8d0d70ea7d410cf9f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: DWARF debugging hiearchy. <br /></td></tr>
<tr class="separator:a46fa09ed9c4ff8d0d70ea7d410cf9f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f334c131f854781a7af09c4acef267" id="r_aa0f334c131f854781a7af09c4acef267"><td class="memItemLeft" align="right" valign="top"><a id="aa0f334c131f854781a7af09c4acef267" name="aa0f334c131f854781a7af09c4acef267"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dwarfInfo</b> (<a class="el" href="classSgAsmDwarfCompilationUnitList.html">SgAsmDwarfCompilationUnitList</a> *const &amp;)</td></tr>
<tr class="memdesc:aa0f334c131f854781a7af09c4acef267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: DWARF debugging hiearchy. <br /></td></tr>
<tr class="separator:aa0f334c131f854781a7af09c4acef267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1f853b9781b345a2df61a1c900674d9" id="r_ae1f853b9781b345a2df61a1c900674d9"><td class="memItemLeft" align="right" valign="top"><a id="ae1f853b9781b345a2df61a1c900674d9" name="ae1f853b9781b345a2df61a1c900674d9"></a>
std::string const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_name</b> () const</td></tr>
<tr class="memdesc:ae1f853b9781b345a2df61a1c900674d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name of file. <br /></td></tr>
<tr class="separator:ae1f853b9781b345a2df61a1c900674d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab423b50815b4585be71b0fcfd5cb37" id="r_acab423b50815b4585be71b0fcfd5cb37"><td class="memItemLeft" align="right" valign="top"><a id="acab423b50815b4585be71b0fcfd5cb37" name="acab423b50815b4585be71b0fcfd5cb37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_name</b> (std::string const &amp;)</td></tr>
<tr class="memdesc:acab423b50815b4585be71b0fcfd5cb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Name of file. <br /></td></tr>
<tr class="separator:acab423b50815b4585be71b0fcfd5cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a72172f73132bd0eff84e43996b342404" id="r_a72172f73132bd0eff84e43996b342404"><td class="memItemLeft" align="right" valign="top">int const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a72172f73132bd0eff84e43996b342404">get_fd</a> () const</td></tr>
<tr class="memdesc:a72172f73132bd0eff84e43996b342404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Read-only file descriptor.  <br /></td></tr>
<tr class="separator:a72172f73132bd0eff84e43996b342404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d57c721cf3d617aec40247fb4b6d00" id="r_a20d57c721cf3d617aec40247fb4b6d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a20d57c721cf3d617aec40247fb4b6d00">set_fd</a> (int const &amp;)</td></tr>
<tr class="memdesc:a20d57c721cf3d617aec40247fb4b6d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Read-only file descriptor.  <br /></td></tr>
<tr class="separator:a20d57c721cf3d617aec40247fb4b6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b35c916a56c96b629445eef543f1393" id="r_a0b35c916a56c96b629445eef543f1393"><td class="memItemLeft" align="right" valign="top"><a id="a0b35c916a56c96b629445eef543f1393" name="a0b35c916a56c96b629445eef543f1393"></a>
<a class="el" href="classSgSharedVector.html">SgFileContentList</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_data</b> () const</td></tr>
<tr class="memdesc:a0b35c916a56c96b629445eef543f1393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Contents of the file. <br /></td></tr>
<tr class="separator:a0b35c916a56c96b629445eef543f1393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199abc6d5fdd5f9ebde5c94c92571de4" id="r_a199abc6d5fdd5f9ebde5c94c92571de4"><td class="memItemLeft" align="right" valign="top"><a id="a199abc6d5fdd5f9ebde5c94c92571de4" name="a199abc6d5fdd5f9ebde5c94c92571de4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_data</b> (<a class="el" href="classSgSharedVector.html">SgFileContentList</a> const &amp;)</td></tr>
<tr class="memdesc:a199abc6d5fdd5f9ebde5c94c92571de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Contents of the file. <br /></td></tr>
<tr class="separator:a199abc6d5fdd5f9ebde5c94c92571de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23159c7bd620566feb92884834a1bbd2" id="r_a23159c7bd620566feb92884834a1bbd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericHeaderList.html">SgAsmGenericHeaderList</a> *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a23159c7bd620566feb92884834a1bbd2">get_headers</a> () const</td></tr>
<tr class="memdesc:a23159c7bd620566feb92884834a1bbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: List of all headers in file.  <br /></td></tr>
<tr class="separator:a23159c7bd620566feb92884834a1bbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7bdaa9b19668370eb45b67c4b0984e" id="r_acc7bdaa9b19668370eb45b67c4b0984e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#acc7bdaa9b19668370eb45b67c4b0984e">set_headers</a> (<a class="el" href="classSgAsmGenericHeaderList.html">SgAsmGenericHeaderList</a> *const &amp;)</td></tr>
<tr class="memdesc:acc7bdaa9b19668370eb45b67c4b0984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: List of all headers in file.  <br /></td></tr>
<tr class="separator:acc7bdaa9b19668370eb45b67c4b0984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a188cc62343dc85f4006acf2f8c58c5a6" id="r_a188cc62343dc85f4006acf2f8c58c5a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a188cc62343dc85f4006acf2f8c58c5a6">get_holes</a> () const</td></tr>
<tr class="memdesc:a188cc62343dc85f4006acf2f8c58c5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Addresses unreferenced during parsing.  <br /></td></tr>
<tr class="separator:a188cc62343dc85f4006acf2f8c58c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239c63d6ca0c84e7f62689361054c55a" id="r_a239c63d6ca0c84e7f62689361054c55a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a239c63d6ca0c84e7f62689361054c55a">set_holes</a> (<a class="el" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *const &amp;)</td></tr>
<tr class="memdesc:a239c63d6ca0c84e7f62689361054c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Addresses unreferenced during parsing.  <br /></td></tr>
<tr class="separator:a239c63d6ca0c84e7f62689361054c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad9401dfa5644fddaecaaa8e6c9f4646c" id="r_ad9401dfa5644fddaecaaa8e6c9f4646c"><td class="memItemLeft" align="right" valign="top"><a id="ad9401dfa5644fddaecaaa8e6c9f4646c" name="ad9401dfa5644fddaecaaa8e6c9f4646c"></a>
bool const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_truncateZeros</b> () const</td></tr>
<tr class="memdesc:ad9401dfa5644fddaecaaa8e6c9f4646c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to truncate zeros on writes. <br /></td></tr>
<tr class="separator:ad9401dfa5644fddaecaaa8e6c9f4646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c425363a54af725935bbc32bf37ec18" id="r_a2c425363a54af725935bbc32bf37ec18"><td class="memItemLeft" align="right" valign="top"><a id="a2c425363a54af725935bbc32bf37ec18" name="a2c425363a54af725935bbc32bf37ec18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_truncateZeros</b> (bool const &amp;)</td></tr>
<tr class="memdesc:a2c425363a54af725935bbc32bf37ec18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to truncate zeros on writes. <br /></td></tr>
<tr class="separator:a2c425363a54af725935bbc32bf37ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aefc1a1bb3e78044959f20e9022b768de" id="r_aefc1a1bb3e78044959f20e9022b768de"><td class="memItemLeft" align="right" valign="top"><a id="aefc1a1bb3e78044959f20e9022b768de" name="aefc1a1bb3e78044959f20e9022b768de"></a>
bool const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_trackingReferences</b> () const</td></tr>
<tr class="memdesc:aefc1a1bb3e78044959f20e9022b768de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to track referenced areas during parsing. <br /></td></tr>
<tr class="separator:aefc1a1bb3e78044959f20e9022b768de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d8ff1faef452ab73b150e275cef534" id="r_a46d8ff1faef452ab73b150e275cef534"><td class="memItemLeft" align="right" valign="top"><a id="a46d8ff1faef452ab73b150e275cef534" name="a46d8ff1faef452ab73b150e275cef534"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_trackingReferences</b> (bool const &amp;)</td></tr>
<tr class="memdesc:a46d8ff1faef452ab73b150e275cef534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Whether to track referenced areas during parsing. <br /></td></tr>
<tr class="separator:a46d8ff1faef452ab73b150e275cef534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafeee10fc8c5b7448d1aa53c2608d7dd" id="r_aafeee10fc8c5b7448d1aa53c2608d7dd"><td class="memItemLeft" align="right" valign="top"><a id="aafeee10fc8c5b7448d1aa53c2608d7dd" name="aafeee10fc8c5b7448d1aa53c2608d7dd"></a>
<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_referencedExtents</b> () const</td></tr>
<tr class="memdesc:aafeee10fc8c5b7448d1aa53c2608d7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Addresses referenced during parsing. <br /></td></tr>
<tr class="separator:aafeee10fc8c5b7448d1aa53c2608d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e86ceb0aef95b79a66fd2e9dce044c9" id="r_a6e86ceb0aef95b79a66fd2e9dce044c9"><td class="memItemLeft" align="right" valign="top"><a id="a6e86ceb0aef95b79a66fd2e9dce044c9" name="a6e86ceb0aef95b79a66fd2e9dce044c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_referencedExtents</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">Rose::BinaryAnalysis::AddressIntervalSet</a> const &amp;)</td></tr>
<tr class="memdesc:a6e86ceb0aef95b79a66fd2e9dce044c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Addresses referenced during parsing. <br /></td></tr>
<tr class="separator:a6e86ceb0aef95b79a66fd2e9dce044c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a01132ca31c7793bb68ba8bc6f270861b" id="r_a01132ca31c7793bb68ba8bc6f270861b"><td class="memItemLeft" align="right" valign="top"><a id="a01132ca31c7793bb68ba8bc6f270861b" name="a01132ca31c7793bb68ba8bc6f270861b"></a>
bool const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_neuter</b> () const</td></tr>
<tr class="memdesc:a01132ca31c7793bb68ba8bc6f270861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: If set, refuse to unparse file. <br /></td></tr>
<tr class="separator:a01132ca31c7793bb68ba8bc6f270861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce0c017aa52bc39fc7e4538de7479fc" id="r_a4ce0c017aa52bc39fc7e4538de7479fc"><td class="memItemLeft" align="right" valign="top"><a id="a4ce0c017aa52bc39fc7e4538de7479fc" name="a4ce0c017aa52bc39fc7e4538de7479fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_neuter</b> (bool const &amp;)</td></tr>
<tr class="memdesc:a4ce0c017aa52bc39fc7e4538de7479fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: If set, refuse to unparse file. <br /></td></tr>
<tr class="separator:a4ce0c017aa52bc39fc7e4538de7479fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaed8b442eacc042f18dab8f20a26fb8e" id="r_aaed8b442eacc042f18dab8f20a26fb8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataConverter.html">DataConverter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#aaed8b442eacc042f18dab8f20a26fb8e">get_dataConverter</a> () const</td></tr>
<tr class="memdesc:aaed8b442eacc042f18dab8f20a26fb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Data converter.  <br /></td></tr>
<tr class="separator:aaed8b442eacc042f18dab8f20a26fb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932a10a09cfdf7827a1c700ce05f8a02" id="r_a932a10a09cfdf7827a1c700ce05f8a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a932a10a09cfdf7827a1c700ce05f8a02">set_dataConverter</a> (<a class="el" href="classDataConverter.html">DataConverter</a> *)</td></tr>
<tr class="memdesc:a932a10a09cfdf7827a1c700ce05f8a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Data converter.  <br /></td></tr>
<tr class="separator:a932a10a09cfdf7827a1c700ce05f8a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a83384bc3cba90b97c33d64871edc901d" id="r_a83384bc3cba90b97c33d64871edc901d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a83384bc3cba90b97c33d64871edc901d">shiftExtend</a> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *, rose_addr_t sa, rose_addr_t sn, <a class="el" href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">AddressSpace</a>, <a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">Elasticity</a>)</td></tr>
<tr class="memdesc:a83384bc3cba90b97c33d64871edc901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves and enlarges a section.  <br /></td></tr>
<tr class="separator:a83384bc3cba90b97c33d64871edc901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b04fc25a41f77e8b0331de19c07de9" id="r_a25b04fc25a41f77e8b0331de19c07de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a25b04fc25a41f77e8b0331de19c07de9">shiftExtend</a> (<a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *s, rose_addr_t sa, rose_addr_t sn)</td></tr>
<tr class="memdesc:a25b04fc25a41f77e8b0331de19c07de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves and enlarges a section.  <br /></td></tr>
<tr class="separator:a25b04fc25a41f77e8b0331de19c07de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSgAsmExecutableFileFormat"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSgAsmExecutableFileFormat')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSgAsmExecutableFileFormat.html">SgAsmExecutableFileFormat</a></td></tr>
<tr class="memitem:adeb74172ba3dcc6ca251f0ba1ecf6741 inherit pub_methods_classSgAsmExecutableFileFormat" id="r_adeb74172ba3dcc6ca251f0ba1ecf6741"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SgAsmExecutableFileFormat</b> ()</td></tr>
<tr class="memdesc:adeb74172ba3dcc6ca251f0ba1ecf6741 inherit pub_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adeb74172ba3dcc6ca251f0ba1ecf6741 inherit pub_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSgAsmNode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSgAsmNode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSgAsmNode.html">SgAsmNode</a></td></tr>
<tr class="memitem:ae01957c79949c19b809f4edf9601275a inherit pub_methods_classSgAsmNode" id="r_ae01957c79949c19b809f4edf9601275a"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SgAsmNode</b> ()</td></tr>
<tr class="memdesc:ae01957c79949c19b809f4edf9601275a inherit pub_methods_classSgAsmNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae01957c79949c19b809f4edf9601275a inherit pub_methods_classSgAsmNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14383b9c5481aa3a0ba4af40d287f552 inherit pub_methods_classSgAsmNode" id="r_a14383b9c5481aa3a0ba4af40d287f552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmNode.html#a14383b9c5481aa3a0ba4af40d287f552">attributes</a> () const</td></tr>
<tr class="memdesc:a14383b9c5481aa3a0ba4af40d287f552 inherit pub_methods_classSgAsmNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute storage.  <br /></td></tr>
<tr class="separator:a14383b9c5481aa3a0ba4af40d287f552 inherit pub_methods_classSgAsmNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41718ae7e55b4a5e482a10b11f68602f inherit pub_methods_classSgAsmNode" id="r_a41718ae7e55b4a5e482a10b11f68602f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmNode.html#a41718ae7e55b4a5e482a10b11f68602f">attributes</a> ()</td></tr>
<tr class="memdesc:a41718ae7e55b4a5e482a10b11f68602f inherit pub_methods_classSgAsmNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute storage.  <br /></td></tr>
<tr class="separator:a41718ae7e55b4a5e482a10b11f68602f inherit pub_methods_classSgAsmNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSgNode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:a617686f2db3be003fdcde76e0645ff9f inherit pub_methods_classSgNode" id="r_a617686f2db3be003fdcde76e0645ff9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a617686f2db3be003fdcde76e0645ff9f">copy</a> (<a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a617686f2db3be003fdcde76e0645ff9f inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8723e70f7512769a015e94ca03224d2 inherit pub_methods_classSgNode" id="r_aa8723e70f7512769a015e94ca03224d2"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa8723e70f7512769a015e94ca03224d2">class_name</a> () const</td></tr>
<tr class="memdesc:aa8723e70f7512769a015e94ca03224d2 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a string representing the class name  <br /></td></tr>
<tr class="separator:aa8723e70f7512769a015e94ca03224d2 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9a652bb8435da633422a2440c64541 inherit pub_methods_classSgNode" id="r_a7c9a652bb8435da633422a2440c64541"><td class="memItemLeft" align="right" valign="top">virtual VariantT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7c9a652bb8435da633422a2440c64541">variantT</a> () const</td></tr>
<tr class="memdesc:a7c9a652bb8435da633422a2440c64541 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns new style SageIII enum values  <br /></td></tr>
<tr class="separator:a7c9a652bb8435da633422a2440c64541 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode" id="r_a4c46e191b0361d09e3c5f1e5389bfbeb"><td class="memItemLeft" align="right" valign="top">
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size)</td></tr>
<tr class="memdesc:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to newly allocated IR node <br /></td></tr>
<tr class="separator:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode" id="r_a9f851c77c2f9f8f4733aefea7c0358f4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *pointer, size_t size)</td></tr>
<tr class="memdesc:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocated memory for IR node (returns memory to memory pool for reuse) <br /></td></tr>
<tr class="separator:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d728ae391feaefc3e3af87f6e1dedc inherit pub_methods_classSgNode" id="r_af6d728ae391feaefc3e3af87f6e1dedc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af6d728ae391feaefc3e3af87f6e1dedc">operator delete</a> (void *pointer)</td></tr>
<tr class="separator:af6d728ae391feaefc3e3af87f6e1dedc inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode" id="r_a1114b78016dbb20ad0c4e6bf5da1d4aa"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a1114b78016dbb20ad0c4e6bf5da1d4aa">get_numberOfTraversalSuccessors</a> ()</td></tr>
<tr class="memdesc:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of children in the traversal successor list  <br /></td></tr>
<tr class="separator:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode" id="r_acf6d63ae159dc932a992c6224c4122bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#acf6d63ae159dc932a992c6224c4122bf">get_traversalSuccessorByIndex</a> (size_t idx)</td></tr>
<tr class="memdesc:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">index-based access to traversal successors by index number  <br /></td></tr>
<tr class="separator:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode" id="r_a8aaa6ee5e7d213fd8319c1a50f7a8e76"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8aaa6ee5e7d213fd8319c1a50f7a8e76">get_childIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *child)</td></tr>
<tr class="memdesc:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">index-based access to traversal successors by child node  <br /></td></tr>
<tr class="separator:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0785fc9b5ab58521d70919f2c725f4 inherit pub_methods_classSgNode" id="r_add0785fc9b5ab58521d70919f2c725f4"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#add0785fc9b5ab58521d70919f2c725f4">sage_class_name</a> () const</td></tr>
<tr class="memdesc:add0785fc9b5ab58521d70919f2c725f4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">generates string representing the class name: (e.g. for <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> returns "SgNode").  <br /></td></tr>
<tr class="separator:add0785fc9b5ab58521d70919f2c725f4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode" id="r_ad1f747541970207330922c79a2c2251b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeVisitorMemberFunction</b> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern. <br /></td></tr>
<tr class="separator:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode" id="r_ac7fe76b245438a4b6919d4740bcb1e4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ac7fe76b245438a4b6919d4740bcb1e4b">accept</a> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">support for the classic visitor pattern done in GoF  <br /></td></tr>
<tr class="separator:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode" id="r_a430e7d4b37350bda0b2d715f13b1a5be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a430e7d4b37350bda0b2d715f13b1a5be">isInMemoryPool</a> ()</td></tr>
<tr class="memdesc:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> This is used in internal tests to verify that all IR nodes are allocated from the heap.  <br /></td></tr>
<tr class="separator:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode" id="r_ab49821f9ecbe5ccc0450689a4b4498ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab49821f9ecbe5ccc0450689a4b4498ac">checkDataMemberPointersIfInMemoryPool</a> ()</td></tr>
<tr class="memdesc:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> This is used in internal tests to verify that all IR nodes are allocated from the heap.  <br /></td></tr>
<tr class="separator:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode" id="r_ae67d0fbf6c39c0df4ed876033624f9fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae67d0fbf6c39c0df4ed876033624f9fd">returnDataMemberPointers</a> () const</td></tr>
<tr class="memdesc:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Returns STL vector of pairs of SgNode* and strings for use in AST tools  <br /></td></tr>
<tr class="separator:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode" id="r_a5976ecccfd70128418f56adafb0e6570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5976ecccfd70128418f56adafb0e6570">processDataMemberReferenceToPointers</a> (<a class="el" href="structReferenceToPointerHandler.html">ReferenceToPointerHandler</a> *)</td></tr>
<tr class="memdesc:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Processes pairs of references to SgNode* and strings for use in AST tools  <br /></td></tr>
<tr class="separator:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode" id="r_a7fef0c98fa9b09becdc2b77ff3d3b9a5"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7fef0c98fa9b09becdc2b77ff3d3b9a5">getChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *childNode) const</td></tr>
<tr class="memdesc:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Returns a unique index value for the childNode in the list of children at this IR node.  <br /></td></tr>
<tr class="separator:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode" id="r_a3ef22a1eda7a0462f191f514aad203ef"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>SgNode</b> (const <a class="el" href="classSgNode.html#a16bbfdf2bb19fd99727dac1b6dd8f3a7">SgNodeStorageClass</a> &amp;source)</td></tr>
<tr class="memdesc:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR node constructor to support AST File I/O. <br /></td></tr>
<tr class="separator:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode" id="r_afa07e37b9a6415ed2cb47c2248f13194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afa07e37b9a6415ed2cb47c2248f13194">addRegExpAttribute</a> (std::string s, <a class="el" href="classAstRegExAttribute.html">AstRegExAttribute</a> *a)</td></tr>
<tr class="memdesc:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for AST matching using regular expression.  <br /></td></tr>
<tr class="separator:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ae02f0cd73cb84cbef103cbb002301 inherit pub_methods_classSgNode" id="r_a67ae02f0cd73cb84cbef103cbb002301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a67ae02f0cd73cb84cbef103cbb002301">set_isModified</a> (bool isModified)</td></tr>
<tr class="memdesc:a67ae02f0cd73cb84cbef103cbb002301 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">All nodes in the AST contain a isModified flag used to track changes to the AST.  <br /></td></tr>
<tr class="separator:a67ae02f0cd73cb84cbef103cbb002301 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode" id="r_ae9c046a0acefae5adcf3b33d8a159a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae9c046a0acefae5adcf3b33d8a159a4e">set_containsTransformation</a> (bool containsTransformation)</td></tr>
<tr class="memdesc:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many nodes can hide other AST nodes and we need to track when outer nodes contain modified nodes even if they are not themselves modified.  <br /></td></tr>
<tr class="separator:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff782b38c2276bbeb21be3251b49b572 inherit pub_methods_classSgNode" id="r_aff782b38c2276bbeb21be3251b49b572"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aff782b38c2276bbeb21be3251b49b572">get_isModified</a> () const</td></tr>
<tr class="memdesc:aff782b38c2276bbeb21be3251b49b572 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acess function for isModified flag.  <br /></td></tr>
<tr class="separator:aff782b38c2276bbeb21be3251b49b572 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode" id="r_a2950d7d073030ed9a2f19dd41fda4e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2950d7d073030ed9a2f19dd41fda4e87">get_containsTransformation</a> () const</td></tr>
<tr class="memdesc:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acess function for containsTransformation flag.  <br /></td></tr>
<tr class="separator:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode" id="r_afb1993c7632febff12e431d7601726a5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_raw_parent</b> () const</td></tr>
<tr class="memdesc:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for direct access to uncomputed value of parent node. <br /></td></tr>
<tr class="separator:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode" id="r_a7135c0858b44de99bf9f5f7b963949cb"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isChild</b> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query function for if the input IR nodes is a child of the current IR node. <br /></td></tr>
<tr class="separator:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode" id="r_a84ddeb6d61550e4dc3257f04010635b0"><td class="memItemLeft" align="right" valign="top">
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>unparseToString</b> (<a class="el" href="classSgUnparse__Info.html">SgUnparse_Info</a> *info) const</td></tr>
<tr class="memdesc:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unparses the AST node (excluding comments and unnecessary white space) <br /></td></tr>
<tr class="separator:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0076ef6afaa2beb56b547248cc2b4385 inherit pub_methods_classSgNode" id="r_a0076ef6afaa2beb56b547248cc2b4385"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>unparseToString</b> () const</td></tr>
<tr class="separator:a0076ef6afaa2beb56b547248cc2b4385 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e64b82e0d09e529e90f0f701b4353 inherit pub_methods_classSgNode" id="r_a434e64b82e0d09e529e90f0f701b4353"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a434e64b82e0d09e529e90f0f701b4353">variant</a> () const</td></tr>
<tr class="memdesc:a434e64b82e0d09e529e90f0f701b4353 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Older version function returns enum value "NODE".  <br /></td></tr>
<tr class="separator:a434e64b82e0d09e529e90f0f701b4353 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode" id="r_af427c3577c5feefda5cfa65ff2310f80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af427c3577c5feefda5cfa65ff2310f80">addNewAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new attribute represented by the named string.  <br /></td></tr>
<tr class="separator:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode" id="r_ab7531df38956eda593957d43134b5d99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab7531df38956eda593957d43134b5d99">getAttribute</a> (std::string s) const</td></tr>
<tr class="memdesc:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns attribute of name 's'.  <br /></td></tr>
<tr class="separator:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode" id="r_aec1b35f2a31719338b3c21cf44e95771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aec1b35f2a31719338b3c21cf44e95771">updateAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace existing attribute of name 's' with new <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>.  <br /></td></tr>
<tr class="separator:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode" id="r_a6664b9cd24a4e95b74c06996c2bed499"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a6664b9cd24a4e95b74c06996c2bed499">setAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper function with the following semantics: if no attribute of name 's' exists then <b>addNewAttribute(s,a)</b>; is called, otherwise <b>updateAttribute(s,a)</b>; is called.  <br /></td></tr>
<tr class="separator:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode" id="r_ad59bedb25d7fb8849a1486a815627da9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad59bedb25d7fb8849a1486a815627da9">removeAttribute</a> (std::string s)</td></tr>
<tr class="memdesc:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove attribute of name 's' if present.  <br /></td></tr>
<tr class="separator:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode" id="r_ad131aae2364f1bebc93aeb5f536e6dd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad131aae2364f1bebc93aeb5f536e6dd4">attributeExists</a> (std::string s) const</td></tr>
<tr class="memdesc:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if attribute of name 's' is present.  <br /></td></tr>
<tr class="separator:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode" id="r_aa29002ed951897fde4d1fc760b6a01b5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa29002ed951897fde4d1fc760b6a01b5">numberOfAttributes</a> () const</td></tr>
<tr class="memdesc:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes on this IR node.  <br /></td></tr>
<tr class="separator:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode" id="r_a642bb08ac1475d17a779256780beb099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a642bb08ac1475d17a779256780beb099">get_attributeMechanism</a> () const</td></tr>
<tr class="memdesc:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Access function; if an attribute exists then a pointer to it is returned, else error.  <br /></td></tr>
<tr class="separator:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode" id="r_afabfe1171b41ef49014b6b28c4b1cd1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afabfe1171b41ef49014b6b28c4b1cd1a">set_attributeMechanism</a> (<a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> *a)</td></tr>
<tr class="memdesc:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Access function; sets poiner to value <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a>.  <br /></td></tr>
<tr class="separator:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9218b95114cf157ec5a953dd60467f6e inherit pub_methods_classSgNode" id="r_a9218b95114cf157ec5a953dd60467f6e"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_scopes</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a9218b95114cf157ec5a953dd60467f6e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295c35f52c8c45fb8efe751bce5d35a inherit pub_methods_classSgNode" id="r_a6295c35f52c8c45fb8efe751bce5d35a"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_symbols</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a6295c35f52c8c45fb8efe751bce5d35a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2edb17ee8f14bc362ce9442f54eaed inherit pub_methods_classSgNode" id="r_a5d2edb17ee8f14bc362ce9442f54eaed"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_references</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a5d2edb17ee8f14bc362ce9442f54eaed inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode" id="r_aca3ee618bfd011d30ce9722ccf53b3cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aca3ee618bfd011d30ce9722ccf53b3cf">get_file_info</a> (void) const</td></tr>
<tr class="memdesc:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">File information containing filename, line number, column number, and if the <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> is a part of a new transformation, etc.  <br /></td></tr>
<tr class="separator:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode" id="r_a10d93dd5340822273cd521d2d3aaec89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a10d93dd5340822273cd521d2d3aaec89">get_startOfConstruct</a> (void) const</td></tr>
<tr class="memdesc:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">New function interface for <a class="el" href="classSg__File__Info.html" title="This class represents the location of the code associated with the IR node in the original source cod...">Sg_File_Info</a> data stores starting location of contruct (typically the opening brace or first letter of keyword).  <br /></td></tr>
<tr class="separator:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode" id="r_a1aaae5c5e3a74786caf493ce3d9c1a67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a1aaae5c5e3a74786caf493ce3d9c1a67">get_endOfConstruct</a> (void) const</td></tr>
<tr class="memdesc:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">New function interface for <a class="el" href="classSg__File__Info.html" title="This class represents the location of the code associated with the IR node in the original source cod...">Sg_File_Info</a> data stores ending location of contruct (typically the closing brace).  <br /></td></tr>
<tr class="separator:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode" id="r_a84a728494263300c7c838c5c98b3e9bc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classVirtualCFG_1_1CFGNode.html">VirtualCFG::CFGNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cfgForBeginning</b> ()</td></tr>
<tr class="memdesc:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CFG node for just before this AST node. <br /></td></tr>
<tr class="separator:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode" id="r_a4a1b6336271a584701a04a9969b873fb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classVirtualCFG_1_1CFGNode.html">VirtualCFG::CFGNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cfgForEnd</b> ()</td></tr>
<tr class="memdesc:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CFG node for just after this AST node. <br /></td></tr>
<tr class="separator:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode" id="r_a9fd5b4325c72a34ec57207b87595a20e"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a9fd5b4325c72a34ec57207b87595a20e">cfgIndexForEnd</a> () const</td></tr>
<tr class="memdesc:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the CFG index for the end of this construct.  <br /></td></tr>
<tr class="separator:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode" id="r_af4ddfa0e7f2a3c0d53f2ee8028ffaa37"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af4ddfa0e7f2a3c0d53f2ee8028ffaa37">cfgIsIndexInteresting</a> (unsigned int index) const</td></tr>
<tr class="memdesc:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a particular CFG node index is "interesting" for this kind of node.  <br /></td></tr>
<tr class="separator:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode" id="r_a87948da4e8eaa6fd2e78ddc10769c7a4"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a87948da4e8eaa6fd2e78ddc10769c7a4">cfgFindChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>
<tr class="memdesc:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of n in this node's CFG children.  <br /></td></tr>
<tr class="separator:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode" id="r_ad7d5328d0113e9e74a97369df72b4cb2"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad7d5328d0113e9e74a97369df72b4cb2">cfgFindNextChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>
<tr class="memdesc:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index just after n in this node's CFG children.  <br /></td></tr>
<tr class="separator:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode" id="r_acab55bc7715518ac65d57803062d9954"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classVirtualCFG_1_1CFGEdge.html">VirtualCFG::CFGEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#acab55bc7715518ac65d57803062d9954">cfgOutEdges</a> (unsigned int index=false)</td></tr>
<tr class="memdesc:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the out edges of a CFG node &ndash; internal version.  <br /></td></tr>
<tr class="separator:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode" id="r_a2c4ddc3ad658c9eb344078eed8919133"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classVirtualCFG_1_1CFGEdge.html">VirtualCFG::CFGEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2c4ddc3ad658c9eb344078eed8919133">cfgInEdges</a> (unsigned int index=false)</td></tr>
<tr class="memdesc:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the in edges of a CFG node &ndash; internal version.  <br /></td></tr>
<tr class="separator:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode" id="r_a7583fae3b9add193d6d70d3e8596bcd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7583fae3b9add193d6d70d3e8596bcd9">numberOfNodesInSubtree</a> ()</td></tr>
<tr class="memdesc:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of nodes in the defined subtree of the AST.  <br /></td></tr>
<tr class="separator:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode" id="r_abeeac2376b5ef97a5f8cd9f9413119f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#abeeac2376b5ef97a5f8cd9f9413119f7">depthOfSubtree</a> ()</td></tr>
<tr class="memdesc:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the depth of the current defined subtree of the AST.  <br /></td></tr>
<tr class="separator:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode" id="r_ae13335053ca578ee3ef0f56fa3eb57fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae13335053ca578ee3ef0f56fa3eb57fa">initParentPointer</a> (T *child, <a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated for tree edge data member initializations.  <br /></td></tr>
<tr class="separator:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ab447426bbf5c12cc61defd82eeb91 inherit pub_methods_classSgNode" id="r_a87ab447426bbf5c12cc61defd82eeb91"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_freepointer</b> () const</td></tr>
<tr class="separator:a87ab447426bbf5c12cc61defd82eeb91 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1030fd77f7614c0667001ec01afe425d inherit pub_methods_classSgNode" id="r_a1030fd77f7614c0667001ec01afe425d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_freepointer</b> (<a class="el" href="classSgNode.html">SgNode</a> *freepointer)</td></tr>
<tr class="separator:a1030fd77f7614c0667001ec01afe425d inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840c24c66e0715a831e0edd2a337394a inherit pub_methods_classSgNode" id="r_a840c24c66e0715a831e0edd2a337394a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a840c24c66e0715a831e0edd2a337394a">~SgNode</a> ()</td></tr>
<tr class="memdesc:a840c24c66e0715a831e0edd2a337394a inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the destructor.  <br /></td></tr>
<tr class="separator:a840c24c66e0715a831e0edd2a337394a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586c38a3338b1955193a8ed61c8a0162 inherit pub_methods_classSgNode" id="r_a586c38a3338b1955193a8ed61c8a0162"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a586c38a3338b1955193a8ed61c8a0162">SgNode</a> ()</td></tr>
<tr class="memdesc:a586c38a3338b1955193a8ed61c8a0162 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the constructor.  <br /></td></tr>
<tr class="separator:a586c38a3338b1955193a8ed61c8a0162 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617686f2db3be003fdcde76e0645ff9f inherit pub_methods_classSgNode" id="r_a617686f2db3be003fdcde76e0645ff9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a617686f2db3be003fdcde76e0645ff9f">copy</a> (<a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a617686f2db3be003fdcde76e0645ff9f inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ece7437b5993628f1a762081bcc4a0 inherit pub_methods_classSgNode" id="r_a74ece7437b5993628f1a762081bcc4a0"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a74ece7437b5993628f1a762081bcc4a0">class_name</a> () const</td></tr>
<tr class="memdesc:a74ece7437b5993628f1a762081bcc4a0 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a string representing the class name  <br /></td></tr>
<tr class="separator:a74ece7437b5993628f1a762081bcc4a0 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118e6ecfdcfae04a7a836bbc218ca1dd inherit pub_methods_classSgNode" id="r_a118e6ecfdcfae04a7a836bbc218ca1dd"><td class="memItemLeft" align="right" valign="top">virtual VariantT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a118e6ecfdcfae04a7a836bbc218ca1dd">variantT</a> () const</td></tr>
<tr class="memdesc:a118e6ecfdcfae04a7a836bbc218ca1dd inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns new style SageIII enum values  <br /></td></tr>
<tr class="separator:a118e6ecfdcfae04a7a836bbc218ca1dd inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode" id="r_a4c46e191b0361d09e3c5f1e5389bfbeb"><td class="memItemLeft" align="right" valign="top">
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size)</td></tr>
<tr class="memdesc:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to newly allocated IR node <br /></td></tr>
<tr class="separator:a4c46e191b0361d09e3c5f1e5389bfbeb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode" id="r_a9f851c77c2f9f8f4733aefea7c0358f4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *pointer, size_t size)</td></tr>
<tr class="memdesc:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocated memory for IR node (returns memory to memory pool for reuse) <br /></td></tr>
<tr class="separator:a9f851c77c2f9f8f4733aefea7c0358f4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d728ae391feaefc3e3af87f6e1dedc inherit pub_methods_classSgNode" id="r_af6d728ae391feaefc3e3af87f6e1dedc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af6d728ae391feaefc3e3af87f6e1dedc">operator delete</a> (void *pointer)</td></tr>
<tr class="separator:af6d728ae391feaefc3e3af87f6e1dedc inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd827ac8c5eca213039ae9e5ae6dca3 inherit pub_methods_classSgNode" id="r_a2fd827ac8c5eca213039ae9e5ae6dca3"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2fd827ac8c5eca213039ae9e5ae6dca3">get_traversalSuccessorContainer</a> ()</td></tr>
<tr class="memdesc:a2fd827ac8c5eca213039ae9e5ae6dca3 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of pointers to AST successor nodes used in the traversal overridden in every class by <em>generated</em> implementation  <br /></td></tr>
<tr class="separator:a2fd827ac8c5eca213039ae9e5ae6dca3 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ab3fdc565f943eedc233a2ad0ddc7c inherit pub_methods_classSgNode" id="r_a22ab3fdc565f943eedc233a2ad0ddc7c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a22ab3fdc565f943eedc233a2ad0ddc7c">get_traversalSuccessorNamesContainer</a> ()</td></tr>
<tr class="memdesc:a22ab3fdc565f943eedc233a2ad0ddc7c inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of names of variables or container indices used used in the traversal to access AST successor nodes overridden in every class by <em>generated</em> implementation  <br /></td></tr>
<tr class="separator:a22ab3fdc565f943eedc233a2ad0ddc7c inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode" id="r_a1114b78016dbb20ad0c4e6bf5da1d4aa"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a1114b78016dbb20ad0c4e6bf5da1d4aa">get_numberOfTraversalSuccessors</a> ()</td></tr>
<tr class="memdesc:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of children in the traversal successor list  <br /></td></tr>
<tr class="separator:a1114b78016dbb20ad0c4e6bf5da1d4aa inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode" id="r_acf6d63ae159dc932a992c6224c4122bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#acf6d63ae159dc932a992c6224c4122bf">get_traversalSuccessorByIndex</a> (size_t idx)</td></tr>
<tr class="memdesc:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">index-based access to traversal successors by index number  <br /></td></tr>
<tr class="separator:acf6d63ae159dc932a992c6224c4122bf inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode" id="r_a8aaa6ee5e7d213fd8319c1a50f7a8e76"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8aaa6ee5e7d213fd8319c1a50f7a8e76">get_childIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *child)</td></tr>
<tr class="memdesc:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">index-based access to traversal successors by child node  <br /></td></tr>
<tr class="separator:a8aaa6ee5e7d213fd8319c1a50f7a8e76 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194fbd9abf0f1179320e8c8fb7db8480 inherit pub_methods_classSgNode" id="r_a194fbd9abf0f1179320e8c8fb7db8480"><td class="memItemLeft" align="right" valign="top">virtual RTIReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a194fbd9abf0f1179320e8c8fb7db8480">roseRTI</a> ()</td></tr>
<tr class="memdesc:a194fbd9abf0f1179320e8c8fb7db8480 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">return C++ Runtime-Time-Information  <br /></td></tr>
<tr class="separator:a194fbd9abf0f1179320e8c8fb7db8480 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de18dfbe57328dcfcf544fa941bc94 inherit pub_methods_classSgNode" id="r_ae7de18dfbe57328dcfcf544fa941bc94"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae7de18dfbe57328dcfcf544fa941bc94">sage_class_name</a> () const</td></tr>
<tr class="separator:ae7de18dfbe57328dcfcf544fa941bc94 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode" id="r_ad1f747541970207330922c79a2c2251b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeVisitorMemberFunction</b> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern. <br /></td></tr>
<tr class="separator:ad1f747541970207330922c79a2c2251b inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode" id="r_ac7fe76b245438a4b6919d4740bcb1e4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ac7fe76b245438a4b6919d4740bcb1e4b">accept</a> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">support for the classic visitor pattern done in GoF  <br /></td></tr>
<tr class="separator:ac7fe76b245438a4b6919d4740bcb1e4b inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode" id="r_a430e7d4b37350bda0b2d715f13b1a5be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a430e7d4b37350bda0b2d715f13b1a5be">isInMemoryPool</a> ()</td></tr>
<tr class="memdesc:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> This is used in internal tests to verify that all IR nodes are allocated from the heap.  <br /></td></tr>
<tr class="separator:a430e7d4b37350bda0b2d715f13b1a5be inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode" id="r_ab49821f9ecbe5ccc0450689a4b4498ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab49821f9ecbe5ccc0450689a4b4498ac">checkDataMemberPointersIfInMemoryPool</a> ()</td></tr>
<tr class="memdesc:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> This is used in internal tests to verify that all IR nodes are allocated from the heap.  <br /></td></tr>
<tr class="separator:ab49821f9ecbe5ccc0450689a4b4498ac inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode" id="r_ae67d0fbf6c39c0df4ed876033624f9fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae67d0fbf6c39c0df4ed876033624f9fd">returnDataMemberPointers</a> () const</td></tr>
<tr class="memdesc:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Returns STL vector of pairs of SgNode* and strings for use in AST tools  <br /></td></tr>
<tr class="separator:ae67d0fbf6c39c0df4ed876033624f9fd inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode" id="r_a5976ecccfd70128418f56adafb0e6570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5976ecccfd70128418f56adafb0e6570">processDataMemberReferenceToPointers</a> (<a class="el" href="structReferenceToPointerHandler.html">ReferenceToPointerHandler</a> *)</td></tr>
<tr class="memdesc:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Processes pairs of references to SgNode* and strings for use in AST tools  <br /></td></tr>
<tr class="separator:a5976ecccfd70128418f56adafb0e6570 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode" id="r_a7fef0c98fa9b09becdc2b77ff3d3b9a5"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7fef0c98fa9b09becdc2b77ff3d3b9a5">getChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *childNode) const</td></tr>
<tr class="memdesc:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Returns a unique index value for the childNode in the list of children at this IR node.  <br /></td></tr>
<tr class="separator:a7fef0c98fa9b09becdc2b77ff3d3b9a5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode" id="r_a3ef22a1eda7a0462f191f514aad203ef"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>SgNode</b> (const <a class="el" href="classSgNode.html#a16bbfdf2bb19fd99727dac1b6dd8f3a7">SgNodeStorageClass</a> &amp;source)</td></tr>
<tr class="memdesc:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR node constructor to support AST File I/O. <br /></td></tr>
<tr class="separator:a3ef22a1eda7a0462f191f514aad203ef inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode" id="r_afa07e37b9a6415ed2cb47c2248f13194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afa07e37b9a6415ed2cb47c2248f13194">addRegExpAttribute</a> (std::string s, <a class="el" href="classAstRegExAttribute.html">AstRegExAttribute</a> *a)</td></tr>
<tr class="memdesc:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for AST matching using regular expression.  <br /></td></tr>
<tr class="separator:afa07e37b9a6415ed2cb47c2248f13194 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8407bb4cd2f8ba917d54c902a3cb6a inherit pub_methods_classSgNode" id="r_a2c8407bb4cd2f8ba917d54c902a3cb6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2c8407bb4cd2f8ba917d54c902a3cb6a">set_isModified</a> (bool isModified)</td></tr>
<tr class="memdesc:a2c8407bb4cd2f8ba917d54c902a3cb6a inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">All nodes in the AST contain a isModified flag used to track changes to the AST.  <br /></td></tr>
<tr class="separator:a2c8407bb4cd2f8ba917d54c902a3cb6a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode" id="r_ae9c046a0acefae5adcf3b33d8a159a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae9c046a0acefae5adcf3b33d8a159a4e">set_containsTransformation</a> (bool containsTransformation)</td></tr>
<tr class="memdesc:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many nodes can hide other AST nodes and we need to track when outer nodes contain modified nodes even if they are not themselves modified.  <br /></td></tr>
<tr class="separator:ae9c046a0acefae5adcf3b33d8a159a4e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0eaeb30b3d1043bc36467ab97aaf70 inherit pub_methods_classSgNode" id="r_abc0eaeb30b3d1043bc36467ab97aaf70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#abc0eaeb30b3d1043bc36467ab97aaf70">get_isModified</a> () const</td></tr>
<tr class="memdesc:abc0eaeb30b3d1043bc36467ab97aaf70 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acess function for isModified flag.  <br /></td></tr>
<tr class="separator:abc0eaeb30b3d1043bc36467ab97aaf70 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode" id="r_a2950d7d073030ed9a2f19dd41fda4e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2950d7d073030ed9a2f19dd41fda4e87">get_containsTransformation</a> () const</td></tr>
<tr class="memdesc:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acess function for containsTransformation flag.  <br /></td></tr>
<tr class="separator:a2950d7d073030ed9a2f19dd41fda4e87 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d550b959e2637e8b2d793abf13a41c inherit pub_methods_classSgNode" id="r_a56d550b959e2637e8b2d793abf13a41c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_parent</b> (<a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:a56d550b959e2637e8b2d793abf13a41c inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">All nodes in the AST contain a reference to a parent node. <br /></td></tr>
<tr class="separator:a56d550b959e2637e8b2d793abf13a41c inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700fda4ecd4b1b07838a359688a543a5 inherit pub_methods_classSgNode" id="r_a700fda4ecd4b1b07838a359688a543a5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_parent</b> () const</td></tr>
<tr class="memdesc:a700fda4ecd4b1b07838a359688a543a5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for parent node. <br /></td></tr>
<tr class="separator:a700fda4ecd4b1b07838a359688a543a5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode" id="r_afb1993c7632febff12e431d7601726a5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_raw_parent</b> () const</td></tr>
<tr class="memdesc:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for direct access to uncomputed value of parent node. <br /></td></tr>
<tr class="separator:afb1993c7632febff12e431d7601726a5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode" id="r_a7135c0858b44de99bf9f5f7b963949cb"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isChild</b> (<a class="el" href="classSgNode.html">SgNode</a> *node) const</td></tr>
<tr class="memdesc:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query function for if the input IR nodes is a child of the current IR node. <br /></td></tr>
<tr class="separator:a7135c0858b44de99bf9f5f7b963949cb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode" id="r_a84ddeb6d61550e4dc3257f04010635b0"><td class="memItemLeft" align="right" valign="top">
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>unparseToString</b> (<a class="el" href="classSgUnparse__Info.html">SgUnparse_Info</a> *info) const</td></tr>
<tr class="memdesc:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unparses the AST node (excluding comments and unnecessary white space) <br /></td></tr>
<tr class="separator:a84ddeb6d61550e4dc3257f04010635b0 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0076ef6afaa2beb56b547248cc2b4385 inherit pub_methods_classSgNode" id="r_a0076ef6afaa2beb56b547248cc2b4385"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>unparseToString</b> () const</td></tr>
<tr class="separator:a0076ef6afaa2beb56b547248cc2b4385 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02439e086a7a623afc2df536788000c0 inherit pub_methods_classSgNode" id="r_a02439e086a7a623afc2df536788000c0"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>unparseToCompleteString</b> ()</td></tr>
<tr class="memdesc:a02439e086a7a623afc2df536788000c0 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unparses the AST node (including comments and white space) <br /></td></tr>
<tr class="separator:a02439e086a7a623afc2df536788000c0 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60c31c05fa6f6e73ea6c18bc3785d94 inherit pub_methods_classSgNode" id="r_ae60c31c05fa6f6e73ea6c18bc3785d94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae60c31c05fa6f6e73ea6c18bc3785d94">variant</a> () const</td></tr>
<tr class="separator:ae60c31c05fa6f6e73ea6c18bc3785d94 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc0637ad70218effc8babb32179e9d2 inherit pub_methods_classSgNode" id="r_aefc0637ad70218effc8babb32179e9d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aefc0637ad70218effc8babb32179e9d2">get_isVisited</a> () const</td></tr>
<tr class="memdesc:aefc0637ad70218effc8babb32179e9d2 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOCS IN HEADER: Access function for p_isVisited flag used previously by the AST traversals.  <br /></td></tr>
<tr class="separator:aefc0637ad70218effc8babb32179e9d2 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19d4d77f71f56361059577e73d82a24 inherit pub_methods_classSgNode" id="r_ad19d4d77f71f56361059577e73d82a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad19d4d77f71f56361059577e73d82a24">set_isVisited</a> (bool isVisited)</td></tr>
<tr class="memdesc:ad19d4d77f71f56361059577e73d82a24 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for p_isVisited flag used previously by the AST traversals.  <br /></td></tr>
<tr class="separator:ad19d4d77f71f56361059577e73d82a24 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode" id="r_af427c3577c5feefda5cfa65ff2310f80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af427c3577c5feefda5cfa65ff2310f80">addNewAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new attribute represented by the named string.  <br /></td></tr>
<tr class="separator:af427c3577c5feefda5cfa65ff2310f80 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode" id="r_ab7531df38956eda593957d43134b5d99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttribute.html">AstAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab7531df38956eda593957d43134b5d99">getAttribute</a> (std::string s) const</td></tr>
<tr class="memdesc:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns attribute of name 's'.  <br /></td></tr>
<tr class="separator:ab7531df38956eda593957d43134b5d99 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode" id="r_aec1b35f2a31719338b3c21cf44e95771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aec1b35f2a31719338b3c21cf44e95771">updateAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace existing attribute of name 's' with new <a class="el" href="classAstAttribute.html" title="Base class for all IR node attribute values.">AstAttribute</a>.  <br /></td></tr>
<tr class="separator:aec1b35f2a31719338b3c21cf44e95771 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode" id="r_a6664b9cd24a4e95b74c06996c2bed499"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a6664b9cd24a4e95b74c06996c2bed499">setAttribute</a> (std::string s, <a class="el" href="classAstAttribute.html">AstAttribute</a> *a)</td></tr>
<tr class="memdesc:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper function with the following semantics: if no attribute of name 's' exists then <b>addNewAttribute(s,a)</b>; is called, otherwise <b>updateAttribute(s,a)</b>; is called.  <br /></td></tr>
<tr class="separator:a6664b9cd24a4e95b74c06996c2bed499 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode" id="r_ad59bedb25d7fb8849a1486a815627da9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad59bedb25d7fb8849a1486a815627da9">removeAttribute</a> (std::string s)</td></tr>
<tr class="memdesc:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove attribute of name 's' if present.  <br /></td></tr>
<tr class="separator:ad59bedb25d7fb8849a1486a815627da9 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode" id="r_ad131aae2364f1bebc93aeb5f536e6dd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad131aae2364f1bebc93aeb5f536e6dd4">attributeExists</a> (std::string s) const</td></tr>
<tr class="memdesc:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if attribute of name 's' is present.  <br /></td></tr>
<tr class="separator:ad131aae2364f1bebc93aeb5f536e6dd4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode" id="r_aa29002ed951897fde4d1fc760b6a01b5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa29002ed951897fde4d1fc760b6a01b5">numberOfAttributes</a> () const</td></tr>
<tr class="memdesc:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of attributes on this IR node.  <br /></td></tr>
<tr class="separator:aa29002ed951897fde4d1fc760b6a01b5 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode" id="r_a642bb08ac1475d17a779256780beb099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a642bb08ac1475d17a779256780beb099">get_attributeMechanism</a> () const</td></tr>
<tr class="memdesc:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Access function; if an attribute exists then a pointer to it is returned, else error.  <br /></td></tr>
<tr class="separator:a642bb08ac1475d17a779256780beb099 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode" id="r_afabfe1171b41ef49014b6b28c4b1cd1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afabfe1171b41ef49014b6b28c4b1cd1a">set_attributeMechanism</a> (<a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> *a)</td></tr>
<tr class="memdesc:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Access function; sets poiner to value <a class="el" href="classAstAttributeMechanism.html" title="Stores named attributes in Sage IR nodes.">AstAttributeMechanism</a>.  <br /></td></tr>
<tr class="separator:afabfe1171b41ef49014b6b28c4b1cd1a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9218b95114cf157ec5a953dd60467f6e inherit pub_methods_classSgNode" id="r_a9218b95114cf157ec5a953dd60467f6e"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_scopes</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a9218b95114cf157ec5a953dd60467f6e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295c35f52c8c45fb8efe751bce5d35a inherit pub_methods_classSgNode" id="r_a6295c35f52c8c45fb8efe751bce5d35a"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_symbols</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a6295c35f52c8c45fb8efe751bce5d35a inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2edb17ee8f14bc362ce9442f54eaed inherit pub_methods_classSgNode" id="r_a5d2edb17ee8f14bc362ce9442f54eaed"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fixupCopy_references</b> (<a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help) const</td></tr>
<tr class="separator:a5d2edb17ee8f14bc362ce9442f54eaed inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode" id="r_aca3ee618bfd011d30ce9722ccf53b3cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aca3ee618bfd011d30ce9722ccf53b3cf">get_file_info</a> (void) const</td></tr>
<tr class="memdesc:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">File information containing filename, line number, column number, and if the <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> is a part of a new transformation, etc.  <br /></td></tr>
<tr class="separator:aca3ee618bfd011d30ce9722ccf53b3cf inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode" id="r_a10d93dd5340822273cd521d2d3aaec89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a10d93dd5340822273cd521d2d3aaec89">get_startOfConstruct</a> (void) const</td></tr>
<tr class="memdesc:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">New function interface for <a class="el" href="classSg__File__Info.html" title="This class represents the location of the code associated with the IR node in the original source cod...">Sg_File_Info</a> data stores starting location of contruct (typically the opening brace or first letter of keyword).  <br /></td></tr>
<tr class="separator:a10d93dd5340822273cd521d2d3aaec89 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode" id="r_a1aaae5c5e3a74786caf493ce3d9c1a67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a1aaae5c5e3a74786caf493ce3d9c1a67">get_endOfConstruct</a> (void) const</td></tr>
<tr class="memdesc:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">New function interface for <a class="el" href="classSg__File__Info.html" title="This class represents the location of the code associated with the IR node in the original source cod...">Sg_File_Info</a> data stores ending location of contruct (typically the closing brace).  <br /></td></tr>
<tr class="separator:a1aaae5c5e3a74786caf493ce3d9c1a67 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode" id="r_a84a728494263300c7c838c5c98b3e9bc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classVirtualCFG_1_1CFGNode.html">VirtualCFG::CFGNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cfgForBeginning</b> ()</td></tr>
<tr class="memdesc:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CFG node for just before this AST node. <br /></td></tr>
<tr class="separator:a84a728494263300c7c838c5c98b3e9bc inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode" id="r_a4a1b6336271a584701a04a9969b873fb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classVirtualCFG_1_1CFGNode.html">VirtualCFG::CFGNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cfgForEnd</b> ()</td></tr>
<tr class="memdesc:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CFG node for just after this AST node. <br /></td></tr>
<tr class="separator:a4a1b6336271a584701a04a9969b873fb inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode" id="r_a9fd5b4325c72a34ec57207b87595a20e"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a9fd5b4325c72a34ec57207b87595a20e">cfgIndexForEnd</a> () const</td></tr>
<tr class="memdesc:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the CFG index for the end of this construct.  <br /></td></tr>
<tr class="separator:a9fd5b4325c72a34ec57207b87595a20e inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode" id="r_af4ddfa0e7f2a3c0d53f2ee8028ffaa37"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af4ddfa0e7f2a3c0d53f2ee8028ffaa37">cfgIsIndexInteresting</a> (unsigned int index) const</td></tr>
<tr class="memdesc:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a particular CFG node index is "interesting" for this kind of node.  <br /></td></tr>
<tr class="separator:af4ddfa0e7f2a3c0d53f2ee8028ffaa37 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode" id="r_a87948da4e8eaa6fd2e78ddc10769c7a4"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a87948da4e8eaa6fd2e78ddc10769c7a4">cfgFindChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>
<tr class="memdesc:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of n in this node's CFG children.  <br /></td></tr>
<tr class="separator:a87948da4e8eaa6fd2e78ddc10769c7a4 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode" id="r_ad7d5328d0113e9e74a97369df72b4cb2"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad7d5328d0113e9e74a97369df72b4cb2">cfgFindNextChildIndex</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>
<tr class="memdesc:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index just after n in this node's CFG children.  <br /></td></tr>
<tr class="separator:ad7d5328d0113e9e74a97369df72b4cb2 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode" id="r_acab55bc7715518ac65d57803062d9954"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classVirtualCFG_1_1CFGEdge.html">VirtualCFG::CFGEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#acab55bc7715518ac65d57803062d9954">cfgOutEdges</a> (unsigned int index=false)</td></tr>
<tr class="memdesc:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the out edges of a CFG node &ndash; internal version.  <br /></td></tr>
<tr class="separator:acab55bc7715518ac65d57803062d9954 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode" id="r_a2c4ddc3ad658c9eb344078eed8919133"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classVirtualCFG_1_1CFGEdge.html">VirtualCFG::CFGEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a2c4ddc3ad658c9eb344078eed8919133">cfgInEdges</a> (unsigned int index=false)</td></tr>
<tr class="memdesc:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the in edges of a CFG node &ndash; internal version.  <br /></td></tr>
<tr class="separator:a2c4ddc3ad658c9eb344078eed8919133 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode" id="r_a7583fae3b9add193d6d70d3e8596bcd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7583fae3b9add193d6d70d3e8596bcd9">numberOfNodesInSubtree</a> ()</td></tr>
<tr class="memdesc:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of nodes in the defined subtree of the AST.  <br /></td></tr>
<tr class="separator:a7583fae3b9add193d6d70d3e8596bcd9 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode" id="r_abeeac2376b5ef97a5f8cd9f9413119f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#abeeac2376b5ef97a5f8cd9f9413119f7">depthOfSubtree</a> ()</td></tr>
<tr class="memdesc:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the depth of the current defined subtree of the AST.  <br /></td></tr>
<tr class="separator:abeeac2376b5ef97a5f8cd9f9413119f7 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode" id="r_ae13335053ca578ee3ef0f56fa3eb57fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae13335053ca578ee3ef0f56fa3eb57fa">initParentPointer</a> (T *child, <a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated for tree edge data member initializations.  <br /></td></tr>
<tr class="separator:ae13335053ca578ee3ef0f56fa3eb57fa inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ab447426bbf5c12cc61defd82eeb91 inherit pub_methods_classSgNode" id="r_a87ab447426bbf5c12cc61defd82eeb91"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_freepointer</b> () const</td></tr>
<tr class="separator:a87ab447426bbf5c12cc61defd82eeb91 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1030fd77f7614c0667001ec01afe425d inherit pub_methods_classSgNode" id="r_a1030fd77f7614c0667001ec01afe425d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_freepointer</b> (<a class="el" href="classSgNode.html">SgNode</a> *freepointer)</td></tr>
<tr class="separator:a1030fd77f7614c0667001ec01afe425d inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2fdab2e0a2561e9cb2d783703a8598 inherit pub_methods_classSgNode" id="r_a8f2fdab2e0a2561e9cb2d783703a8598"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8f2fdab2e0a2561e9cb2d783703a8598">get_traversalSuccessorContainer</a> ()</td></tr>
<tr class="memdesc:a8f2fdab2e0a2561e9cb2d783703a8598 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of pointers to AST successor nodes used in the traversal overridden in every class by <em>generated</em> implementation  <br /></td></tr>
<tr class="separator:a8f2fdab2e0a2561e9cb2d783703a8598 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109e9adf9ae1d934b16d25e711b4324 inherit pub_methods_classSgNode" id="r_a3109e9adf9ae1d934b16d25e711b4324"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3109e9adf9ae1d934b16d25e711b4324">get_traversalSuccessorNamesContainer</a> ()</td></tr>
<tr class="memdesc:a3109e9adf9ae1d934b16d25e711b4324 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of names of variables or container indices used used in the traversal to access AST successor nodes overridden in every class by <em>generated</em> implementation  <br /></td></tr>
<tr class="separator:a3109e9adf9ae1d934b16d25e711b4324 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1882176119ee23f65992d327e4cbfd68 inherit pub_methods_classSgNode" id="r_a1882176119ee23f65992d327e4cbfd68"><td class="memItemLeft" align="right" valign="top">virtual RTIReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a1882176119ee23f65992d327e4cbfd68">roseRTI</a> ()</td></tr>
<tr class="memdesc:a1882176119ee23f65992d327e4cbfd68 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">return C++ Runtime-Time-Information  <br /></td></tr>
<tr class="separator:a1882176119ee23f65992d327e4cbfd68 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83017efa378d75b031330739c963749d inherit pub_methods_classSgNode" id="r_a83017efa378d75b031330739c963749d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a83017efa378d75b031330739c963749d">set_parent</a> (<a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:a83017efa378d75b031330739c963749d inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">All nodes in the AST contain a reference to a parent node.  <br /></td></tr>
<tr class="separator:a83017efa378d75b031330739c963749d inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384eb2fc572b3371cd9681121cbefa3 inherit pub_methods_classSgNode" id="r_a3384eb2fc572b3371cd9681121cbefa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3384eb2fc572b3371cd9681121cbefa3">get_parent</a> () const</td></tr>
<tr class="memdesc:a3384eb2fc572b3371cd9681121cbefa3 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for parent node.  <br /></td></tr>
<tr class="separator:a3384eb2fc572b3371cd9681121cbefa3 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424645345b57be63499504a4ae3871e0 inherit pub_methods_classSgNode" id="r_a424645345b57be63499504a4ae3871e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a424645345b57be63499504a4ae3871e0">unparseToCompleteString</a> ()</td></tr>
<tr class="memdesc:a424645345b57be63499504a4ae3871e0 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unparses the AST node (including comments and white space)  <br /></td></tr>
<tr class="separator:a424645345b57be63499504a4ae3871e0 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ba7946ae97fa7ca914d029a1092646 inherit pub_methods_classSgNode" id="r_af9ba7946ae97fa7ca914d029a1092646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af9ba7946ae97fa7ca914d029a1092646">get_isVisited</a> () const</td></tr>
<tr class="memdesc:af9ba7946ae97fa7ca914d029a1092646 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOCS IN HEADER: Access function for p_isVisited flag used previously by the AST traversals.  <br /></td></tr>
<tr class="separator:af9ba7946ae97fa7ca914d029a1092646 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad299ccda7834cc319ae80d9f2dfc81e2 inherit pub_methods_classSgNode" id="r_ad299ccda7834cc319ae80d9f2dfc81e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad299ccda7834cc319ae80d9f2dfc81e2">set_isVisited</a> (bool isVisited)</td></tr>
<tr class="memdesc:ad299ccda7834cc319ae80d9f2dfc81e2 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for p_isVisited flag used previously by the AST traversals.  <br /></td></tr>
<tr class="separator:ad299ccda7834cc319ae80d9f2dfc81e2 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode" id="r_a54e809b89e895623d5739842b445a24c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_pointer&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#a54e809b89e895623d5739842b445a24c">changeChildPointer</a> (T &amp;edge, T const &amp;child)</td></tr>
<tr class="memdesc:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a child edge in a tree to point to a specific child.  <br /></td></tr>
<tr class="separator:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode" id="r_ad1ac181adba605f9780db498fb48fc50"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_pointer&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad1ac181adba605f9780db498fb48fc50">changeChildPointer</a> (T &amp;edge, T const &amp;child)</td></tr>
<tr class="memdesc:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a child edge in a tree to point to a specific child.  <br /></td></tr>
<tr class="separator:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode" id="r_a54e809b89e895623d5739842b445a24c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_pointer&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#a54e809b89e895623d5739842b445a24c">changeChildPointer</a> (T &amp;edge, T const &amp;child)</td></tr>
<tr class="memdesc:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a child edge in a tree to point to a specific child.  <br /></td></tr>
<tr class="separator:a54e809b89e895623d5739842b445a24c inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode" id="r_ad1ac181adba605f9780db498fb48fc50"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_pointer&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#ad1ac181adba605f9780db498fb48fc50">changeChildPointer</a> (T &amp;edge, T const &amp;child)</td></tr>
<tr class="memdesc:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a child edge in a tree to point to a specific child.  <br /></td></tr>
<tr class="separator:ad1ac181adba605f9780db498fb48fc50 inherit pub_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abfccc26a6dfe20b01a7da8a52d98d7cc" id="r_abfccc26a6dfe20b01a7da8a52d98d7cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#abfccc26a6dfe20b01a7da8a52d98d7cc">bestSectionByVa</a> (const SgAsmGenericSectionPtrList &amp;sections, rose_addr_t va)</td></tr>
<tr class="memdesc:abfccc26a6dfe20b01a7da8a52d98d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for "best".  <br /></td></tr>
<tr class="separator:abfccc26a6dfe20b01a7da8a52d98d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bad6b0e75409ecaf57989120975923" id="r_a15bad6b0e75409ecaf57989120975923"><td class="memItemLeft" align="right" valign="top"><a id="a15bad6b0e75409ecaf57989120975923" name="a15bad6b0e75409ecaf57989120975923"></a>
static <a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>best_section_by_va</b> (const SgAsmGenericSectionPtrList &amp;, rose_addr_t)</td></tr>
<tr class="separator:a15bad6b0e75409ecaf57989120975923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSgAsmExecutableFileFormat"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSgAsmExecutableFileFormat')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSgAsmExecutableFileFormat.html">SgAsmExecutableFileFormat</a></td></tr>
<tr class="memitem:a6bb26c72e374127d7ee0eb52a102ad6f inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a6bb26c72e374127d7ee0eb52a102ad6f"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parseBinaryFormat</b> (const char *name)</td></tr>
<tr class="memdesc:a6bb26c72e374127d7ee0eb52a102ad6f inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that parses a binary file. <br /></td></tr>
<tr class="separator:a6bb26c72e374127d7ee0eb52a102ad6f inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d859164653dd2d3a4f4059956dc2905 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a3d859164653dd2d3a4f4059956dc2905"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a3d859164653dd2d3a4f4059956dc2905">unparseBinaryFormat</a> (const std::string &amp;name, <a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *)</td></tr>
<tr class="memdesc:a3d859164653dd2d3a4f4059956dc2905 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debugging information into a named text file.  <br /></td></tr>
<tr class="separator:a3d859164653dd2d3a4f4059956dc2905 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885ef99b6198532dddad56053ff523c6 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a885ef99b6198532dddad56053ff523c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a885ef99b6198532dddad56053ff523c6">unparseBinaryFormat</a> (std::ostream &amp;, <a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *)</td></tr>
<tr class="memdesc:a885ef99b6198532dddad56053ff523c6 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debugging information to specified stream.  <br /></td></tr>
<tr class="separator:a885ef99b6198532dddad56053ff523c6 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7616620194d3bf24def0e91dc41953 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a2b7616620194d3bf24def0e91dc41953"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a2b7616620194d3bf24def0e91dc41953">initDiagnostics</a> ()</td></tr>
<tr class="memdesc:a2b7616620194d3bf24def0e91dc41953 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize diagnostic streams.  <br /></td></tr>
<tr class="separator:a2b7616620194d3bf24def0e91dc41953 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e5cfd8e6810197dd67c2e4ccbe1fb8 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_ae0e5cfd8e6810197dd67c2e4ccbe1fb8"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>isaFamilyToString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:ae0e5cfd8e6810197dd67c2e4ccbe1fb8 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1056f2e50b1e7c8f1ae97165a61885 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a1f1056f2e50b1e7c8f1ae97165a61885"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>isaToString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:a1f1056f2e50b1e7c8f1ae97165a61885 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf7d9e91e6fa7c91606093082d73587 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_aadf7d9e91e6fa7c91606093082d73587"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:aadf7d9e91e6fa7c91606093082d73587 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51841eee783e4247474427932ce473d7 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a51841eee783e4247474427932ce473d7"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65d">SgAsmExecutableFileFormat::ExecFamily</a>)</td></tr>
<tr class="separator:a51841eee783e4247474427932ce473d7 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddcc7908feb4b25276f3370a1f416c7 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a1ddcc7908feb4b25276f3370a1f416c7"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17">SgAsmExecutableFileFormat::ExecABI</a>)</td></tr>
<tr class="separator:a1ddcc7908feb4b25276f3370a1f416c7 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5cbaeaeb12235992d41b658973a887 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a3c5cbaeaeb12235992d41b658973a887"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732a">SgAsmExecutableFileFormat::ExecPurpose</a>)</td></tr>
<tr class="separator:a3c5cbaeaeb12235992d41b658973a887 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b40ef50df8c02cb92cb97233eaeb40e inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a3b40ef50df8c02cb92cb97233eaeb40e"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>isa_family_to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:a3b40ef50df8c02cb92cb97233eaeb40e inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae400b83f827436f60f15fd04add2767f inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_ae400b83f827436f60f15fd04add2767f"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>isa_to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:ae400b83f827436f60f15fd04add2767f inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5ecea2c8b38e1e25a7c06bb970caac inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_abf5ecea2c8b38e1e25a7c06bb970caac"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#ae83545a0f1393e82be1225c168ba5224">SgAsmExecutableFileFormat::InsSetArchitecture</a>)</td></tr>
<tr class="separator:abf5ecea2c8b38e1e25a7c06bb970caac inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ff9c61117ec03d3d99b09fd25f9cf inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_ab55ff9c61117ec03d3d99b09fd25f9cf"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#aa4a1858391921731cd54cf531fcfa65d">SgAsmExecutableFileFormat::ExecFamily</a>)</td></tr>
<tr class="separator:ab55ff9c61117ec03d3d99b09fd25f9cf inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638bc803aeb37207412e0e937df5718 inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a1638bc803aeb37207412e0e937df5718"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#a8624b5b893e68f75dceec02588a4cd17">SgAsmExecutableFileFormat::ExecABI</a>)</td></tr>
<tr class="separator:a1638bc803aeb37207412e0e937df5718 inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2af5c5b48d08ae849c2489d4316b6d inherit pub_static_methods_classSgAsmExecutableFileFormat" id="r_a8c2af5c5b48d08ae849c2489d4316b6d"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="classSgAsmExecutableFileFormat.html#a27fc70e134433bff16d86749ed5c732a">SgAsmExecutableFileFormat::ExecPurpose</a>)</td></tr>
<tr class="separator:a8c2af5c5b48d08ae849c2489d4316b6d inherit pub_static_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSgNode')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:ae72130a2186bf786ed11bc3779525a30 inherit pub_static_methods_classSgNode" id="r_ae72130a2186bf786ed11bc3779525a30"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteMemoryPool</b> ()</td></tr>
<tr class="separator:ae72130a2186bf786ed11bc3779525a30 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode" id="r_ab6b9cf345bf5500bea5655fd1af4c700"><td class="memItemLeft" align="right" valign="top">
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfNodes</b> ()</td></tr>
<tr class="memdesc:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of IR nodes of this type. <br /></td></tr>
<tr class="separator:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode" id="r_adb5267af9b8e5a132c5e01718fc5e0c3"><td class="memItemLeft" align="right" valign="top">
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memoryUsage</b> ()</td></tr>
<tr class="memdesc:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the total memory allocated for all IR nodes of this type. <br /></td></tr>
<tr class="separator:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode" id="r_adb939c489834d1860d8d9ff01df41592"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>traverseMemoryPoolNodes</b> (<a class="el" href="classROSE__VisitTraversal.html">ROSE_VisitTraversal</a> &amp;visit)</td></tr>
<tr class="memdesc:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern over all IR nodes by type of IR node. <br /></td></tr>
<tr class="separator:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode" id="r_ad118bfc06f7cade49a62d9eab5bdaa94"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>traverseMemoryPoolVisitorPattern</b> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern. <br /></td></tr>
<tr class="separator:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode" id="r_aa88cb0725cc125647f593549a3411579"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>visitRepresentativeNode</b> (<a class="el" href="classROSE__VisitTraversal.html">ROSE_VisitTraversal</a> &amp;visit)</td></tr>
<tr class="memdesc:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for type-based traversal. <br /></td></tr>
<tr class="separator:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode" id="r_ad3fbc32bd2deecd9c2d577ab26023a4d"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeByNodeId</b> (VariantT <a class="el" href="classSgNode.html#a7c9a652bb8435da633422a2440c64541">variantT</a>, size_t poolIdx, size_t itemIdx)</td></tr>
<tr class="memdesc:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node by its variant type, pool index, and item index. <br /></td></tr>
<tr class="separator:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode" id="r_af18f29e1a3f9ceb28756d3a0c2759c0b"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeByNodeIdInternal</b> (size_t poolIdx, size_t itemIdx)</td></tr>
<tr class="memdesc:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Find an <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> from its memory pool and location therin. <br /></td></tr>
<tr class="separator:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode" id="r_a42931e0c37df98010e022856aabdb69d"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeIdString</b> (<a class="el" href="classSgNode.html">SgNode</a> *sgnode)</td></tr>
<tr class="memdesc:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the NodeId for a particular SgNode*. <br /></td></tr>
<tr class="separator:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa33d7d56c2097a8357c52130aeeed9c inherit pub_static_methods_classSgNode" id="r_afa33d7d56c2097a8357c52130aeeed9c"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeIdStringInternal</b> (<a class="el" href="classSgNode.html">SgNode</a> *sgnode)</td></tr>
<tr class="separator:afa33d7d56c2097a8357c52130aeeed9c inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode" id="r_a990a5dada5673f783c37568ce998f6b3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a990a5dada5673f783c37568ce998f6b3">buildCommandLineToSubstituteTransformationFile</a> (const std::vector&lt; std::string &gt; &amp;argv, std::string newFileName)</td></tr>
<tr class="memdesc:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line support for this compilation The command line is saved as a static variable so that it will be available to support the rewrite mechanism.  <br /></td></tr>
<tr class="separator:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50d202c42e0df8942e9284900ae8137 inherit pub_static_methods_classSgNode" id="r_ae50d202c42e0df8942e9284900ae8137"><td class="memItemLeft" align="right" valign="top">
static std::vector&lt; VariantT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getClassHierarchySubTreeFunction</b> (VariantT v)</td></tr>
<tr class="separator:ae50d202c42e0df8942e9284900ae8137 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44122613a477c66fbac5b8727bc8c63 inherit pub_static_methods_classSgNode" id="r_aa44122613a477c66fbac5b8727bc8c63"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>getClassHierarchySubTreeFunction</b> (VariantT v, std::vector&lt; VariantT &gt; &amp;)</td></tr>
<tr class="separator:aa44122613a477c66fbac5b8727bc8c63 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode" id="r_aad4f45df9fd4503f6bf26eee0e037c84"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aad4f45df9fd4503f6bf26eee0e037c84">get_globalMangledNameMap</a> ()</td></tr>
<tr class="memdesc:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for performance optimizing global mangled name map.  <br /></td></tr>
<tr class="separator:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode" id="r_a04e7c67a1b500af8a87ad1b2a6d876e1"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGlobalMangledNameMap</b> ()</td></tr>
<tr class="memdesc:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support to clear the performance optimizing global mangled name map. <br /></td></tr>
<tr class="separator:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode" id="r_afd79324976600b7f1c72fdbe781ab136"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afd79324976600b7f1c72fdbe781ab136">get_shortMangledNameCache</a> ()</td></tr>
<tr class="memdesc:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for lower level optimizing of global mangled name map.  <br /></td></tr>
<tr class="separator:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode" id="r_a5a8f0d8071004dd845926a9b72e64cfb"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5a8f0d8071004dd845926a9b72e64cfb">get_globalQualifiedNameMapForNames</a> ()</td></tr>
<tr class="memdesc:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names).  <br /></td></tr>
<tr class="separator:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode" id="r_a35f76eb5ae3140ebf76ea6d526040623"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a35f76eb5ae3140ebf76ea6d526040623">set_globalQualifiedNameMapForNames</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names).  <br /></td></tr>
<tr class="separator:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode" id="r_a71dd1395d914fd5868d6c8d65d02f7d2"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a71dd1395d914fd5868d6c8d65d02f7d2">get_globalQualifiedNameMapForTypes</a> ()</td></tr>
<tr class="memdesc:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for type).  <br /></td></tr>
<tr class="separator:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode" id="r_ae20b9e11f7b97c3c9e45fb9f49fe3489"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae20b9e11f7b97c3c9e45fb9f49fe3489">set_globalQualifiedNameMapForTypes</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for type).  <br /></td></tr>
<tr class="separator:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode" id="r_a7a044e5d834c3b4a9f37c0bd5ff640f5"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7a044e5d834c3b4a9f37c0bd5ff640f5">get_globalQualifiedNameMapForMapsOfTypes</a> ()</td></tr>
<tr class="memdesc:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for maps of types).  <br /></td></tr>
<tr class="separator:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode" id="r_a5865eb7cffbcf0c4b59901e1ddb82e2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5865eb7cffbcf0c4b59901e1ddb82e2b">set_globalQualifiedNameMapForMapsOfTypes</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for maps of types).  <br /></td></tr>
<tr class="separator:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode" id="r_aa1e011be4cad10e33975ad91d0857b1a"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa1e011be4cad10e33975ad91d0857b1a">get_globalQualifiedNameMapForTemplateHeaders</a> ()</td></tr>
<tr class="memdesc:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for template headers in template declarations).  <br /></td></tr>
<tr class="separator:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode" id="r_a3ac52de7c460ef4073865aefc39201ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3ac52de7c460ef4073865aefc39201ab">set_globalQualifiedNameMapForTemplateHeaders</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for template headers in template declarations).  <br /></td></tr>
<tr class="separator:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode" id="r_ab6812987b6e9bcfaf9837777ef482292"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab6812987b6e9bcfaf9837777ef482292">get_globalTypeNameMap</a> ()</td></tr>
<tr class="memdesc:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names of types).  <br /></td></tr>
<tr class="separator:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode" id="r_adcbb5ff78ec7dad2b9f276a33504348a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#adcbb5ff78ec7dad2b9f276a33504348a">set_globalTypeNameMap</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names of types).  <br /></td></tr>
<tr class="separator:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode" id="r_ac7543cd1a0753e22696c65b59e762b80"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_globalFunctionTypeTable</b> ()</td></tr>
<tr class="memdesc:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to function types. <br /></td></tr>
<tr class="separator:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode" id="r_ae6db1ea8b3044f7c6bbfba3a9cc3ea8b"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_globalFunctionTypeTable</b> (<a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a> *globalFunctionTypeTable)</td></tr>
<tr class="memdesc:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to function types. <br /></td></tr>
<tr class="separator:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode" id="r_a180a7e75f06f5c4b6f271b427d094fc0"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgTypeTable.html">SgTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_globalTypeTable</b> ()</td></tr>
<tr class="memdesc:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to non-function types. <br /></td></tr>
<tr class="separator:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode" id="r_a8e59c06d1063ab7bc23cec9d1d3afe86"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_globalTypeTable</b> (<a class="el" href="classSgTypeTable.html">SgTypeTable</a> *globalTypeTable)</td></tr>
<tr class="memdesc:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to non-function types. <br /></td></tr>
<tr class="separator:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143872d405142f47be32ab0fcad4194 inherit pub_static_methods_classSgNode" id="r_a0143872d405142f47be32ab0fcad4194"><td class="memItemLeft" align="right" valign="top">
static VariantT&#160;</td><td class="memItemRight" valign="bottom"><b>variantFromPool</b> (<a class="el" href="classSgNode.html">SgNode</a> const *n)</td></tr>
<tr class="separator:a0143872d405142f47be32ab0fcad4194 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode" id="r_aa0a671458fc85d51de9c1960fd43d513"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classSgNode.html">SgNode</a>, T &gt;::value, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa0a671458fc85d51de9c1960fd43d513">createAndParent</a> (<a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a new node after setting its parent.  <br /></td></tr>
<tr class="separator:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72130a2186bf786ed11bc3779525a30 inherit pub_static_methods_classSgNode" id="r_ae72130a2186bf786ed11bc3779525a30"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteMemoryPool</b> ()</td></tr>
<tr class="separator:ae72130a2186bf786ed11bc3779525a30 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode" id="r_ab6b9cf345bf5500bea5655fd1af4c700"><td class="memItemLeft" align="right" valign="top">
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfNodes</b> ()</td></tr>
<tr class="memdesc:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of IR nodes of this type. <br /></td></tr>
<tr class="separator:ab6b9cf345bf5500bea5655fd1af4c700 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode" id="r_adb5267af9b8e5a132c5e01718fc5e0c3"><td class="memItemLeft" align="right" valign="top">
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>memoryUsage</b> ()</td></tr>
<tr class="memdesc:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the total memory allocated for all IR nodes of this type. <br /></td></tr>
<tr class="separator:adb5267af9b8e5a132c5e01718fc5e0c3 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode" id="r_adb939c489834d1860d8d9ff01df41592"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>traverseMemoryPoolNodes</b> (<a class="el" href="classROSE__VisitTraversal.html">ROSE_VisitTraversal</a> &amp;visit)</td></tr>
<tr class="memdesc:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern over all IR nodes by type of IR node. <br /></td></tr>
<tr class="separator:adb939c489834d1860d8d9ff01df41592 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode" id="r_ad118bfc06f7cade49a62d9eab5bdaa94"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>traverseMemoryPoolVisitorPattern</b> (<a class="el" href="classROSE__VisitorPattern.html">ROSE_VisitorPattern</a> &amp;visitor)</td></tr>
<tr class="memdesc:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for visitor pattern. <br /></td></tr>
<tr class="separator:ad118bfc06f7cade49a62d9eab5bdaa94 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode" id="r_aa88cb0725cc125647f593549a3411579"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>visitRepresentativeNode</b> (<a class="el" href="classROSE__VisitTraversal.html">ROSE_VisitTraversal</a> &amp;visit)</td></tr>
<tr class="memdesc:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Support for type-based traversal. <br /></td></tr>
<tr class="separator:aa88cb0725cc125647f593549a3411579 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode" id="r_ad3fbc32bd2deecd9c2d577ab26023a4d"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeByNodeId</b> (VariantT <a class="el" href="classSgNode.html#a7c9a652bb8435da633422a2440c64541">variantT</a>, size_t poolIdx, size_t itemIdx)</td></tr>
<tr class="memdesc:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node by its variant type, pool index, and item index. <br /></td></tr>
<tr class="separator:ad3fbc32bd2deecd9c2d577ab26023a4d inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode" id="r_af18f29e1a3f9ceb28756d3a0c2759c0b"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeByNodeIdInternal</b> (size_t poolIdx, size_t itemIdx)</td></tr>
<tr class="memdesc:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>FOR</b> <b>INTERNAL</b> <b>USE</b> Find an <a class="el" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> from its memory pool and location therin. <br /></td></tr>
<tr class="separator:af18f29e1a3f9ceb28756d3a0c2759c0b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode" id="r_a42931e0c37df98010e022856aabdb69d"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeIdString</b> (<a class="el" href="classSgNode.html">SgNode</a> *sgnode)</td></tr>
<tr class="memdesc:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the NodeId for a particular SgNode*. <br /></td></tr>
<tr class="separator:a42931e0c37df98010e022856aabdb69d inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa33d7d56c2097a8357c52130aeeed9c inherit pub_static_methods_classSgNode" id="r_afa33d7d56c2097a8357c52130aeeed9c"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeIdStringInternal</b> (<a class="el" href="classSgNode.html">SgNode</a> *sgnode)</td></tr>
<tr class="separator:afa33d7d56c2097a8357c52130aeeed9c inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode" id="r_a990a5dada5673f783c37568ce998f6b3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a990a5dada5673f783c37568ce998f6b3">buildCommandLineToSubstituteTransformationFile</a> (const std::vector&lt; std::string &gt; &amp;argv, std::string newFileName)</td></tr>
<tr class="memdesc:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line support for this compilation The command line is saved as a static variable so that it will be available to support the rewrite mechanism.  <br /></td></tr>
<tr class="separator:a990a5dada5673f783c37568ce998f6b3 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50d202c42e0df8942e9284900ae8137 inherit pub_static_methods_classSgNode" id="r_ae50d202c42e0df8942e9284900ae8137"><td class="memItemLeft" align="right" valign="top">
static std::vector&lt; VariantT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getClassHierarchySubTreeFunction</b> (VariantT v)</td></tr>
<tr class="separator:ae50d202c42e0df8942e9284900ae8137 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44122613a477c66fbac5b8727bc8c63 inherit pub_static_methods_classSgNode" id="r_aa44122613a477c66fbac5b8727bc8c63"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>getClassHierarchySubTreeFunction</b> (VariantT v, std::vector&lt; VariantT &gt; &amp;)</td></tr>
<tr class="separator:aa44122613a477c66fbac5b8727bc8c63 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode" id="r_aad4f45df9fd4503f6bf26eee0e037c84"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aad4f45df9fd4503f6bf26eee0e037c84">get_globalMangledNameMap</a> ()</td></tr>
<tr class="memdesc:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for performance optimizing global mangled name map.  <br /></td></tr>
<tr class="separator:aad4f45df9fd4503f6bf26eee0e037c84 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode" id="r_a04e7c67a1b500af8a87ad1b2a6d876e1"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGlobalMangledNameMap</b> ()</td></tr>
<tr class="memdesc:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support to clear the performance optimizing global mangled name map. <br /></td></tr>
<tr class="separator:a04e7c67a1b500af8a87ad1b2a6d876e1 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode" id="r_afd79324976600b7f1c72fdbe781ab136"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#afd79324976600b7f1c72fdbe781ab136">get_shortMangledNameCache</a> ()</td></tr>
<tr class="memdesc:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for lower level optimizing of global mangled name map.  <br /></td></tr>
<tr class="separator:afd79324976600b7f1c72fdbe781ab136 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode" id="r_a5a8f0d8071004dd845926a9b72e64cfb"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5a8f0d8071004dd845926a9b72e64cfb">get_globalQualifiedNameMapForNames</a> ()</td></tr>
<tr class="memdesc:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names).  <br /></td></tr>
<tr class="separator:a5a8f0d8071004dd845926a9b72e64cfb inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode" id="r_a35f76eb5ae3140ebf76ea6d526040623"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a35f76eb5ae3140ebf76ea6d526040623">set_globalQualifiedNameMapForNames</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names).  <br /></td></tr>
<tr class="separator:a35f76eb5ae3140ebf76ea6d526040623 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode" id="r_a71dd1395d914fd5868d6c8d65d02f7d2"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a71dd1395d914fd5868d6c8d65d02f7d2">get_globalQualifiedNameMapForTypes</a> ()</td></tr>
<tr class="memdesc:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for type).  <br /></td></tr>
<tr class="separator:a71dd1395d914fd5868d6c8d65d02f7d2 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode" id="r_ae20b9e11f7b97c3c9e45fb9f49fe3489"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae20b9e11f7b97c3c9e45fb9f49fe3489">set_globalQualifiedNameMapForTypes</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for type).  <br /></td></tr>
<tr class="separator:ae20b9e11f7b97c3c9e45fb9f49fe3489 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode" id="r_a7a044e5d834c3b4a9f37c0bd5ff640f5"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a7a044e5d834c3b4a9f37c0bd5ff640f5">get_globalQualifiedNameMapForMapsOfTypes</a> ()</td></tr>
<tr class="memdesc:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for maps of types).  <br /></td></tr>
<tr class="separator:a7a044e5d834c3b4a9f37c0bd5ff640f5 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode" id="r_a5865eb7cffbcf0c4b59901e1ddb82e2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a5865eb7cffbcf0c4b59901e1ddb82e2b">set_globalQualifiedNameMapForMapsOfTypes</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for maps of types).  <br /></td></tr>
<tr class="separator:a5865eb7cffbcf0c4b59901e1ddb82e2b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode" id="r_aa1e011be4cad10e33975ad91d0857b1a"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa1e011be4cad10e33975ad91d0857b1a">get_globalQualifiedNameMapForTemplateHeaders</a> ()</td></tr>
<tr class="memdesc:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for template headers in template declarations).  <br /></td></tr>
<tr class="separator:aa1e011be4cad10e33975ad91d0857b1a inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode" id="r_a3ac52de7c460ef4073865aefc39201ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3ac52de7c460ef4073865aefc39201ab">set_globalQualifiedNameMapForTemplateHeaders</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for template headers in template declarations).  <br /></td></tr>
<tr class="separator:a3ac52de7c460ef4073865aefc39201ab inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode" id="r_ab6812987b6e9bcfaf9837777ef482292"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ab6812987b6e9bcfaf9837777ef482292">get_globalTypeNameMap</a> ()</td></tr>
<tr class="memdesc:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names of types).  <br /></td></tr>
<tr class="separator:ab6812987b6e9bcfaf9837777ef482292 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode" id="r_adcbb5ff78ec7dad2b9f276a33504348a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#adcbb5ff78ec7dad2b9f276a33504348a">set_globalTypeNameMap</a> (const std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &amp;X)</td></tr>
<tr class="memdesc:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for name qualification support (for names of types).  <br /></td></tr>
<tr class="separator:adcbb5ff78ec7dad2b9f276a33504348a inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode" id="r_ac7543cd1a0753e22696c65b59e762b80"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_globalFunctionTypeTable</b> ()</td></tr>
<tr class="memdesc:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to function types. <br /></td></tr>
<tr class="separator:ac7543cd1a0753e22696c65b59e762b80 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode" id="r_ae6db1ea8b3044f7c6bbfba3a9cc3ea8b"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_globalFunctionTypeTable</b> (<a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a> *globalFunctionTypeTable)</td></tr>
<tr class="memdesc:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to function types. <br /></td></tr>
<tr class="separator:ae6db1ea8b3044f7c6bbfba3a9cc3ea8b inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode" id="r_a180a7e75f06f5c4b6f271b427d094fc0"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classSgTypeTable.html">SgTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_globalTypeTable</b> ()</td></tr>
<tr class="memdesc:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to non-function types. <br /></td></tr>
<tr class="separator:a180a7e75f06f5c4b6f271b427d094fc0 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode" id="r_a8e59c06d1063ab7bc23cec9d1d3afe86"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_globalTypeTable</b> (<a class="el" href="classSgTypeTable.html">SgTypeTable</a> *globalTypeTable)</td></tr>
<tr class="memdesc:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access function for symbol table specific to non-function types. <br /></td></tr>
<tr class="separator:a8e59c06d1063ab7bc23cec9d1d3afe86 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143872d405142f47be32ab0fcad4194 inherit pub_static_methods_classSgNode" id="r_a0143872d405142f47be32ab0fcad4194"><td class="memItemLeft" align="right" valign="top">
static VariantT&#160;</td><td class="memItemRight" valign="bottom"><b>variantFromPool</b> (<a class="el" href="classSgNode.html">SgNode</a> const *n)</td></tr>
<tr class="separator:a0143872d405142f47be32ab0fcad4194 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode" id="r_aa0a671458fc85d51de9c1960fd43d513"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classSgNode.html">SgNode</a>, T &gt;::value, T * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSgNode.html#aa0a671458fc85d51de9c1960fd43d513">createAndParent</a> (<a class="el" href="classSgNode.html">SgNode</a> *parent)</td></tr>
<tr class="memdesc:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a new node after setting its parent.  <br /></td></tr>
<tr class="separator:aa0a671458fc85d51de9c1960fd43d513 inherit pub_static_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8b7ca2c0a9e1fb14deb75ceb5d9d487e" id="r_a8b7ca2c0a9e1fb14deb75ceb5d9d487e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a8b7ca2c0a9e1fb14deb75ceb5d9d487e">destructorHelper</a> () override</td></tr>
<tr class="memdesc:a8b7ca2c0a9e1fb14deb75ceb5d9d487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets called by all Rosebud-generated destructors.  <br /></td></tr>
<tr class="separator:a8b7ca2c0a9e1fb14deb75ceb5d9d487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c649e7b84715d29a966873d80900983" id="r_a0c649e7b84715d29a966873d80900983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmGenericFile.html#a0c649e7b84715d29a966873d80900983">initializeProperties</a> ()</td></tr>
<tr class="memdesc:a0c649e7b84715d29a966873d80900983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all properties that have explicit initial values.  <br /></td></tr>
<tr class="separator:a0c649e7b84715d29a966873d80900983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSgAsmExecutableFileFormat"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSgAsmExecutableFileFormat')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSgAsmExecutableFileFormat.html">SgAsmExecutableFileFormat</a></td></tr>
<tr class="memitem:a945a2c3d73f408532c520d25e769283a inherit pro_methods_classSgAsmExecutableFileFormat" id="r_a945a2c3d73f408532c520d25e769283a"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>SgAsmExecutableFileFormat</b> ()</td></tr>
<tr class="memdesc:a945a2c3d73f408532c520d25e769283a inherit pro_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a945a2c3d73f408532c520d25e769283a inherit pro_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b443686b75fb44dd23507f2dadd939 inherit pro_methods_classSgAsmExecutableFileFormat" id="r_a99b443686b75fb44dd23507f2dadd939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a99b443686b75fb44dd23507f2dadd939">initializeProperties</a> ()</td></tr>
<tr class="memdesc:a99b443686b75fb44dd23507f2dadd939 inherit pro_methods_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all properties that have explicit initial values.  <br /></td></tr>
<tr class="separator:a99b443686b75fb44dd23507f2dadd939 inherit pro_methods_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSgAsmNode"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSgAsmNode')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSgAsmNode.html">SgAsmNode</a></td></tr>
<tr class="memitem:a0f6b0db2a2da87d1f0dceb54aee0f9b7 inherit pro_methods_classSgAsmNode" id="r_a0f6b0db2a2da87d1f0dceb54aee0f9b7"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>SgAsmNode</b> ()</td></tr>
<tr class="memdesc:a0f6b0db2a2da87d1f0dceb54aee0f9b7 inherit pro_methods_classSgAsmNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a0f6b0db2a2da87d1f0dceb54aee0f9b7 inherit pro_methods_classSgAsmNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa454ee12560558fcaf97eff236a5d5 inherit pro_methods_classSgAsmNode" id="r_aefa454ee12560558fcaf97eff236a5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmNode.html#aefa454ee12560558fcaf97eff236a5d5">initializeProperties</a> ()</td></tr>
<tr class="memdesc:aefa454ee12560558fcaf97eff236a5d5 inherit pro_methods_classSgAsmNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all properties that have explicit initial values.  <br /></td></tr>
<tr class="separator:aefa454ee12560558fcaf97eff236a5d5 inherit pro_methods_classSgAsmNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSgNode')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode" id="r_adcd43e8897cd3d612c6bf876c495cc8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#adcd43e8897cd3d612c6bf876c495cc8a">post_construction_initialization</a> ()</td></tr>
<tr class="memdesc:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final initialization for constructors This function is called at the end of generated constructors to allow the specification writer to add special initialization functions or tests. Default is to do nothing. Otherwise it should be overridden in the spec file, in NewHeaderCode/NewOutlinedCode.  <br /></td></tr>
<tr class="separator:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode" id="r_adcd43e8897cd3d612c6bf876c495cc8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#adcd43e8897cd3d612c6bf876c495cc8a">post_construction_initialization</a> ()</td></tr>
<tr class="memdesc:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final initialization for constructors This function is called at the end of generated constructors to allow the specification writer to add special initialization functions or tests. Default is to do nothing. Otherwise it should be overridden in the spec file, in NewHeaderCode/NewOutlinedCode.  <br /></td></tr>
<tr class="separator:adcd43e8897cd3d612c6bf876c495cc8a inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode" id="r_a8c7576ab9ac41494d497be7e569d3e6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8c7576ab9ac41494d497be7e569d3e6c">debugSerializationBegin</a> (const char *className)</td></tr>
<tr class="memdesc:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by generated serializers.  <br /></td></tr>
<tr class="separator:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode" id="r_a3a7703e0b030216b1ca4665f7b5af44b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3a7703e0b030216b1ca4665f7b5af44b">debugSerializationEnd</a> (const char *className)</td></tr>
<tr class="memdesc:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by generated serializers.  <br /></td></tr>
<tr class="separator:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode" id="r_a8c7576ab9ac41494d497be7e569d3e6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8c7576ab9ac41494d497be7e569d3e6c">debugSerializationBegin</a> (const char *className)</td></tr>
<tr class="memdesc:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by generated serializers.  <br /></td></tr>
<tr class="separator:a8c7576ab9ac41494d497be7e569d3e6c inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode" id="r_a3a7703e0b030216b1ca4665f7b5af44b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3a7703e0b030216b1ca4665f7b5af44b">debugSerializationEnd</a> (const char *className)</td></tr>
<tr class="memdesc:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by generated serializers.  <br /></td></tr>
<tr class="separator:a3a7703e0b030216b1ca4665f7b5af44b inherit pro_methods_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classSgAsmExecutableFileFormat"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classSgAsmExecutableFileFormat')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classSgAsmExecutableFileFormat.html">SgAsmExecutableFileFormat</a></td></tr>
<tr class="memitem:a0baa46cabcd118e86d9d49e3585bef13 inherit pub_static_attribs_classSgAsmExecutableFileFormat" id="r_a0baa46cabcd118e86d9d49e3585bef13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSawyer_1_1Message_1_1Facility.html">Sawyer::Message::Facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgAsmExecutableFileFormat.html#a0baa46cabcd118e86d9d49e3585bef13">mlog</a></td></tr>
<tr class="memdesc:a0baa46cabcd118e86d9d49e3585bef13 inherit pub_static_attribs_classSgAsmExecutableFileFormat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic stream.  <br /></td></tr>
<tr class="separator:a0baa46cabcd118e86d9d49e3585bef13 inherit pub_static_attribs_classSgAsmExecutableFileFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSgNode')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:a099db24d896d49debc48f475eb3cc254 inherit pro_attribs_classSgNode" id="r_a099db24d896d49debc48f475eb3cc254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a099db24d896d49debc48f475eb3cc254">p_parent</a></td></tr>
<tr class="memdesc:a099db24d896d49debc48f475eb3cc254 inherit pro_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the pointer to the parent IR node in the AST.  <br /></td></tr>
<tr class="separator:a099db24d896d49debc48f475eb3cc254 inherit pro_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedceb116d3e9ee421db9a63e28b54152 inherit pro_attribs_classSgNode" id="r_aedceb116d3e9ee421db9a63e28b54152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#aedceb116d3e9ee421db9a63e28b54152">p_isModified</a></td></tr>
<tr class="memdesc:aedceb116d3e9ee421db9a63e28b54152 inherit pro_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records if IR node has been modified (data members reset).  <br /></td></tr>
<tr class="separator:aedceb116d3e9ee421db9a63e28b54152 inherit pro_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671fad6d6802a79c086b7c4fe5338481 inherit pro_attribs_classSgNode" id="r_a671fad6d6802a79c086b7c4fe5338481"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a671fad6d6802a79c086b7c4fe5338481">p_containsTransformation</a></td></tr>
<tr class="separator:a671fad6d6802a79c086b7c4fe5338481 inherit pro_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19821bc93b4bbacf594dee9ac988c5b inherit pro_attribs_classSgNode" id="r_af19821bc93b4bbacf594dee9ac988c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#af19821bc93b4bbacf594dee9ac988c5b">p_freepointer</a></td></tr>
<tr class="memdesc:af19821bc93b4bbacf594dee9ac988c5b inherit pro_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the pointer to the chain of previously freed objects.  <br /></td></tr>
<tr class="separator:af19821bc93b4bbacf594dee9ac988c5b inherit pro_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classSgNode"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classSgNode')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classSgNode.html">SgNode</a></td></tr>
<tr class="memitem:abf05ae47b5bc2dd0b29e33b37956fecc inherit pro_static_attribs_classSgNode" id="r_abf05ae47b5bc2dd0b29e33b37956fecc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::tuple&lt; unsigned char *, unsigned, VariantT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#abf05ae47b5bc2dd0b29e33b37956fecc">all_pools</a></td></tr>
<tr class="separator:abf05ae47b5bc2dd0b29e33b37956fecc inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a009e105201bab5e652f0ed77be31ea inherit pro_static_attribs_classSgNode" id="r_a8a009e105201bab5e652f0ed77be31ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a8a009e105201bab5e652f0ed77be31ea">p_globalFunctionTypeTable</a></td></tr>
<tr class="memdesc:a8a009e105201bab5e652f0ed77be31ea inherit pro_static_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to symbol table specific to function types.  <br /></td></tr>
<tr class="separator:a8a009e105201bab5e652f0ed77be31ea inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a5cc6683353bc2df5dec1ca94744d4 inherit pro_static_attribs_classSgNode" id="r_a84a5cc6683353bc2df5dec1ca94744d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSgTypeTable.html">SgTypeTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a84a5cc6683353bc2df5dec1ca94744d4">p_globalTypeTable</a></td></tr>
<tr class="separator:a84a5cc6683353bc2df5dec1ca94744d4 inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c5b45e5216e99b0508e36ab22244ec inherit pro_static_attribs_classSgNode" id="r_ae4c5b45e5216e99b0508e36ab22244ec"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ae4c5b45e5216e99b0508e36ab22244ec">p_globalMangledNameMap</a></td></tr>
<tr class="memdesc:ae4c5b45e5216e99b0508e36ab22244ec inherit pro_static_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache of mangled names to avoid regeneration of previously build mangled names or parts of mangled names. This is a performance optimization.  <br /></td></tr>
<tr class="separator:ae4c5b45e5216e99b0508e36ab22244ec inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56459786fa853c6c0066a61cc323b9 inherit pro_static_attribs_classSgNode" id="r_ade56459786fa853c6c0066a61cc323b9"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#ade56459786fa853c6c0066a61cc323b9">p_shortMangledNameCache</a></td></tr>
<tr class="memdesc:ade56459786fa853c6c0066a61cc323b9 inherit pro_static_attribs_classSgNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL map used as a cache to shorten generated mangled names. This is mostly a space optimization ofr mangled names of templates.  <br /></td></tr>
<tr class="separator:ade56459786fa853c6c0066a61cc323b9 inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783fcb0072c4a49cf4474852eaf2ecd6 inherit pro_static_attribs_classSgNode" id="r_a783fcb0072c4a49cf4474852eaf2ecd6"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a783fcb0072c4a49cf4474852eaf2ecd6">p_globalQualifiedNameMapForNames</a></td></tr>
<tr class="separator:a783fcb0072c4a49cf4474852eaf2ecd6 inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446364fd7c2f25e237b489bc0fb48623 inherit pro_static_attribs_classSgNode" id="r_a446364fd7c2f25e237b489bc0fb48623"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a446364fd7c2f25e237b489bc0fb48623">p_globalQualifiedNameMapForTypes</a></td></tr>
<tr class="separator:a446364fd7c2f25e237b489bc0fb48623 inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf533c636e2a5ecb00e67383293b8e3b inherit pro_static_attribs_classSgNode" id="r_adf533c636e2a5ecb00e67383293b8e3b"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#adf533c636e2a5ecb00e67383293b8e3b">p_globalQualifiedNameMapForTemplateHeaders</a></td></tr>
<tr class="separator:adf533c636e2a5ecb00e67383293b8e3b inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85978d2546b54880958a7d7debd286ed inherit pro_static_attribs_classSgNode" id="r_a85978d2546b54880958a7d7debd286ed"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a85978d2546b54880958a7d7debd286ed">p_globalTypeNameMap</a></td></tr>
<tr class="separator:a85978d2546b54880958a7d7debd286ed inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3010f514d21a452991ddb3366b60afe4 inherit pro_static_attribs_classSgNode" id="r_a3010f514d21a452991ddb3366b60afe4"><td class="memItemLeft" align="right" valign="top">static std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgNode.html#a3010f514d21a452991ddb3366b60afe4">p_globalQualifiedNameMapForMapsOfTypes</a></td></tr>
<tr class="separator:a3010f514d21a452991ddb3366b60afe4 inherit pro_static_attribs_classSgNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae86e310e8abb3d0a044ee16e1bc6c9eb" name="ae86e310e8abb3d0a044ee16e1bc6c9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86e310e8abb3d0a044ee16e1bc6c9eb">&#9670;&#160;</a></span>AddressSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">SgAsmGenericFile::AddressSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Section modification functions for <a class="el" href="classSgAsmGenericFile.html#a83384bc3cba90b97c33d64871edc901d">shiftExtend</a>. </p>

<p class="definition">Definition at line <a class="el" href="binaryInstruction_8C_source.html#l15418">15418</a> of file <a class="el" href="binaryInstruction_8C_source.html">binaryInstruction.C</a>.</p>

</div>
</div>
<a id="af29ae621857658ed39d2524011eef404" name="af29ae621857658ed39d2524011eef404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29ae621857658ed39d2524011eef404">&#9670;&#160;</a></span>Elasticity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">SgAsmGenericFile::Elasticity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elasticity argument for <a class="el" href="classSgAsmGenericFile.html#a83384bc3cba90b97c33d64871edc901d">shiftExtend</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af29ae621857658ed39d2524011eef404a3118e0ab7640900385b0b6719c5e1b38" name="af29ae621857658ed39d2524011eef404a3118e0ab7640900385b0b6719c5e1b38"></a>ELASTIC_NONE&#160;</td><td class="fielddoc"><p>Nothing is elastic; other parts of space are shifted. </p>
</td></tr>
<tr><td class="fieldname"><a id="af29ae621857658ed39d2524011eef404a21e3926eefe9c11df0a7b9c7d0b2cf24" name="af29ae621857658ed39d2524011eef404a21e3926eefe9c11df0a7b9c7d0b2cf24"></a>ELASTIC_UNREF&#160;</td><td class="fielddoc"><p>Unreferenced address space is elastic. </p>
</td></tr>
<tr><td class="fieldname"><a id="af29ae621857658ed39d2524011eef404a4f653980791bcbb59a1d18d808cd41a9" name="af29ae621857658ed39d2524011eef404a4f653980791bcbb59a1d18d808cd41a9"></a>ELASTIC_HOLE&#160;</td><td class="fielddoc"><p>Unreferenced and "hole" sections are elastic. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="binaryInstruction_8C_source.html#l15425">15425</a> of file <a class="el" href="binaryInstruction_8C_source.html">binaryInstruction.C</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72172f73132bd0eff84e43996b342404" name="a72172f73132bd0eff84e43996b342404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72172f73132bd0eff84e43996b342404">&#9670;&#160;</a></span>get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int const  &amp; SgAsmGenericFile::get_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Read-only file descriptor. </p>
<p>Negative represents lack of valid file descriptor. </p>

</div>
</div>
<a id="a20d57c721cf3d617aec40247fb4b6d00" name="a20d57c721cf3d617aec40247fb4b6d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d57c721cf3d617aec40247fb4b6d00">&#9670;&#160;</a></span>set_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::set_fd </td>
          <td>(</td>
          <td class="paramtype">int const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Read-only file descriptor. </p>
<p>Negative represents lack of valid file descriptor. </p>

</div>
</div>
<a id="a23159c7bd620566feb92884834a1bbd2" name="a23159c7bd620566feb92884834a1bbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23159c7bd620566feb92884834a1bbd2">&#9670;&#160;</a></span>get_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericHeaderList.html">SgAsmGenericHeaderList</a> *const  &amp; SgAsmGenericFile::get_headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: List of all headers in file. </p>
<p>This is stored as a pointer to another node that contains the list due to limitations of ROSETTA. </p>

</div>
</div>
<a id="acc7bdaa9b19668370eb45b67c4b0984e" name="acc7bdaa9b19668370eb45b67c4b0984e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7bdaa9b19668370eb45b67c4b0984e">&#9670;&#160;</a></span>set_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::set_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeaderList.html">SgAsmGenericHeaderList</a> *const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: List of all headers in file. </p>
<p>This is stored as a pointer to another node that contains the list due to limitations of ROSETTA. </p>

</div>
</div>
<a id="a188cc62343dc85f4006acf2f8c58c5a6" name="a188cc62343dc85f4006acf2f8c58c5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188cc62343dc85f4006acf2f8c58c5a6">&#9670;&#160;</a></span>get_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *const  &amp; SgAsmGenericFile::get_holes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Addresses unreferenced during parsing. </p>
<p>This is a pointer to a node that contains a list of pointers to the holes. It is done this way rather than storing the list directly, because of limitations of ROSETTA. </p>

</div>
</div>
<a id="a239c63d6ca0c84e7f62689361054c55a" name="a239c63d6ca0c84e7f62689361054c55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239c63d6ca0c84e7f62689361054c55a">&#9670;&#160;</a></span>set_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::set_holes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Addresses unreferenced during parsing. </p>
<p>This is a pointer to a node that contains a list of pointers to the holes. It is done this way rather than storing the list directly, because of limitations of ROSETTA. </p>

</div>
</div>
<a id="a76038fa98a5f4d96501e67de9e0cd1cb" name="a76038fa98a5f4d96501e67de9e0cd1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76038fa98a5f4d96501e67de9e0cd1cb">&#9670;&#160;</a></span>unparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::unparse </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mirror image of parsing an executable file. </p>
<p>The result (unless the AST has been modified) should be identical to the original file. If the file's neuter property is true, then rather than creating a binary file, the output will contain a note indicating that the neuter property is set. This is intended to prevent ASTs that represent malicious binaries from accidently being used to create the binary. </p>

</div>
</div>
<a id="a6559122f82991a9e67cbaef2a0e81d14" name="a6559122f82991a9e67cbaef2a0e81d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6559122f82991a9e67cbaef2a0e81d14">&#9670;&#160;</a></span>dumpAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::dumpAll </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_cwd</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print text file containing all known information about a binary file. </p>
<p>If in_cwd is set, then the file is created in the current working directory rather than the directory containing the binary file (the default is to create the file in the current working directory). If <code>ext</code> is non-null then these characters are added to the end of the binary file name. The default null pointer causes the string ".dump" to be appended to the file name. </p>

</div>
</div>
<a id="aaed8b442eacc042f18dab8f20a26fb8e" name="aaed8b442eacc042f18dab8f20a26fb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed8b442eacc042f18dab8f20a26fb8e">&#9670;&#160;</a></span>get_dataConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataConverter.html">DataConverter</a> * SgAsmGenericFile::get_dataConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Data converter. </p>
<p><a class="el" href="classFunction.html">Function</a> to encode/decode data as it's transferred to/from disk. The default is to do no transformation. </p>

</div>
</div>
<a id="a932a10a09cfdf7827a1c700ce05f8a02" name="a932a10a09cfdf7827a1c700ce05f8a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932a10a09cfdf7827a1c700ce05f8a02">&#9670;&#160;</a></span>set_dataConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::set_dataConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataConverter.html">DataConverter</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Data converter. </p>
<p><a class="el" href="classFunction.html">Function</a> to encode/decode data as it's transferred to/from disk. The default is to do no transformation. </p>

</div>
</div>
<a id="a19dba6143fa4c50272edea03b56bf8ee" name="a19dba6143fa4c50272edea03b56bf8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dba6143fa4c50272edea03b56bf8ee">&#9670;&#160;</a></span>readContent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SgAsmGenericFile::readContent </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from a file. </p>
<p>Reads up to <code>size</code> bytes of data from the file beginning at the specified byte offset (measured from the beginning of the file), placing the result in <code>dst_buf</code>, and returning the number of bytes read. If the number of bytes read is less than <code>size</code> then one of two things happen: if <code>strict</code> is true then an <a class="el" href="classSgAsmExecutableFileFormat_1_1ShortRead.html">SgAsmExecutableFileFormat::ShortRead</a> exception is thrown; otherwise <code>dst_buf</code> is zero padded so that exactly <code>size</code> bytes are always initialized. </p>

</div>
</div>
<a id="a252f8814e2fe64cc3239b0e804997dbc" name="a252f8814e2fe64cc3239b0e804997dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252f8814e2fe64cc3239b0e804997dbc">&#9670;&#160;</a></span>readContent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SgAsmGenericFile::readContent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from a file. </p>
<p>Reads up to <code>size</code> bytes of data starting at the specified (absolute) virtual address. The <code>map</code> specifies how virtual addresses are mapped to file offsets. As bytes are read, if we encounter a virtual address that is not mapped we stop reading and do one of two things: if <code>strict</code> is set then a <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NotMapped.html">Rose::BinaryAnalysis::MemoryMap::NotMapped</a> exception is thrown; otherwise the rest of the <code>dst_buf</code> is zero filled and the number of bytes read (not filled) is returned. </p>

</div>
</div>
<a id="ac2379f9b8d4fb276f799724bc22140c0" name="ac2379f9b8d4fb276f799724bc22140c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2379f9b8d4fb276f799724bc22140c0">&#9670;&#160;</a></span>readContentString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SgAsmGenericFile::readContentString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1MemoryMap.html#a0dbb47f6fe164ce6ef8816f28dc93a1f">Rose::BinaryAnalysis::MemoryMap::Ptr</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string from a file. </p>
<p>Returns the string stored at the specified (absolute) virtual address. The returned string contains the bytes beginning at the starting virtual address and continuing until we reach a NUL byte or an address which is not mapped. If we reach an address which is not mapped then one of two things happen: if <code>strict</code> is set then a <a class="el" href="structRose_1_1BinaryAnalysis_1_1MemoryMap_1_1NotMapped.html">Rose::BinaryAnalysis::MemoryMap::NotMapped</a> exception is thrown; otherwise the string is simply terminated. The returned string does not include the NUL byte. </p>

</div>
</div>
<a id="ab040c5803ed38617694376851364b8b2" name="ab040c5803ed38617694376851364b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab040c5803ed38617694376851364b8b2">&#9670;&#160;</a></span>readContentString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SgAsmGenericFile::readContentString </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>abs_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string from a file. </p>
<p>Returns the NUL-terminated string stored at the specified relative virtual address. The returned string contains the bytes beginning at the specified starting file offset and continuing until we reach a NUL byte or an invalid file offset. If we reach an invalid file offset one of two things happen: if <code>strict</code> is set (the default) then an <a class="el" href="classSgAsmExecutableFileFormat_1_1ShortRead.html">SgAsmExecutableFileFormat::ShortRead</a> exception is thrown; otherwise the string is simply terminated. The returned string does not include the NUL byte. </p>

</div>
</div>
<a id="afde5f1c91419b93ebae83e10a9c2c02f" name="afde5f1c91419b93ebae83e10a9c2c02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde5f1c91419b93ebae83e10a9c2c02f">&#9670;&#160;</a></span>content() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSgSharedVector.html">SgFileContentList</a> &amp; SgAsmGenericFile::content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Entire file contents. </p>

<p class="definition">Definition at line <a class="el" href="binaryInstruction_8C_source.html#l15623">15623</a> of file <a class="el" href="binaryInstruction_8C_source.html">binaryInstruction.C</a>.</p>

</div>
</div>
<a id="a7886919c377cb42bb88cf5c8a17085ba" name="a7886919c377cb42bb88cf5c8a17085ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7886919c377cb42bb88cf5c8a17085ba">&#9670;&#160;</a></span>content() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgSharedVector.html">SgFileContentList</a> SgAsmGenericFile::content </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector that points to part of the file. </p>
<p>Returns a vector that points to part of the file content without actually ever reading or otherwise referencing the file content until the vector elements are referenced. If the desired extent falls entirely or partially outside the range of data known to the file then throw an <a class="el" href="classSgAsmExecutableFileFormat_1_1ShortRead.html">SgAsmExecutableFileFormat::ShortRead</a> exception. This function never updates reference tracking lists for the file. </p>

</div>
</div>
<a id="abfdf8ef66f15bc944b97180903a65ad0" name="abfdf8ef66f15bc944b97180903a65ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdf8ef66f15bc944b97180903a65ad0">&#9670;&#160;</a></span>get_sectionsByOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgAsmGenericSectionPtrList SgAsmGenericFile::get_sectionsByOffset </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find sections by their offset. </p>
<p>Returns all sections that contain all of the specified portion of the file across all headers, including headers and holes. </p>

</div>
</div>
<a id="a40404103a545c1b130be6e14eb047039" name="a40404103a545c1b130be6e14eb047039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40404103a545c1b130be6e14eb047039">&#9670;&#160;</a></span>get_sectionsByRva()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgAsmGenericSectionPtrList SgAsmGenericFile::get_sectionsByRva </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>rva</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find sections by address. </p>
<p>Returns all sections that are mapped to include the specified relative virtual address across all headers, including headers and holes. This uses the preferred mapping of the section rather than the actual mapping. </p>

</div>
</div>
<a id="af46017e4d4b908a0f15cb946aa97d56e" name="af46017e4d4b908a0f15cb946aa97d56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46017e4d4b908a0f15cb946aa97d56e">&#9670;&#160;</a></span>get_sectionsByVa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SgAsmGenericSectionPtrList SgAsmGenericFile::get_sectionsByVa </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find sections by address. </p>
<p>Returns all sections that are mapped to include the specified virtual address across all headers, including headers and holes. This uses the preferred mapping rather than the actual mapping. </p>

</div>
</div>
<a id="aa4b7870ced16eb1c8428138fd9251731" name="aa4b7870ced16eb1c8428138fd9251731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b7870ced16eb1c8428138fd9251731">&#9670;&#160;</a></span>get_sectionById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_sectionById </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section with specified ID. </p>
<p>Returns the pointer to section with the specified ID across all headers only if there's exactly one match. Headers and holes are included in the results. </p>

</div>
</div>
<a id="abdfc09503c7e77aa3c0b5390ebf3a0dc" name="abdfc09503c7e77aa3c0b5390ebf3a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfc09503c7e77aa3c0b5390ebf3a0dc">&#9670;&#160;</a></span>get_sectionByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_sectionByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section by name. </p>
<p>Returns pointer to the section with the specified name, or NULL if there isn't exactly one match. Any characters in the name after the first occurrence of SEP are ignored (default is NUL). For instance, if sep=='$' then the following names are all equivalent: .idata, .idata$, and .idata$1 </p>

</div>
</div>
<a id="a3237f487efa29c859f883a54a60f9ff6" name="a3237f487efa29c859f883a54a60f9ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3237f487efa29c859f883a54a60f9ff6">&#9670;&#160;</a></span>get_sectionByOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_sectionByOffset </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section by file offset. </p>
<p>Returns single section that contains all of the specified portion of the file across all headers, including headers and holes. </p>

</div>
</div>
<a id="a44e30b67244bc4726b7da0e16be52af1" name="a44e30b67244bc4726b7da0e16be52af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e30b67244bc4726b7da0e16be52af1">&#9670;&#160;</a></span>get_sectionByRva()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_sectionByRva </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>rva</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section by address. </p>
<p>Returns single section that is mapped to include the specified relative virtual file address across all headers, including headers and holes. </p>

</div>
</div>
<a id="a951c23913477cf2a8d4a644ecd615d8c" name="a951c23913477cf2a8d4a644ecd615d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951c23913477cf2a8d4a644ecd615d8c">&#9670;&#160;</a></span>get_sectionByVa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_sectionByVa </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section by address. </p>
<p>Returns single section that is mapped to include the specified virtual address across all headers. See also <a class="el" href="classSgAsmGenericFile.html#a32d262168c4fb85e97984fd72a61e4a5">get_bestSectionByVa</a>. </p>

</div>
</div>
<a id="a32d262168c4fb85e97984fd72a61e4a5" name="a32d262168c4fb85e97984fd72a61e4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d262168c4fb85e97984fd72a61e4a5">&#9670;&#160;</a></span>get_bestSectionByVa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::get_bestSectionByVa </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>nfound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find section by address. </p>
<p>Similar to <a class="el" href="classSgAsmGenericFile.html#a951c23913477cf2a8d4a644ecd615d8c">get_sectionByVa</a> except when more than one section contains the specified virtual address this choose the "best" one. All candidates must map the virtual address to the same file address or else we fail (return null and number of candidates). See <a class="el" href="classSgAsmGenericFile.html#abfccc26a6dfe20b01a7da8a52d98d7cc">bestSectionByVa</a> for definition of "best". </p>

</div>
</div>
<a id="abfccc26a6dfe20b01a7da8a52d98d7cc" name="abfccc26a6dfe20b01a7da8a52d98d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfccc26a6dfe20b01a7da8a52d98d7cc">&#9670;&#160;</a></span>bestSectionByVa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> * SgAsmGenericFile::bestSectionByVa </td>
          <td>(</td>
          <td class="paramtype">const SgAsmGenericSectionPtrList &amp;&#160;</td>
          <td class="paramname"><em>sections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition for "best". </p>
<p>This is the definition of "best" as used by <a class="el" href="classSgAsmGenericFile.html#a32d262168c4fb85e97984fd72a61e4a5">get_bestSectionByVa</a> and <a class="el" href="classSgAsmGenericHeader.html#adbe8794f3bdc7d041aca53177311734d">SgAsmGenericHeader::get_bestSectionByVa</a>. The specified list of sections is scanned and the best one containing the specified virtual address is returned. The operation is equivalent to the successive elimination of bad sections: first eliminate all sections that do not contain the virtual address. If more than one remains, eliminate all but the smallest. If two or more are tied in size and at least one has a name, eliminate those that don't have names. If more than one section remains, return the section that is earliest in the specified list of sections. Return the null pointer if no section contains the specified virtual address, or if any two sections that contain the virtual address map it to different parts of the underlying binary file. </p>

</div>
</div>
<a id="a83384bc3cba90b97c33d64871edc901d" name="a83384bc3cba90b97c33d64871edc901d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83384bc3cba90b97c33d64871edc901d">&#9670;&#160;</a></span>shiftExtend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::shiftExtend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericFile.html#ae86e310e8abb3d0a044ee16e1bc6c9eb">AddressSpace</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericFile.html#af29ae621857658ed39d2524011eef404">Elasticity</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves and enlarges a section. </p>
<p>Shifts (to a higher offset) and/or enlarges the specified section, S, taking all other sections into account. The positions of sections are based on their preferred virtual mappings rather than the actual mapping.</p>
<p>The neighborhood(S) is S itself and the set of all sections that overlap or are adjacent to the neighborhood of S, recursively.</p>
<p>The address space can be partitioned into three categories: </p><ul>
<li>Section: part of an address space that is referenced by an <a class="el" href="classSgAsmGenericSection.html" title="Contiguous region of a file.">SgAsmGenericSection</a> other than a "hole" section. </li>
<li>Hole: part of an address space that is referenced only by a "hole" section. </li>
<li>Unref: part of an address space that is not used by any section, including any "hole" section.</li>
</ul>
<p>The last two categories define parts of the address space that can be optionally elastic&ndash;they expand or contract to take up slack or provide space for neighboring sections. This is controlled by the "elasticity" argument.</p>
<p>Note that when elasticity is ELASTIC_HOLE we simply ignore the "hole" sections, effectively removing their addresses from the range of addresses under consideration. This avoids complications that arise when a "hole" overlaps with a real section (due to someone changing offsets in an incompatible manner), but causes the hole offset and size to remain fixed. (FIXME RPM 2008-10-20)</p>
<p>When section S is shifted by 'Sa' bytes and/or enlarged by 'Sn' bytes, other sections are affected as follows: </p><ul>
<li>Cat L: Not affected </li>
<li>Cat R: Shifted by Sa+Sn if they are in neighborhood(S). Otherwise the amount of shifting depends on the size of the hole right of neighborhood(S). </li>
<li>Cat C: Shifted Sa and enlarged Sn. </li>
<li>Cat O: If starting address are the same: Shifted Sa. If starting address not equal: Englarged Sa+Sn </li>
<li>Cat I: Shifted Sa, not enlarged </li>
<li>Cat B: Not shifted, but enlarged Sn </li>
<li>Cat E: Shifted Sa and enlarged Sn</li>
</ul>
<p>Generally speaking, the AddressSpace argument should be SgAsmGenericFile::ADDRSP_ALL in order to adjust both file and memory offsets and sizes in a consistent manner.</p>
<p>To change the address and/or size of S without regard to other sections in the same file, use set_offset() and set_size() (for file address space) or set_mapped_preferred_rva() and set_mapped_size() (for memory address space). </p>

</div>
</div>
<a id="a25b04fc25a41f77e8b0331de19c07de9" name="a25b04fc25a41f77e8b0331de19c07de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b04fc25a41f77e8b0331de19c07de9">&#9670;&#160;</a></span>shiftExtend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::shiftExtend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>sn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves and enlarges a section. </p>
<p>Shifts (to a higher offset) and/or enlarges the specified section, S, taking all other sections into account. The positions of sections are based on their preferred virtual mappings rather than the actual mapping.</p>
<p>The neighborhood(S) is S itself and the set of all sections that overlap or are adjacent to the neighborhood of S, recursively.</p>
<p>The address space can be partitioned into three categories: </p><ul>
<li>Section: part of an address space that is referenced by an <a class="el" href="classSgAsmGenericSection.html" title="Contiguous region of a file.">SgAsmGenericSection</a> other than a "hole" section. </li>
<li>Hole: part of an address space that is referenced only by a "hole" section. </li>
<li>Unref: part of an address space that is not used by any section, including any "hole" section.</li>
</ul>
<p>The last two categories define parts of the address space that can be optionally elastic&ndash;they expand or contract to take up slack or provide space for neighboring sections. This is controlled by the "elasticity" argument.</p>
<p>Note that when elasticity is ELASTIC_HOLE we simply ignore the "hole" sections, effectively removing their addresses from the range of addresses under consideration. This avoids complications that arise when a "hole" overlaps with a real section (due to someone changing offsets in an incompatible manner), but causes the hole offset and size to remain fixed. (FIXME RPM 2008-10-20)</p>
<p>When section S is shifted by 'Sa' bytes and/or enlarged by 'Sn' bytes, other sections are affected as follows: </p><ul>
<li>Cat L: Not affected </li>
<li>Cat R: Shifted by Sa+Sn if they are in neighborhood(S). Otherwise the amount of shifting depends on the size of the hole right of neighborhood(S). </li>
<li>Cat C: Shifted Sa and enlarged Sn. </li>
<li>Cat O: If starting address are the same: Shifted Sa. If starting address not equal: Englarged Sa+Sn </li>
<li>Cat I: Shifted Sa, not enlarged </li>
<li>Cat B: Not shifted, but enlarged Sn </li>
<li>Cat E: Shifted Sa and enlarged Sn</li>
</ul>
<p>Generally speaking, the AddressSpace argument should be SgAsmGenericFile::ADDRSP_ALL in order to adjust both file and memory offsets and sizes in a consistent manner.</p>
<p>To change the address and/or size of S without regard to other sections in the same file, use set_offset() and set_size() (for file address space) or set_mapped_preferred_rva() and set_mapped_size() (for memory address space). </p>

</div>
</div>
<a id="a820c9f8bc6c6c8a422240104faa275be" name="a820c9f8bc6c6c8a422240104faa275be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820c9f8bc6c6c8a422240104faa275be">&#9670;&#160;</a></span>get_nextSectionOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rose_addr_t SgAsmGenericFile::get_nextSectionOffset </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File offset of next section. </p>
<p>Given a file address, return the file offset of the following section. If there is no following section then return an address of -1 (when signed) </p>

</div>
</div>
<a id="a19af530ae4e1701f18171eec1c761ee2" name="a19af530ae4e1701f18171eec1c761ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19af530ae4e1701f18171eec1c761ee2">&#9670;&#160;</a></span>addHole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::addHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new hole to the file. </p>
<p>This is called implicitly by the hole constructor. </p>

</div>
</div>
<a id="a47eae5f0d37b7869a92c629b1f8a1aa9" name="a47eae5f0d37b7869a92c629b1f8a1aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47eae5f0d37b7869a92c629b1f8a1aa9">&#9670;&#160;</a></span>fillHoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::fillHoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find holes in file and create sections to fill them. </p>
<p>Synthesizes "hole" sections to describe the parts of the file that are not yet referenced by other sections. Note that holes are used to represent parts of the original file data, before sections were modified by walking the AST (at this time it is not possible to create a hole outside the original file content). </p>

</div>
</div>
<a id="abe3754c110e34d4af0c975c3536ee6a2" name="abe3754c110e34d4af0c975c3536ee6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3754c110e34d4af0c975c3536ee6a2">&#9670;&#160;</a></span>unfillHoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::unfillHoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes "hole" sections. </p>
<p>Undoes what <a class="el" href="classSgAsmGenericFile.html#a47eae5f0d37b7869a92c629b1f8a1aa9">fillHoles</a> did. </p>

</div>
</div>
<a id="a4e5128083f0085f16312365c56faef78" name="a4e5128083f0085f16312365c56faef78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5128083f0085f16312365c56faef78">&#9670;&#160;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new header to the file. </p>
<p>This is called implicitly by the header constructor </p>

</div>
</div>
<a id="a411753a548cee3d6d5bee20dd4f73507" name="a411753a548cee3d6d5bee20dd4f73507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411753a548cee3d6d5bee20dd4f73507">&#9670;&#160;</a></span>formatName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * SgAsmGenericFile::formatName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string describing the file format. </p>
<p>This uses the last header so that files like PE, NE, LE, LX, etc. which also have a DOS header report the format of the second (PE, etc.) header rather than the DOS header. </p>

</div>
</div>
<a id="a8b7ca2c0a9e1fb14deb75ceb5d9d487e" name="a8b7ca2c0a9e1fb14deb75ceb5d9d487e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7ca2c0a9e1fb14deb75ceb5d9d487e">&#9670;&#160;</a></span>destructorHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SgAsmGenericFile::destructorHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets called by all Rosebud-generated destructors. </p>
<p><a class="el" href="namespaceRosebud.html" title="Rosebud is a tool to generate abstract syntax trees.">Rosebud</a> generates a call to <code>destructorHelper</code> from every destructor implementation. This gives the user a chance to do something special. There are some things to be aware of when reimplementing this function, and you should be well versed in the C++ rules about calling virtual functions from destructors.</p>
<ul>
<li>The implementation must not attempt to access any data members of derived classes. These data members have already been destroyed by time this function is called.</li>
</ul>
<ul>
<li>Any calls you make to virtual functions declared in this class will dispatch only to implementations in this class or its base classes, not any derived classes.</li>
</ul>
<ul>
<li>Your implementation must expect to be called multiple times for the same object. This occurs when this class implements this function but its derived class does not. During destruction of a derived object, the derived class's Rosebud-generated destructor will call <code>destructorHelper</code>, which will dispatch to the implementation in this class. Then, when the part of the object corresponding to this class is being destroyed, the destructor will call <code>destructorHelper</code> again, which will dispatch to this implementation again. This may happen recursively mutliple times.</li>
</ul>
<ul>
<li>Your implementation should not destroy anything that a subclass might need during its destruction. This follows from the rule above, but is generally not a problem in practice. The reason it's not a problem is that the derived classes are usually Rosebud-generated and thus their destructors only call <code>destructorHelper</code>. Therefore, in order for any derived class to any work, it must be done in its <code>destructorHelper</code>, which would be called before the implementation of <code>destructorHelper</code> in this class is called.</li>
</ul>
<p>All attempts should be made to avoid having to implement a <code>destructorHelper</code> in any class but the most base class (and that one does nothing). Instead, use data members whose own destructors do their cleanup. For instance, if this class needs a pointer to data allocated on the stack, then instead of using a raw pointer which needs to be deleted in this class's destructor, use a smart pointer whose own destructor deletes the data. If you follow this advice, then you don't need to be well-versed in the details of C++ object destruction. </p>

<p>Reimplemented from <a class="el" href="classSgNode.html#afbfd547cd09eb7054c0432da0fb8d1de">SgNode</a>.</p>

</div>
</div>
<a id="a0c649e7b84715d29a966873d80900983" name="a0c649e7b84715d29a966873d80900983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c649e7b84715d29a966873d80900983">&#9670;&#160;</a></span>initializeProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SgAsmGenericFile::initializeProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all properties that have explicit initial values. </p>
<p>This function is mostly for use in user-defined constructors where the user desires to initialize all the properties but does not know the names of the data members that store the property values. This function initializes the properties that have explicit initializations within this class, but does not recursively initialize base classes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="binaryInstruction_8C_source.html">binaryInstruction.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:08:45 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
