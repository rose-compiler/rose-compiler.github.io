<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Tree.html">Tree</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Vertex</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Tree_1_1Vertex_1_1Edge-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class B&gt;<br />
template&lt;class T&gt;<br />
class Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt;</div><p>A parent-to-child edge in a tree. </p>
<p>A parent-to-child edge is a pointer-like object that points from an parent vertex to a child vertex or nullptr. It is also responsible for adjusting the child's parent pointer. The term "edge" is used instead of "pointer" because the relationship between the parent and child is bidirectional. The full term is "forward edge", but since this is the only kind of edge that users will work with, we've shortened the name to just "edge". A "reverse edge" is the pointer from child to parent.</p>
<p>An forward edge is always a data member of a vertex and never instantiated in other circumstances. Thus users don't normally instanticate these directly, but they do interact with them to obtain pointers to children from a parent.</p>
<p>This type is used to define a data member in the parent that points to a child. For instance, the following binary expression vertex has left-hand-side and right-hand-side children that are part of the tree. If <code>lhs</code> and <code>rhs</code> were not intended to be part of the tree data structure, then their types would be pointers (<code>ExpressionPtr</code>) instead of edges.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>BinaryExpression: <span class="keyword">public</span> Expression {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>Ptr = std::shared_ptr&lt;BinaryExpression&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge&lt;Expression&gt;</a> lhs;</div>
<div class="line">    <a class="code hl_class" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge&lt;Expression&gt;</a> rhs;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    BinaryExpression()</div>
<div class="line">        : lhs(*this), rhs(*this) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> Ptr instance() {</div>
<div class="line">        <span class="keywordflow">return</span> Ptr(<span class="keyword">new</span> BinaryExpression);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassSawyer_1_1Tree_1_1Vertex_1_1Edge_html"><div class="ttname"><a href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Sawyer::Tree::Vertex::Edge</a></div><div class="ttdoc">A parent-to-child edge in a tree.</div><div class="ttdef"><b>Definition</b> <a href="Tree_8h_source.html#l00358">Tree.h:358</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00358">358</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Sawyer/Tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Vertex_1_1Edge__inherit__graph.png" border="0" usemap="#aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_inherit__map" id="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_inherit__map">
<area shape="rect" title="A parent&#45;to&#45;child edge in a tree." alt="" coords="7,95,151,135"/>
<area shape="rect" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html" title=" " alt="" coords="5,197,152,237"/>
<area shape="poly" title=" " alt="" coords="81,149,81,197,76,197,76,149"/>
<area shape="rect" title=" " alt="" coords="7,5,151,45"/>
<area shape="poly" title=" " alt="" coords="81,59,81,94,76,94,76,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Sawyer::Tree::Vertex&lt; B &gt;::Edge&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Tree_1_1Vertex_1_1Edge__coll__graph.png" border="0" usemap="#aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_coll__map" id="aSawyer_1_1Tree_1_1Vertex_3_01B_01_4_1_1Edge_3_01T_01_4_coll__map">
<area shape="rect" title="A parent&#45;to&#45;child edge in a tree." alt="" coords="5,95,149,135"/>
<area shape="rect" title=" " alt="" coords="5,5,149,45"/>
<area shape="poly" title=" " alt="" coords="80,59,80,94,75,94,75,59"/>
<area shape="poly" title=" " alt="" coords="164,17,176,25,168,33,150,36,149,30,166,28,171,26,161,22"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a15f738953bc3a96397430004bc5b3012" id="r_a15f738953bc3a96397430004bc5b3012"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a15f738953bc3a96397430004bc5b3012">Child</a> = T</td></tr>
<tr class="memdesc:a15f738953bc3a96397430004bc5b3012"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of child being pointed to.  <br /></td></tr>
<tr class="separator:a15f738953bc3a96397430004bc5b3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6a7bc79a98a6f8fbf2fe114637ad9e" id="r_a1e6a7bc79a98a6f8fbf2fe114637ad9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> = std::shared_ptr&lt; <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a15f738953bc3a96397430004bc5b3012">Child</a> &gt;</td></tr>
<tr class="memdesc:a1e6a7bc79a98a6f8fbf2fe114637ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of pointer to the child.  <br /></td></tr>
<tr class="separator:a1e6a7bc79a98a6f8fbf2fe114637ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdbfa855315f6347865bf708c352cc60" id="r_acdbfa855315f6347865bf708c352cc60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#acdbfa855315f6347865bf708c352cc60">~Edge</a> ()</td></tr>
<tr class="memdesc:acdbfa855315f6347865bf708c352cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears child's parent.  <br /></td></tr>
<tr class="separator:acdbfa855315f6347865bf708c352cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c34ecfa1e8383a703b024056d3c53" id="r_a478c34ecfa1e8383a703b024056d3c53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a478c34ecfa1e8383a703b024056d3c53">operator bool</a> () const</td></tr>
<tr class="memdesc:a478c34ecfa1e8383a703b024056d3c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if child is not null.  <br /></td></tr>
<tr class="separator:a478c34ecfa1e8383a703b024056d3c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e9fd0ddf5ff95174eb40a909e1ba65" id="r_a84e9fd0ddf5ff95174eb40a909e1ba65"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a84e9fd0ddf5ff95174eb40a909e1ba65">beforeChange</a> (const typename ChangeSignal::slot_type &amp;slot)</td></tr>
<tr class="memdesc:a84e9fd0ddf5ff95174eb40a909e1ba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functors to call before the child pointer is changed.  <br /></td></tr>
<tr class="separator:a84e9fd0ddf5ff95174eb40a909e1ba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2a973c27d81f811a3b75621c9efe2a" id="r_abe2a973c27d81f811a3b75621c9efe2a"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#abe2a973c27d81f811a3b75621c9efe2a">afterChange</a> (const typename ChangeSignal::slot_type &amp;slot)</td></tr>
<tr class="memdesc:abe2a973c27d81f811a3b75621c9efe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functors to call after the child pointer is changed.  <br /></td></tr>
<tr class="separator:abe2a973c27d81f811a3b75621c9efe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae8e2ab0f27c152d20bfdf768f80bcc14" id="r_ae8e2ab0f27c152d20bfdf768f80bcc14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#ae8e2ab0f27c152d20bfdf768f80bcc14">Edge</a> (<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> &amp;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a5605ce3a8f9a875e41a56b00b549d222">parent</a>)</td></tr>
<tr class="memdesc:ae8e2ab0f27c152d20bfdf768f80bcc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a child edge that belongs to the specified parent.  <br /></td></tr>
<tr class="separator:ae8e2ab0f27c152d20bfdf768f80bcc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cfb9a77ddca748e03d707b421a8c7c" id="r_af4cfb9a77ddca748e03d707b421a8c7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#af4cfb9a77ddca748e03d707b421a8c7c">Edge</a> (<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> &amp;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a5605ce3a8f9a875e41a56b00b549d222">parent</a>, const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab9afb3d01af45a09ac593f1577ff2bc3">child</a>)</td></tr>
<tr class="memdesc:af4cfb9a77ddca748e03d707b421a8c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a child edge that belongs to the specified parent.  <br /></td></tr>
<tr class="separator:af4cfb9a77ddca748e03d707b421a8c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad7e66d3dd57053a0bd19ac3d641ecf58" id="r_ad7e66d3dd57053a0bd19ac3d641ecf58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#ad7e66d3dd57053a0bd19ac3d641ecf58">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:ad7e66d3dd57053a0bd19ac3d641ecf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child if there is one, else null.  <br /></td></tr>
<tr class="separator:ad7e66d3dd57053a0bd19ac3d641ecf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85badeffe0bddfc66df826ff0c52e467" id="r_a85badeffe0bddfc66df826ff0c52e467"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a85badeffe0bddfc66df826ff0c52e467">operator()</a> () const</td></tr>
<tr class="memdesc:a85badeffe0bddfc66df826ff0c52e467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child if there is one, else null.  <br /></td></tr>
<tr class="separator:a85badeffe0bddfc66df826ff0c52e467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6dcfcc80528776412d5cde27e1823fb1" id="r_a6dcfcc80528776412d5cde27e1823fb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a6dcfcc80528776412d5cde27e1823fb1">operator==</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a6dcfcc80528776412d5cde27e1823fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:a6dcfcc80528776412d5cde27e1823fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820a192911eed160acee0f9261692d33" id="r_a820a192911eed160acee0f9261692d33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a820a192911eed160acee0f9261692d33">operator!=</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a> &amp;) const</td></tr>
<tr class="memdesc:a820a192911eed160acee0f9261692d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:a820a192911eed160acee0f9261692d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb1376103e43901492286b14849be46" id="r_afcb1376103e43901492286b14849be46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#afcb1376103e43901492286b14849be46">operator==</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a> &amp;) const</td></tr>
<tr class="memdesc:afcb1376103e43901492286b14849be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:afcb1376103e43901492286b14849be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c670ade78d4cc17ef3aa0bc18492d8b" id="r_a5c670ade78d4cc17ef3aa0bc18492d8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a5c670ade78d4cc17ef3aa0bc18492d8b">operator!=</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a> &amp;) const</td></tr>
<tr class="memdesc:a5c670ade78d4cc17ef3aa0bc18492d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:a5c670ade78d4cc17ef3aa0bc18492d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7978c031f62f99f77f5090a2c2cf4b4" id="r_ac7978c031f62f99f77f5090a2c2cf4b4"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ac7978c031f62f99f77f5090a2c2cf4b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#ac7978c031f62f99f77f5090a2c2cf4b4">operator==</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a>&lt; U &gt; &amp;) const</td></tr>
<tr class="memdesc:ac7978c031f62f99f77f5090a2c2cf4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:ac7978c031f62f99f77f5090a2c2cf4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5514499776c720a8c6f2913a0b7b17a3" id="r_a5514499776c720a8c6f2913a0b7b17a3"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a5514499776c720a8c6f2913a0b7b17a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a5514499776c720a8c6f2913a0b7b17a3">operator!=</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a>&lt; U &gt; &amp;) const</td></tr>
<tr class="memdesc:a5514499776c720a8c6f2913a0b7b17a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the child pointer to another pointer.  <br /></td></tr>
<tr class="separator:a5514499776c720a8c6f2913a0b7b17a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d9ae3fb01425b1e83a7ebdb161a5d23" id="r_a1d9ae3fb01425b1e83a7ebdb161a5d23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1d9ae3fb01425b1e83a7ebdb161a5d23">operator=</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;newChild)</td></tr>
<tr class="memdesc:a1d9ae3fb01425b1e83a7ebdb161a5d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a pointer to a child.  <br /></td></tr>
<tr class="separator:a1d9ae3fb01425b1e83a7ebdb161a5d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f240aabdaa97784809b4a7f067b214" id="r_ac2f240aabdaa97784809b4a7f067b214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#ac2f240aabdaa97784809b4a7f067b214">operator=</a> (const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a> &amp;<a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#a5605ce3a8f9a875e41a56b00b549d222">parent</a>)</td></tr>
<tr class="memdesc:ac2f240aabdaa97784809b4a7f067b214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a pointer to a child.  <br /></td></tr>
<tr class="separator:ac2f240aabdaa97784809b4a7f067b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a15f738953bc3a96397430004bc5b3012" name="a15f738953bc3a96397430004bc5b3012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f738953bc3a96397430004bc5b3012">&#9670;&#160;</a></span>Child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::Child =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of child being pointed to. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00361">361</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a1e6a7bc79a98a6f8fbf2fe114637ad9e" name="a1e6a7bc79a98a6f8fbf2fe114637ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6a7bc79a98a6f8fbf2fe114637ad9e">&#9670;&#160;</a></span>ChildPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::ChildPtr =  std::shared_ptr&lt;<a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a15f738953bc3a96397430004bc5b3012">Child</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of pointer to the child. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00364">364</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acdbfa855315f6347865bf708c352cc60" name="acdbfa855315f6347865bf708c352cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbfa855315f6347865bf708c352cc60">&#9670;&#160;</a></span>~Edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::~<a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor clears child's parent. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01198">1198</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="Tree_8h_source.html#l00856">Sawyer::Tree::Vertex&lt; B &gt;::parent</a>.</p>

</div>
</div>
<a id="ae8e2ab0f27c152d20bfdf768f80bcc14" name="ae8e2ab0f27c152d20bfdf768f80bcc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e2ab0f27c152d20bfdf768f80bcc14">&#9670;&#160;</a></span>Edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;<a class="el" href="structEdge.html">::Edge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a child edge that belongs to the specified parent. </p>
<p>When constructing a class containing a data member of this type (i.e., a tree edge that points to a child of this vertex), the data member must be initialized by passing <code>*this</code> as the argument. See the example in this class documentation.</p>
<p>An optional second argument initializes the child pointer for the edge. The initialization is the same as if the child had been assigned with <code>operator=</code> later. I.e., the child must not already have a parent. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01205">1205</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="af4cfb9a77ddca748e03d707b421a8c7c" name="af4cfb9a77ddca748e03d707b421a8c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cfb9a77ddca748e03d707b421a8c7c">&#9670;&#160;</a></span>Edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;<a class="el" href="structEdge.html">::Edge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#aca09343f0861a4d024bc2f3340bf5e97">UserBase</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a child edge that belongs to the specified parent. </p>
<p>When constructing a class containing a data member of this type (i.e., a tree edge that points to a child of this vertex), the data member must be initialized by passing <code>*this</code> as the argument. See the example in this class documentation.</p>
<p>An optional second argument initializes the child pointer for the edge. The initialization is the same as if the child had been assigned with <code>operator=</code> later. I.e., the child must not already have a parent. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7e66d3dd57053a0bd19ac3d641ecf58" name="ad7e66d3dd57053a0bd19ac3d641ecf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e66d3dd57053a0bd19ac3d641ecf58">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; T &gt; &amp; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the child if there is one, else null. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01254">1254</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a85badeffe0bddfc66df826ff0c52e467" name="a85badeffe0bddfc66df826ff0c52e467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85badeffe0bddfc66df826ff0c52e467">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; T &gt; &amp; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the child if there is one, else null. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01262">1262</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a6dcfcc80528776412d5cde27e1823fb1" name="a6dcfcc80528776412d5cde27e1823fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcfcc80528776412d5cde27e1823fb1">&#9670;&#160;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01269">1269</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a820a192911eed160acee0f9261692d33" name="a820a192911eed160acee0f9261692d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820a192911eed160acee0f9261692d33">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html#ab166ccc76337e352321b3e90a077be69">UserBasePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01276">1276</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="afcb1376103e43901492286b14849be46" name="afcb1376103e43901492286b14849be46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb1376103e43901492286b14849be46">&#9670;&#160;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01283">1283</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a5c670ade78d4cc17ef3aa0bc18492d8b" name="a5c670ade78d4cc17ef3aa0bc18492d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c670ade78d4cc17ef3aa0bc18492d8b">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01290">1290</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ac7978c031f62f99f77f5090a2c2cf4b4" name="ac7978c031f62f99f77f5090a2c2cf4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7978c031f62f99f77f5090a2c2cf4b4">&#9670;&#160;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01298">1298</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a5514499776c720a8c6f2913a0b7b17a3" name="a5514499776c720a8c6f2913a0b7b17a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5514499776c720a8c6f2913a0b7b17a3">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the child pointer to another pointer. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l01306">1306</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a1d9ae3fb01425b1e83a7ebdb161a5d23" name="a1d9ae3fb01425b1e83a7ebdb161a5d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ae3fb01425b1e83a7ebdb161a5d23">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a> &amp; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html#a1e6a7bc79a98a6f8fbf2fe114637ad9e">ChildPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>newChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a pointer to a child. </p>
<p>If this edge points to an old child then that child is removed and its parent is reset. If the specified new child is non-null, then it is inserted and its parent pointer set to the parent of this edge.</p>
<p>However, if the new child already has a non-null parent, then no changes are made and an <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html">InsertionError</a> is thrown with the error's vertex pointing to the intended child. Otherwise, if the new child is non-null and is the parent or any more distant ancestor of this edge's vertex, then a <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1CycleError.html">CycleError</a> is thrown. Cycle errors are only thrown if debugging is enabled (i.e., the CPP macro <code>NDEBUG</code> is undefined).</p>
<p>Attempting to assign one child edge object to another is a compile-time error (its operator= is not declared) because every non-null child edge points to a child whose parent is non-null, which would trigger an <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html">InsertionError</a>. Therefore only null child edges could be assigned. But since only null child edges can be assigned, its more concise and clear to assign the null pointer directly. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00452">452</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="ac2f240aabdaa97784809b4a7f067b214" name="ac2f240aabdaa97784809b4a7f067b214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f240aabdaa97784809b4a7f067b214">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1Edge.html">Edge</a> &amp; <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1ReverseEdge.html">ReverseEdge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a pointer to a child. </p>
<p>If this edge points to an old child then that child is removed and its parent is reset. If the specified new child is non-null, then it is inserted and its parent pointer set to the parent of this edge.</p>
<p>However, if the new child already has a non-null parent, then no changes are made and an <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html">InsertionError</a> is thrown with the error's vertex pointing to the intended child. Otherwise, if the new child is non-null and is the parent or any more distant ancestor of this edge's vertex, then a <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1CycleError.html">CycleError</a> is thrown. Cycle errors are only thrown if debugging is enabled (i.e., the CPP macro <code>NDEBUG</code> is undefined).</p>
<p>Attempting to assign one child edge object to another is a compile-time error (its operator= is not declared) because every non-null child edge points to a child whose parent is non-null, which would trigger an <a class="el" href="classSawyer_1_1Tree_1_1Vertex_1_1InsertionError.html">InsertionError</a>. Therefore only null child edges could be assigned. But since only null child edges can be assigned, its more concise and clear to assign the null pointer directly. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00476">476</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

<p class="reference">References <a class="el" href="Tree_8h_source.html#l00856">Sawyer::Tree::Vertex&lt; B &gt;::parent</a>.</p>

</div>
</div>
<a id="a478c34ecfa1e8383a703b024056d3c53" name="a478c34ecfa1e8383a703b024056d3c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c34ecfa1e8383a703b024056d3c53">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if child is not null. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00482">482</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="a84e9fd0ddf5ff95174eb40a909e1ba65" name="a84e9fd0ddf5ff95174eb40a909e1ba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e9fd0ddf5ff95174eb40a909e1ba65">&#9670;&#160;</a></span>beforeChange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::beforeChange </td>
          <td>(</td>
          <td class="paramtype">const typename ChangeSignal::slot_type &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functors to call before the child pointer is changed. </p>
<p>The functor is called before the child pointer is changed and may throw an exception to indicate that the change should not occur. The two arguments are the old and new child pointers, either of which might be null. The callbacks are not invoked during edge constructor or destructor calls. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00491">491</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<a id="abe2a973c27d81f811a3b75621c9efe2a" name="abe2a973c27d81f811a3b75621c9efe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2a973c27d81f811a3b75621c9efe2a">&#9670;&#160;</a></span>afterChange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSawyer_1_1Tree_1_1Vertex.html">Sawyer::Tree::Vertex</a>&lt; B &gt;<a class="el" href="structEdge.html">::Edge</a>&lt; T &gt;::afterChange </td>
          <td>(</td>
          <td class="paramtype">const typename ChangeSignal::slot_type &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functors to call after the child pointer is changed. </p>
<p>The functor is called after the edge child pointer is changed. The two arguments are the old and new child pointers, either of which might be null. The callbacks are not invoked during edge constructor or destructor calls. </p>

<p class="definition">Definition at line <a class="el" href="Tree_8h_source.html#l00499">499</a> of file <a class="el" href="Tree_8h_source.html">Tree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:37 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
