<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::Callbacks::List&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1Callbacks.html">Callbacks</a></li><li class="navelem"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRose_1_1Callbacks_1_1List-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::Callbacks::List&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class Rose::Callbacks::List&lt; T &gt;</div><p><a class="el" href="classRose_1_1Callbacks_1_1List.html" title="List of callback functors.">List</a> of callback functors. </p>
<p>This template defines ordered containers of callback functors and thread-safe functions for accessing the containers.</p>
<h1><a class="anchor" id="Rose_Callbacks_List_Example1"></a>
Example Usage</h1>
<p>The first step is to create a functor class having one or more callbacks (operator() methods), each of which takes a struct reference containing the data to which the callback is applied.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyCallback: <span class="keyword">public</span> MyCallbackBase { <span class="comment">//base class optional</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyCallback(): ncalls(0) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Callback argument structure.  Data members can be anything</span></div>
<div class="line">    <span class="comment">// you want, and you can even have more than one of these</span></div>
<div class="line">    <span class="comment">// structs--one per callback signature.  The constructor</span></div>
<div class="line">    <span class="comment">// should generally just assign arguments to data members.</span></div>
<div class="line">    <span class="keyword">struct </span>Args {</div>
<div class="line">        Args(<a class="code hl_class" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn, <span class="keywordtype">int</span> callno, <span class="keywordtype">char</span> *name):</div>
<div class="line">            insn(insn), callno(callno), name(name) {}</div>
<div class="line">        <a class="code hl_class" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn;</div>
<div class="line">        <span class="keywordtype">int</span> callno;</div>
<div class="line">        <span class="keywordtype">char</span> *name;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The callback.  You can overload these, but they&#39;ll all</span></div>
<div class="line">    <span class="comment">// take two arguments where the first is a Boolean and the</span></div>
<div class="line">    <span class="comment">// second is one of the argument types you defined above.</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> b, <span class="keyword">const</span> Args &amp;args) {</div>
<div class="line">        ncalls++;</div>
<div class="line">        printf(stderr,<span class="stringliteral">&quot;%s: %d\n&quot;</span>, args.name, args.callno);</div>
<div class="line">        insns.push_back(args.insn);</div>
<div class="line">        <span class="keywordflow">return</span> b;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Some data members accessible by the callback(s)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> ncalls;</div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;SgAsmInstruction*&gt; insns;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSgAsmInstruction_html"><div class="ttname"><a href="classSgAsmInstruction.html">SgAsmInstruction</a></div><div class="ttdoc">Base class for machine instructions.</div><div class="ttdef"><b>Definition</b> <a href="binaryInstruction_8C_source.html#l43208">binaryInstruction.C:43208</a></div></div>
</div><!-- fragment --><p>The second step is to create a list to hold these callbacks. Our example callback was derived from a base class, so we'll use that base class as the list element type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List&lt;MyCallbackBase&gt;</a> MyCallbackList;</div>
<div class="line">MyCallbackList cbl;</div>
<div class="ttc" id="aclassRose_1_1Callbacks_1_1List_html"><div class="ttname"><a href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a></div><div class="ttdoc">List of callback functors.</div><div class="ttdef"><b>Definition</b> <a href="callbacks_8h_source.html#l00083">callbacks.h:83</a></div></div>
</div><!-- fragment --><p>Add some callbacks to the list. We'll just add one for this example.</p>
<div class="fragment"><div class="line">cbl.append(<span class="keyword">new</span> MyCallback);</div>
</div><!-- fragment --><p>Finally, invoke all the callbacks in the list, supplying some arguments that will be used for each callback.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> result = cbl.apply(<span class="keyword">true</span>, MyCallback::Args(insn, 5, <span class="stringliteral">&quot;foo&quot;</span>));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00083">83</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="callbacks_8h_source.html">roseSupport/callbacks.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::Callbacks::List&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1Callbacks_1_1List__inherit__graph.png" border="0" usemap="#aRose_1_1Callbacks_1_1List_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1Callbacks_1_1List_3_01T_01_4_inherit__map" id="aRose_1_1Callbacks_1_1List_3_01T_01_4_inherit__map">
<area shape="rect" title="List of callback functors." alt="" coords="5,60,185,85"/>
<area shape="rect" href="classRose_1_1Callbacks_1_1List.html" title=" " alt="" coords="461,5,711,60"/>
<area shape="poly" title=" " alt="" coords="199,60,209,59,461,39,461,45,210,65,199,66"/>
<area shape="rect" href="classRose_1_1Callbacks_1_1List.html" title=" " alt="" coords="469,84,703,139"/>
<area shape="poly" title=" " alt="" coords="179,85,210,89,344,100,469,106,469,111,343,105,209,94,179,90"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac877aeb689fa504967866d98d328db7" id="r_aac877aeb689fa504967866d98d328db7"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a></td></tr>
<tr class="memdesc:aac877aeb689fa504967866d98d328db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor class.  <br /></td></tr>
<tr class="separator:aac877aeb689fa504967866d98d328db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad1ff17b28fa4f088e088d6b38254ff" id="r_a5ad1ff17b28fa4f088e088d6b38254ff"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a5ad1ff17b28fa4f088e088d6b38254ff">CBList</a></td></tr>
<tr class="memdesc:a5ad1ff17b28fa4f088e088d6b38254ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard vector of functor pointers.  <br /></td></tr>
<tr class="separator:a5ad1ff17b28fa4f088e088d6b38254ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08619cd98ebd36a1494ac229b196677d" id="r_a08619cd98ebd36a1494ac229b196677d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a08619cd98ebd36a1494ac229b196677d">List</a> (const <a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;other)</td></tr>
<tr class="separator:a08619cd98ebd36a1494ac229b196677d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fc351010b321746ae3ff9a748c9fa5" id="r_a46fc351010b321746ae3ff9a748c9fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a46fc351010b321746ae3ff9a748c9fa5">List</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *callback)</td></tr>
<tr class="separator:a46fc351010b321746ae3ff9a748c9fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d58e68e913dd05b7b59b3f6772833cb" id="r_a6d58e68e913dd05b7b59b3f6772833cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a6d58e68e913dd05b7b59b3f6772833cb">size</a> () const</td></tr>
<tr class="memdesc:a6d58e68e913dd05b7b59b3f6772833cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of callbacks in the list.  <br /></td></tr>
<tr class="separator:a6d58e68e913dd05b7b59b3f6772833cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d079325c6533c4fe5b01c5012d064b4" id="r_a8d079325c6533c4fe5b01c5012d064b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a8d079325c6533c4fe5b01c5012d064b4">empty</a> () const</td></tr>
<tr class="memdesc:a8d079325c6533c4fe5b01c5012d064b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to test whether the list is empty.  <br /></td></tr>
<tr class="separator:a8d079325c6533c4fe5b01c5012d064b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2755b10294ed9bb72244e88dd8d2d" id="r_ab2d2755b10294ed9bb72244e88dd8d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#ab2d2755b10294ed9bb72244e88dd8d2d">append</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *cb)</td></tr>
<tr class="memdesc:ab2d2755b10294ed9bb72244e88dd8d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a functor to the end of the list without copying it.  <br /></td></tr>
<tr class="separator:ab2d2755b10294ed9bb72244e88dd8d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b52acc4c7d250c57cb15bd59e6cf8bb" id="r_a3b52acc4c7d250c57cb15bd59e6cf8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a3b52acc4c7d250c57cb15bd59e6cf8bb">prepend</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *cb)</td></tr>
<tr class="memdesc:a3b52acc4c7d250c57cb15bd59e6cf8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend callback to beginning of list without copying it.  <br /></td></tr>
<tr class="separator:a3b52acc4c7d250c57cb15bd59e6cf8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c12dbd037eac5939ea5342ec88f223" id="r_ac3c12dbd037eac5939ea5342ec88f223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#ac3c12dbd037eac5939ea5342ec88f223">after</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *relative_to, <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *cb, size_t nreplacements=<a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a>)</td></tr>
<tr class="memdesc:ac3c12dbd037eac5939ea5342ec88f223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a callback after another.  <br /></td></tr>
<tr class="separator:ac3c12dbd037eac5939ea5342ec88f223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd22e796c73a1735f1ab4c3950f9fe14" id="r_acd22e796c73a1735f1ab4c3950f9fe14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#acd22e796c73a1735f1ab4c3950f9fe14">before</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *relative_to, <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *cb, size_t nreplacements=<a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a>)</td></tr>
<tr class="memdesc:acd22e796c73a1735f1ab4c3950f9fe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a callback before another.  <br /></td></tr>
<tr class="separator:acd22e796c73a1735f1ab4c3950f9fe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0043bf9f66c517a16eb762f71221e440" id="r_a0043bf9f66c517a16eb762f71221e440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a0043bf9f66c517a16eb762f71221e440">replace</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *old_cb, <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *new_cb, size_t nreplacements=<a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a>, <a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a> dir=<a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a>)</td></tr>
<tr class="memdesc:a0043bf9f66c517a16eb762f71221e440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace one callback with another.  <br /></td></tr>
<tr class="separator:a0043bf9f66c517a16eb762f71221e440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed98263665b3746ceeca037195ea9f7" id="r_a4ed98263665b3746ceeca037195ea9f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a4ed98263665b3746ceeca037195ea9f7">erase</a> (<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *cb, <a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a> dir=<a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a>)</td></tr>
<tr class="memdesc:a4ed98263665b3746ceeca037195ea9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a callback from a list without destroying it.  <br /></td></tr>
<tr class="separator:a4ed98263665b3746ceeca037195ea9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8b8cb64a677019aa191b5969832521" id="r_a2a8b8cb64a677019aa191b5969832521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a2a8b8cb64a677019aa191b5969832521">clear</a> ()</td></tr>
<tr class="memdesc:a2a8b8cb64a677019aa191b5969832521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all callbacks from list without destroying them.  <br /></td></tr>
<tr class="separator:a2a8b8cb64a677019aa191b5969832521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f0abbb28cb6b33bd6061566a43c3ec" id="r_ad4f0abbb28cb6b33bd6061566a43c3ec"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#ad4f0abbb28cb6b33bd6061566a43c3ec">callbacks</a> () const</td></tr>
<tr class="memdesc:ad4f0abbb28cb6b33bd6061566a43c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the underlying STL vector of functors.  <br /></td></tr>
<tr class="separator:ad4f0abbb28cb6b33bd6061566a43c3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c77a2d4994183ec9d73b6307c3f6c" id="r_a7d8c77a2d4994183ec9d73b6307c3f6c"><td class="memTemplParams" colspan="2">template&lt;class ArgumentType &gt; </td></tr>
<tr class="memitem:a7d8c77a2d4994183ec9d73b6307c3f6c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c">apply</a> (bool b, const ArgumentType &amp;args, <a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a> dir=<a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a>) const</td></tr>
<tr class="memdesc:a7d8c77a2d4994183ec9d73b6307c3f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes all functors in the callback list.  <br /></td></tr>
<tr class="separator:a7d8c77a2d4994183ec9d73b6307c3f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aac877aeb689fa504967866d98d328db7" name="aac877aeb689fa504967866d98d328db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac877aeb689fa504967866d98d328db7">&#9670;&#160;</a></span>CallbackType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::CallbackType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor class. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00085">85</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a5ad1ff17b28fa4f088e088d6b38254ff" name="a5ad1ff17b28fa4f088e088d6b38254ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad1ff17b28fa4f088e088d6b38254ff">&#9670;&#160;</a></span>CBList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a>*&gt; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::CBList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard vector of functor pointers. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00086">86</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aebac13a32b16ed18bda1de4b95049280" name="aebac13a32b16ed18bda1de4b95049280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac13a32b16ed18bda1de4b95049280">&#9670;&#160;</a></span>List() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::List </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00093">93</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a08619cd98ebd36a1494ac229b196677d" name="a08619cd98ebd36a1494ac229b196677d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08619cd98ebd36a1494ac229b196677d">&#9670;&#160;</a></span>List() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::List </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00095">95</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a46fc351010b321746ae3ff9a748c9fa5" name="a46fc351010b321746ae3ff9a748c9fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fc351010b321746ae3ff9a748c9fa5">&#9670;&#160;</a></span>List() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00100">100</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6d58e68e913dd05b7b59b3f6772833cb" name="a6d58e68e913dd05b7b59b3f6772833cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d58e68e913dd05b7b59b3f6772833cb">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of callbacks in the list. </p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00107">107</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a8d079325c6533c4fe5b01c5012d064b4" name="a8d079325c6533c4fe5b01c5012d064b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d079325c6533c4fe5b01c5012d064b4">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate to test whether the list is empty. </p>
<p>Returns true if the list is empty, false otherwise.</p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00117">117</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="ab2d2755b10294ed9bb72244e88dd8d2d" name="ab2d2755b10294ed9bb72244e88dd8d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2755b10294ed9bb72244e88dd8d2d">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a functor to the end of the list without copying it. </p>
<p>Functors can be inserted more than once into a list, and each occurrence will be called by the <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> method.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00128">128</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a3b52acc4c7d250c57cb15bd59e6cf8bb" name="a3b52acc4c7d250c57cb15bd59e6cf8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b52acc4c7d250c57cb15bd59e6cf8bb">&#9670;&#160;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend callback to beginning of list without copying it. </p>
<p>Functors can be inserted more than once into a list, and each occurrence will be called by the <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> method.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00141">141</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="ac3c12dbd037eac5939ea5342ec88f223" name="ac3c12dbd037eac5939ea5342ec88f223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c12dbd037eac5939ea5342ec88f223">&#9670;&#160;</a></span>after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>relative_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nreplacements</em> = <code><a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a callback after another. </p>
<p>The callback is inserted after each occurrence of the <code>relative_to</code> callback. Up to <code>nreplacement</code> insertions are made beginning at the front of the list.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00155">155</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="acd22e796c73a1735f1ab4c3950f9fe14" name="acd22e796c73a1735f1ab4c3950f9fe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd22e796c73a1735f1ab4c3950f9fe14">&#9670;&#160;</a></span>before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>relative_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nreplacements</em> = <code><a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a callback before another. </p>
<p>The callback is inserted before each occurrence of the <code>relative_to</code> callback. Up to <code>nreplacement</code> insertions are made begin$ning at the front of the list.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00172">172</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

</div>
</div>
<a id="a0043bf9f66c517a16eb762f71221e440" name="a0043bf9f66c517a16eb762f71221e440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0043bf9f66c517a16eb762f71221e440">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>old_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>new_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nreplacements</em> = <code><a class="el" href="namespaceRose.html#a4b5151acabd95113a472f41c0c335231">UNLIMITED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace one callback with another. </p>
<p>The replaced callback is removed from the list as if by <a class="el" href="classRose_1_1Callbacks_1_1List.html#a4ed98263665b3746ceeca037195ea9f7" title="Remove a callback from a list without destroying it.">erase()</a> without deleting it, and its replacement is inserted at the same position without copying it. At most <code>nreplacements</code> are performed (the default is unlimited). Replacements are performed in the direction specified.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00193">193</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

<p class="reference">References <a class="el" href="callbacks_8h_source.html#l00016">Rose::Callbacks::FORWARD</a>.</p>

</div>
</div>
<a id="a4ed98263665b3746ceeca037195ea9f7" name="a4ed98263665b3746ceeca037195ea9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed98263665b3746ceeca037195ea9f7">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a callback from a list without destroying it. </p>
<p>The list is traversed in the specified direction and the first functor that matches (by pointer comparison) the specified callback is removed from the list. Returns true if a functor was removed, false otherwise.</p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00221">221</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

<p class="reference">References <a class="el" href="callbacks_8h_source.html#l00016">Rose::Callbacks::FORWARD</a>.</p>

</div>
</div>
<a id="a2a8b8cb64a677019aa191b5969832521" name="a2a8b8cb64a677019aa191b5969832521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8b8cb64a677019aa191b5969832521">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1Callbacks_1_1List.html">List</a> &amp; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all callbacks from list without destroying them. </p>
<p>Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> is calling the functors on that list. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00245">245</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmUnparser_8h_source.html#l00962">Rose::BinaryAnalysis::AsmUnparser::CallbackLists::clear()</a>.</p>

</div>
</div>
<a id="ad4f0abbb28cb6b33bd6061566a43c3ec" name="ad4f0abbb28cb6b33bd6061566a43c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f0abbb28cb6b33bd6061566a43c3ec">&#9670;&#160;</a></span>callbacks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="classRose_1_1Callbacks_1_1List.html#aac877aeb689fa504967866d98d328db7">CallbackType</a> * &gt; <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the underlying STL vector of functors. </p>
<p>Thread safety: This method is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00254">254</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="callbacks_8h_source.html#l00272">Rose::Callbacks::List&lt; T &gt;::apply()</a>.</p>

</div>
</div>
<a id="a7d8c77a2d4994183ec9d73b6307c3f6c" name="a7d8c77a2d4994183ec9d73b6307c3f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8c77a2d4994183ec9d73b6307c3f6c">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class ArgumentType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRose_1_1Callbacks_1_1List.html">Rose::Callbacks::List</a>&lt; T &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgumentType &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224a">Direction</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="el" href="namespaceRose_1_1Callbacks.html#a5957746e95778322cffb343f06d0224aaa936039cb5ec878cc5abf56c40e06660">FORWARD</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes all functors in the callback list. </p>
<p>The functors are invoked sequentially in the order specified by calling its operator() method. Two arguments are provided: a boolean value, and an additional argument with parameterized type. The boolean argument for the first callback is the <code>b</code> argument of this method; the boolean argument of the subsequent callbacks is the return value of the previous callback; the return value of this method is the return value of the last callback (or the initial value of <code>b</code> if no callbacks were made).</p>
<p>Thread safety: This method is thread safe. If this list is modified by one or more of the functors on this list or by another thread, those changes do not affect which callbacks are made by this invocation of <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a>. The callbacks should not assume that any particular mutexes or other thread synchronization resources are held. It is possible for a single callback to be invoked concurrently if two or more threads invoke <a class="el" href="classRose_1_1Callbacks_1_1List.html#a7d8c77a2d4994183ec9d73b6307c3f6c" title="Invokes all functors in the callback list.">apply()</a> concurrently. </p>

<p class="definition">Definition at line <a class="el" href="callbacks_8h_source.html#l00272">272</a> of file <a class="el" href="callbacks_8h_source.html">callbacks.h</a>.</p>

<p class="reference">References <a class="el" href="callbacks_8h_source.html#l00254">Rose::Callbacks::List&lt; T &gt;::callbacks()</a>, and <a class="el" href="callbacks_8h_source.html#l00016">Rose::Callbacks::FORWARD</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="callbacks_8h_source.html">callbacks.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
