<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Sawyer::Container::HashMap&lt; K, T, H, C, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSawyer.html">Sawyer</a></li><li class="navelem"><a class="el" href="namespaceSawyer_1_1Container.html">Container</a></li><li class="navelem"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSawyer_1_1Container_1_1HashMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class K, class T, class H = boost::hash&lt;K&gt;, class C = std::equal_to&lt;K&gt;, class A = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt;<br />
class Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;</div><p>Container associating values with keys. </p>
<p>This container is similar to TL's <code>unordered_map</code> in that it stores a value for each key using a hash-based mechanism, although it works for C++ versions before C++11. The naming scheme is similar to other Sawyer containers. If you're used to the STL, the main differences are described in the documentation for the <a class="el" href="namespaceSawyer_1_1Container.html">Sawyer::Container</a> name space.</p>
<p>See also, <a class="el" href="classMap.html">Map</a>. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00030">30</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="HashMap_8h_source.html">Sawyer/HashMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSawyer_1_1Container_1_1HashMap__inherit__graph.png" border="0" usemap="#aSawyer_1_1Container_1_1HashMap_3_01K_00_01T_00_01H_00_01C_00_01A_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSawyer_1_1Container_1_1HashMap_3_01K_00_01T_00_01H_00_01C_00_01A_01_4_inherit__map" id="aSawyer_1_1Container_1_1HashMap_3_01K_00_01T_00_01H_00_01C_00_01A_01_4_inherit__map">
<area shape="rect" title="Container associating values with keys." alt="" coords="5,53,184,93"/>
<area shape="rect" href="classSawyer_1_1Container_1_1HashMap.html" title=" " alt="" coords="483,5,645,60"/>
<area shape="poly" title=" " alt="" coords="198,60,208,59,482,36,483,42,208,65,198,66"/>
<area shape="rect" href="classSawyer_1_1Container_1_1HashMap.html" title=" " alt="" coords="449,84,679,139"/>
<area shape="poly" title=" " alt="" coords="198,87,208,89,333,99,449,105,449,111,332,105,208,94,197,93"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator over keys.  <a href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html">ConstNodeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator over key/value nodes.  <a href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstValueIterator.html">ConstValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator over values.  <a href="classSawyer_1_1Container_1_1HashMap_1_1ConstValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> for stored nodes.  <a href="classSawyer_1_1Container_1_1HashMap_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator over key/value nodes.  <a href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html">ValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator over values.  <a href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac71e99fb6c0d2a3f2bcdcc9bb4b26b50" id="r_ac71e99fb6c0d2a3f2bcdcc9bb4b26b50"><td class="memItemLeft" align="right" valign="top">typedef K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a></td></tr>
<tr class="memdesc:ac71e99fb6c0d2a3f2bcdcc9bb4b26b50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of keys.  <br /></td></tr>
<tr class="separator:ac71e99fb6c0d2a3f2bcdcc9bb4b26b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eacdb66a2c72395bd31d1bfd2b3dd5b" id="r_a4eacdb66a2c72395bd31d1bfd2b3dd5b"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a></td></tr>
<tr class="memdesc:a4eacdb66a2c72395bd31d1bfd2b3dd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of values.  <br /></td></tr>
<tr class="separator:a4eacdb66a2c72395bd31d1bfd2b3dd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b464432529c364630704e76cd6c91d" id="r_a52b464432529c364630704e76cd6c91d"><td class="memItemLeft" align="right" valign="top">typedef H&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a52b464432529c364630704e76cd6c91d">Hasher</a></td></tr>
<tr class="memdesc:a52b464432529c364630704e76cd6c91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for hashing keys.  <br /></td></tr>
<tr class="separator:a52b464432529c364630704e76cd6c91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08925681ab0ebc5e1cd33ed140b44e7b" id="r_a08925681ab0ebc5e1cd33ed140b44e7b"><td class="memItemLeft" align="right" valign="top">typedef C&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a></td></tr>
<tr class="memdesc:a08925681ab0ebc5e1cd33ed140b44e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for comparing keys.  <br /></td></tr>
<tr class="separator:a08925681ab0ebc5e1cd33ed140b44e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78e8941b43c88e91ff03cde9c7726b" id="r_a1d78e8941b43c88e91ff03cde9c7726b"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1d78e8941b43c88e91ff03cde9c7726b">Allocator</a></td></tr>
<tr class="memdesc:a1d78e8941b43c88e91ff03cde9c7726b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for allocating node memory.  <br /></td></tr>
<tr class="separator:a1d78e8941b43c88e91ff03cde9c7726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3df3d3a4f25ed1ac1013b19754dc6816" id="r_a3df3d3a4f25ed1ac1013b19754dc6816"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3df3d3a4f25ed1ac1013b19754dc6816">HashMap</a> ()</td></tr>
<tr class="memdesc:a3df3d3a4f25ed1ac1013b19754dc6816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a3df3d3a4f25ed1ac1013b19754dc6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4bff1224e8d7ec437fc2fd79cdebf3" id="r_a6e4bff1224e8d7ec437fc2fd79cdebf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a6e4bff1224e8d7ec437fc2fd79cdebf3">HashMap</a> (size_t n, const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a52b464432529c364630704e76cd6c91d">Hasher</a> &amp;hasher=<a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a52b464432529c364630704e76cd6c91d">Hasher</a>(), const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a> &amp;cmp=<a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a>(), const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1d78e8941b43c88e91ff03cde9c7726b">Allocator</a> &amp;alloc=<a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1d78e8941b43c88e91ff03cde9c7726b">Allocator</a>())</td></tr>
<tr class="memdesc:a6e4bff1224e8d7ec437fc2fd79cdebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a hash map with at least <code>n</code> buckets.  <br /></td></tr>
<tr class="separator:a6e4bff1224e8d7ec437fc2fd79cdebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519e4316d264de076c62f4a558c15246" id="r_a519e4316d264de076c62f4a558c15246"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a519e4316d264de076c62f4a558c15246">HashMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;other)</td></tr>
<tr class="memdesc:a519e4316d264de076c62f4a558c15246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a519e4316d264de076c62f4a558c15246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea82e271e7a1c3102dc78e1e1041caaa" id="r_aea82e271e7a1c3102dc78e1e1041caaa"><td class="memTemplParams" colspan="2">template&lt;class K2 , class T2 , class H2 , class C2 , class A2 &gt; </td></tr>
<tr class="memitem:aea82e271e7a1c3102dc78e1e1041caaa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#aea82e271e7a1c3102dc78e1e1041caaa">HashMap</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt; K2, T2, H2, C2, A2 &gt; &amp;other)</td></tr>
<tr class="memdesc:aea82e271e7a1c3102dc78e1e1041caaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:aea82e271e7a1c3102dc78e1e1041caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb04ffcefe8b484916647db6e8c90a1" id="r_aacb04ffcefe8b484916647db6e8c90a1"><td class="memTemplParams" colspan="2">template&lt;class K2 , class T2 , class H2 , class C2 , class A2 &gt; </td></tr>
<tr class="memitem:aacb04ffcefe8b484916647db6e8c90a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#aacb04ffcefe8b484916647db6e8c90a1">operator=</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt; K2, T2, H2, C2, A2 &gt; &amp;other)</td></tr>
<tr class="memdesc:aacb04ffcefe8b484916647db6e8c90a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:aacb04ffcefe8b484916647db6e8c90a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06ee85bf9dcab09f66f33ea93e153e8" id="r_ad06ee85bf9dcab09f66f33ea93e153e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ad06ee85bf9dcab09f66f33ea93e153e8">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad06ee85bf9dcab09f66f33ea93e153e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this container is empty.  <br /></td></tr>
<tr class="separator:ad06ee85bf9dcab09f66f33ea93e153e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf0e9e1d015eee7dc5ae70cda8095c" id="r_a99bf0e9e1d015eee7dc5ae70cda8095c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a99bf0e9e1d015eee7dc5ae70cda8095c">size</a> () const</td></tr>
<tr class="memdesc:a99bf0e9e1d015eee7dc5ae70cda8095c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes, keys, or values in this container.  <br /></td></tr>
<tr class="separator:a99bf0e9e1d015eee7dc5ae70cda8095c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016f92af6b04581aed1365e4135c705d" id="r_a016f92af6b04581aed1365e4135c705d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a016f92af6b04581aed1365e4135c705d">nBuckets</a> () const</td></tr>
<tr class="memdesc:a016f92af6b04581aed1365e4135c705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buckets.  <br /></td></tr>
<tr class="separator:a016f92af6b04581aed1365e4135c705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94eeedf3aed3cda1bda55933d1a73a5" id="r_af94eeedf3aed3cda1bda55933d1a73a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#af94eeedf3aed3cda1bda55933d1a73a5">loadFactor</a> () const</td></tr>
<tr class="memdesc:af94eeedf3aed3cda1bda55933d1a73a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average number of nodes per bucket.  <br /></td></tr>
<tr class="separator:af94eeedf3aed3cda1bda55933d1a73a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b84e5aa6adb3d8f9e324d1c6061ea2" id="r_a07b84e5aa6adb3d8f9e324d1c6061ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a07b84e5aa6adb3d8f9e324d1c6061ea2">rehash</a> (size_t <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a016f92af6b04581aed1365e4135c705d">nBuckets</a>)</td></tr>
<tr class="memdesc:a07b84e5aa6adb3d8f9e324d1c6061ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change number of buckets.  <br /></td></tr>
<tr class="separator:a07b84e5aa6adb3d8f9e324d1c6061ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf3c5e167249cd836c0a4e3c6365071" id="r_afbf3c5e167249cd836c0a4e3c6365071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#afbf3c5e167249cd836c0a4e3c6365071">exists</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:afbf3c5e167249cd836c0a4e3c6365071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a key exists.  <br /></td></tr>
<tr class="separator:afbf3c5e167249cd836c0a4e3c6365071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe7ba304c9e5e3ec2e02aa15abd402f" id="r_aabe7ba304c9e5e3ec2e02aa15abd402f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#aabe7ba304c9e5e3ec2e02aa15abd402f">getOptional</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:aabe7ba304c9e5e3ec2e02aa15abd402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or nothing.  <br /></td></tr>
<tr class="separator:aabe7ba304c9e5e3ec2e02aa15abd402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea7da9e8880ae9f53c2f1b05628faef" id="r_acea7da9e8880ae9f53c2f1b05628faef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#acea7da9e8880ae9f53c2f1b05628faef">getOrDefault</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:acea7da9e8880ae9f53c2f1b05628faef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or a default.  <br /></td></tr>
<tr class="separator:acea7da9e8880ae9f53c2f1b05628faef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3883f6eceb7c92c45579310c1132c2" id="r_a9c3883f6eceb7c92c45579310c1132c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2">insert</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key, const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;value)</td></tr>
<tr class="memdesc:a9c3883f6eceb7c92c45579310c1132c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update a key/value pair.  <br /></td></tr>
<tr class="separator:a9c3883f6eceb7c92c45579310c1132c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0caa8acebcd65055c5f493919912c" id="r_abbd0caa8acebcd65055c5f493919912c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c">insertDefault</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:abbd0caa8acebcd65055c5f493919912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update a key with a default value.  <br /></td></tr>
<tr class="separator:abbd0caa8acebcd65055c5f493919912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70569f756cfea58e3ee1486c9e529909" id="r_a70569f756cfea58e3ee1486c9e529909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909">insertMaybe</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key, const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;value)</td></tr>
<tr class="memdesc:a70569f756cfea58e3ee1486c9e529909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally insert a new key/value pair.  <br /></td></tr>
<tr class="separator:a70569f756cfea58e3ee1486c9e529909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a57c82cee6f42f16297d4739ebdca79" id="r_a5a57c82cee6f42f16297d4739ebdca79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79">insertMaybeDefault</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a5a57c82cee6f42f16297d4739ebdca79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally insert a new key with default value.  <br /></td></tr>
<tr class="separator:a5a57c82cee6f42f16297d4739ebdca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa599b8d2307279d0189cfc0dbb53bd" id="r_a5aa599b8d2307279d0189cfc0dbb53bd"><td class="memTemplParams" colspan="2">template&lt;class OtherNodeIterator &gt; </td></tr>
<tr class="memitem:a5aa599b8d2307279d0189cfc0dbb53bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd">insertMaybeMultiple</a> (const boost::iterator_range&lt; OtherNodeIterator &gt; &amp;range)</td></tr>
<tr class="memdesc:a5aa599b8d2307279d0189cfc0dbb53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally insert multiple key/value pairs.  <br /></td></tr>
<tr class="separator:a5aa599b8d2307279d0189cfc0dbb53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee329dccb2885622059f0b33e4d06e9e" id="r_aee329dccb2885622059f0b33e4d06e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#aee329dccb2885622059f0b33e4d06e9e">clear</a> ()</td></tr>
<tr class="memdesc:aee329dccb2885622059f0b33e4d06e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes.  <br /></td></tr>
<tr class="separator:aee329dccb2885622059f0b33e4d06e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a397f9af24c087cf034f229f22dfae" id="r_ac6a397f9af24c087cf034f229f22dfae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae">erase</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ac6a397f9af24c087cf034f229f22dfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node with specified key.  <br /></td></tr>
<tr class="separator:ac6a397f9af24c087cf034f229f22dfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f28e1561ca4ff3c5ffc84f6433bc41" id="r_a21f28e1561ca4ff3c5ffc84f6433bc41"><td class="memTemplParams" colspan="2">template&lt;class OtherKeyIterator &gt; </td></tr>
<tr class="memitem:a21f28e1561ca4ff3c5ffc84f6433bc41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41">eraseMultiple</a> (const boost::iterator_range&lt; OtherKeyIterator &gt; &amp;range)</td></tr>
<tr class="memdesc:a21f28e1561ca4ff3c5ffc84f6433bc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove keys stored in another <a class="el" href="classSawyer_1_1Container_1_1HashMap.html" title="Container associating values with keys.">HashMap</a>.  <br /></td></tr>
<tr class="separator:a21f28e1561ca4ff3c5ffc84f6433bc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a79b300f85237d11f968acea4aa21fd73" id="r_a79b300f85237d11f968acea4aa21fd73"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a79b300f85237d11f968acea4aa21fd73">nodes</a> ()</td></tr>
<tr class="memdesc:a79b300f85237d11f968acea4aa21fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container nodes.  <br /></td></tr>
<tr class="separator:a79b300f85237d11f968acea4aa21fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e56e98237554afbafb8a1b742ce1d9" id="r_a74e56e98237554afbafb8a1b742ce1d9"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html">ConstNodeIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a74e56e98237554afbafb8a1b742ce1d9">nodes</a> () const</td></tr>
<tr class="memdesc:a74e56e98237554afbafb8a1b742ce1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container nodes.  <br /></td></tr>
<tr class="separator:a74e56e98237554afbafb8a1b742ce1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abbbdf1941a62b60c1711838a04459643" id="r_abbbdf1941a62b60c1711838a04459643"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbbdf1941a62b60c1711838a04459643">keys</a> ()</td></tr>
<tr class="memdesc:abbbdf1941a62b60c1711838a04459643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container keys.  <br /></td></tr>
<tr class="separator:abbbdf1941a62b60c1711838a04459643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a608e9a01d216787d3f7a1ffb159e4" id="r_ac3a608e9a01d216787d3f7a1ffb159e4"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac3a608e9a01d216787d3f7a1ffb159e4">keys</a> () const</td></tr>
<tr class="memdesc:ac3a608e9a01d216787d3f7a1ffb159e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container keys.  <br /></td></tr>
<tr class="separator:ac3a608e9a01d216787d3f7a1ffb159e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2646178811bcc1e22515621bdfbc4f22" id="r_a2646178811bcc1e22515621bdfbc4f22"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html">ValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a2646178811bcc1e22515621bdfbc4f22">values</a> ()</td></tr>
<tr class="memdesc:a2646178811bcc1e22515621bdfbc4f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container values.  <br /></td></tr>
<tr class="separator:a2646178811bcc1e22515621bdfbc4f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45923ee922eb9ca1a160a1dc09a8299e" id="r_a45923ee922eb9ca1a160a1dc09a8299e"><td class="memItemLeft" align="right" valign="top">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstValueIterator.html">ConstValueIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a45923ee922eb9ca1a160a1dc09a8299e">values</a> () const</td></tr>
<tr class="memdesc:a45923ee922eb9ca1a160a1dc09a8299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators for container values.  <br /></td></tr>
<tr class="separator:a45923ee922eb9ca1a160a1dc09a8299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5288bcd06f18f17ac09fbb361619967d" id="r_a5288bcd06f18f17ac09fbb361619967d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5288bcd06f18f17ac09fbb361619967d">maxLoadFactor</a> () const</td></tr>
<tr class="memdesc:a5288bcd06f18f17ac09fbb361619967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Maximum allowed load faster before automatic rehash.  <br /></td></tr>
<tr class="separator:a5288bcd06f18f17ac09fbb361619967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149470bb92b63edd3c7ffa326e8ff16d" id="r_a149470bb92b63edd3c7ffa326e8ff16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a149470bb92b63edd3c7ffa326e8ff16d">maxLoadFactor</a> (double mlf)</td></tr>
<tr class="memdesc:a149470bb92b63edd3c7ffa326e8ff16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Maximum allowed load faster before automatic rehash.  <br /></td></tr>
<tr class="separator:a149470bb92b63edd3c7ffa326e8ff16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a64412ef5ef27a61197863df6c8dfacac" id="r_a64412ef5ef27a61197863df6c8dfacac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a64412ef5ef27a61197863df6c8dfacac">find</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a64412ef5ef27a61197863df6c8dfacac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node by key.  <br /></td></tr>
<tr class="separator:a64412ef5ef27a61197863df6c8dfacac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6186fe9fd3b47ffb4694b1495ca71714" id="r_a6186fe9fd3b47ffb4694b1495ca71714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html">ConstNodeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a6186fe9fd3b47ffb4694b1495ca71714">find</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a6186fe9fd3b47ffb4694b1495ca71714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node by key.  <br /></td></tr>
<tr class="separator:a6186fe9fd3b47ffb4694b1495ca71714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0669c73ac87505e88f57837c94789893" id="r_a0669c73ac87505e88f57837c94789893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a0669c73ac87505e88f57837c94789893">operator[]</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:a0669c73ac87505e88f57837c94789893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to an existing value.  <br /></td></tr>
<tr class="separator:a0669c73ac87505e88f57837c94789893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ee4dd5031337a467ba85216e9c6fb2" id="r_a40ee4dd5031337a467ba85216e9c6fb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a40ee4dd5031337a467ba85216e9c6fb2">operator[]</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a40ee4dd5031337a467ba85216e9c6fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to an existing value.  <br /></td></tr>
<tr class="separator:a40ee4dd5031337a467ba85216e9c6fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae876c2dbf8c3e8a8838e9ca2ba8f2e6c" id="r_ae876c2dbf8c3e8a8838e9ca2ba8f2e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae876c2dbf8c3e8a8838e9ca2ba8f2e6c">get</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key)</td></tr>
<tr class="memdesc:ae876c2dbf8c3e8a8838e9ca2ba8f2e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and retun an existing value.  <br /></td></tr>
<tr class="separator:ae876c2dbf8c3e8a8838e9ca2ba8f2e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3495bef8a0ab52a02e633d6f1d87c0" id="r_a5b3495bef8a0ab52a02e633d6f1d87c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5b3495bef8a0ab52a02e633d6f1d87c0">get</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key) const</td></tr>
<tr class="memdesc:a5b3495bef8a0ab52a02e633d6f1d87c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and retun an existing value.  <br /></td></tr>
<tr class="separator:a5b3495bef8a0ab52a02e633d6f1d87c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5792398241910e0a0bb71671633a7c6f" id="r_a5792398241910e0a0bb71671633a7c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5792398241910e0a0bb71671633a7c6f">getOrElse</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key, <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;dflt)</td></tr>
<tr class="memdesc:a5792398241910e0a0bb71671633a7c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:a5792398241910e0a0bb71671633a7c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693cbba199be5ad58e3e1087fb4ce523" id="r_a693cbba199be5ad58e3e1087fb4ce523"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a693cbba199be5ad58e3e1087fb4ce523">getOrElse</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;key, const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;dflt) const</td></tr>
<tr class="memdesc:a693cbba199be5ad58e3e1087fb4ce523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup and return a value or something else.  <br /></td></tr>
<tr class="separator:a693cbba199be5ad58e3e1087fb4ce523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae489d2ad771568b7172b466f21fab459" id="r_ae489d2ad771568b7172b466f21fab459"><td class="memTemplParams" colspan="2">template&lt;class OtherNodeIterator &gt; </td></tr>
<tr class="memitem:ae489d2ad771568b7172b466f21fab459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459">insertMultiple</a> (const OtherNodeIterator &amp;begin, const OtherNodeIterator &amp;end)</td></tr>
<tr class="memdesc:ae489d2ad771568b7172b466f21fab459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple values.  <br /></td></tr>
<tr class="separator:ae489d2ad771568b7172b466f21fab459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec8be40f52a7383603b2ae2339b63bc" id="r_afec8be40f52a7383603b2ae2339b63bc"><td class="memTemplParams" colspan="2">template&lt;class OtherNodeIterator &gt; </td></tr>
<tr class="memitem:afec8be40f52a7383603b2ae2339b63bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#afec8be40f52a7383603b2ae2339b63bc">insertMultiple</a> (const boost::iterator_range&lt; OtherNodeIterator &gt; &amp;range)</td></tr>
<tr class="memdesc:afec8be40f52a7383603b2ae2339b63bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple values.  <br /></td></tr>
<tr class="separator:afec8be40f52a7383603b2ae2339b63bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3803e6fa5047a80a701f0914e4599b2b" id="r_a3803e6fa5047a80a701f0914e4599b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3803e6fa5047a80a701f0914e4599b2b">eraseAt</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a> &amp;iter)</td></tr>
<tr class="memdesc:a3803e6fa5047a80a701f0914e4599b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node by iterator.  <br /></td></tr>
<tr class="separator:a3803e6fa5047a80a701f0914e4599b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69107b9e33f19a3e870a47d6121df3bb" id="r_a69107b9e33f19a3e870a47d6121df3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a69107b9e33f19a3e870a47d6121df3bb">eraseAt</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &amp;iter)</td></tr>
<tr class="memdesc:a69107b9e33f19a3e870a47d6121df3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node by iterator.  <br /></td></tr>
<tr class="separator:a69107b9e33f19a3e870a47d6121df3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1569e684f816d4b6ca4b1e6a307dad3f" id="r_a1569e684f816d4b6ca4b1e6a307dad3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1569e684f816d4b6ca4b1e6a307dad3f">eraseAt</a> (const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html">ValueIterator</a> &amp;iter)</td></tr>
<tr class="memdesc:a1569e684f816d4b6ca4b1e6a307dad3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node by iterator.  <br /></td></tr>
<tr class="separator:a1569e684f816d4b6ca4b1e6a307dad3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02bdd7b7ca0e8df1813dc620cc0e86fe" id="r_a02bdd7b7ca0e8df1813dc620cc0e86fe"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a02bdd7b7ca0e8df1813dc620cc0e86fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe">eraseAtMultiple</a> (const Iter &amp;begin, const Iter &amp;end)</td></tr>
<tr class="memdesc:a02bdd7b7ca0e8df1813dc620cc0e86fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple nodes by iterator range.  <br /></td></tr>
<tr class="separator:a02bdd7b7ca0e8df1813dc620cc0e86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13edc7c78e6e9fab8949a3a9579891c" id="r_aa13edc7c78e6e9fab8949a3a9579891c"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:aa13edc7c78e6e9fab8949a3a9579891c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#aa13edc7c78e6e9fab8949a3a9579891c">eraseAtMultiple</a> (const boost::iterator_range&lt; Iter &gt; &amp;range)</td></tr>
<tr class="memdesc:aa13edc7c78e6e9fab8949a3a9579891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove multiple nodes by iterator range.  <br /></td></tr>
<tr class="separator:aa13edc7c78e6e9fab8949a3a9579891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac71e99fb6c0d2a3f2bcdcc9bb4b26b50" name="ac71e99fb6c0d2a3f2bcdcc9bb4b26b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">&#9670;&#160;</a></span>Key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef K <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::Key</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of keys. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00032">32</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a4eacdb66a2c72395bd31d1bfd2b3dd5b" name="a4eacdb66a2c72395bd31d1bfd2b3dd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eacdb66a2c72395bd31d1bfd2b3dd5b">&#9670;&#160;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSawyer_1_1Type.html" title="Data types.">Type</a> of values. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00033">33</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a52b464432529c364630704e76cd6c91d" name="a52b464432529c364630704e76cd6c91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b464432529c364630704e76cd6c91d">&#9670;&#160;</a></span>Hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef H <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::Hasher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor for hashing keys. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00034">34</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a08925681ab0ebc5e1cd33ed140b44e7b" name="a08925681ab0ebc5e1cd33ed140b44e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08925681ab0ebc5e1cd33ed140b44e7b">&#9670;&#160;</a></span>Comparator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef C <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::Comparator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor for comparing keys. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00035">35</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a1d78e8941b43c88e91ff03cde9c7726b" name="a1d78e8941b43c88e91ff03cde9c7726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d78e8941b43c88e91ff03cde9c7726b">&#9670;&#160;</a></span>Allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor for allocating node memory. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00036">36</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3df3d3a4f25ed1ac1013b19754dc6816" name="a3df3d3a4f25ed1ac1013b19754dc6816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df3d3a4f25ed1ac1013b19754dc6816">&#9670;&#160;</a></span>HashMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::HashMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty map. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00253">253</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a6e4bff1224e8d7ec437fc2fd79cdebf3" name="a6e4bff1224e8d7ec437fc2fd79cdebf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4bff1224e8d7ec437fc2fd79cdebf3">&#9670;&#160;</a></span>HashMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::HashMap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a52b464432529c364630704e76cd6c91d">Hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>hasher</em> = <code><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a52b464432529c364630704e76cd6c91d">Hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a> &amp;&#160;</td>
          <td class="paramname"><em>cmp</em> = <code><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1d78e8941b43c88e91ff03cde9c7726b">Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a1d78e8941b43c88e91ff03cde9c7726b">Allocator</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a hash map with at least <code>n</code> buckets. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00256">256</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a519e4316d264de076c62f4a558c15246" name="a519e4316d264de076c62f4a558c15246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519e4316d264de076c62f4a558c15246">&#9670;&#160;</a></span>HashMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::HashMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt; K, T, H, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00260">260</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="aea82e271e7a1c3102dc78e1e1041caaa" name="aea82e271e7a1c3102dc78e1e1041caaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea82e271e7a1c3102dc78e1e1041caaa">&#9670;&#160;</a></span>HashMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class K2 , class T2 , class H2 , class C2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::HashMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt; K2, T2, H2, C2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Initializes the new map with copies of the nodes of the <code>other</code> map. The keys and values must be convertible from the ohter map to this map. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00268">268</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00296">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::nodes()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aacb04ffcefe8b484916647db6e8c90a1" name="aacb04ffcefe8b484916647db6e8c90a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb04ffcefe8b484916647db6e8c90a1">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class K2 , class T2 , class H2 , class C2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt; K2, T2, H2, C2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00277">277</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00601">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::clear()</a>, and <a class="el" href="HashMap_8h_source.html#l00296">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::nodes()</a>.</p>

</div>
</div>
<a id="a79b300f85237d11f968acea4aa21fd73" name="a79b300f85237d11f968acea4aa21fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b300f85237d11f968acea4aa21fd73">&#9670;&#160;</a></span>nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container nodes. </p>
<p>This returns a range of node-iterators that will traverse all nodes (key/value pairs) of this container. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00296">296</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00268">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::HashMap()</a>, and <a class="el" href="HashMap_8h_source.html#l00277">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a74e56e98237554afbafb8a1b742ce1d9" name="a74e56e98237554afbafb8a1b742ce1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e56e98237554afbafb8a1b742ce1d9">&#9670;&#160;</a></span>nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html">ConstNodeIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container nodes. </p>
<p>This returns a range of node-iterators that will traverse all nodes (key/value pairs) of this container. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00299">299</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="abbbdf1941a62b60c1711838a04459643" name="abbbdf1941a62b60c1711838a04459643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbdf1941a62b60c1711838a04459643">&#9670;&#160;</a></span>keys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container keys. </p>
<p>Returns a range of key-iterators that will traverse the keys of this container. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00309">309</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="ac3a608e9a01d216787d3f7a1ffb159e4" name="ac3a608e9a01d216787d3f7a1ffb159e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a608e9a01d216787d3f7a1ffb159e4">&#9670;&#160;</a></span>keys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container keys. </p>
<p>Returns a range of key-iterators that will traverse the keys of this container. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00312">312</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a2646178811bcc1e22515621bdfbc4f22" name="a2646178811bcc1e22515621bdfbc4f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2646178811bcc1e22515621bdfbc4f22">&#9670;&#160;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html">ValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container values. </p>
<p>Returns a range of iterators that will traverse the user-defined values of this container. The values are iterated in key order, although the keys are not directly available via these iterators. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00323">323</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a45923ee922eb9ca1a160a1dc09a8299e" name="a45923ee922eb9ca1a160a1dc09a8299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45923ee922eb9ca1a160a1dc09a8299e">&#9670;&#160;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::iterator_range&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstValueIterator.html">ConstValueIterator</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators for container values. </p>
<p>Returns a range of iterators that will traverse the user-defined values of this container. The values are iterated in key order, although the keys are not directly available via these iterators. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00326">326</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="ad06ee85bf9dcab09f66f33ea93e153e8" name="ad06ee85bf9dcab09f66f33ea93e153e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06ee85bf9dcab09f66f33ea93e153e8">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether this container is empty. </p>
<p>Returns true if the container is empty, and false if it has at least one node. This method executes in constant time. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00339">339</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a99bf0e9e1d015eee7dc5ae70cda8095c" name="a99bf0e9e1d015eee7dc5ae70cda8095c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf0e9e1d015eee7dc5ae70cda8095c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of nodes, keys, or values in this container. </p>
<p>Returns the number of nodes currently stored in this container. A node is a key + value pair. This method executes in constant time. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00347">347</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstructionProvider_8h_source.html#l00110">Rose::BinaryAnalysis::InstructionProvider::nCached()</a>.</p>

</div>
</div>
<a id="a016f92af6b04581aed1365e4135c705d" name="a016f92af6b04581aed1365e4135c705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016f92af6b04581aed1365e4135c705d">&#9670;&#160;</a></span>nBuckets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::nBuckets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of buckets. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00352">352</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00373">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::rehash()</a>.</p>

</div>
</div>
<a id="af94eeedf3aed3cda1bda55933d1a73a5" name="af94eeedf3aed3cda1bda55933d1a73a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94eeedf3aed3cda1bda55933d1a73a5">&#9670;&#160;</a></span>loadFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::loadFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average number of nodes per bucket. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00357">357</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a5288bcd06f18f17ac09fbb361619967d" name="a5288bcd06f18f17ac09fbb361619967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5288bcd06f18f17ac09fbb361619967d">&#9670;&#160;</a></span>maxLoadFactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::maxLoadFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Maximum allowed load faster before automatic rehash. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00364">364</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a149470bb92b63edd3c7ffa326e8ff16d" name="a149470bb92b63edd3c7ffa326e8ff16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149470bb92b63edd3c7ffa326e8ff16d">&#9670;&#160;</a></span>maxLoadFactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::maxLoadFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mlf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Property: Maximum allowed load faster before automatic rehash. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00367">367</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a07b84e5aa6adb3d8f9e324d1c6061ea2" name="a07b84e5aa6adb3d8f9e324d1c6061ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b84e5aa6adb3d8f9e324d1c6061ea2">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBuckets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change number of buckets. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00373">373</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00352">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::nBuckets()</a>.</p>

</div>
</div>
<a id="a64412ef5ef27a61197863df6c8dfacac" name="a64412ef5ef27a61197863df6c8dfacac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64412ef5ef27a61197863df6c8dfacac">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node by key. </p>
<p>Looks for a node whose key is equal to the specified <code>key</code> and returns an iterator to that node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00388">388</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a6186fe9fd3b47ffb4694b1495ca71714" name="a6186fe9fd3b47ffb4694b1495ca71714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6186fe9fd3b47ffb4694b1495ca71714">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstNodeIterator.html">ConstNodeIterator</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node by key. </p>
<p>Looks for a node whose key is equal to the specified <code>key</code> and returns an iterator to that node, or the end iterator if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00391">391</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="afbf3c5e167249cd836c0a4e3c6365071" name="afbf3c5e167249cd836c0a4e3c6365071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf3c5e167249cd836c0a4e3c6365071">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a key exists. </p>
<p>Looks for a node whose key is equal to the specified <code>key</code> and returns true if found, or false if no such node exists. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00400">400</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a0669c73ac87505e88f57837c94789893" name="a0669c73ac87505e88f57837c94789893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0669c73ac87505e88f57837c94789893">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>key</code>. Unlike <code>std::map</code>, this container does not instantiate a new key/value pair if the <code>key</code> is not in the map's domain. In other words, the array operator for this class is more like an array operator on arrays or vectors&ndash;such objects are not automatically extended if dereferenced with an operand that is outside the domain.</p>
<p>If the <code>key</code> is not part of this map's domain then an <code>std::domain_error</code> is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00421">421</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00437">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::get()</a>.</p>

</div>
</div>
<a id="a40ee4dd5031337a467ba85216e9c6fb2" name="a40ee4dd5031337a467ba85216e9c6fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ee4dd5031337a467ba85216e9c6fb2">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>key</code>. Unlike <code>std::map</code>, this container does not instantiate a new key/value pair if the <code>key</code> is not in the map's domain. In other words, the array operator for this class is more like an array operator on arrays or vectors&ndash;such objects are not automatically extended if dereferenced with an operand that is outside the domain.</p>
<p>If the <code>key</code> is not part of this map's domain then an <code>std::domain_error</code> is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00424">424</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00437">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::get()</a>.</p>

</div>
</div>
<a id="ae876c2dbf8c3e8a8838e9ca2ba8f2e6c" name="ae876c2dbf8c3e8a8838e9ca2ba8f2e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae876c2dbf8c3e8a8838e9ca2ba8f2e6c">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and retun an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>key</code>, which must exist. If the <code>key</code> is not part of this map's domain, then an <code>std::domain_error</code> is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00437">437</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00421">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::operator[]()</a>, and <a class="el" href="HashMap_8h_source.html#l00424">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::operator[]()</a>.</p>

</div>
</div>
<a id="a5b3495bef8a0ab52a02e633d6f1d87c0" name="a5b3495bef8a0ab52a02e633d6f1d87c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3495bef8a0ab52a02e633d6f1d87c0">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and retun an existing value. </p>
<p>Returns a reference to the value at the node with the specified <code>key</code>, which must exist. If the <code>key</code> is not part of this map's domain, then an <code>std::domain_error</code> is thrown.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00443">443</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="aabe7ba304c9e5e3ec2e02aa15abd402f" name="aabe7ba304c9e5e3ec2e02aa15abd402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe7ba304c9e5e3ec2e02aa15abd402f">&#9670;&#160;</a></span>getOptional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Optional.html">Optional</a>&lt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &gt; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::getOptional </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or nothing. </p>
<p>Looks up the node with the specified key and returns either a copy of its value, or nothing.</p>
<p>Here's an example of one convenient way to use this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1HashMap.html">HashMap&lt;std::string, FileInfo&gt;</a> files;</div>
<div class="line">...</div>
<div class="line">if (<a class="code hl_class" href="classSawyer_1_1Optional.html">Optional&lt;FileInfo&gt;</a> fileInfo = files.<a class="code hl_function" href="classSawyer_1_1Container_1_1HashMap.html#aabe7ba304c9e5e3ec2e02aa15abd402f">getOptional</a>(fileName))</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;file info for \&quot;&quot;</span> &lt;&lt;fileName &lt;&lt;<span class="stringliteral">&quot;\&quot; is &quot;</span> &lt;&lt;*fileInfo &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1HashMap_html"><div class="ttname"><a href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a></div><div class="ttdoc">Container associating values with keys.</div><div class="ttdef"><b>Definition</b> <a href="HashMap_8h_source.html#l00030">HashMap.h:30</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1HashMap_html_aabe7ba304c9e5e3ec2e02aa15abd402f"><div class="ttname"><a href="classSawyer_1_1Container_1_1HashMap.html#aabe7ba304c9e5e3ec2e02aa15abd402f">Sawyer::Container::HashMap::getOptional</a></div><div class="ttdeci">Optional&lt; Value &gt; getOptional(const Key &amp;key) const</div><div class="ttdoc">Lookup and return a value or nothing.</div><div class="ttdef"><b>Definition</b> <a href="HashMap_8h_source.html#l00473">HashMap.h:473</a></div></div>
<div class="ttc" id="aclassSawyer_1_1Optional_html"><div class="ttname"><a href="classSawyer_1_1Optional.html">Sawyer::Optional</a></div><div class="ttdoc">Holds a value or nothing.</div><div class="ttdef"><b>Definition</b> <a href="Optional_8h_source.html#l00056">Optional.h:56</a></div></div>
</div><!-- fragment --><p>The equivalent STL approach is:</p>
<div class="fragment"><div class="line">std::map&lt;std::string, FileInfo&gt; files;</div>
<div class="line">...</div>
<div class="line">std::map&lt;std::string, FileInfo&gt;::const_iterator filesIter = files.<a class="code hl_function" href="classSawyer_1_1Container_1_1HashMap.html#a64412ef5ef27a61197863df6c8dfacac">find</a>(fileName);</div>
<div class="line"><span class="keywordflow">if</span> (fileIter != files.end())</div>
<div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;file info for \&quot;&quot;</span> &lt;&lt;fileName &lt;&lt;<span class="stringliteral">&quot;\&quot; is &quot;</span> &lt;&lt;filesIter-&gt;second &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassSawyer_1_1Container_1_1HashMap_html_a64412ef5ef27a61197863df6c8dfacac"><div class="ttname"><a href="classSawyer_1_1Container_1_1HashMap.html#a64412ef5ef27a61197863df6c8dfacac">Sawyer::Container::HashMap::find</a></div><div class="ttdeci">NodeIterator find(const Key &amp;key)</div><div class="ttdoc">Find a node by key.</div><div class="ttdef"><b>Definition</b> <a href="HashMap_8h_source.html#l00388">HashMap.h:388</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00473">473</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a5792398241910e0a0bb71671633a7c6f" name="a5792398241910e0a0bb71671633a7c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5792398241910e0a0bb71671633a7c6f">&#9670;&#160;</a></span>getOrElse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::getOrElse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or something else. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae876c2dbf8c3e8a8838e9ca2ba8f2e6c">get</a> method, except a default can be provided. If a node with the specified <code>key</code> is present in this container, then a reference to that node's value is returned, otherwise the (reference to) supplied default is returned. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00485">485</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a693cbba199be5ad58e3e1087fb4ce523" name="a693cbba199be5ad58e3e1087fb4ce523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693cbba199be5ad58e3e1087fb4ce523">&#9670;&#160;</a></span>getOrElse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::getOrElse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>dflt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or something else. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae876c2dbf8c3e8a8838e9ca2ba8f2e6c">get</a> method, except a default can be provided. If a node with the specified <code>key</code> is present in this container, then a reference to that node's value is returned, otherwise the (reference to) supplied default is returned. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00489">489</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="acea7da9e8880ae9f53c2f1b05628faef" name="acea7da9e8880ae9f53c2f1b05628faef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea7da9e8880ae9f53c2f1b05628faef">&#9670;&#160;</a></span>getOrDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::getOrDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup and return a value or a default. </p>
<p>This is similar to the <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5792398241910e0a0bb71671633a7c6f">getOrElse</a> method except when the key is not present in the map, a reference to a const, default-constructed value is returned. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00499">499</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

</div>
</div>
<a id="a9c3883f6eceb7c92c45579310c1132c2" name="a9c3883f6eceb7c92c45579310c1132c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3883f6eceb7c92c45579310c1132c2">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update a key/value pair. </p>
<p>Inserts the key/value pair into the container. If a previous node already had the same key then it is replaced by the new node.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909" title="Conditionally insert a new key/value pair.">insertMaybe</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459" title="Insert multiple values.">insertMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00516">516</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00516">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00516">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insert()</a>, <a class="el" href="HashMap_8h_source.html#l00529">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertDefault()</a>, and <a class="el" href="HashMap_8h_source.html#l00551">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMultiple()</a>.</p>

</div>
</div>
<a id="abbd0caa8acebcd65055c5f493919912c" name="abbd0caa8acebcd65055c5f493919912c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0caa8acebcd65055c5f493919912c">&#9670;&#160;</a></span>insertDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert or update a key with a default value. </p>
<p>The value associated with <code>key</code> in the map is replaced with a default-constructed value. If the key does not exist then it is inserted with a default value. This operation is similar to the array operator of <code>std::map</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909" title="Conditionally insert a new key/value pair.">insertMaybe</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459" title="Insert multiple values.">insertMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00529">529</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00516">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insert()</a>.</p>

</div>
</div>
<a id="ae489d2ad771568b7172b466f21fab459" name="ae489d2ad771568b7172b466f21fab459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae489d2ad771568b7172b466f21fab459">&#9670;&#160;</a></span>insertMultiple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherNodeIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertMultiple </td>
          <td>(</td>
          <td class="paramtype">const OtherNodeIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNodeIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple values. </p>
<p>Inserts copies of the nodes in the specified node iterator range. The iterators must iterate over objects that have <code>key</code> and <code>value</code> methods that return keys and values that are convertible to the types used by this container.</p>
<p>The normal way to insert the contents of one map into another is:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt;...&gt; source = ...;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt;...&gt; destination = ...;</div>
<div class="line">destination.insertMultiple(source.nodes());</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909" title="Conditionally insert a new key/value pair.">insertMaybe</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00551">551</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00516">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00557">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMultiple()</a>.</p>

</div>
</div>
<a id="afec8be40f52a7383603b2ae2339b63bc" name="afec8be40f52a7383603b2ae2339b63bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec8be40f52a7383603b2ae2339b63bc">&#9670;&#160;</a></span>insertMultiple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherNodeIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertMultiple </td>
          <td>(</td>
          <td class="paramtype">const boost::iterator_range&lt; OtherNodeIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple values. </p>
<p>Inserts copies of the nodes in the specified node iterator range. The iterators must iterate over objects that have <code>key</code> and <code>value</code> methods that return keys and values that are convertible to the types used by this container.</p>
<p>The normal way to insert the contents of one map into another is:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt;...&gt; source = ...;</div>
<div class="line"><a class="code hl_class" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a>&lt;...&gt; destination = ...;</div>
<div class="line">destination.insertMultiple(source.nodes());</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909" title="Conditionally insert a new key/value pair.">insertMaybe</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00557">557</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00551">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMultiple()</a>.</p>

</div>
</div>
<a id="a70569f756cfea58e3ee1486c9e529909" name="a70569f756cfea58e3ee1486c9e529909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70569f756cfea58e3ee1486c9e529909">&#9670;&#160;</a></span>insertMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertMaybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally insert a new key/value pair. </p>
<p>Inserts the key/value pair into the container if the container does not yet have a node with the same key. The return value is a reference to the value that is in the container, either the value that previously existed or a copy of the specified <code>value</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459" title="Insert multiple values.">insertMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00569">569</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00580">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMaybeDefault()</a>, and <a class="el" href="HashMap_8h_source.html#l00591">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMaybeMultiple()</a>.</p>

</div>
</div>
<a id="a5a57c82cee6f42f16297d4739ebdca79" name="a5a57c82cee6f42f16297d4739ebdca79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a57c82cee6f42f16297d4739ebdca79">&#9670;&#160;</a></span>insertMaybeDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a4eacdb66a2c72395bd31d1bfd2b3dd5b">Value</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertMaybeDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally insert a new key with default value. </p>
<p>Inserts a key/value pair into the container if the container does not yet have a node with the same key. The value is default-constructed. The return value is a reference to the value that is in the container, either the value that previously existed or the new default-constructed value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459" title="Insert multiple values.">insertMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5aa599b8d2307279d0189cfc0dbb53bd" title="Conditionally insert multiple key/value pairs.">insertMaybeMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00580">580</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00569">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMaybe()</a>.</p>

</div>
</div>
<a id="a5aa599b8d2307279d0189cfc0dbb53bd" name="a5aa599b8d2307279d0189cfc0dbb53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa599b8d2307279d0189cfc0dbb53bd">&#9670;&#160;</a></span>insertMaybeMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherNodeIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::insertMaybeMultiple </td>
          <td>(</td>
          <td class="paramtype">const boost::iterator_range&lt; OtherNodeIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally insert multiple key/value pairs. </p>
<p>Inserts each of the specified key/value pairs into this container where this container does not already contain a value for the key. The return value is a reference to the container itself so that this method can be chained with others.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a9c3883f6eceb7c92c45579310c1132c2" title="Insert or update a key/value pair.">insert</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#abbd0caa8acebcd65055c5f493919912c" title="Insert or update a key with a default value.">insertDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a70569f756cfea58e3ee1486c9e529909" title="Conditionally insert a new key/value pair.">insertMaybe</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a5a57c82cee6f42f16297d4739ebdca79" title="Conditionally insert a new key with default value.">insertMaybeDefault</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ae489d2ad771568b7172b466f21fab459" title="Insert multiple values.">insertMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00591">591</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00569">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::insertMaybe()</a>.</p>

</div>
</div>
<a id="aee329dccb2885622059f0b33e4d06e9e" name="aee329dccb2885622059f0b33e4d06e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee329dccb2885622059f0b33e4d06e9e">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes. </p>
<p>All nodes are removed from this container. This method executes in linear time in the number of nodes in this container. </p>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00601">601</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00601">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00601">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::clear()</a>, and <a class="el" href="HashMap_8h_source.html#l00277">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::operator=()</a>.</p>

</div>
</div>
<a id="ac6a397f9af24c087cf034f229f22dfae" name="ac6a397f9af24c087cf034f229f22dfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a397f9af24c087cf034f229f22dfae">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac71e99fb6c0d2a3f2bcdcc9bb4b26b50">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node with specified key. </p>
<p>Removes the node whose key is equal to the specified key, or does nothing if no such node exists. Two keys are considered equal if this container's <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a> object returns false reflexively.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3803e6fa5047a80a701f0914e4599b2b" title="Remove a node by iterator.">eraseAt</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe" title="Remove multiple nodes by iterator range.">eraseAtMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00612">612</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>, <a class="el" href="HashMap_8h_source.html#l00642">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseAt()</a>, <a class="el" href="HashMap_8h_source.html#l00638">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseAt()</a>, <a class="el" href="HashMap_8h_source.html#l00646">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseAt()</a>, <a class="el" href="HashMap_8h_source.html#l00665">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseAtMultiple()</a>, <a class="el" href="HashMap_8h_source.html#l00660">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseAtMultiple()</a>, and <a class="el" href="HashMap_8h_source.html#l00625">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::eraseMultiple()</a>.</p>

</div>
</div>
<a id="a21f28e1561ca4ff3c5ffc84f6433bc41" name="a21f28e1561ca4ff3c5ffc84f6433bc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f28e1561ca4ff3c5ffc84f6433bc41">&#9670;&#160;</a></span>eraseMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherKeyIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseMultiple </td>
          <td>(</td>
          <td class="paramtype">const boost::iterator_range&lt; OtherKeyIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove keys stored in another <a class="el" href="classSawyer_1_1Container_1_1HashMap.html" title="Container associating values with keys.">HashMap</a>. </p>
<p>All nodes of this container whose keys are equal to any key in the <code>other</code> container are removed from this container. The keys of the other container must be convertible to the types used by this container, and two keys are considered equal if this container's <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a08925681ab0ebc5e1cd33ed140b44e7b">Comparator</a> object returns false reflexively.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3803e6fa5047a80a701f0914e4599b2b" title="Remove a node by iterator.">eraseAt</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe" title="Remove multiple nodes by iterator range.">eraseAtMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00625">625</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<a id="a3803e6fa5047a80a701f0914e4599b2b" name="a3803e6fa5047a80a701f0914e4599b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3803e6fa5047a80a701f0914e4599b2b">&#9670;&#160;</a></span>eraseAt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1NodeIterator.html">NodeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node by iterator. </p>
<p>Removes the node referenced by <code>iter</code>. The iterator must reference a valid node in this container.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe" title="Remove multiple nodes by iterator range.">eraseAtMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00638">638</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<a id="a69107b9e33f19a3e870a47d6121df3bb" name="a69107b9e33f19a3e870a47d6121df3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69107b9e33f19a3e870a47d6121df3bb">&#9670;&#160;</a></span>eraseAt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ConstKeyIterator.html">ConstKeyIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node by iterator. </p>
<p>Removes the node referenced by <code>iter</code>. The iterator must reference a valid node in this container.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe" title="Remove multiple nodes by iterator range.">eraseAtMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00642">642</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<a id="a1569e684f816d4b6ca4b1e6a307dad3f" name="a1569e684f816d4b6ca4b1e6a307dad3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1569e684f816d4b6ca4b1e6a307dad3f">&#9670;&#160;</a></span>eraseAt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSawyer_1_1Container_1_1HashMap_1_1ValueIterator.html">ValueIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node by iterator. </p>
<p>Removes the node referenced by <code>iter</code>. The iterator must reference a valid node in this container.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a02bdd7b7ca0e8df1813dc620cc0e86fe" title="Remove multiple nodes by iterator range.">eraseAtMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00646">646</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<a id="a02bdd7b7ca0e8df1813dc620cc0e86fe" name="a02bdd7b7ca0e8df1813dc620cc0e86fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bdd7b7ca0e8df1813dc620cc0e86fe">&#9670;&#160;</a></span>eraseAtMultiple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseAtMultiple </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove multiple nodes by iterator range. </p>
<p>The iterator range must contain iterators that point into this container.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3803e6fa5047a80a701f0914e4599b2b" title="Remove a node by iterator.">eraseAt</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00660">660</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<a id="aa13edc7c78e6e9fab8949a3a9579891c" name="aa13edc7c78e6e9fab8949a3a9579891c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13edc7c78e6e9fab8949a3a9579891c">&#9670;&#160;</a></span>eraseAtMultiple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class H  = boost::hash&lt;K&gt;, class C  = std::equal_to&lt;K&gt;, class A  = std::allocator&lt;std::pair&lt;const K, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSawyer_1_1Container_1_1HashMap.html">HashMap</a> &amp; <a class="el" href="classSawyer_1_1Container_1_1HashMap.html">Sawyer::Container::HashMap</a>&lt; K, T, H, C, A &gt;::eraseAtMultiple </td>
          <td>(</td>
          <td class="paramtype">const boost::iterator_range&lt; Iter &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove multiple nodes by iterator range. </p>
<p>The iterator range must contain iterators that point into this container.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSawyer_1_1Container_1_1HashMap.html#ac6a397f9af24c087cf034f229f22dfae" title="Remove a node with specified key.">erase</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a3803e6fa5047a80a701f0914e4599b2b" title="Remove a node by iterator.">eraseAt</a> <a class="el" href="classSawyer_1_1Container_1_1HashMap.html#a21f28e1561ca4ff3c5ffc84f6433bc41" title="Remove keys stored in another HashMap.">eraseMultiple</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HashMap_8h_source.html#l00665">665</a> of file <a class="el" href="HashMap_8h_source.html">HashMap.h</a>.</p>

<p class="reference">References <a class="el" href="HashMap_8h_source.html#l00612">Sawyer::Container::HashMap&lt; K, T, H, C, A &gt;::erase()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="HashMap_8h_source.html">HashMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:36 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
