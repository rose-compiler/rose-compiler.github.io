<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::Partitioner2::Function Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html">Partitioner2</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html">Function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::Partitioner2::Function Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Describes one function. </p>
<p>A function consists of one or more basic blocks. Exactly one block is special in that it serves as the entry point when this function is invoked from elsewhere; the only incoming inter-function edges are to this entry block. This function may have outgoing inter-function edges that represent invocations of other functions, and the targets of all such edges will be the entry block of another function. A function may also own zero or more data blocks consisting of a base address and size (type).</p>
<p>A function may exist as part of the partitioner's control flow graph, or in a detached state. When a function is represented by the control flow graph then it is in a frozen state, meaning that its basic blocks and data blocks cannot be adjusted adjusted; one must use the partitioner interface to do so. </p>

<p class="definition">Definition at line <a class="el" href="Function_8h_source.html#l00041">41</a> of file <a class="el" href="Function_8h_source.html">Function.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="Function_8h_source.html">Rose/BinaryAnalysis/Partitioner2/Function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::Partitioner2::Function:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_inherit__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_inherit__map">
<area shape="rect" title="Describes one function." alt="" coords="90,93,245,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,13,159,38"/>
<area shape="poly" title=" " alt="" coords="106,46,150,91,146,95,102,50"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="183,5,325,45"/>
<area shape="poly" title=" " alt="" coords="226,57,189,95,185,91,223,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::Partitioner2::Function:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_coll__map" id="aRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function_coll__map">
<area shape="rect" title="Describes one function." alt="" coords="90,93,245,133"/>
<area shape="rect" href="classSawyer_1_1SharedObject.html" title="Base class for reference counted objects." alt="" coords="5,13,159,38"/>
<area shape="poly" title=" " alt="" coords="106,46,150,91,146,95,102,50"/>
<area shape="rect" href="classSawyer_1_1Attribute_1_1Storage.html" title="API and storage for attributes." alt="" coords="183,5,325,45"/>
<area shape="poly" title=" " alt="" coords="226,57,189,95,185,91,223,53"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3b50628f55f2427f73b63b3c49ed5e8a" id="r_a3b50628f55f2427f73b63b3c49ed5e8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8a">Ownership</a> { <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8aa412777f9a4c5ffc43485f20f796cbe2b">OWN_UNOWNED</a> =0
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8aa7148033a9ca16478ca206b543f1ba721">OWN_EXPLICIT</a>
, <br />
&#160;&#160;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8aa74b0c155f5a6ed140203019b29cc3e9b">OWN_PROVISIONAL</a>
<br />
 }</td></tr>
<tr class="memdesc:a3b50628f55f2427f73b63b3c49ed5e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manner in which a function owns a block.  <a href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8a">More...</a><br /></td></tr>
<tr class="separator:a3b50628f55f2427f73b63b3c49ed5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a61a1b32259bc515367d7b64f60fd9" id="r_a24a61a1b32259bc515367d7b64f60fd9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Ptr</a></td></tr>
<tr class="memdesc:a24a61a1b32259bc515367d7b64f60fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared-ownership pointer for function.  <br /></td></tr>
<tr class="separator:a24a61a1b32259bc515367d7b64f60fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage" id="r_a6232bff42634b42d2dcd3b68ba39a39c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSawyer_1_1SynchronizationTraits.html">SynchronizationTraits</a>&lt; SyncTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a6232bff42634b42d2dcd3b68ba39a39c">Sync</a></td></tr>
<tr class="separator:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38a12180234d39ccde92c6d55d600b41" id="r_a38a12180234d39ccde92c6d55d600b41"><td class="memItemLeft" align="right" valign="top">rose_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a38a12180234d39ccde92c6d55d600b41">address</a> () const</td></tr>
<tr class="memdesc:a38a12180234d39ccde92c6d55d600b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only property: Entry address.  <br /></td></tr>
<tr class="separator:a38a12180234d39ccde92c6d55d600b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c9e8b91e51cd01c1f87125418f66e7" id="r_a53c9e8b91e51cd01c1f87125418f66e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a53c9e8b91e51cd01c1f87125418f66e7">insertReasons</a> (unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a>)</td></tr>
<tr class="memdesc:a53c9e8b91e51cd01c1f87125418f66e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert additional function reason bits.  <br /></td></tr>
<tr class="separator:a53c9e8b91e51cd01c1f87125418f66e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a6d28c182ed3f4874d0c6bdb96356" id="r_a800a6d28c182ed3f4874d0c6bdb96356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a800a6d28c182ed3f4874d0c6bdb96356">eraseReasons</a> (unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a>)</td></tr>
<tr class="memdesc:a800a6d28c182ed3f4874d0c6bdb96356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove function reason bits.  <br /></td></tr>
<tr class="separator:a800a6d28c182ed3f4874d0c6bdb96356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a278596ea10db9397619beabe350661" id="r_a9a278596ea10db9397619beabe350661"><td class="memItemLeft" align="right" valign="top">const std::set&lt; rose_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9a278596ea10db9397619beabe350661">basicBlockAddresses</a> () const</td></tr>
<tr class="memdesc:a9a278596ea10db9397619beabe350661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns basic block addresses.  <br /></td></tr>
<tr class="separator:a9a278596ea10db9397619beabe350661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce7aee5f22716933766dec96399acfe" id="r_acce7aee5f22716933766dec96399acfe"><td class="memItemLeft" align="right" valign="top"><a id="acce7aee5f22716933766dec96399acfe" name="acce7aee5f22716933766dec96399acfe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ownsBasicBlock</b> (rose_addr_t bblockVa) const</td></tr>
<tr class="memdesc:acce7aee5f22716933766dec96399acfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to test whether a function owns a basic block address. <br /></td></tr>
<tr class="separator:acce7aee5f22716933766dec96399acfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c1532525d85b99dbb9848f5156794" id="r_af35c1532525d85b99dbb9848f5156794"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#af35c1532525d85b99dbb9848f5156794">insertBasicBlock</a> (rose_addr_t bblockVa)</td></tr>
<tr class="memdesc:af35c1532525d85b99dbb9848f5156794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a basic block to this function.  <br /></td></tr>
<tr class="separator:af35c1532525d85b99dbb9848f5156794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4dda118fcf4d3eeddded08840cde2b" id="r_a0c4dda118fcf4d3eeddded08840cde2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a0c4dda118fcf4d3eeddded08840cde2b">eraseBasicBlock</a> (rose_addr_t bblockVa)</td></tr>
<tr class="memdesc:a0c4dda118fcf4d3eeddded08840cde2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block from this function.  <br /></td></tr>
<tr class="separator:a0c4dda118fcf4d3eeddded08840cde2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9cf08fd54d695f80ac559ba54a6e5" id="r_a94e9cf08fd54d695f80ac559ba54a6e5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a94e9cf08fd54d695f80ac559ba54a6e5">dataBlocks</a> () const</td></tr>
<tr class="memdesc:a94e9cf08fd54d695f80ac559ba54a6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data blocks owned by this function.  <br /></td></tr>
<tr class="separator:a94e9cf08fd54d695f80ac559ba54a6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4bf65be507d78a361f28e069ba24d9" id="r_a3c4bf65be507d78a361f28e069ba24d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3c4bf65be507d78a361f28e069ba24d9">insertDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a3c4bf65be507d78a361f28e069ba24d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a data block to this function.  <br /></td></tr>
<tr class="separator:a3c4bf65be507d78a361f28e069ba24d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ead7c29d44f77ce0f41db67cc448a9" id="r_a94ead7c29d44f77ce0f41db67cc448a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a94ead7c29d44f77ce0f41db67cc448a9">eraseDataBlock</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;)</td></tr>
<tr class="memdesc:a94ead7c29d44f77ce0f41db67cc448a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove specified or equivalent data block from this function.  <br /></td></tr>
<tr class="separator:a94ead7c29d44f77ce0f41db67cc448a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f2e7669ff5dcd065a069d0045883c5" id="r_ac4f2e7669ff5dcd065a069d0045883c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ac4f2e7669ff5dcd065a069d0045883c5">dataBlockExists</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;) const</td></tr>
<tr class="memdesc:ac4f2e7669ff5dcd065a069d0045883c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this function contains the specified data block, or equivalent.  <br /></td></tr>
<tr class="separator:ac4f2e7669ff5dcd065a069d0045883c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33638d73ded67a33d1f5d53c9e585b52" id="r_a33638d73ded67a33d1f5d53c9e585b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a33638d73ded67a33d1f5d53c9e585b52">dataAddresses</a> () const</td></tr>
<tr class="memdesc:a33638d73ded67a33d1f5d53c9e585b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addresses that are part of static data.  <br /></td></tr>
<tr class="separator:a33638d73ded67a33d1f5d53c9e585b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33c157d54b41ec8e8fa4f71d7cde58d" id="r_ae33c157d54b41ec8e8fa4f71d7cde58d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae33c157d54b41ec8e8fa4f71d7cde58d">isFrozen</a> () const</td></tr>
<tr class="memdesc:ae33c157d54b41ec8e8fa4f71d7cde58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a function is frozen.  <br /></td></tr>
<tr class="separator:ae33c157d54b41ec8e8fa4f71d7cde58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6a3d59f85e98e1e25ac8f90a7d15ac" id="r_a3e6a3d59f85e98e1e25ac8f90a7d15ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3e6a3d59f85e98e1e25ac8f90a7d15ac">isThunk</a> () const</td></tr>
<tr class="memdesc:a3e6a3d59f85e98e1e25ac8f90a7d15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if function is a thunk.  <br /></td></tr>
<tr class="separator:a3e6a3d59f85e98e1e25ac8f90a7d15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec8123642aae2ee256da80b836dd975" id="r_a6ec8123642aae2ee256da80b836dd975"><td class="memItemLeft" align="right" valign="top"><a id="a6ec8123642aae2ee256da80b836dd975" name="a6ec8123642aae2ee256da80b836dd975"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nBasicBlocks</b> () const</td></tr>
<tr class="memdesc:a6ec8123642aae2ee256da80b836dd975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of basic blocks in the function. <br /></td></tr>
<tr class="separator:a6ec8123642aae2ee256da80b836dd975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df97334d21ae068c7a4c47364891446" id="r_a5df97334d21ae068c7a4c47364891446"><td class="memItemLeft" align="right" valign="top"><a id="a5df97334d21ae068c7a4c47364891446" name="a5df97334d21ae068c7a4c47364891446"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nDataBlocks</b> () const</td></tr>
<tr class="memdesc:a5df97334d21ae068c7a4c47364891446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of data blocks in the function. <br /></td></tr>
<tr class="separator:a5df97334d21ae068c7a4c47364891446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca0b6525c866a4db8f7e84ffa94f53" id="r_a11ca0b6525c866a4db8f7e84ffa94f53"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a11ca0b6525c866a4db8f7e84ffa94f53">printableName</a> () const</td></tr>
<tr class="memdesc:a11ca0b6525c866a4db8f7e84ffa94f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A printable name for the function.  <br /></td></tr>
<tr class="separator:a11ca0b6525c866a4db8f7e84ffa94f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db7fd6c60a1d5d2a1c8ee4f446e483d" id="r_a4db7fd6c60a1d5d2a1c8ee4f446e483d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a4db7fd6c60a1d5d2a1c8ee4f446e483d">isNoop</a> () const</td></tr>
<tr class="memdesc:a4db7fd6c60a1d5d2a1c8ee4f446e483d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached results of function no-op analysis.  <br /></td></tr>
<tr class="separator:a4db7fd6c60a1d5d2a1c8ee4f446e483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e61b1591d2a417cd10a102bf8e170df" id="r_a4e61b1591d2a417cd10a102bf8e170df"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a4e61b1591d2a417cd10a102bf8e170df">name</a> () const</td></tr>
<tr class="memdesc:a4e61b1591d2a417cd10a102bf8e170df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional function name.  <br /></td></tr>
<tr class="separator:a4e61b1591d2a417cd10a102bf8e170df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa6b9974ac7ce56ce21770994e1864" id="r_ae4fa6b9974ac7ce56ce21770994e1864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae4fa6b9974ac7ce56ce21770994e1864">name</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae4fa6b9974ac7ce56ce21770994e1864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional function name.  <br /></td></tr>
<tr class="separator:ae4fa6b9974ac7ce56ce21770994e1864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7d00be24fd23b50142f9eb41b00550f5" id="r_a7d00be24fd23b50142f9eb41b00550f5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a7d00be24fd23b50142f9eb41b00550f5">demangledName</a> () const</td></tr>
<tr class="memdesc:a7d00be24fd23b50142f9eb41b00550f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional demangled name.  <br /></td></tr>
<tr class="separator:a7d00be24fd23b50142f9eb41b00550f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c2e5591fb3897ea68f8f195e449374" id="r_a54c2e5591fb3897ea68f8f195e449374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a54c2e5591fb3897ea68f8f195e449374">demangledName</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a54c2e5591fb3897ea68f8f195e449374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional demangled name.  <br /></td></tr>
<tr class="separator:a54c2e5591fb3897ea68f8f195e449374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a96fb9becba7c8e433b390bc970460c4b" id="r_a96fb9becba7c8e433b390bc970460c4b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a96fb9becba7c8e433b390bc970460c4b">comment</a> () const</td></tr>
<tr class="memdesc:a96fb9becba7c8e433b390bc970460c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional function comment.  <br /></td></tr>
<tr class="separator:a96fb9becba7c8e433b390bc970460c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d485ec0d285deadcc6bc3f64fee47a" id="r_a07d485ec0d285deadcc6bc3f64fee47a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a07d485ec0d285deadcc6bc3f64fee47a">comment</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a07d485ec0d285deadcc6bc3f64fee47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Optional function comment.  <br /></td></tr>
<tr class="separator:a07d485ec0d285deadcc6bc3f64fee47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4651d5e309acc01d804eb78fc3eda0da" id="r_a4651d5e309acc01d804eb78fc3eda0da"><td class="memItemLeft" align="right" valign="top"><a id="a4651d5e309acc01d804eb78fc3eda0da" name="a4651d5e309acc01d804eb78fc3eda0da"></a>
const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sourceLocation</b> () const</td></tr>
<tr class="memdesc:a4651d5e309acc01d804eb78fc3eda0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of function definition in source code, if known. <br /></td></tr>
<tr class="separator:a4651d5e309acc01d804eb78fc3eda0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ad5f0801fa0fbef556f0a574bf66d3" id="r_a21ad5f0801fa0fbef556f0a574bf66d3"><td class="memItemLeft" align="right" valign="top"><a id="a21ad5f0801fa0fbef556f0a574bf66d3" name="a21ad5f0801fa0fbef556f0a574bf66d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sourceLocation</b> (const <a class="el" href="classRose_1_1SourceLocation.html">SourceLocation</a> &amp;)</td></tr>
<tr class="memdesc:a21ad5f0801fa0fbef556f0a574bf66d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: <a class="el" href="classRose_1_1Location.html" title="Base class for location types.">Location</a> of function definition in source code, if known. <br /></td></tr>
<tr class="separator:a21ad5f0801fa0fbef556f0a574bf66d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9bc7c27e0befd1ca69ccfaff36067dfd" id="r_a9bc7c27e0befd1ca69ccfaff36067dfd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a> () const</td></tr>
<tr class="memdesc:a9bc7c27e0befd1ca69ccfaff36067dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Bit vector of function reasons.  <br /></td></tr>
<tr class="separator:a9bc7c27e0befd1ca69ccfaff36067dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b4503e0b13a4d484ed368c6ff68bfc" id="r_a70b4503e0b13a4d484ed368c6ff68bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a70b4503e0b13a4d484ed368c6ff68bfc">reasons</a> (unsigned)</td></tr>
<tr class="memdesc:a70b4503e0b13a4d484ed368c6ff68bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Bit vector of function reasons.  <br /></td></tr>
<tr class="separator:a70b4503e0b13a4d484ed368c6ff68bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3e541fbf31ea7b19fe899df054b581cf" id="r_a3e541fbf31ea7b19fe899df054b581cf"><td class="memItemLeft" align="right" valign="top"><a id="a3e541fbf31ea7b19fe899df054b581cf" name="a3e541fbf31ea7b19fe899df054b581cf"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reasonComment</b> () const</td></tr>
<tr class="memdesc:a3e541fbf31ea7b19fe899df054b581cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Additional comment for why function was detected. <br /></td></tr>
<tr class="separator:a3e541fbf31ea7b19fe899df054b581cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b23101ddda6b54b9e7a918d165d7f6" id="r_a16b23101ddda6b54b9e7a918d165d7f6"><td class="memItemLeft" align="right" valign="top"><a id="a16b23101ddda6b54b9e7a918d165d7f6" name="a16b23101ddda6b54b9e7a918d165d7f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reasonComment</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a16b23101ddda6b54b9e7a918d165d7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Additional comment for why function was detected. <br /></td></tr>
<tr class="separator:a16b23101ddda6b54b9e7a918d165d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb56c48f312c73d7fac7db541d66a2a2" id="r_adb56c48f312c73d7fac7db541d66a2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#adb56c48f312c73d7fac7db541d66a2a2">stackDelta</a> () const</td></tr>
<tr class="memdesc:adb56c48f312c73d7fac7db541d66a2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta.  <br /></td></tr>
<tr class="separator:adb56c48f312c73d7fac7db541d66a2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b0202e9ba7bad1732e23d762e2c8e" id="r_adb7b0202e9ba7bad1732e23d762e2c8e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#adb7b0202e9ba7bad1732e23d762e2c8e">stackDeltaConcrete</a> () const</td></tr>
<tr class="memdesc:adb7b0202e9ba7bad1732e23d762e2c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta.  <br /></td></tr>
<tr class="separator:adb7b0202e9ba7bad1732e23d762e2c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae17e466907794bfa8be00920fa413dda" id="r_ae17e466907794bfa8be00920fa413dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae17e466907794bfa8be00920fa413dda">stackDeltaOverride</a> () const</td></tr>
<tr class="memdesc:ae17e466907794bfa8be00920fa413dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta override.  <br /></td></tr>
<tr class="separator:ae17e466907794bfa8be00920fa413dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df53a4479700f189ba649e6ffeb159b" id="r_a3df53a4479700f189ba649e6ffeb159b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3df53a4479700f189ba649e6ffeb159b">stackDeltaOverride</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;delta)</td></tr>
<tr class="memdesc:a3df53a4479700f189ba649e6ffeb159b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta override.  <br /></td></tr>
<tr class="separator:a3df53a4479700f189ba649e6ffeb159b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea87254486abffada7b22b781a215669" id="r_aea87254486abffada7b22b781a215669"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html">StackDelta::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#aea87254486abffada7b22b781a215669">stackDeltaAnalysis</a> () const</td></tr>
<tr class="memdesc:aea87254486abffada7b22b781a215669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta analysis results.  <br /></td></tr>
<tr class="separator:aea87254486abffada7b22b781a215669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfecb29b79c50be7fd922dcb02d3dd9a" id="r_acfecb29b79c50be7fd922dcb02d3dd9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html">StackDelta::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#acfecb29b79c50be7fd922dcb02d3dd9a">stackDeltaAnalysis</a> ()</td></tr>
<tr class="memdesc:acfecb29b79c50be7fd922dcb02d3dd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Stack delta analysis results.  <br /></td></tr>
<tr class="separator:acfecb29b79c50be7fd922dcb02d3dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af7c57d1e3d138db3e6555c39993a0f3f" id="r_af7c57d1e3d138db3e6555c39993a0f3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#af7c57d1e3d138db3e6555c39993a0f3f">callingConventionAnalysis</a> () const</td></tr>
<tr class="memdesc:af7c57d1e3d138db3e6555c39993a0f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Calling convention analysis results.  <br /></td></tr>
<tr class="separator:af7c57d1e3d138db3e6555c39993a0f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f58271bfcff859ee3e662901fe6530" id="r_a67f58271bfcff859ee3e662901fe6530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a67f58271bfcff859ee3e662901fe6530">callingConventionAnalysis</a> ()</td></tr>
<tr class="memdesc:a67f58271bfcff859ee3e662901fe6530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Calling convention analysis results.  <br /></td></tr>
<tr class="separator:a67f58271bfcff859ee3e662901fe6530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9818787cfbc296996817d20d6c180850" id="r_a9818787cfbc296996817d20d6c180850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">CallingConvention::DefinitionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9818787cfbc296996817d20d6c180850">callingConventionDefinition</a> ()</td></tr>
<tr class="memdesc:a9818787cfbc296996817d20d6c180850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Best calling convention definition.  <br /></td></tr>
<tr class="separator:a9818787cfbc296996817d20d6c180850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b7828574d341b1829ce917947a2a7" id="r_a5a5b7828574d341b1829ce917947a2a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a5a5b7828574d341b1829ce917947a2a7">callingConventionDefinition</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">CallingConvention::DefinitionPtr</a> &amp;)</td></tr>
<tr class="memdesc:a5a5b7828574d341b1829ce917947a2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Best calling convention definition.  <br /></td></tr>
<tr class="separator:a5a5b7828574d341b1829ce917947a2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae15492e36a2af8002023cab5afeaf671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae15492e36a2af8002023cab5afeaf671">Storage</a> ()</td></tr>
<tr class="memdesc:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9f66f01b292f92cdc70a18de1a7085ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9f66f01b292f92cdc70a18de1a7085ef">Storage</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae0dda357eaeee6b1974c3feae00c40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae0dda357eaeee6b1974c3feae00c40dd">operator=</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_abf3618e6d7c3a3f4bcc38ad23da3b8e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#abf3618e6d7c3a3f4bcc38ad23da3b8e9">attributeExists</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check attribute existence.  <br /></td></tr>
<tr class="separator:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a5a79e661eb48d0b9548bd0dacc63daba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a5a79e661eb48d0b9548bd0dacc63daba">eraseAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>)</td></tr>
<tr class="memdesc:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute.  <br /></td></tr>
<tr class="separator:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ab9276a22e706c4e76d65d45e715051e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ab9276a22e706c4e76d65d45e715051e0">clearAttributes</a> ()</td></tr>
<tr class="memdesc:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all attributes.  <br /></td></tr>
<tr class="separator:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9900916e61e6c0ce53e87803221962c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9900916e61e6c0ce53e87803221962c0">setAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute.  <br /></td></tr>
<tr class="separator:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a2143837f634be78ae5143e962d272fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a2143837f634be78ae5143e962d272fb8">setAttributeMaybe</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute if not already present.  <br /></td></tr>
<tr class="separator:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae39391002b59fc46db71a536cbe3e075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae39391002b59fc46db71a536cbe3e075">getAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute that is known to exist.  <br /></td></tr>
<tr class="separator:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a921b9ff8dc5cd78f751517bc22127496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a921b9ff8dc5cd78f751517bc22127496">attributeOrElse</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;dflt) const</td></tr>
<tr class="memdesc:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a specified value.  <br /></td></tr>
<tr class="separator:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a80072b861bfe95e1146934a3a53506ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a80072b861bfe95e1146934a3a53506ed">attributeOrDefault</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a default-constructed value.  <br /></td></tr>
<tr class="separator:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4277013fbe140a78e10182ca9053935c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4277013fbe140a78e10182ca9053935c">optionalAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute as an optional value.  <br /></td></tr>
<tr class="separator:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4b9e838c10d8c99838518457b35783ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4b9e838c10d8c99838518457b35783ac">nAttributes</a> () const</td></tr>
<tr class="memdesc:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <br /></td></tr>
<tr class="separator:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a1739a58e26f1dd40590fd9ee78936781"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a1739a58e26f1dd40590fd9ee78936781">attributeIds</a> () const</td></tr>
<tr class="memdesc:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ID numbers for all IDs stored in this container.  <br /></td></tr>
<tr class="separator:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abeccc1e38059b4a92aff0be375a7b7e3" id="r_abeccc1e38059b4a92aff0be375a7b7e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#abeccc1e38059b4a92aff0be375a7b7e3">instance</a> (rose_addr_t entryVa, const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a4e61b1591d2a417cd10a102bf8e170df">name</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a>=0)</td></tr>
<tr class="memdesc:abeccc1e38059b4a92aff0be375a7b7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static allocating constructor.  <br /></td></tr>
<tr class="separator:abeccc1e38059b4a92aff0be375a7b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2cf8f0cfd71760ff94d9f7482c3c3" id="r_a3ed2cf8f0cfd71760ff94d9f7482c3c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3ed2cf8f0cfd71760ff94d9f7482c3c3">instance</a> (rose_addr_t entryVa, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a>)</td></tr>
<tr class="memdesc:a3ed2cf8f0cfd71760ff94d9f7482c3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static allocating constructor.  <br /></td></tr>
<tr class="separator:a3ed2cf8f0cfd71760ff94d9f7482c3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afb2516fa96cf22a95d38cd07717bbc9a" id="r_afb2516fa96cf22a95d38cd07717bbc9a"><td class="memItemLeft" align="right" valign="top"><a id="afb2516fa96cf22a95d38cd07717bbc9a" name="afb2516fa96cf22a95d38cd07717bbc9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Function</b> (rose_addr_t entryVa, const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a4e61b1591d2a417cd10a102bf8e170df">name</a>, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a>)</td></tr>
<tr class="separator:afb2516fa96cf22a95d38cd07717bbc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a24a61a1b32259bc515367d7b64f60fd9" name="a24a61a1b32259bc515367d7b64f60fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a61a1b32259bc515367d7b64f60fd9">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#a80531f2b8cbb5250b1a0813b4abb3584">FunctionPtr</a> <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Rose::BinaryAnalysis::Partitioner2::Function::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared-ownership pointer for function. </p>

<p class="definition">Definition at line <a class="el" href="Function_8h_source.html#l00050">50</a> of file <a class="el" href="Function_8h_source.html">Function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3b50628f55f2427f73b63b3c49ed5e8a" name="a3b50628f55f2427f73b63b3c49ed5e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b50628f55f2427f73b63b3c49ed5e8a">&#9670;&#160;</a></span>Ownership</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a3b50628f55f2427f73b63b3c49ed5e8a">Rose::BinaryAnalysis::Partitioner2::Function::Ownership</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manner in which a function owns a block. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b50628f55f2427f73b63b3c49ed5e8aa412777f9a4c5ffc43485f20f796cbe2b" name="a3b50628f55f2427f73b63b3c49ed5e8aa412777f9a4c5ffc43485f20f796cbe2b"></a>OWN_UNOWNED&#160;</td><td class="fielddoc"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> does not own the block. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b50628f55f2427f73b63b3c49ed5e8aa7148033a9ca16478ca206b543f1ba721" name="a3b50628f55f2427f73b63b3c49ed5e8aa7148033a9ca16478ca206b543f1ba721"></a>OWN_EXPLICIT&#160;</td><td class="fielddoc"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> owns the block explicitly, the normal ownership. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b50628f55f2427f73b63b3c49ed5e8aa74b0c155f5a6ed140203019b29cc3e9b" name="a3b50628f55f2427f73b63b3c49ed5e8aa74b0c155f5a6ed140203019b29cc3e9b"></a>OWN_PROVISIONAL&#160;</td><td class="fielddoc"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html" title="Describes one function.">Function</a> might own the block in the future. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Function_8h_source.html#l00044">44</a> of file <a class="el" href="Function_8h_source.html">Function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abeccc1e38059b4a92aff0be375a7b7e3" name="abeccc1e38059b4a92aff0be375a7b7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeccc1e38059b4a92aff0be375a7b7e3">&#9670;&#160;</a></span>instance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Ptr</a> Rose::BinaryAnalysis::Partitioner2::Function::instance </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>entryVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reasons</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static allocating constructor. </p>
<p>Creates a new function having the specified characteristics. </p>

</div>
</div>
<a id="a3ed2cf8f0cfd71760ff94d9f7482c3c3" name="a3ed2cf8f0cfd71760ff94d9f7482c3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2cf8f0cfd71760ff94d9f7482c3c3">&#9670;&#160;</a></span>instance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a24a61a1b32259bc515367d7b64f60fd9">Ptr</a> Rose::BinaryAnalysis::Partitioner2::Function::instance </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>entryVa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reasons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static allocating constructor. </p>
<p>Creates a new function having the specified characteristics. </p>

</div>
</div>
<a id="a38a12180234d39ccde92c6d55d600b41" name="a38a12180234d39ccde92c6d55d600b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a12180234d39ccde92c6d55d600b41">&#9670;&#160;</a></span>address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rose_addr_t Rose::BinaryAnalysis::Partitioner2::Function::address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only property: Entry address. </p>
<p>The entry address also serves as an identifier for the function since the CFG can only hold one function per entry address. Detached functions need not have unique entry addresses. </p>

</div>
</div>
<a id="a4e61b1591d2a417cd10a102bf8e170df" name="a4e61b1591d2a417cd10a102bf8e170df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e61b1591d2a417cd10a102bf8e170df">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::Function::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional function name. </p>
<p>This is the official name. See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a7d00be24fd23b50142f9eb41b00550f5">demangledName</a>, which can also return the value of this <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> property. </p>

</div>
</div>
<a id="ae4fa6b9974ac7ce56ce21770994e1864" name="ae4fa6b9974ac7ce56ce21770994e1864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa6b9974ac7ce56ce21770994e1864">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional function name. </p>
<p>This is the official name. See also <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a7d00be24fd23b50142f9eb41b00550f5">demangledName</a>, which can also return the value of this <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> property. </p>

</div>
</div>
<a id="a7d00be24fd23b50142f9eb41b00550f5" name="a7d00be24fd23b50142f9eb41b00550f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d00be24fd23b50142f9eb41b00550f5">&#9670;&#160;</a></span>demangledName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::Function::demangledName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional demangled name. </p>
<p>This property holds the override string to use as the demangled name. If set to the empty string, then reading this property returns the true <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> instead. </p>

</div>
</div>
<a id="a54c2e5591fb3897ea68f8f195e449374" name="a54c2e5591fb3897ea68f8f195e449374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c2e5591fb3897ea68f8f195e449374">&#9670;&#160;</a></span>demangledName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::demangledName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional demangled name. </p>
<p>This property holds the override string to use as the demangled name. If set to the empty string, then reading this property returns the true <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a> instead. </p>

</div>
</div>
<a id="a96fb9becba7c8e433b390bc970460c4b" name="a96fb9becba7c8e433b390bc970460c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fb9becba7c8e433b390bc970460c4b">&#9670;&#160;</a></span>comment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rose::BinaryAnalysis::Partitioner2::Function::comment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional function comment. </p>
<p>Comments are multi-line, plain-text (not HTML), ASCII. </p>

</div>
</div>
<a id="a07d485ec0d285deadcc6bc3f64fee47a" name="a07d485ec0d285deadcc6bc3f64fee47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d485ec0d285deadcc6bc3f64fee47a">&#9670;&#160;</a></span>comment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::comment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Optional function comment. </p>
<p>Comments are multi-line, plain-text (not HTML), ASCII. </p>

</div>
</div>
<a id="a9bc7c27e0befd1ca69ccfaff36067dfd" name="a9bc7c27e0befd1ca69ccfaff36067dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc7c27e0befd1ca69ccfaff36067dfd">&#9670;&#160;</a></span>reasons() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Rose::BinaryAnalysis::Partitioner2::Function::reasons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Bit vector of function reasons. </p>
<p>These are <a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852c" title="Reasons why an instruction might be considered the beginning of a function.">SgAsmFunction::FunctionReason</a> bits. </p>

</div>
</div>
<a id="a70b4503e0b13a4d484ed368c6ff68bfc" name="a70b4503e0b13a4d484ed368c6ff68bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b4503e0b13a4d484ed368c6ff68bfc">&#9670;&#160;</a></span>reasons() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::reasons </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Bit vector of function reasons. </p>
<p>These are <a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852c" title="Reasons why an instruction might be considered the beginning of a function.">SgAsmFunction::FunctionReason</a> bits. </p>

</div>
</div>
<a id="a53c9e8b91e51cd01c1f87125418f66e7" name="a53c9e8b91e51cd01c1f87125418f66e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c9e8b91e51cd01c1f87125418f66e7">&#9670;&#160;</a></span>insertReasons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::insertReasons </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reasons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert additional function reason bits. </p>
<p>The high-order bits 16 bits are OR'd into the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a> property, while the low-order 16 bits given in the argument replace the low-order 16 bits stored in the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a> property. </p>

</div>
</div>
<a id="a800a6d28c182ed3f4874d0c6bdb96356" name="a800a6d28c182ed3f4874d0c6bdb96356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a6d28c182ed3f4874d0c6bdb96356">&#9670;&#160;</a></span>eraseReasons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::eraseReasons </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>reasons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove function reason bits. </p>
<p>Removes the high-order 16 bits that appear in the argument from the <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a9bc7c27e0befd1ca69ccfaff36067dfd">reasons</a> property. The low-order 16 bits are all cleared if any of the low-order 16 bits of the argument are set. </p>

</div>
</div>
<a id="a9a278596ea10db9397619beabe350661" name="a9a278596ea10db9397619beabe350661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a278596ea10db9397619beabe350661">&#9670;&#160;</a></span>basicBlockAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; rose_addr_t &gt; &amp; Rose::BinaryAnalysis::Partitioner2::Function::basicBlockAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns basic block addresses. </p>
<p>Because functions can exist in a detatched state, a function stores basic block addresses rather than basic blocks. This allows a function to indicate which blocks will be ultimately part of its definition without requiring that the blocks actually exist. When a detached function is inserted into the CFG then basic block placeholders will be created for any basic blocks that don't exist in the CFG (see <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#ae1ac2f6619db585e2e05730cc5e6d713">Partitioner::attachFunction</a>). </p>

</div>
</div>
<a id="af35c1532525d85b99dbb9848f5156794" name="af35c1532525d85b99dbb9848f5156794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c1532525d85b99dbb9848f5156794">&#9670;&#160;</a></span>insertBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Function::insertBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>bblockVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a basic block to this function. </p>
<p>This method does not adjust the partitioner CFG. Basic blocks cannot be added by this method when this function is attached to the CFG since it would cause the CFG to become outdated with respect to this function, but as long as the function is detached blocks can be inserted and removed arbitrarily. If the specified address is already part of the function then it is not added a second time.</p>
<p>Returns true if the block is inserted, false if the block was already part of this function. </p>

</div>
</div>
<a id="a0c4dda118fcf4d3eeddded08840cde2b" name="a0c4dda118fcf4d3eeddded08840cde2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4dda118fcf4d3eeddded08840cde2b">&#9670;&#160;</a></span>eraseBasicBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::eraseBasicBlock </td>
          <td>(</td>
          <td class="paramtype">rose_addr_t&#160;</td>
          <td class="paramname"><em>bblockVa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block from this function. </p>
<p>This method does not adjust the partitioner CFG. Basic blocks cannot be removed by this method when this function is attached to the CFG since it would cause the CFG to become outdated with respect to this function, but as long as the function is detached blocks can be inserted and removed arbitrarily. If the specified address is not a basic block address for this function then this is a no-op. Removing the function's entry address is never permitted. </p>

</div>
</div>
<a id="a94e9cf08fd54d695f80ac559ba54a6e5" name="a94e9cf08fd54d695f80ac559ba54a6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e9cf08fd54d695f80ac559ba54a6e5">&#9670;&#160;</a></span>dataBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &gt; &amp; Rose::BinaryAnalysis::Partitioner2::Function::dataBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns data blocks owned by this function. </p>
<p>Returns the data blocks that are owned by this function in order of their starting address. </p>

</div>
</div>
<a id="a3c4bf65be507d78a361f28e069ba24d9" name="a3c4bf65be507d78a361f28e069ba24d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4bf65be507d78a361f28e069ba24d9">&#9670;&#160;</a></span>insertDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Function::insertDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a data block to this function. </p>
<p>This method does not adjust the partitioner CFG. Data blocks cannot be added by this method when this function is attached to the CFG since it would cause the CFG to become outdated with respect to this function, but as long as the function is detached blocks can be inserted and removed arbitrarily. The specified data block cannot be a null pointer. If the data block is already owned by this function then nothing happens and this method returns false; otherwise the data block is inserted and the method returns true. </p>

</div>
</div>
<a id="a94ead7c29d44f77ce0f41db67cc448a9" name="a94ead7c29d44f77ce0f41db67cc448a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ead7c29d44f77ce0f41db67cc448a9">&#9670;&#160;</a></span>eraseDataBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Function::eraseDataBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove specified or equivalent data block from this function. </p>
<p>If this function is in a detached state (i.e., not part of the CFG/AUM) then the specified data block or equivalent data block is removed from this function. Returns the data block that was erased, or null if none was erased.</p>
<p>It is an error to invoke this method on function that is attached to the CFG/AUM, for which <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae33c157d54b41ec8e8fa4f71d7cde58d">isFrozen</a> returns true. This method is a no-op if the specified data block is a null pointer. </p>

</div>
</div>
<a id="ac4f2e7669ff5dcd065a069d0045883c5" name="ac4f2e7669ff5dcd065a069d0045883c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f2e7669ff5dcd065a069d0045883c5">&#9670;&#160;</a></span>dataBlockExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> Rose::BinaryAnalysis::Partitioner2::Function::dataBlockExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1Partitioner2.html#aa7d95e808e98c66e47216bd15f405718">DataBlockPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if this function contains the specified data block, or equivalent. </p>
<p>If this function owns the specified data block or an equivalent data block then this method returns a pointer to the existing data block, otherwise it returns the null pointer.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="a33638d73ded67a33d1f5d53c9e585b52" name="a33638d73ded67a33d1f5d53c9e585b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33638d73ded67a33d1f5d53c9e585b52">&#9670;&#160;</a></span>dataAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#a349b80f46d577ff595e62fc4b20deaa9">AddressIntervalSet</a> Rose::BinaryAnalysis::Partitioner2::Function::dataAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addresses that are part of static data. </p>
<p>Returns all addresses that are part of static data.</p>
<p>Thread safety: This method is not thread safe. </p>

</div>
</div>
<a id="ae33c157d54b41ec8e8fa4f71d7cde58d" name="ae33c157d54b41ec8e8fa4f71d7cde58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33c157d54b41ec8e8fa4f71d7cde58d">&#9670;&#160;</a></span>isFrozen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Function::isFrozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a function is frozen. </p>
<p>The ownership relations (instructions, basic blocks, and data blocks) cannot be adjusted while a function is in a frozen state. All functions that are represented in the control flow graph are in a frozen state; detaching a function from the CFG thaws it. </p>

</div>
</div>
<a id="a3e6a3d59f85e98e1e25ac8f90a7d15ac" name="a3e6a3d59f85e98e1e25ac8f90a7d15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6a3d59f85e98e1e25ac8f90a7d15ac">&#9670;&#160;</a></span>isThunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Rose::BinaryAnalysis::Partitioner2::Function::isThunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if function is a thunk. </p>
<p>This function is a thunk if it is marked as such in its reason codes via <a class="el" href="classSgAsmFunction.html#adbeeade0378b1c09170ad8d5d808852ca331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a> and it has exactly one basic block.</p>
<p>See also, <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Partitioner.html#a3647eb2c1fc6c7e941013cb1c2794fcb">Partitioner::functionIsThunk</a> that is a stronger predicate and also returns the address of the thunk target. </p>

</div>
</div>
<a id="adb56c48f312c73d7fac7db541d66a2a2" name="adb56c48f312c73d7fac7db541d66a2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb56c48f312c73d7fac7db541d66a2a2">&#9670;&#160;</a></span>stackDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::Partitioner2::Function::stackDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta. </p>
<p>The set or computed stack delta. If a stack delta override has been set (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae17e466907794bfa8be00920fa413dda">stackDeltaOverride</a>) then that value is returned. Otherwise, if the stack delta analysis has been run and a stack delta is known, it is returned. Otherwise a null pointer is returned. Calling this method returns previously computed values rather than running a potentially expensive analysis. </p>

</div>
</div>
<a id="adb7b0202e9ba7bad1732e23d762e2c8e" name="adb7b0202e9ba7bad1732e23d762e2c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b0202e9ba7bad1732e23d762e2c8e">&#9670;&#160;</a></span>stackDeltaConcrete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Rose::BinaryAnalysis::Partitioner2::Function::stackDeltaConcrete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta. </p>
<p>The set or computed stack delta. If a stack delta override has been set (<a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#ae17e466907794bfa8be00920fa413dda">stackDeltaOverride</a>) then that value is returned. Otherwise, if the stack delta analysis has been run and a stack delta is known, it is returned. Otherwise a null pointer is returned. Calling this method returns previously computed values rather than running a potentially expensive analysis. </p>

</div>
</div>
<a id="ae17e466907794bfa8be00920fa413dda" name="ae17e466907794bfa8be00920fa413dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17e466907794bfa8be00920fa413dda">&#9670;&#160;</a></span>stackDeltaOverride() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> Rose::BinaryAnalysis::Partitioner2::Function::stackDeltaOverride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta override. </p>
<p>This is the value returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#adb56c48f312c73d7fac7db541d66a2a2">stackDelta</a> in preference to using the stack delta analysis results. It allows a user to override the stack delta analysis. The partitioner will not run stack delta analysis if an override value is set. </p>

</div>
</div>
<a id="a3df53a4479700f189ba649e6ffeb159b" name="a3df53a4479700f189ba649e6ffeb159b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df53a4479700f189ba649e6ffeb159b">&#9670;&#160;</a></span>stackDeltaOverride() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::stackDeltaOverride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html#ae281182bb99b033e6087f27309dcf603">InstructionSemantics::BaseSemantics::SValuePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta override. </p>
<p>This is the value returned by <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#adb56c48f312c73d7fac7db541d66a2a2">stackDelta</a> in preference to using the stack delta analysis results. It allows a user to override the stack delta analysis. The partitioner will not run stack delta analysis if an override value is set. </p>

</div>
</div>
<a id="aea87254486abffada7b22b781a215669" name="aea87254486abffada7b22b781a215669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea87254486abffada7b22b781a215669">&#9670;&#160;</a></span>stackDeltaAnalysis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html">StackDelta::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Function::stackDeltaAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta analysis results. </p>
<p>This property holds the results from stack delta analysis. It contains the stack entry and exit values for each basic block computed from data flow, and the overall stack delta for the function. The analysis is not updated by this class; objects of this class only store the results provided by something else.</p>
<p>The <code>hasResults</code> and <code>didConverge</code> methods invoked on the return value will tell you whether an analysis has run and whether the results are valid, respectively. </p>

</div>
</div>
<a id="acfecb29b79c50be7fd922dcb02d3dd9a" name="acfecb29b79c50be7fd922dcb02d3dd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfecb29b79c50be7fd922dcb02d3dd9a">&#9670;&#160;</a></span>stackDeltaAnalysis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1StackDelta_1_1Analysis.html">StackDelta::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Function::stackDeltaAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Stack delta analysis results. </p>
<p>This property holds the results from stack delta analysis. It contains the stack entry and exit values for each basic block computed from data flow, and the overall stack delta for the function. The analysis is not updated by this class; objects of this class only store the results provided by something else.</p>
<p>The <code>hasResults</code> and <code>didConverge</code> methods invoked on the return value will tell you whether an analysis has run and whether the results are valid, respectively. </p>

</div>
</div>
<a id="af7c57d1e3d138db3e6555c39993a0f3f" name="af7c57d1e3d138db3e6555c39993a0f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c57d1e3d138db3e6555c39993a0f3f">&#9670;&#160;</a></span>callingConventionAnalysis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Function::callingConventionAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Calling convention analysis results. </p>
<p>This property holds the results from calling convention analysis. It contains information about what registers and stack locations are accessed and whether they serve as inputs or outputs and which registers are used but restored before returning (callee-saved). It also stores a concrete stack delta. The analysis is not updated by this class; objects of this class only store the results provided by something else.</p>
<p>The analysis itself does not fully describe a calling convention since a function might not use all features of the calling convention. For instance, a no-op function could match any number of calling convention definitions.</p>
<p>The <code>hasResults</code> and <code>didConverge</code> methods invoked on the return value will tell you whether an analysis has run and whether the results are valid, respectively. </p>

</div>
</div>
<a id="a67f58271bfcff859ee3e662901fe6530" name="a67f58271bfcff859ee3e662901fe6530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f58271bfcff859ee3e662901fe6530">&#9670;&#160;</a></span>callingConventionAnalysis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRose_1_1BinaryAnalysis_1_1CallingConvention_1_1Analysis.html">CallingConvention::Analysis</a> &amp; Rose::BinaryAnalysis::Partitioner2::Function::callingConventionAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Calling convention analysis results. </p>
<p>This property holds the results from calling convention analysis. It contains information about what registers and stack locations are accessed and whether they serve as inputs or outputs and which registers are used but restored before returning (callee-saved). It also stores a concrete stack delta. The analysis is not updated by this class; objects of this class only store the results provided by something else.</p>
<p>The analysis itself does not fully describe a calling convention since a function might not use all features of the calling convention. For instance, a no-op function could match any number of calling convention definitions.</p>
<p>The <code>hasResults</code> and <code>didConverge</code> methods invoked on the return value will tell you whether an analysis has run and whether the results are valid, respectively. </p>

</div>
</div>
<a id="a9818787cfbc296996817d20d6c180850" name="a9818787cfbc296996817d20d6c180850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818787cfbc296996817d20d6c180850">&#9670;&#160;</a></span>callingConventionDefinition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">CallingConvention::DefinitionPtr</a> Rose::BinaryAnalysis::Partitioner2::Function::callingConventionDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Best calling convention definition. </p>
<p>This is the best calling convention definition for this function. Calling conventions have two parts: (1) the behavior of the function such as which locations serve as inputs (read-before-write) and outputs (write-last), and callee-saved locations (read-before-write and write-last and same initial and final value), and (2) a list of well-known calling convention definitions that match the function's behavior. More than one definition can match. This property holds one defintion which is usually the "best" one. </p>

</div>
</div>
<a id="a5a5b7828574d341b1829ce917947a2a7" name="a5a5b7828574d341b1829ce917947a2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5b7828574d341b1829ce917947a2a7">&#9670;&#160;</a></span>callingConventionDefinition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::Partitioner2::Function::callingConventionDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1CallingConvention.html#a6972c0b19c9b461f30af6fb4fb3e3c44">CallingConvention::DefinitionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Property: Best calling convention definition. </p>
<p>This is the best calling convention definition for this function. Calling conventions have two parts: (1) the behavior of the function such as which locations serve as inputs (read-before-write) and outputs (write-last), and callee-saved locations (read-before-write and write-last and same initial and final value), and (2) a list of well-known calling convention definitions that match the function's behavior. More than one definition can match. This property holds one defintion which is usually the "best" one. </p>

</div>
</div>
<a id="a11ca0b6525c866a4db8f7e84ffa94f53" name="a11ca0b6525c866a4db8f7e84ffa94f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca0b6525c866a4db8f7e84ffa94f53">&#9670;&#160;</a></span>printableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Rose::BinaryAnalysis::Partitioner2::Function::printableName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A printable name for the function. </p>
<p>Returns a string like 'function 0x10001234 "main"'. The function name is not included if this function has neither a demangled name nor a true name. The <a class="el" href="classRose_1_1BinaryAnalysis_1_1Partitioner2_1_1Function.html#a7d00be24fd23b50142f9eb41b00550f5">demangledName</a> overrides the true <a class="el" href="namespaceSawyer_1_1Message.html#name">Naming tips</a>. </p>

</div>
</div>
<a id="a4db7fd6c60a1d5d2a1c8ee4f446e483d" name="a4db7fd6c60a1d5d2a1c8ee4f446e483d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db7fd6c60a1d5d2a1c8ee4f446e483d">&#9670;&#160;</a></span>isNoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSawyer_1_1Cached.html">Sawyer::Cached</a>&lt; bool &gt; &amp; Rose::BinaryAnalysis::Partitioner2::Function::isNoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached results of function no-op analysis. </p>
<p>If a value is cached, then the analysis has run and the cached value is true if the analysis proved that the function is a no-op. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Function_8h_source.html">Function.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:10 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
