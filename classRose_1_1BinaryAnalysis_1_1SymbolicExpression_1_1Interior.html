<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSE: Rose::BinaryAnalysis::SymbolicExpression::Interior Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ROSE"/>
<link href="roseDoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ROSE<span id="projectnumber">&#160;0.11.145.141</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRose.html">Rose</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis.html">BinaryAnalysis</a></li><li class="navelem"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html">SymbolicExpression</a></li><li class="navelem"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Rose::BinaryAnalysis::SymbolicExpression::Interior Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html" title="Interior node of an expression tree for instruction semantics.">Interior</a> node of an expression tree for instruction semantics. </p>
<p>Each interior node has an operator (constant for the life of the node and obtainable with get_operator()) and zero or more children. Children are added to the interior node during the construction phase. Once construction is complete, the children should only change in ways that don't affect the value of the node as a whole (since this node might be pointed to by any number of expressions). </p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01073">1073</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>
</div>
<p><code>#include &lt;<a class="el" href="SymbolicExpression_8h_source.html">Rose/BinaryAnalysis/SymbolicExpression.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Rose::BinaryAnalysis::SymbolicExpression::Interior:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior__inherit__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_inherit__map" alt="Inheritance graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_inherit__map" id="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_inherit__map">
<area shape="rect" title="Interior node of an expression tree for instruction semantics." alt="" coords="25,93,174,148"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html" title="Base class for symbolic expression nodes." alt="" coords="5,5,193,45"/>
<area shape="poly" title=" " alt="" coords="102,59,102,93,97,93,97,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Rose::BinaryAnalysis::SymbolicExpression::Interior:</div>
<div class="dyncontent">
<div class="center"><img src="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior__coll__graph.png" border="0" usemap="#aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_coll__map" alt="Collaboration graph"/></div>
<map name="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_coll__map" id="aRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior_coll__map">
<area shape="rect" title="Interior node of an expression tree for instruction semantics." alt="" coords="25,93,174,148"/>
<area shape="rect" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html" title="Base class for symbolic expression nodes." alt="" coords="5,5,193,45"/>
<area shape="poly" title=" " alt="" coords="102,59,102,93,97,93,97,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78c705d0f227ef34d22338b5ca64b00e" id="r_a78c705d0f227ef34d22338b5ca64b00e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a78c705d0f227ef34d22338b5ca64b00e">mustEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) override</td></tr>
<tr class="memdesc:a78c705d0f227ef34d22338b5ca64b00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two expressions must be equal (cannot be unequal).  <br /></td></tr>
<tr class="separator:a78c705d0f227ef34d22338b5ca64b00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87408ef44dbfe818f9aaffc35a54eba3" id="r_a87408ef44dbfe818f9aaffc35a54eba3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a87408ef44dbfe818f9aaffc35a54eba3">mayEqual</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) override</td></tr>
<tr class="memdesc:a87408ef44dbfe818f9aaffc35a54eba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two expressions might be equal, but not necessarily be equal.  <br /></td></tr>
<tr class="separator:a87408ef44dbfe818f9aaffc35a54eba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef45221d7363ac51fda9a2317e7db2" id="r_a0aef45221d7363ac51fda9a2317e7db2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0aef45221d7363ac51fda9a2317e7db2">isEquivalentTo</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other) override</td></tr>
<tr class="memdesc:a0aef45221d7363ac51fda9a2317e7db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests two expressions for structural equivalence.  <br /></td></tr>
<tr class="separator:a0aef45221d7363ac51fda9a2317e7db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af854016fb108ef5952b1e4154d4235da" id="r_af854016fb108ef5952b1e4154d4235da"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#af854016fb108ef5952b1e4154d4235da">isEquivalentHelper</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, EquivPairs &amp;) override</td></tr>
<tr class="separator:af854016fb108ef5952b1e4154d4235da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c5b048a77a09c7632f366b9d2d765" id="r_a4c7c5b048a77a09c7632f366b9d2d765"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a4c7c5b048a77a09c7632f366b9d2d765">compareStructure</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;other) override</td></tr>
<tr class="memdesc:a4c7c5b048a77a09c7632f366b9d2d765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions structurally for sorting.  <br /></td></tr>
<tr class="separator:a4c7c5b048a77a09c7632f366b9d2d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2da3652d6ed93d0fe44411683e6e30" id="r_a6e2da3652d6ed93d0fe44411683e6e30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a6e2da3652d6ed93d0fe44411683e6e30">substitute</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;from, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;to, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()) override</td></tr>
<tr class="memdesc:a6e2da3652d6ed93d0fe44411683e6e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute one value for another.  <br /></td></tr>
<tr class="separator:a6e2da3652d6ed93d0fe44411683e6e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a216d4d603b4189f33d0d53cc05e1" id="r_a173a216d4d603b4189f33d0d53cc05e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">VisitAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a173a216d4d603b4189f33d0d53cc05e1">depthFirstTraversal</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html">Visitor</a> &amp;) const override</td></tr>
<tr class="memdesc:a173a216d4d603b4189f33d0d53cc05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the expression.  <br /></td></tr>
<tr class="separator:a173a216d4d603b4189f33d0d53cc05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d09948ed3ac39201a6b9f13e3dab8f" id="r_a74d09948ed3ac39201a6b9f13e3dab8f"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a74d09948ed3ac39201a6b9f13e3dab8f">nNodes</a> () const override</td></tr>
<tr class="memdesc:a74d09948ed3ac39201a6b9f13e3dab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of an expression by counting the number of nodes.  <br /></td></tr>
<tr class="separator:a74d09948ed3ac39201a6b9f13e3dab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec08aaef61e5b49b6c95127b8870307" id="r_abec08aaef61e5b49b6c95127b8870307"><td class="memItemLeft" align="right" valign="top">virtual const Nodes &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#abec08aaef61e5b49b6c95127b8870307">children</a> () const override</td></tr>
<tr class="memdesc:abec08aaef61e5b49b6c95127b8870307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments.  <br /></td></tr>
<tr class="separator:abec08aaef61e5b49b6c95127b8870307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddb0a222fca419f04f6d56f37cdfae8" id="r_afddb0a222fca419f04f6d56f37cdfae8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#afddb0a222fca419f04f6d56f37cdfae8">getOperator</a> () const override</td></tr>
<tr class="memdesc:afddb0a222fca419f04f6d56f37cdfae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for interior nodes.  <br /></td></tr>
<tr class="separator:afddb0a222fca419f04f6d56f37cdfae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e56601b3af934ae9d096841ed7680" id="r_ad40e56601b3af934ae9d096841ed7680"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#ad40e56601b3af934ae9d096841ed7680">nChildren</a> () const override</td></tr>
<tr class="memdesc:ad40e56601b3af934ae9d096841ed7680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of arguments.  <br /></td></tr>
<tr class="separator:ad40e56601b3af934ae9d096841ed7680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaab2064f1bb704bf1626253bbc22c94" id="r_aaaab2064f1bb704bf1626253bbc22c94"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aaaab2064f1bb704bf1626253bbc22c94">child</a> (size_t idx) const override</td></tr>
<tr class="memdesc:aaaab2064f1bb704bf1626253bbc22c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument.  <br /></td></tr>
<tr class="separator:aaaab2064f1bb704bf1626253bbc22c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e52c3ad7bfbbb02e97c16106aeffe" id="r_a064e52c3ad7bfbbb02e97c16106aeffe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a064e52c3ad7bfbbb02e97c16106aeffe">childRaw</a> (size_t idx) const override</td></tr>
<tr class="memdesc:a064e52c3ad7bfbbb02e97c16106aeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument.  <br /></td></tr>
<tr class="separator:a064e52c3ad7bfbbb02e97c16106aeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d456d1090a050bae2a3225bef6b0bd" id="r_ac6d456d1090a050bae2a3225bef6b0bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#ac6d456d1090a050bae2a3225bef6b0bd">toUnsigned</a> () const override</td></tr>
<tr class="memdesc:ac6d456d1090a050bae2a3225bef6b0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsigned integer value of the expression.  <br /></td></tr>
<tr class="separator:ac6d456d1090a050bae2a3225bef6b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719924096a5750512c366e48f00ddaff" id="r_a719924096a5750512c366e48f00ddaff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a719924096a5750512c366e48f00ddaff">toSigned</a> () const override</td></tr>
<tr class="memdesc:a719924096a5750512c366e48f00ddaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signed integer value of the expression.  <br /></td></tr>
<tr class="separator:a719924096a5750512c366e48f00ddaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e2357995ee3c4526e69874314680d3" id="r_af6e2357995ee3c4526e69874314680d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#af6e2357995ee3c4526e69874314680d3">isConstant</a> () const override</td></tr>
<tr class="memdesc:af6e2357995ee3c4526e69874314680d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a constant.  <br /></td></tr>
<tr class="separator:af6e2357995ee3c4526e69874314680d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e5fe9bba00fca957cc96b5ea520f7a" id="r_a96e5fe9bba00fca957cc96b5ea520f7a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a96e5fe9bba00fca957cc96b5ea520f7a">isVariable2</a> () const override</td></tr>
<tr class="memdesc:a96e5fe9bba00fca957cc96b5ea520f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a variable.  <br /></td></tr>
<tr class="separator:a96e5fe9bba00fca957cc96b5ea520f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae30e208e441e27c5626bca947cd3de2" id="r_aae30e208e441e27c5626bca947cd3de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aae30e208e441e27c5626bca947cd3de2">simplifyTop</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:aae30e208e441e27c5626bca947cd3de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the specified interior node.  <br /></td></tr>
<tr class="separator:aae30e208e441e27c5626bca947cd3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee96f0d3449721f8e94391be115067a" id="r_a7ee96f0d3449721f8e94391be115067a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a7ee96f0d3449721f8e94391be115067a">foldConstants</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html">Simplifier</a> &amp;)</td></tr>
<tr class="memdesc:a7ee96f0d3449721f8e94391be115067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform constant folding.  <br /></td></tr>
<tr class="separator:a7ee96f0d3449721f8e94391be115067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f21c4d4587a94c45e3039296e5bcc5" id="r_aa5f21c4d4587a94c45e3039296e5bcc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aa5f21c4d4587a94c45e3039296e5bcc5">associative</a> ()</td></tr>
<tr class="memdesc:aa5f21c4d4587a94c45e3039296e5bcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies non-associative operators by flattening the specified interior node with its children that are the same interior node type.  <br /></td></tr>
<tr class="separator:aa5f21c4d4587a94c45e3039296e5bcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9438364053512103c4d7c067aec644b0" id="r_a9438364053512103c4d7c067aec644b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a9438364053512103c4d7c067aec644b0">commutative</a> ()</td></tr>
<tr class="memdesc:a9438364053512103c4d7c067aec644b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies commutative operators by sorting arguments.  <br /></td></tr>
<tr class="separator:a9438364053512103c4d7c067aec644b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc16fb68b1045f1bb8617d9cc06fd4e7" id="r_abc16fb68b1045f1bb8617d9cc06fd4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#abc16fb68b1045f1bb8617d9cc06fd4e7">idempotent</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:abc16fb68b1045f1bb8617d9cc06fd4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies idempotent operators.  <br /></td></tr>
<tr class="separator:abc16fb68b1045f1bb8617d9cc06fd4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bad0707de6e0163ff9c509d15c83f8" id="r_a25bad0707de6e0163ff9c509d15c83f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a25bad0707de6e0163ff9c509d15c83f8">involutary</a> ()</td></tr>
<tr class="memdesc:a25bad0707de6e0163ff9c509d15c83f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies involutary operators.  <br /></td></tr>
<tr class="separator:a25bad0707de6e0163ff9c509d15c83f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2ca571d56ffa4d9623427df7b5f1b6" id="r_a5d2ca571d56ffa4d9623427df7b5f1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a5d2ca571d56ffa4d9623427df7b5f1b6">additiveNesting</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a5d2ca571d56ffa4d9623427df7b5f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies nested shift-like operators.  <br /></td></tr>
<tr class="separator:a5d2ca571d56ffa4d9623427df7b5f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3370e898081adcd4debe5de599d18d" id="r_a5e3370e898081adcd4debe5de599d18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a5e3370e898081adcd4debe5de599d18d">identity</a> (uint64_t ident, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a5e3370e898081adcd4debe5de599d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identity arguments.  <br /></td></tr>
<tr class="separator:a5e3370e898081adcd4debe5de599d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078812595acfcc17124debba443cc116" id="r_a078812595acfcc17124debba443cc116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a078812595acfcc17124debba443cc116">poisonNan</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a078812595acfcc17124debba443cc116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NaN if any argument is NaN.  <br /></td></tr>
<tr class="separator:a078812595acfcc17124debba443cc116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5e43843491f5687b708ce66f2cae5a" id="r_aca5e43843491f5687b708ce66f2cae5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aca5e43843491f5687b708ce66f2cae5a">unaryNoOp</a> ()</td></tr>
<tr class="memdesc:aca5e43843491f5687b708ce66f2cae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a binary operator with its only argument.  <br /></td></tr>
<tr class="separator:aca5e43843491f5687b708ce66f2cae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8359569ef293d9f0a9d16098f6599e24" id="r_a8359569ef293d9f0a9d16098f6599e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a8359569ef293d9f0a9d16098f6599e24">rewrite</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html">Simplifier</a> &amp;simplifier, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a8359569ef293d9f0a9d16098f6599e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an interior node.  <br /></td></tr>
<tr class="separator:a8359569ef293d9f0a9d16098f6599e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3fdd53e186c07c07dbf935b597145e" id="r_a0e3fdd53e186c07c07dbf935b597145e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0e3fdd53e186c07c07dbf935b597145e">print</a> (std::ostream &amp;, <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;) const override</td></tr>
<tr class="memdesc:a0e3fdd53e186c07c07dbf935b597145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the expression to a stream.  <br /></td></tr>
<tr class="separator:a0e3fdd53e186c07c07dbf935b597145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a></td></tr>
<tr class="memitem:a7c8f48cfd3521023847cca801219dabd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a7c8f48cfd3521023847cca801219dabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a> () const</td></tr>
<tr class="memdesc:a7c8f48cfd3521023847cca801219dabd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html" title="Type of symbolic expression.">Type</a> of value.  <br /></td></tr>
<tr class="separator:a7c8f48cfd3521023847cca801219dabd inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b59e5b6ef63515a74fad13d9badacea inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a3b59e5b6ef63515a74fad13d9badacea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3b59e5b6ef63515a74fad13d9badacea">substituteMultiple</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;substitutions, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:a3b59e5b6ef63515a74fad13d9badacea inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite expression by substituting subexpressions.  <br /></td></tr>
<tr class="separator:a3b59e5b6ef63515a74fad13d9badacea inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0c120a647a35eda4b476b65f63efbb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_abf0c120a647a35eda4b476b65f63efbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abf0c120a647a35eda4b476b65f63efbb">renameVariables</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1ExprExprHashMap.html">ExprExprHashMap</a> &amp;index, size_t &amp;nextVariableId, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>())</td></tr>
<tr class="memdesc:abf0c120a647a35eda4b476b65f63efbb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite using lowest numbered variable names.  <br /></td></tr>
<tr class="separator:abf0c120a647a35eda4b476b65f63efbb inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d445634c2ac85a3ae052cc4e249d71 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ad1d445634c2ac85a3ae052cc4e249d71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad1d445634c2ac85a3ae052cc4e249d71">isIntegerExpr</a> () const</td></tr>
<tr class="memdesc:ad1d445634c2ac85a3ae052cc4e249d71 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of an integer type.  <br /></td></tr>
<tr class="separator:ad1d445634c2ac85a3ae052cc4e249d71 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5199dca72c6d392692b90e744adc263 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ac5199dca72c6d392692b90e744adc263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ac5199dca72c6d392692b90e744adc263">isFloatingPointExpr</a> () const</td></tr>
<tr class="memdesc:ac5199dca72c6d392692b90e744adc263 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of a floating-point type.  <br /></td></tr>
<tr class="separator:ac5199dca72c6d392692b90e744adc263 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea2b3523f2401682e3a9442bd781c15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_abea2b3523f2401682e3a9442bd781c15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abea2b3523f2401682e3a9442bd781c15">isMemoryExpr</a> () const</td></tr>
<tr class="memdesc:abea2b3523f2401682e3a9442bd781c15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is of a memory type.  <br /></td></tr>
<tr class="separator:abea2b3523f2401682e3a9442bd781c15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829b6434685caeec93f955ab9f7471f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ab829b6434685caeec93f955ab9f7471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab829b6434685caeec93f955ab9f7471f">isScalarExpr</a> () const</td></tr>
<tr class="memdesc:ab829b6434685caeec93f955ab9f7471f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the expression is a scalar type.  <br /></td></tr>
<tr class="separator:ab829b6434685caeec93f955ab9f7471f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ecfa22d26e9724dccbf291c6669da0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a54ecfa22d26e9724dccbf291c6669da0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a54ecfa22d26e9724dccbf291c6669da0">isIntegerConstant</a> () const</td></tr>
<tr class="memdesc:a54ecfa22d26e9724dccbf291c6669da0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is an integer constant.  <br /></td></tr>
<tr class="separator:a54ecfa22d26e9724dccbf291c6669da0 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5323cec0c40b5771584a9b2fd4ba7105 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a5323cec0c40b5771584a9b2fd4ba7105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a5323cec0c40b5771584a9b2fd4ba7105">isFloatingPointConstant</a> () const</td></tr>
<tr class="memdesc:a5323cec0c40b5771584a9b2fd4ba7105 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this epxression is a floating-point constant.  <br /></td></tr>
<tr class="separator:a5323cec0c40b5771584a9b2fd4ba7105 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e66d88572ecd51e879add8284fd0a64 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a3e66d88572ecd51e879add8284fd0a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3e66d88572ecd51e879add8284fd0a64">isScalarConstant</a> () const</td></tr>
<tr class="memdesc:a3e66d88572ecd51e879add8284fd0a64 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a scalar constant.  <br /></td></tr>
<tr class="separator:a3e66d88572ecd51e879add8284fd0a64 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d47d97801ab2bd9243c4556126ffb2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a2d47d97801ab2bd9243c4556126ffb2e"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFloatingPointNan</b> () const</td></tr>
<tr class="memdesc:a2d47d97801ab2bd9243c4556126ffb2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a floating-point NaN constant. <br /></td></tr>
<tr class="separator:a2d47d97801ab2bd9243c4556126ffb2e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a36eb99cf5418d0c724180a9f25d593 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a2a36eb99cf5418d0c724180a9f25d593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2a36eb99cf5418d0c724180a9f25d593">variableId</a> () const</td></tr>
<tr class="memdesc:a2a36eb99cf5418d0c724180a9f25d593 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable ID number.  <br /></td></tr>
<tr class="separator:a2a36eb99cf5418d0c724180a9f25d593 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2763916848fd850d7d789b2b192d30 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a0c2763916848fd850d7d789b2b192d30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0c2763916848fd850d7d789b2b192d30">isIntegerVariable</a> () const</td></tr>
<tr class="memdesc:a0c2763916848fd850d7d789b2b192d30 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is an integer variable.  <br /></td></tr>
<tr class="separator:a0c2763916848fd850d7d789b2b192d30 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d385c59ccbad2264cc262f4e7765be inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a38d385c59ccbad2264cc262f4e7765be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a38d385c59ccbad2264cc262f4e7765be">isFloatingPointVariable</a> () const</td></tr>
<tr class="memdesc:a38d385c59ccbad2264cc262f4e7765be inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a floating-point variable.  <br /></td></tr>
<tr class="separator:a38d385c59ccbad2264cc262f4e7765be inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679762843045af43cb32ac03dec41ef2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a679762843045af43cb32ac03dec41ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a679762843045af43cb32ac03dec41ef2">isMemoryVariable</a> () const</td></tr>
<tr class="memdesc:a679762843045af43cb32ac03dec41ef2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a memory state variable.  <br /></td></tr>
<tr class="separator:a679762843045af43cb32ac03dec41ef2 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7f791741ff816e19268589f68bf8b6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a7a7f791741ff816e19268589f68bf8b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7a7f791741ff816e19268589f68bf8b6">isScalarVariable</a> () const</td></tr>
<tr class="memdesc:a7a7f791741ff816e19268589f68bf8b6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this expression is a scalar variable.  <br /></td></tr>
<tr class="separator:a7a7f791741ff816e19268589f68bf8b6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400e3a4c11a81e183dbfbc0a3c9016e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a9400e3a4c11a81e183dbfbc0a3c9016e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a9400e3a4c11a81e183dbfbc0a3c9016e">nBits</a> () const</td></tr>
<tr class="memdesc:a9400e3a4c11a81e183dbfbc0a3c9016e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Number of significant bits.  <br /></td></tr>
<tr class="separator:a9400e3a4c11a81e183dbfbc0a3c9016e inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5ef9fca6895de57fd49d4ed41ded9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ae2a5ef9fca6895de57fd49d4ed41ded9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a> () const</td></tr>
<tr class="memdesc:ae2a5ef9fca6895de57fd49d4ed41ded9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined bit flags.  <br /></td></tr>
<tr class="separator:ae2a5ef9fca6895de57fd49d4ed41ded9 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552e6affeb1a82b2ff20a4f39a68d072 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a552e6affeb1a82b2ff20a4f39a68d072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a552e6affeb1a82b2ff20a4f39a68d072">newFlags</a> (unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>) const</td></tr>
<tr class="memdesc:a552e6affeb1a82b2ff20a4f39a68d072 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets flags.  <br /></td></tr>
<tr class="separator:a552e6affeb1a82b2ff20a4f39a68d072 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb9599b465398f87191a448b11b5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a0bb9599b465398f87191a448b11b5780"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0bb9599b465398f87191a448b11b5780">domainWidth</a> () const</td></tr>
<tr class="memdesc:a0bb9599b465398f87191a448b11b5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Width for memory expressions.  <br /></td></tr>
<tr class="separator:a0bb9599b465398f87191a448b11b5780 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a4e2eea5f7e1fe9f8b32e0ca3038cd4ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a4e2eea5f7e1fe9f8b32e0ca3038cd4ab">isScalar</a> () const</td></tr>
<tr class="memdesc:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether expression is scalar.  <br /></td></tr>
<tr class="separator:a4e2eea5f7e1fe9f8b32e0ca3038cd4ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ddbc715c01d4c9db9ce7beb3870bd7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a37ddbc715c01d4c9db9ce7beb3870bd7"><td class="memItemLeft" align="right" valign="top">
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>nNodesUnique</b> () const</td></tr>
<tr class="memdesc:a37ddbc715c01d4c9db9ce7beb3870bd7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of unique nodes in expression. <br /></td></tr>
<tr class="separator:a37ddbc715c01d4c9db9ce7beb3870bd7 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4600680bf010f5c2c3e80cb57f8d8ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ad4600680bf010f5c2c3e80cb57f8d8ab"><td class="memItemLeft" align="right" valign="top">
std::set&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVariables</b> () const</td></tr>
<tr class="memdesc:ad4600680bf010f5c2c3e80cb57f8d8ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variables appearing in the expression. <br /></td></tr>
<tr class="separator:ad4600680bf010f5c2c3e80cb57f8d8ab inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9811180477b08c100b72965f99c3da inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a2b9811180477b08c100b72965f99c3da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2b9811180477b08c100b72965f99c3da">isHashed</a> () const</td></tr>
<tr class="memdesc:a2b9811180477b08c100b72965f99c3da inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node has a hash value computed and cached.  <br /></td></tr>
<tr class="separator:a2b9811180477b08c100b72965f99c3da inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2587115bb1a247402f90dbb4bfbd533a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a2587115bb1a247402f90dbb4bfbd533a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2587115bb1a247402f90dbb4bfbd533a">hash</a> () const</td></tr>
<tr class="memdesc:a2587115bb1a247402f90dbb4bfbd533a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (and caches) the hash value for this node.  <br /></td></tr>
<tr class="separator:a2587115bb1a247402f90dbb4bfbd533a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520d58ea2374d0fdb5cb900d63b4842f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a520d58ea2374d0fdb5cb900d63b4842f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>) const</td></tr>
<tr class="separator:a520d58ea2374d0fdb5cb900d63b4842f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12247d8fd79c4528fa10b5de51989d15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a12247d8fd79c4528fa10b5de51989d15"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> () const</td></tr>
<tr class="memdesc:a12247d8fd79c4528fa10b5de51989d15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert expression to string. <br /></td></tr>
<tr class="separator:a12247d8fd79c4528fa10b5de51989d15 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac913729c72ab980b7cec178096fa8c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_aac913729c72ab980b7cec178096fa8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aac913729c72ab980b7cec178096fa8c3">assertAcyclic</a> () const</td></tr>
<tr class="memdesc:aac913729c72ab980b7cec178096fa8c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that expressions are acyclic.  <br /></td></tr>
<tr class="separator:aac913729c72ab980b7cec178096fa8c3 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae606f125a10a3787b5c8d615c25a1445 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ae606f125a10a3787b5c8d615c25a1445"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae606f125a10a3787b5c8d615c25a1445">findCommonSubexpressions</a> () const</td></tr>
<tr class="memdesc:ae606f125a10a3787b5c8d615c25a1445 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find common subexpressions.  <br /></td></tr>
<tr class="separator:ae606f125a10a3787b5c8d615c25a1445 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f14e3470fc6f5b7d2923b8afa0559 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_aa38f14e3470fc6f5b7d2923b8afa0559"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa38f14e3470fc6f5b7d2923b8afa0559">matchAddVariableConstant</a> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;<a class="el" href="classvariable.html">variable</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a> &amp;constant) const</td></tr>
<tr class="memdesc:aa38f14e3470fc6f5b7d2923b8afa0559 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an expression is a variable plus a constant.  <br /></td></tr>
<tr class="separator:aa38f14e3470fc6f5b7d2923b8afa0559 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c3d320b448dc7594b1862d870236d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a31c3d320b448dc7594b1862d870236d6"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isOperator</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a>) const</td></tr>
<tr class="memdesc:a31c3d320b448dc7594b1862d870236d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">True (non-null) if this node is the specified operator. <br /></td></tr>
<tr class="separator:a31c3d320b448dc7594b1862d870236d6 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c6b16bcd8a718198fdcd8b874a26bf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a98c6b16bcd8a718198fdcd8b874a26bf"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a> () const</td></tr>
<tr class="memdesc:a98c6b16bcd8a718198fdcd8b874a26bf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Comment.  <br /></td></tr>
<tr class="separator:a98c6b16bcd8a718198fdcd8b874a26bf inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67648c26b65adccb3710f8d2a88551dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a67648c26b65adccb3710f8d2a88551dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a67648c26b65adccb3710f8d2a88551dc">comment</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a67648c26b65adccb3710f8d2a88551dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: Comment.  <br /></td></tr>
<tr class="separator:a67648c26b65adccb3710f8d2a88551dc inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d4564d54dcc27002a51f5e83e575fa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a80d4564d54dcc27002a51f5e83e575fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a80d4564d54dcc27002a51f5e83e575fa">userData</a> (boost::any &amp;data)</td></tr>
<tr class="memdesc:a80d4564d54dcc27002a51f5e83e575fa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined data.  <br /></td></tr>
<tr class="separator:a80d4564d54dcc27002a51f5e83e575fa inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82e5a3ef07ca2876f8b5a1b949480c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_aeb82e5a3ef07ca2876f8b5a1b949480c"><td class="memItemLeft" align="right" valign="top">const boost::any &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aeb82e5a3ef07ca2876f8b5a1b949480c">userData</a> () const</td></tr>
<tr class="memdesc:aeb82e5a3ef07ca2876f8b5a1b949480c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property: User-defined data.  <br /></td></tr>
<tr class="separator:aeb82e5a3ef07ca2876f8b5a1b949480c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c996a02b7c0f8ecfe3db379b0211e1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a18c996a02b7c0f8ecfe3db379b0211e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a18c996a02b7c0f8ecfe3db379b0211e1">isInteriorNode</a> () const</td></tr>
<tr class="memdesc:a18c996a02b7c0f8ecfe3db379b0211e1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to an interior node.  <br /></td></tr>
<tr class="separator:a18c996a02b7c0f8ecfe3db379b0211e1 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca4b0d89020fd62390ae12d88231f1a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_aaca4b0d89020fd62390ae12d88231f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html">Interior</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aaca4b0d89020fd62390ae12d88231f1a">isInteriorNodeRaw</a> () const</td></tr>
<tr class="memdesc:aaca4b0d89020fd62390ae12d88231f1a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to an interior node.  <br /></td></tr>
<tr class="separator:aaca4b0d89020fd62390ae12d88231f1a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51741dd7626aa6bf76c2fefc87ee15c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_aa51741dd7626aa6bf76c2fefc87ee15c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae9d5bbc5fcd4c7d776264c9c83b804e5">LeafPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa51741dd7626aa6bf76c2fefc87ee15c">isLeafNode</a> () const</td></tr>
<tr class="memdesc:aa51741dd7626aa6bf76c2fefc87ee15c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to a leaf node.  <br /></td></tr>
<tr class="separator:aa51741dd7626aa6bf76c2fefc87ee15c inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867a0b78c5b62720b46513cb1e0e10f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ae867a0b78c5b62720b46513cb1e0e10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html">Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae867a0b78c5b62720b46513cb1e0e10f">isLeafNodeRaw</a> () const</td></tr>
<tr class="memdesc:ae867a0b78c5b62720b46513cb1e0e10f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast of this object to a leaf node.  <br /></td></tr>
<tr class="separator:ae867a0b78c5b62720b46513cb1e0e10f inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0edf10cd2ebf66cabd68609838553a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_afd0edf10cd2ebf66cabd68609838553a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#afd0edf10cd2ebf66cabd68609838553a">withFormat</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:afd0edf10cd2ebf66cabd68609838553a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a node with a formatter for printing.  <br /></td></tr>
<tr class="separator:afd0edf10cd2ebf66cabd68609838553a inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25faa0406d9ac372bea9e6cf86a91d2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a25faa0406d9ac372bea9e6cf86a91d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node_1_1WithFormatter.html">WithFormatter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a25faa0406d9ac372bea9e6cf86a91d2b">operator+</a> (<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;fmt)</td></tr>
<tr class="memdesc:a25faa0406d9ac372bea9e6cf86a91d2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a node with a formatter for printing.  <br /></td></tr>
<tr class="separator:a25faa0406d9ac372bea9e6cf86a91d2b inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daa64f5d1daa3110f60408bfd3d3e11 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a3daa64f5d1daa3110f60408bfd3d3e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3daa64f5d1daa3110f60408bfd3d3e11">print</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a3daa64f5d1daa3110f60408bfd3d3e11 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the expression to a stream.  <br /></td></tr>
<tr class="separator:a3daa64f5d1daa3110f60408bfd3d3e11 inherit pub_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedObject.html">Sawyer::SharedObject</a></td></tr>
<tr class="memitem:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject" id="r_af65fdccd9575d75238c9ce5615b102bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#af65fdccd9575d75238c9ce5615b102bb">SharedObject</a> ()</td></tr>
<tr class="memdesc:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:af65fdccd9575d75238c9ce5615b102bb inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject" id="r_a4f1155ff49f2c62afd307c0168d6f84e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a4f1155ff49f2c62afd307c0168d6f84e">SharedObject</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a4f1155ff49f2c62afd307c0168d6f84e inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a5a0ad0a0708358bb6a27191dd375b404"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a5a0ad0a0708358bb6a27191dd375b404">~SharedObject</a> ()</td></tr>
<tr class="memdesc:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a5a0ad0a0708358bb6a27191dd375b404 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject" id="r_a50779eb24667162b6ef1c7604b3b08f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedObject.html#a50779eb24667162b6ef1c7604b3b08f5">operator=</a> (const <a class="el" href="classSawyer_1_1SharedObject.html">SharedObject</a> &amp;)</td></tr>
<tr class="memdesc:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <br /></td></tr>
<tr class="separator:a50779eb24667162b6ef1c7604b3b08f5 inherit pub_methods_classSawyer_1_1SharedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1SharedFromThis"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1SharedFromThis')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1SharedFromThis.html">Sawyer::SharedFromThis&lt; Node &gt;</a></td></tr>
<tr class="memitem:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a5225cf4c7055339254ace1c62005ac55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a5225cf4c7055339254ace1c62005ac55">sharedFromThis</a> ()</td></tr>
<tr class="memdesc:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a5225cf4c7055339254ace1c62005ac55 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis" id="r_a8b829a965e98f9ccb1b22da4a68a6f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1SharedPointer.html">SharedPointer</a>&lt; const Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SharedFromThis.html#a8b829a965e98f9ccb1b22da4a68a6f76">sharedFromThis</a> () const</td></tr>
<tr class="memdesc:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer from <code>this</code>.  <br /></td></tr>
<tr class="separator:a8b829a965e98f9ccb1b22da4a68a6f76 inherit pub_methods_classSawyer_1_1SharedFromThis"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae15492e36a2af8002023cab5afeaf671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae15492e36a2af8002023cab5afeaf671">Storage</a> ()</td></tr>
<tr class="memdesc:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae15492e36a2af8002023cab5afeaf671 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9f66f01b292f92cdc70a18de1a7085ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9f66f01b292f92cdc70a18de1a7085ef">Storage</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a9f66f01b292f92cdc70a18de1a7085ef inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae0dda357eaeee6b1974c3feae00c40dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae0dda357eaeee6b1974c3feae00c40dd">operator=</a> (const <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="memdesc:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="separator:ae0dda357eaeee6b1974c3feae00c40dd inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_abf3618e6d7c3a3f4bcc38ad23da3b8e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#abf3618e6d7c3a3f4bcc38ad23da3b8e9">attributeExists</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check attribute existence.  <br /></td></tr>
<tr class="separator:abf3618e6d7c3a3f4bcc38ad23da3b8e9 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a5a79e661eb48d0b9548bd0dacc63daba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a5a79e661eb48d0b9548bd0dacc63daba">eraseAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>)</td></tr>
<tr class="memdesc:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute.  <br /></td></tr>
<tr class="separator:a5a79e661eb48d0b9548bd0dacc63daba inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ab9276a22e706c4e76d65d45e715051e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ab9276a22e706c4e76d65d45e715051e0">clearAttributes</a> ()</td></tr>
<tr class="memdesc:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all attributes.  <br /></td></tr>
<tr class="separator:ab9276a22e706c4e76d65d45e715051e0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a9900916e61e6c0ce53e87803221962c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a9900916e61e6c0ce53e87803221962c0">setAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute.  <br /></td></tr>
<tr class="separator:a9900916e61e6c0ce53e87803221962c0 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a2143837f634be78ae5143e962d272fb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a2143837f634be78ae5143e962d272fb8">setAttributeMaybe</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an attribute if not already present.  <br /></td></tr>
<tr class="separator:a2143837f634be78ae5143e962d272fb8 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_ae39391002b59fc46db71a536cbe3e075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#ae39391002b59fc46db71a536cbe3e075">getAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute that is known to exist.  <br /></td></tr>
<tr class="separator:ae39391002b59fc46db71a536cbe3e075 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a921b9ff8dc5cd78f751517bc22127496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a921b9ff8dc5cd78f751517bc22127496">attributeOrElse</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>, const T &amp;dflt) const</td></tr>
<tr class="memdesc:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a specified value.  <br /></td></tr>
<tr class="separator:a921b9ff8dc5cd78f751517bc22127496 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a80072b861bfe95e1146934a3a53506ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a80072b861bfe95e1146934a3a53506ed">attributeOrDefault</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute or a default-constructed value.  <br /></td></tr>
<tr class="separator:a80072b861bfe95e1146934a3a53506ed inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4277013fbe140a78e10182ca9053935c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4277013fbe140a78e10182ca9053935c">optionalAttribute</a> (<a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> <a class="el" href="namespaceSawyer_1_1Attribute.html#ae6f1b14d5e7a643013abc21d656b2e02">id</a>) const</td></tr>
<tr class="memdesc:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute as an optional value.  <br /></td></tr>
<tr class="separator:a4277013fbe140a78e10182ca9053935c inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a4b9e838c10d8c99838518457b35783ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a4b9e838c10d8c99838518457b35783ac">nAttributes</a> () const</td></tr>
<tr class="memdesc:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attributes stored.  <br /></td></tr>
<tr class="separator:a4b9e838c10d8c99838518457b35783ac inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage" id="r_a1739a58e26f1dd40590fd9ee78936781"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceSawyer_1_1Attribute.html#ac2390b0d8b09f1b75e5d452e2dc90e68">Id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a1739a58e26f1dd40590fd9ee78936781">attributeIds</a> () const</td></tr>
<tr class="memdesc:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ID numbers for all IDs stored in this container.  <br /></td></tr>
<tr class="separator:a1739a58e26f1dd40590fd9ee78936781 inherit pub_methods_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a974a14e7e92ebc4d87dc771050fb0093" id="r_a974a14e7e92ebc4d87dc771050fb0093"><td class="memItemLeft" align="right" valign="top"><a id="a974a14e7e92ebc4d87dc771050fb0093" name="a974a14e7e92ebc4d87dc771050fb0093"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a974a14e7e92ebc4d87dc771050fb0093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a974a14e7e92ebc4d87dc771050fb0093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b463ec6acbf596c4d2d277553a88d" id="r_ab39b463ec6acbf596c4d2d277553a88d"><td class="memItemLeft" align="right" valign="top"><a id="ab39b463ec6acbf596c4d2d277553a88d" name="ab39b463ec6acbf596c4d2d277553a88d"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:ab39b463ec6acbf596c4d2d277553a88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:ab39b463ec6acbf596c4d2d277553a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d08013a4eb42a9a8a6dd6efc9a707" id="r_ad02d08013a4eb42a9a8a6dd6efc9a707"><td class="memItemLeft" align="right" valign="top"><a id="ad02d08013a4eb42a9a8a6dd6efc9a707" name="ad02d08013a4eb42a9a8a6dd6efc9a707"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:ad02d08013a4eb42a9a8a6dd6efc9a707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:ad02d08013a4eb42a9a8a6dd6efc9a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c09ed52ee94fcd27a5b9539d5ff0f0" id="r_a77c09ed52ee94fcd27a5b9539d5ff0f0"><td class="memItemLeft" align="right" valign="top"><a id="a77c09ed52ee94fcd27a5b9539d5ff0f0" name="a77c09ed52ee94fcd27a5b9539d5ff0f0"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a77c09ed52ee94fcd27a5b9539d5ff0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a77c09ed52ee94fcd27a5b9539d5ff0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c769ef9a89b9216052999e35e9a2e9d" id="r_a7c769ef9a89b9216052999e35e9a2e9d"><td class="memItemLeft" align="right" valign="top"><a id="a7c769ef9a89b9216052999e35e9a2e9d" name="a7c769ef9a89b9216052999e35e9a2e9d"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;c, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a7c769ef9a89b9216052999e35e9a2e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a7c769ef9a89b9216052999e35e9a2e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbb6a16cc48a523ed3e617d149d0344" id="r_a2fbb6a16cc48a523ed3e617d149d0344"><td class="memItemLeft" align="right" valign="top"><a id="a2fbb6a16cc48a523ed3e617d149d0344" name="a2fbb6a16cc48a523ed3e617d149d0344"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;c, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a2fbb6a16cc48a523ed3e617d149d0344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a2fbb6a16cc48a523ed3e617d149d0344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3517efc65e3f3f20c2bff6ea972c8b96" id="r_a3517efc65e3f3f20c2bff6ea972c8b96"><td class="memItemLeft" align="right" valign="top"><a id="a3517efc65e3f3f20c2bff6ea972c8b96" name="a3517efc65e3f3f20c2bff6ea972c8b96"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (<a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const Nodes &amp;arguments, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a3517efc65e3f3f20c2bff6ea972c8b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a3517efc65e3f3f20c2bff6ea972c8b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64884f04edb2bc42b2b63d9ddd069c95" id="r_a64884f04edb2bc42b2b63d9ddd069c95"><td class="memItemLeft" align="right" valign="top"><a id="a64884f04edb2bc42b2b63d9ddd069c95" name="a64884f04edb2bc42b2b63d9ddd069c95"></a>
static <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a7c8f48cfd3521023847cca801219dabd">type</a>, <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> op, const Nodes &amp;arguments, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;solver=<a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>(), const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>=&quot;&quot;, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="memdesc:a64884f04edb2bc42b2b63d9ddd069c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression node. <br /></td></tr>
<tr class="separator:a64884f04edb2bc42b2b63d9ddd069c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSawyer_1_1SmallObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSawyer_1_1SmallObject')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSawyer_1_1SmallObject.html">Sawyer::SmallObject</a></td></tr>
<tr class="memitem:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_a2954194e69a758f9785ef5d00589e936"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceSawyer.html#acb97daf593e6c229322229d001a43784">SynchronizedPoolAllocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#a2954194e69a758f9785ef5d00589e936">poolAllocator</a> ()</td></tr>
<tr class="memdesc:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pool allocator for this class.  <br /></td></tr>
<tr class="separator:a2954194e69a758f9785ef5d00589e936 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead44427ee5b1c52ea7dea3e60d67fbf inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_aead44427ee5b1c52ea7dea3e60d67fbf"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#aead44427ee5b1c52ea7dea3e60d67fbf">operator new</a> (size_t size)</td></tr>
<tr class="separator:aead44427ee5b1c52ea7dea3e60d67fbf inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c539ee5d7754059adb13ecc8dd918a0 inherit pub_static_methods_classSawyer_1_1SmallObject" id="r_a0c539ee5d7754059adb13ecc8dd918a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1SmallObject.html#a0c539ee5d7754059adb13ecc8dd918a0">operator delete</a> (void *ptr, size_t size)</td></tr>
<tr class="separator:a0c539ee5d7754059adb13ecc8dd918a0 inherit pub_static_methods_classSawyer_1_1SmallObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae05dfd5a387c09b94c861f16d8c7c87d" id="r_ae05dfd5a387c09b94c861f16d8c7c87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#ae05dfd5a387c09b94c861f16d8c7c87d">addChild</a> (const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#aaaab2064f1bb704bf1626253bbc22c94">child</a>)</td></tr>
<tr class="memdesc:ae05dfd5a387c09b94c861f16d8c7c87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends <code>child</code> as a new child of this node.  <br /></td></tr>
<tr class="separator:ae05dfd5a387c09b94c861f16d8c7c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a9cd11f0ce53bee459facf6b06c401" id="r_a84a9cd11f0ce53bee459facf6b06c401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a84a9cd11f0ce53bee459facf6b06c401">adjustWidth</a> (const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;)</td></tr>
<tr class="memdesc:a84a9cd11f0ce53bee459facf6b06c401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust width based on operands.  <br /></td></tr>
<tr class="separator:a84a9cd11f0ce53bee459facf6b06c401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be8e02830e797c895149b5c7b809ae4" id="r_a9be8e02830e797c895149b5c7b809ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a9be8e02830e797c895149b5c7b809ae4">adjustBitFlags</a> (unsigned extraFlags)</td></tr>
<tr class="memdesc:a9be8e02830e797c895149b5c7b809ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust user-defined bit flags.  <br /></td></tr>
<tr class="separator:a9be8e02830e797c895149b5c7b809ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a></td></tr>
<tr class="memitem:a5d7a92fd29f1c48a6aa7e73beeba3f59 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a5d7a92fd29f1c48a6aa7e73beeba3f59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a5d7a92fd29f1c48a6aa7e73beeba3f59">Node</a> (const std::string &amp;<a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a98c6b16bcd8a718198fdcd8b874a26bf">comment</a>, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>=0)</td></tr>
<tr class="separator:a5d7a92fd29f1c48a6aa7e73beeba3f59 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702af6acfacf989ef5dbdde94d0d64d1 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a702af6acfacf989ef5dbdde94d0d64d1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>printFlags</b> (std::ostream &amp;o, unsigned <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2a5ef9fca6895de57fd49d4ed41ded9">flags</a>, char &amp;bracket) const</td></tr>
<tr class="separator:a702af6acfacf989ef5dbdde94d0d64d1 inherit pro_methods_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a></td></tr>
<tr class="memitem:a827e86df13553322eba8111c6d1c5dc1 inherit pub_types_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a827e86df13553322eba8111c6d1c5dc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a827e86df13553322eba8111c6d1c5dc1">EquivPairs</a> = std::map&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, std::vector&lt; std::pair&lt; <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *, bool &gt; &gt; &gt;</td></tr>
<tr class="separator:a827e86df13553322eba8111c6d1c5dc1 inherit pub_types_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSawyer_1_1Attribute_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSawyer_1_1Attribute_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSawyer_1_1Attribute_1_1Storage.html">Sawyer::Attribute::Storage&lt; SyncTag &gt;</a></td></tr>
<tr class="memitem:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage" id="r_a6232bff42634b42d2dcd3b68ba39a39c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSawyer_1_1SynchronizationTraits.html">SynchronizationTraits</a>&lt; SyncTag &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSawyer_1_1Attribute_1_1Storage.html#a6232bff42634b42d2dcd3b68ba39a39c">Sync</a></td></tr>
<tr class="separator:a6232bff42634b42d2dcd3b68ba39a39c inherit pub_types_classSawyer_1_1Attribute_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a></td></tr>
<tr class="memitem:adc12dfd081952860a7ee91531f33ec0a inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_adc12dfd081952860a7ee91531f33ec0a"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#adc12dfd081952860a7ee91531f33ec0a">RESERVED_FLAGS</a> = 0x0000ffff</td></tr>
<tr class="memdesc:adc12dfd081952860a7ee91531f33ec0a inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">These flags are reserved for use within ROSE.  <br /></td></tr>
<tr class="separator:adc12dfd081952860a7ee91531f33ec0a inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625ba620262131aa05e55c09710881b inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_ae625ba620262131aa05e55c09710881b"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae625ba620262131aa05e55c09710881b">INDETERMINATE</a> = 0x00000001</td></tr>
<tr class="memdesc:ae625ba620262131aa05e55c09710881b inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value is somehow indeterminate.  <br /></td></tr>
<tr class="separator:ae625ba620262131aa05e55c09710881b inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748427bef1cc117706dbf9100e8cdf8 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a1748427bef1cc117706dbf9100e8cdf8"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a1748427bef1cc117706dbf9100e8cdf8">UNSPECIFIED</a> = 0x00000002</td></tr>
<tr class="memdesc:a1748427bef1cc117706dbf9100e8cdf8 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value is somehow unspecified.  <br /></td></tr>
<tr class="separator:a1748427bef1cc117706dbf9100e8cdf8 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd3df8be8c21eebf285fd2295c170e9 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_abbd3df8be8c21eebf285fd2295c170e9"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abbd3df8be8c21eebf285fd2295c170e9">BOTTOM</a> = 0x00000004</td></tr>
<tr class="memdesc:abbd3df8be8c21eebf285fd2295c170e9 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value represents bottom in dataflow analysis.  <br /></td></tr>
<tr class="separator:abbd3df8be8c21eebf285fd2295c170e9 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9f5524dafe8a99d7f8b2b7cbfd086 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a33b9f5524dafe8a99d7f8b2b7cbfd086"><td class="memItemLeft" align="right" valign="top">static boost::logic::tribool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a33b9f5524dafe8a99d7f8b2b7cbfd086">mayEqualCallback</a> )(const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;a, const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;b, const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;)</td></tr>
<tr class="memdesc:a33b9f5524dafe8a99d7f8b2b7cbfd086 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-supplied predicate to augment alias checking.  <br /></td></tr>
<tr class="separator:a33b9f5524dafe8a99d7f8b2b7cbfd086 inherit pub_static_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a></td></tr>
<tr class="memitem:a2e9500e43872353ee8ca47ef77618bc7 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a2e9500e43872353ee8ca47ef77618bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2e9500e43872353ee8ca47ef77618bc7">type_</a></td></tr>
<tr class="separator:a2e9500e43872353ee8ca47ef77618bc7 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d313b2dbefb0562db93e9489571a62 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a63d313b2dbefb0562db93e9489571a62"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a63d313b2dbefb0562db93e9489571a62">flags_</a></td></tr>
<tr class="memdesc:a63d313b2dbefb0562db93e9489571a62 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit flags.  <br /></td></tr>
<tr class="separator:a63d313b2dbefb0562db93e9489571a62 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0da3c3333c5085a1d462fe529796ff inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a4d0da3c3333c5085a1d462fe529796ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a4d0da3c3333c5085a1d462fe529796ff">comment_</a></td></tr>
<tr class="memdesc:a4d0da3c3333c5085a1d462fe529796ff inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional comment.  <br /></td></tr>
<tr class="separator:a4d0da3c3333c5085a1d462fe529796ff inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e53001033983d1f6a7e9ad72d261502 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a8e53001033983d1f6a7e9ad72d261502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a2fee57f9f5e5cd95ab678fd2853d7735">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a8e53001033983d1f6a7e9ad72d261502">hashval_</a></td></tr>
<tr class="memdesc:a8e53001033983d1f6a7e9ad72d261502 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional hash used as a quick way to indicate that two expressions are different.  <br /></td></tr>
<tr class="separator:a8e53001033983d1f6a7e9ad72d261502 inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba13e8f5b635d9684e91ae88763f3a inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node" id="r_a3cba13e8f5b635d9684e91ae88763f3a"><td class="memItemLeft" align="right" valign="top">boost::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a3cba13e8f5b635d9684e91ae88763f3a">userData_</a></td></tr>
<tr class="memdesc:a3cba13e8f5b635d9684e91ae88763f3a inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-specified data.  <br /></td></tr>
<tr class="separator:a3cba13e8f5b635d9684e91ae88763f3a inherit pro_attribs_classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a78c705d0f227ef34d22338b5ca64b00e" name="a78c705d0f227ef34d22338b5ca64b00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c705d0f227ef34d22338b5ca64b00e">&#9670;&#160;</a></span>mustEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::mustEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if two expressions must be equal (cannot be unequal). </p>
<p>If an SMT solver is specified then that solver is used to answer this question, otherwise equality is established by looking only at the structure of the two expressions. Two expressions can be equal without being the same width (e.g., a 32-bit constant zero is equal to a 16-bit constant zero). </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab1b0c0ee0a7451ee55c3bff01941ab8d">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a87408ef44dbfe818f9aaffc35a54eba3" name="a87408ef44dbfe818f9aaffc35a54eba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87408ef44dbfe818f9aaffc35a54eba3">&#9670;&#160;</a></span>mayEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::mayEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if two expressions might be equal, but not necessarily be equal. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad5bea89ce10dba2b96d83fe118ddeeae">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a0aef45221d7363ac51fda9a2317e7db2" name="a0aef45221d7363ac51fda9a2317e7db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aef45221d7363ac51fda9a2317e7db2">&#9670;&#160;</a></span>isEquivalentTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::isEquivalentTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests two expressions for structural equivalence. </p>
<p>Two leaf nodes are equivalent if they are the same width and have equal values or are the same variable. Two interior nodes are equivalent if they are the same width, the same operation, have the same number of children, and those children are all pairwise equivalent. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa34f8ffaccea6276a689a7005f1b777e">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="af854016fb108ef5952b1e4154d4235da" name="af854016fb108ef5952b1e4154d4235da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af854016fb108ef5952b1e4154d4235da">&#9670;&#160;</a></span>isEquivalentHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::isEquivalentHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivPairs &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a4c7c5b048a77a09c7632f366b9d2d765" name="a4c7c5b048a77a09c7632f366b9d2d765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7c5b048a77a09c7632f366b9d2d765">&#9670;&#160;</a></span>compareStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Rose::BinaryAnalysis::SymbolicExpression::Interior::compareStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two expressions structurally for sorting. </p>
<p>Returns -1 if <code>this</code> is less than <code>other</code>, 0 if they are structurally equal, and 1 if <code>this</code> is greater than <code>other</code>. This function returns zero when an only when <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0aef45221d7363ac51fda9a2317e7db2">isEquivalentTo</a> returns zero, but <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0aef45221d7363ac51fda9a2317e7db2">isEquivalentTo</a> can be much faster since it uses hashing. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae393741530af5fdb0a4491fb93f22e06">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a6e2da3652d6ed93d0fe44411683e6e30" name="a6e2da3652d6ed93d0fe44411683e6e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2da3652d6ed93d0fe44411683e6e30">&#9670;&#160;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitute one value for another. </p>
<p>Finds all occurrances of <code>from</code> in this expression and replace them with <code>to</code>. If a substitution occurs, then a new expression is returned. The matching of <code>from</code> to sub-parts of this expression uses structural equivalence, the <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Interior.html#a0aef45221d7363ac51fda9a2317e7db2">isEquivalentTo</a> predicate. The <code>from</code> and <code>to</code> expressions must have the same width. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#abbb0e0a9fb89e55a4b33424d2ecbcc83">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a173a216d4d603b4189f33d0d53cc05e1" name="a173a216d4d603b4189f33d0d53cc05e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173a216d4d603b4189f33d0d53cc05e1">&#9670;&#160;</a></span>depthFirstTraversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#abed9c2fafec1e169be6d367ed8d5c1a8">VisitAction</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::depthFirstTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the expression. </p>
<p>The expression is traversed in a depth-first visit. The final return value is the final return value of the last call to the visitor. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aa208affad817dc6d89e5f4b7ee552f94">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a74d09948ed3ac39201a6b9f13e3dab8f" name="a74d09948ed3ac39201a6b9f13e3dab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d09948ed3ac39201a6b9f13e3dab8f">&#9670;&#160;</a></span>nNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t Rose::BinaryAnalysis::SymbolicExpression::Interior::nNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the size of an expression by counting the number of nodes. </p>
<p>Operates in constant time. Note that it is possible (even likely) for the 64-bit return value to overflow in expressions when many nodes are shared. For instance, the following loop will create an expression that contains more than 2^64 nodes:</p>
<div class="fragment"><div class="line">SymbolicExpression expr = <a class="code hl_function" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ae31d33b04101d29818bb5474919c8613">Leaf::createVariable</a>(32);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;64; ++i)</div>
<div class="line">    expr = <a class="code hl_function" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae5ceeb4b30f5e41fc1b1385025794280">makeAdd</a>(expr, expr)</div>
<div class="ttc" id="aclassRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf_html_ae31d33b04101d29818bb5474919c8613"><div class="ttname"><a href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html#ae31d33b04101d29818bb5474919c8613">Rose::BinaryAnalysis::SymbolicExpression::Leaf::createVariable</a></div><div class="ttdeci">static LeafPtr createVariable(const Type &amp;, const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</div><div class="ttdoc">Create a new variable.</div></div>
<div class="ttc" id="anamespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression_html_ae5ceeb4b30f5e41fc1b1385025794280"><div class="ttname"><a href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#ae5ceeb4b30f5e41fc1b1385025794280">Rose::BinaryAnalysis::SymbolicExpression::makeAdd</a></div><div class="ttdeci">Ptr makeAdd(const Ptr &amp;a, const Ptr &amp;b, const SmtSolverPtr &amp;solver=SmtSolverPtr(), const std::string &amp;comment=&quot;&quot;, unsigned flags=0)</div><div class="ttdoc">Interior node constructor.</div></div>
</div><!-- fragment --><p>When an overflow occurs the result is meaningless.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a37ddbc715c01d4c9db9ce7beb3870bd7" title="Number of unique nodes in expression.">nNodesUnique</a> </dd></dl>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a90aace1a79aa431d6be1d1f19ded39c9">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01139">1139</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="abec08aaef61e5b49b6c95127b8870307" name="abec08aaef61e5b49b6c95127b8870307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec08aaef61e5b49b6c95127b8870307">&#9670;&#160;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Nodes &amp; Rose::BinaryAnalysis::SymbolicExpression::Interior::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Arguments. </p>
<p>Returns the arguments of an operation for an interior node, or an empty list for a leaf node. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a70c19853fc3b1c94563eaf8f13e5007b">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01140">1140</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="afddb0a222fca419f04f6d56f37cdfae8" name="afddb0a222fca419f04f6d56f37cdfae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddb0a222fca419f04f6d56f37cdfae8">&#9670;&#160;</a></span>getOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2">Operator</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::getOperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for interior nodes. </p>
<p>Return the operator for interior nodes, or <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a7a317419dcb8e9c29864a71d6bbe90b2a26e45d8a426be8586e6f5964a328306c">OP_NONE</a> for leaf nodes that have no operator. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ad22eee8ff5d0eab13d24b95fb60c39e1">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01141">1141</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="ad40e56601b3af934ae9d096841ed7680" name="ad40e56601b3af934ae9d096841ed7680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e56601b3af934ae9d096841ed7680">&#9670;&#160;</a></span>nChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Rose::BinaryAnalysis::SymbolicExpression::Interior::nChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of arguments. </p>
<p>Returns the number of children for an interior node, zero for leaf nodes. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a13b729ec06f2275aba9d5c300511829f">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01142">1142</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolicExpression_8h_source.html#l01633">Rose::BinaryAnalysis::SymbolicExpression::substitute()</a>.</p>

</div>
</div>
<a id="aaaab2064f1bb704bf1626253bbc22c94" name="aaaab2064f1bb704bf1626253bbc22c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaab2064f1bb704bf1626253bbc22c94">&#9670;&#160;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp; Rose::BinaryAnalysis::SymbolicExpression::Interior::child </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument. </p>
<p>Returns the specified argument by index. If the index is out of range, then returns null. A leaf node always returns null since it never has children. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ae2d22be691cf45c4626ed4116eef6f30">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="a064e52c3ad7bfbbb02e97c16106aeffe" name="a064e52c3ad7bfbbb02e97c16106aeffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e52c3ad7bfbbb02e97c16106aeffe">&#9670;&#160;</a></span>childRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html">Node</a> * Rose::BinaryAnalysis::SymbolicExpression::Interior::childRaw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argument. </p>
<p>Returns the specified argument by index. If the index is out of range, then returns null. A leaf node always returns null since it never has children. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a39684cbee10da1cf1e553182ad61d93e">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="ac6d456d1090a050bae2a3225bef6b0bd" name="ac6d456d1090a050bae2a3225bef6b0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d456d1090a050bae2a3225bef6b0bd">&#9670;&#160;</a></span>toUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; uint64_t &gt; Rose::BinaryAnalysis::SymbolicExpression::Interior::toUnsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unsigned integer value of the expression. </p>
<p>Returns nothing if the expression is not a concrete integer value or the value is too wide to be represented by the return type. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#ab463224309cacaa21f359cf935929f75">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01145">1145</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a719924096a5750512c366e48f00ddaff" name="a719924096a5750512c366e48f00ddaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719924096a5750512c366e48f00ddaff">&#9670;&#160;</a></span>toSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSawyer_1_1Optional.html">Sawyer::Optional</a>&lt; int64_t &gt; Rose::BinaryAnalysis::SymbolicExpression::Interior::toSigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The signed integer value of the expression. </p>
<p>Returns nothing if the expression is not a concrete integer value or the value doesn't fit in the return type. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a9738401442bb723c3202f1687f6de671">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01146">1146</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="af6e2357995ee3c4526e69874314680d3" name="af6e2357995ee3c4526e69874314680d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e2357995ee3c4526e69874314680d3">&#9670;&#160;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::isConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a constant. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a0df28fa6b71642a43fd1899529cca270">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01147">1147</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="a96e5fe9bba00fca957cc96b5ea520f7a" name="a96e5fe9bba00fca957cc96b5ea520f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e5fe9bba00fca957cc96b5ea520f7a">&#9670;&#160;</a></span>isVariable2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Rose::BinaryAnalysis::SymbolicExpression::Interior::isVariable2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this expression is a variable. </p>
<p>Warning: <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Leaf.html" title="Leaf node of an expression tree for instruction semantics.">Leaf</a> nodes have a deprecated isVariable method that returns false for memory state variables, thus this method has a "2" appended to its name. After a suitable period of deprecation for Leaf::isVariable, a new isVariable will be added to this class hiearchy and will have the same semantics as isVariable2, which will become deprecated. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#aadfe6d4b7a2124abeece444aa3b0ddd1">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

<p class="definition">Definition at line <a class="el" href="SymbolicExpression_8h_source.html#l01148">1148</a> of file <a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a>.</p>

</div>
</div>
<a id="aae30e208e441e27c5626bca947cd3de2" name="aae30e208e441e27c5626bca947cd3de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae30e208e441e27c5626bca947cd3de2">&#9670;&#160;</a></span>simplifyTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::simplifyTop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the specified interior node. </p>
<p>Returns a new node if necessary, otherwise returns this. The SMT solver is optional and my be the null pointer. </p>

</div>
</div>
<a id="a7ee96f0d3449721f8e94391be115067a" name="a7ee96f0d3449721f8e94391be115067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee96f0d3449721f8e94391be115067a">&#9670;&#160;</a></span>foldConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::foldConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html">Simplifier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform constant folding. </p>
<p>This method returns either a new expression (if changes were mde) or the original expression. The simplifier is specific to the kind of operation at the node being simplified. </p>

</div>
</div>
<a id="aa5f21c4d4587a94c45e3039296e5bcc5" name="aa5f21c4d4587a94c45e3039296e5bcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f21c4d4587a94c45e3039296e5bcc5">&#9670;&#160;</a></span>associative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::associative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies non-associative operators by flattening the specified interior node with its children that are the same interior node type. </p>
<p>Call this only if the top node is a truly non-associative. A new node is returned only if changed. When calling both nonassociative and commutative, it's usually more appropriate to call nonassociative first. </p>

</div>
</div>
<a id="a9438364053512103c4d7c067aec644b0" name="a9438364053512103c4d7c067aec644b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9438364053512103c4d7c067aec644b0">&#9670;&#160;</a></span>commutative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::commutative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies commutative operators by sorting arguments. </p>
<p>The arguments are sorted so that all the interior nodes come before the leaf nodes. Call this only if the top node is truly commutative. A new node is returned only if changed. When calling both nonassociative and commutative, it's usually more appropriate to call nonassociative first. </p>

</div>
</div>
<a id="abc16fb68b1045f1bb8617d9cc06fd4e7" name="abc16fb68b1045f1bb8617d9cc06fd4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc16fb68b1045f1bb8617d9cc06fd4e7">&#9670;&#160;</a></span>idempotent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a259906bede9e5aba6e7e09400d5cd481">InteriorPtr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::idempotent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies idempotent operators. </p>
<p>An idempotent operator I is one such that X I X = X. For operators that have more than two operands, only those repeated neighboring operands are reduced to a single operand. Therefore, if the operator is commutative, then do the commutative simplification before the idempotent simplification. Returns either a new, simplified expression or the original unmodified expression. </p>

</div>
</div>
<a id="a25bad0707de6e0163ff9c509d15c83f8" name="a25bad0707de6e0163ff9c509d15c83f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bad0707de6e0163ff9c509d15c83f8">&#9670;&#160;</a></span>involutary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::involutary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies involutary operators. </p>
<p>An involutary operator is one that is its own inverse. This method should only be called if this node is an interior node whose operator has the involutary property (such as invert or negate). Returns either a new expression that is simplified, or the original expression. </p>

</div>
</div>
<a id="a5d2ca571d56ffa4d9623427df7b5f1b6" name="a5d2ca571d56ffa4d9623427df7b5f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2ca571d56ffa4d9623427df7b5f1b6">&#9670;&#160;</a></span>additiveNesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::additiveNesting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies nested shift-like operators. </p>
<p>Simplifies (shift AMT1 (shift AMT2 X)) to (shift (add AMT1 AMT2) X). The SMT solver may be null. </p>

</div>
</div>
<a id="a5e3370e898081adcd4debe5de599d18d" name="a5e3370e898081adcd4debe5de599d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3370e898081adcd4debe5de599d18d">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::identity </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes identity arguments. </p>
<p>Returns either a new expression or the original expression. The solver may be a null pointer. </p>

</div>
</div>
<a id="a078812595acfcc17124debba443cc116" name="a078812595acfcc17124debba443cc116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078812595acfcc17124debba443cc116">&#9670;&#160;</a></span>poisonNan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::poisonNan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NaN if any argument is NaN. </p>
<p>If any argument is NaN then a new NaN constant expression is returned, otherwise the original expression is returned. The solver may be a null pointer. </p>

</div>
</div>
<a id="aca5e43843491f5687b708ce66f2cae5a" name="aca5e43843491f5687b708ce66f2cae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5e43843491f5687b708ce66f2cae5a">&#9670;&#160;</a></span>unaryNoOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::unaryNoOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a binary operator with its only argument. </p>
<p>Returns either a new expression or the original expression. </p>

</div>
</div>
<a id="a8359569ef293d9f0a9d16098f6599e24" name="a8359569ef293d9f0a9d16098f6599e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8359569ef293d9f0a9d16098f6599e24">&#9670;&#160;</a></span>rewrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> Rose::BinaryAnalysis::SymbolicExpression::Interior::rewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Simplifier.html">Simplifier</a> &amp;&#160;</td>
          <td class="paramname"><em>simplifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="namespaceRose_1_1BinaryAnalysis.html#ac6a5a4bfe0af39c76b621715abea1925">SmtSolverPtr</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an interior node. </p>
<p>Returns a new node if this node could be simplified, otherwise returns this node. When the simplification could result in a leaf node, we return an OP_NOOP interior node instead. The SMT solver is optional and may be the null pointer. </p>

</div>
</div>
<a id="a0e3fdd53e186c07c07dbf935b597145e" name="a0e3fdd53e186c07c07dbf935b597145e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3fdd53e186c07c07dbf935b597145e">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Rose::BinaryAnalysis::SymbolicExpression::Interior::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html">Formatter</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the expression to a stream. </p>
<p>The output is an S-expression with no line-feeds. The format of the output is controlled by the mutable <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Formatter.html" title="Controls formatting of expression trees when printing.">Formatter</a> argument. </p>

<p>Implements <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Node.html#a2364e3da620fa5afd424a0c48f35869d">Rose::BinaryAnalysis::SymbolicExpression::Node</a>.</p>

</div>
</div>
<a id="ae05dfd5a387c09b94c861f16d8c7c87d" name="ae05dfd5a387c09b94c861f16d8c7c87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05dfd5a387c09b94c861f16d8c7c87d">&#9670;&#160;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Interior::addChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceRose_1_1BinaryAnalysis_1_1SymbolicExpression.html#a357a1787c84ab11ac04ffa566345e57c">Ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends <code>child</code> as a new child of this node. </p>
<p>This must only be called from constructors. </p>

</div>
</div>
<a id="a84a9cd11f0ce53bee459facf6b06c401" name="a84a9cd11f0ce53bee459facf6b06c401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a9cd11f0ce53bee459facf6b06c401">&#9670;&#160;</a></span>adjustWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Interior::adjustWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRose_1_1BinaryAnalysis_1_1SymbolicExpression_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust width based on operands. </p>
<p>This must only be called from constructors. The type is needed for certain operations such as convert. </p>

</div>
</div>
<a id="a9be8e02830e797c895149b5c7b809ae4" name="a9be8e02830e797c895149b5c7b809ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8e02830e797c895149b5c7b809ae4">&#9670;&#160;</a></span>adjustBitFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rose::BinaryAnalysis::SymbolicExpression::Interior::adjustBitFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>extraFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust user-defined bit flags. </p>
<p>This must only be called from constructors. Flags are the union of the operand flags subject to simplification rules, unioned with the specified flags. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SymbolicExpression_8h_source.html">SymbolicExpression.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 2 2024 00:09:11 for ROSE by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
